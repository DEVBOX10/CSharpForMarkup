// Start of generated C# Markup API for the Microsoft.WindowsDesktop.App Object hierarchy
#if WPF

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using Windows = System.Windows;
using Stream = System.IO.Stream;
using ListSortDirection = System.ComponentModel.ListSortDirection;
using IEnumerable = System.Collections.IEnumerable;
using CultureInfo = System.Globalization.CultureInfo;
using RequestCachePolicy = System.Net.Cache.RequestCachePolicy;
using StringCollection = System.Collections.Specialized.StringCollection;
using Color = System.Windows.Media.Color;

namespace CSharpMarkup.Wpf // ContentElement
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.ContentElement"/></summary>
        public static ContentElement ContentElement(O<bool> AllowDrop = default, O<bool> Focusable = default, O<bool> IsEnabled = default)
        {
            var ui = new Windows.ContentElement();
            if (AllowDrop.HasValue) ui.AllowDrop = AllowDrop.Value;
            if (Focusable.HasValue) ui.Focusable = Focusable.Value;
            if (IsEnabled.HasValue) ui.IsEnabled = IsEnabled.Value;
            return global::CSharpMarkup.Wpf.ContentElement.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.ContentElement"/></summary>
        public static ContentElement ContentElement()
        {
            var ui = new Windows.ContentElement();
            return global::CSharpMarkup.Wpf.ContentElement.StartChain(ui);
        }
    }

    public partial class ContentElement : DependencyObject, IUI<System.Windows.ContentElement>
    {
        static ContentElement instance;

        internal static ContentElement StartChain(Windows.ContentElement ui)
        {
            if (instance == null) instance = new ContentElement();
            instance.UI = ui;
            return instance;
        }

        Windows.ContentElement ui;

        public new Windows.ContentElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.ContentElement(ContentElement view) => view?.UI;

        public static implicit operator ContentElement(Windows.ContentElement ui) => ContentElement.StartChain(ui);

        protected ContentElement() { }
    }

    public static partial class ContentElementExtensions
    {
        /// <summary>Set <see cref="Windows.ContentElement.AllowDrop"/></summary>
        public static TView AllowDrop<TView>(this TView view, bool value) where TView : ContentElement { view.UI.AllowDrop = value; return view; }

        /// <summary>Set <see cref="Windows.ContentElement.Focusable"/></summary>
        public static TView Focusable<TView>(this TView view, bool value) where TView : ContentElement { view.UI.Focusable = value; return view; }

        /// <summary>Set <see cref="Windows.ContentElement.IsEnabled"/></summary>
        public static TView IsEnabled<TView>(this TView view, bool value) where TView : ContentElement { view.UI.IsEnabled = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.AllowDrop"/></summary>
        public static DependencyProperty<TTarget, bool> AllowDrop<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.AllowDropProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.AreAnyTouchesCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCaptured<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.AreAnyTouchesCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.AreAnyTouchesCapturedWithin"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCapturedWithin<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.AreAnyTouchesCapturedWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.AreAnyTouchesDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesDirectlyOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.AreAnyTouchesDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.AreAnyTouchesOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.AreAnyTouchesOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.Focusable"/></summary>
        public static DependencyProperty<TTarget, bool> Focusable<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.FocusableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsEnabled<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsFocused<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsKeyboardFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocused<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsKeyboardFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsKeyboardFocusWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocusWithin<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsKeyboardFocusWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsMouseCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptured<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsMouseCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsMouseCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptureWithin<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsMouseCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsMouseDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseDirectlyOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsMouseDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsMouseOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsMouseOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsStylusCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptured<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsStylusCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsStylusCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptureWithin<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsStylusCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsStylusDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusDirectlyOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsStylusDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.ContentElement.IsStylusOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusOver<TTarget>(this TTarget target) where TTarget : ContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.ContentElement.IsStylusOverProperty);
    }
}

namespace CSharpMarkup.Wpf // TextDecoration
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.TextDecoration"/></summary>
        public static TextDecoration TextDecoration(O<Windows.TextDecorationLocation> Location = default, O<Windows.Media.Pen> Pen = default, O<double> PenOffset = default, O<Windows.TextDecorationUnit> PenOffsetUnit = default, O<Windows.TextDecorationUnit> PenThicknessUnit = default)
        {
            var ui = new Windows.TextDecoration();
            if (Location.HasValue) ui.Location = Location.Value;
            if (Pen.HasValue) ui.Pen = Pen.Value;
            if (PenOffset.HasValue) ui.PenOffset = PenOffset.Value;
            if (PenOffsetUnit.HasValue) ui.PenOffsetUnit = PenOffsetUnit.Value;
            if (PenThicknessUnit.HasValue) ui.PenThicknessUnit = PenThicknessUnit.Value;
            return global::CSharpMarkup.Wpf.TextDecoration.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.TextDecoration"/></summary>
        public static TextDecoration TextDecoration()
        {
            var ui = new Windows.TextDecoration();
            return global::CSharpMarkup.Wpf.TextDecoration.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.TextDecoration"/></summary>
        public static TextDecoration TextDecoration(Windows.TextDecorationLocation location, Windows.Media.Pen pen, double penOffset, Windows.TextDecorationUnit penOffsetUnit, Windows.TextDecorationUnit penThicknessUnit)
        {
            var ui = new Windows.TextDecoration(location, pen, penOffset, penOffsetUnit, penThicknessUnit);
            return global::CSharpMarkup.Wpf.TextDecoration.StartChain(ui);
        }
    }

    public partial class TextDecoration : Animatable, IUI<System.Windows.TextDecoration>
    {
        static TextDecoration instance;

        internal static TextDecoration StartChain(Windows.TextDecoration ui)
        {
            if (instance == null) instance = new TextDecoration();
            instance.UI = ui;
            return instance;
        }

        Windows.TextDecoration ui;

        public new Windows.TextDecoration UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.TextDecoration(TextDecoration view) => view?.UI;

        public static implicit operator TextDecoration(Windows.TextDecoration ui) => TextDecoration.StartChain(ui);

        protected TextDecoration() { }
    }

    public static partial class TextDecorationExtensions
    {
        /// <summary>Set <see cref="Windows.TextDecoration.Location"/></summary>
        public static TView Location<TView>(this TView view, Windows.TextDecorationLocation value) where TView : TextDecoration { view.UI.Location = value; return view; }

        /// <summary>Set <see cref="Windows.TextDecoration.Pen"/></summary>
        public static TView Pen<TView>(this TView view, Windows.Media.Pen value) where TView : TextDecoration { view.UI.Pen = value; return view; }

        /// <summary>Set <see cref="Windows.TextDecoration.PenOffset"/></summary>
        public static TView PenOffset<TView>(this TView view, double value) where TView : TextDecoration { view.UI.PenOffset = value; return view; }

        /// <summary>Set <see cref="Windows.TextDecoration.PenOffsetUnit"/></summary>
        public static TView PenOffsetUnit<TView>(this TView view, Windows.TextDecorationUnit value) where TView : TextDecoration { view.UI.PenOffsetUnit = value; return view; }

        /// <summary>Set <see cref="Windows.TextDecoration.PenThicknessUnit"/></summary>
        public static TView PenThicknessUnit<TView>(this TView view, Windows.TextDecorationUnit value) where TView : TextDecoration { view.UI.PenThicknessUnit = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.TextDecoration.Location"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationLocation> Location<TTarget>(this TTarget target) where TTarget : TextDecoration
        => DependencyProperty<TTarget, Windows.TextDecorationLocation>.Get(target, Windows.TextDecoration.LocationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.TextDecoration.PenOffset"/></summary>
        public static DependencyProperty<TTarget, double> PenOffset<TTarget>(this TTarget target) where TTarget : TextDecoration
        => DependencyProperty<TTarget, double>.Get(target, Windows.TextDecoration.PenOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.TextDecoration.PenOffsetUnit"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationUnit> PenOffsetUnit<TTarget>(this TTarget target) where TTarget : TextDecoration
        => DependencyProperty<TTarget, Windows.TextDecorationUnit>.Get(target, Windows.TextDecoration.PenOffsetUnitProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.TextDecoration.Pen"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Pen> Pen<TTarget>(this TTarget target) where TTarget : TextDecoration
        => DependencyProperty<TTarget, Windows.Media.Pen>.Get(target, Windows.TextDecoration.PenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.TextDecoration.PenThicknessUnit"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationUnit> PenThicknessUnit<TTarget>(this TTarget target) where TTarget : TextDecoration
        => DependencyProperty<TTarget, Windows.TextDecorationUnit>.Get(target, Windows.TextDecoration.PenThicknessUnitProperty);
    }
}

namespace CSharpMarkup.Wpf // TextDecorationCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.TextDecorationCollection"/></summary>
        public static TextDecorationCollection TextDecorationCollection()
        {
            var ui = new Windows.TextDecorationCollection();
            return global::CSharpMarkup.Wpf.TextDecorationCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.TextDecorationCollection"/></summary>
        public static TextDecorationCollection TextDecorationCollection(IEnumerable<Windows.TextDecoration> collection)
        {
            var ui = new Windows.TextDecorationCollection(collection);
            return global::CSharpMarkup.Wpf.TextDecorationCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.TextDecorationCollection"/></summary>
        public static TextDecorationCollection TextDecorationCollection(int capacity)
        {
            var ui = new Windows.TextDecorationCollection(capacity);
            return global::CSharpMarkup.Wpf.TextDecorationCollection.StartChain(ui);
        }
    }

    public partial class TextDecorationCollection : Animatable, IUI<System.Windows.TextDecorationCollection>
    {
        static TextDecorationCollection instance;

        internal static TextDecorationCollection StartChain(Windows.TextDecorationCollection ui)
        {
            if (instance == null) instance = new TextDecorationCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.TextDecorationCollection ui;

        public new Windows.TextDecorationCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.TextDecorationCollection(TextDecorationCollection view) => view?.UI;

        public static implicit operator TextDecorationCollection(Windows.TextDecorationCollection ui) => TextDecorationCollection.StartChain(ui);

        protected TextDecorationCollection() { }
    }
}

namespace CSharpMarkup.Wpf // UIElement
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.UIElement"/></summary>
        public static UIElement UIElement(O<bool> AllowDrop = default, O<Windows.Media.Effects.BitmapEffect> BitmapEffect = default, O<Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput = default, O<Windows.Media.CacheMode> CacheMode = default, O<Windows.Media.Geometry> Clip = default, O<bool> ClipToBounds = default, O<Windows.Media.Effects.Effect> Effect = default, O<bool> Focusable = default, O<bool> IsEnabled = default, O<bool> IsHitTestVisible = default, O<bool> IsManipulationEnabled = default, O<double> Opacity = default, O<Windows.Media.Brush> OpacityMask = default, O<Windows.Size> RenderSize = default, O<Windows.Media.Transform> RenderTransform = default, O<Windows.Point> RenderTransformOrigin = default, O<bool> SnapsToDevicePixels = default, O<string> Uid = default, O<Windows.Visibility> Visibility = default)
        {
            var ui = new Windows.UIElement();
            if (AllowDrop.HasValue) ui.AllowDrop = AllowDrop.Value;
            if (BitmapEffect.HasValue) ui.BitmapEffect = BitmapEffect.Value;
            if (BitmapEffectInput.HasValue) ui.BitmapEffectInput = BitmapEffectInput.Value;
            if (CacheMode.HasValue) ui.CacheMode = CacheMode.Value;
            if (Clip.HasValue) ui.Clip = Clip.Value;
            if (ClipToBounds.HasValue) ui.ClipToBounds = ClipToBounds.Value;
            if (Effect.HasValue) ui.Effect = Effect.Value;
            if (Focusable.HasValue) ui.Focusable = Focusable.Value;
            if (IsEnabled.HasValue) ui.IsEnabled = IsEnabled.Value;
            if (IsHitTestVisible.HasValue) ui.IsHitTestVisible = IsHitTestVisible.Value;
            if (IsManipulationEnabled.HasValue) ui.IsManipulationEnabled = IsManipulationEnabled.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (OpacityMask.HasValue) ui.OpacityMask = OpacityMask.Value;
            if (RenderSize.HasValue) ui.RenderSize = RenderSize.Value;
            if (RenderTransform.HasValue) ui.RenderTransform = RenderTransform.Value;
            if (RenderTransformOrigin.HasValue) ui.RenderTransformOrigin = RenderTransformOrigin.Value;
            if (SnapsToDevicePixels.HasValue) ui.SnapsToDevicePixels = SnapsToDevicePixels.Value;
            if (Uid.HasValue) ui.Uid = Uid.Value;
            if (Visibility.HasValue) ui.Visibility = Visibility.Value;
            return global::CSharpMarkup.Wpf.UIElement.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.UIElement"/></summary>
        public static UIElement UIElement()
        {
            var ui = new Windows.UIElement();
            return global::CSharpMarkup.Wpf.UIElement.StartChain(ui);
        }
    }

    public partial class UIElement : Visual, IUI<System.Windows.UIElement>
    {
        static UIElement instance;

        internal static UIElement StartChain(Windows.UIElement ui)
        {
            if (instance == null) instance = new UIElement();
            instance.UI = ui;
            return instance;
        }

        Windows.UIElement ui;

        public new Windows.UIElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(UIElement view) => view?.UI;

        public static implicit operator UIElement(Windows.UIElement ui) => UIElement.StartChain(ui);

        protected UIElement() { }
    }

    public static partial class UIElementExtensions
    {
        /// <summary>Set <see cref="Windows.UIElement.AllowDrop"/></summary>
        public static TView AllowDrop<TView>(this TView view, bool value) where TView : UIElement { view.UI.AllowDrop = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.BitmapEffect"/></summary>
        public static TView BitmapEffect<TView>(this TView view, Windows.Media.Effects.BitmapEffect value) where TView : UIElement { view.UI.BitmapEffect = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.BitmapEffectInput"/></summary>
        public static TView BitmapEffectInput<TView>(this TView view, Windows.Media.Effects.BitmapEffectInput value) where TView : UIElement { view.UI.BitmapEffectInput = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.CacheMode"/></summary>
        public static TView CacheMode<TView>(this TView view, Windows.Media.CacheMode value) where TView : UIElement { view.UI.CacheMode = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Clip"/></summary>
        public static TView Clip<TView>(this TView view, Windows.Media.Geometry value) where TView : UIElement { view.UI.Clip = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.ClipToBounds"/></summary>
        public static TView ClipToBounds<TView>(this TView view, bool value) where TView : UIElement { view.UI.ClipToBounds = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Effect"/></summary>
        public static TView Effect<TView>(this TView view, Windows.Media.Effects.Effect value) where TView : UIElement { view.UI.Effect = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Focusable"/></summary>
        public static TView Focusable<TView>(this TView view, bool value) where TView : UIElement { view.UI.Focusable = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.IsEnabled"/></summary>
        public static TView IsEnabled<TView>(this TView view, bool value) where TView : UIElement { view.UI.IsEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.IsHitTestVisible"/></summary>
        public static TView IsHitTestVisible<TView>(this TView view, bool value) where TView : UIElement { view.UI.IsHitTestVisible = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.IsManipulationEnabled"/></summary>
        public static TView IsManipulationEnabled<TView>(this TView view, bool value) where TView : UIElement { view.UI.IsManipulationEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : UIElement { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Windows.Media.Brush value) where TView : UIElement { view.UI.OpacityMask = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Color value) where TView : UIElement { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.UIElement.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, string color) where TView : UIElement { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.UIElement.RenderSize"/></summary>
        public static TView RenderSize<TView>(this TView view, Windows.Size value) where TView : UIElement { view.UI.RenderSize = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.RenderTransform"/></summary>
        public static TView RenderTransform<TView>(this TView view, Windows.Media.Transform value) where TView : UIElement { view.UI.RenderTransform = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.RenderTransformOrigin"/></summary>
        public static TView RenderTransformOrigin<TView>(this TView view, Windows.Point value) where TView : UIElement { view.UI.RenderTransformOrigin = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.SnapsToDevicePixels"/></summary>
        public static TView SnapsToDevicePixels<TView>(this TView view, bool value) where TView : UIElement { view.UI.SnapsToDevicePixels = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Uid"/></summary>
        public static TView Uid<TView>(this TView view, string value) where TView : UIElement { view.UI.Uid = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement.Visibility"/></summary>
        public static TView Visibility<TView>(this TView view, Windows.Visibility value) where TView : UIElement { view.UI.Visibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.AllowDrop"/></summary>
        public static DependencyProperty<TTarget, bool> AllowDrop<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.AllowDropProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.AreAnyTouchesCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCaptured<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.AreAnyTouchesCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.AreAnyTouchesCapturedWithin"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCapturedWithin<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.AreAnyTouchesCapturedWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.AreAnyTouchesDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.AreAnyTouchesDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.AreAnyTouchesOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.AreAnyTouchesOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.BitmapEffectInput"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectInput>.Get(target, Windows.UIElement.BitmapEffectInputProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.BitmapEffect"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffect> BitmapEffect<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffect>.Get(target, Windows.UIElement.BitmapEffectProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.CacheMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.CacheMode> CacheMode<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.CacheMode>.Get(target, Windows.UIElement.CacheModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Clip"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Clip<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.UIElement.ClipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.ClipToBounds"/></summary>
        public static DependencyProperty<TTarget, bool> ClipToBounds<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.ClipToBoundsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Effect"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.Effect> Effect<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Effects.Effect>.Get(target, Windows.UIElement.EffectProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Focusable"/></summary>
        public static DependencyProperty<TTarget, bool> Focusable<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.FocusableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsEnabled<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsFocused<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsHitTestVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsHitTestVisible<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsHitTestVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsKeyboardFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocused<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsKeyboardFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsKeyboardFocusWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocusWithin<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsKeyboardFocusWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsManipulationEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsManipulationEnabled<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsManipulationEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsMouseCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptured<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsMouseCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsMouseCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptureWithin<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsMouseCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsMouseDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsMouseDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsMouseOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsMouseOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsStylusCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptured<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsStylusCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsStylusCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptureWithin<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsStylusCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsStylusDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsStylusDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsStylusOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusOver<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsStylusOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.IsVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsVisible<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.IsVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.OpacityMask"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> OpacityMask<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.UIElement.OpacityMaskProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.UIElement.OpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.RenderTransformOrigin"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> RenderTransformOrigin<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.UIElement.RenderTransformOriginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.RenderTransform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> RenderTransform<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.UIElement.RenderTransformProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.SnapsToDevicePixels"/></summary>
        public static DependencyProperty<TTarget, bool> SnapsToDevicePixels<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement.SnapsToDevicePixelsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Uid"/></summary>
        public static DependencyProperty<TTarget, string> Uid<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, string>.Get(target, Windows.UIElement.UidProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement.Visibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> Visibility<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.UIElement.VisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // UIElement3D
{
    public partial class UIElement3D : Visual3D, IUI<System.Windows.UIElement3D>
    {
        Windows.UIElement3D ui;

        public new Windows.UIElement3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected UIElement3D() { }
    }

    public static partial class UIElement3DExtensions
    {
        /// <summary>Set <see cref="Windows.UIElement3D.AllowDrop"/></summary>
        public static TView AllowDrop<TView>(this TView view, bool value) where TView : UIElement3D { view.UI.AllowDrop = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement3D.Focusable"/></summary>
        public static TView Focusable<TView>(this TView view, bool value) where TView : UIElement3D { view.UI.Focusable = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement3D.IsEnabled"/></summary>
        public static TView IsEnabled<TView>(this TView view, bool value) where TView : UIElement3D { view.UI.IsEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement3D.IsHitTestVisible"/></summary>
        public static TView IsHitTestVisible<TView>(this TView view, bool value) where TView : UIElement3D { view.UI.IsHitTestVisible = value; return view; }

        /// <summary>Set <see cref="Windows.UIElement3D.Visibility"/></summary>
        public static TView Visibility<TView>(this TView view, Windows.Visibility value) where TView : UIElement3D { view.UI.Visibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.AllowDrop"/></summary>
        public static DependencyProperty<TTarget, bool> AllowDrop<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.AllowDropProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.AreAnyTouchesCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCaptured<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.AreAnyTouchesCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.AreAnyTouchesCapturedWithin"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesCapturedWithin<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.AreAnyTouchesCapturedWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.AreAnyTouchesDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.AreAnyTouchesDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.AreAnyTouchesOver"/></summary>
        public static DependencyProperty<TTarget, bool> AreAnyTouchesOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.AreAnyTouchesOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.Focusable"/></summary>
        public static DependencyProperty<TTarget, bool> Focusable<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.FocusableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsEnabled<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsFocused<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsHitTestVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsHitTestVisible<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsHitTestVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsKeyboardFocused"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocused<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsKeyboardFocusedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsKeyboardFocusWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsKeyboardFocusWithin<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsKeyboardFocusWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsMouseCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptured<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsMouseCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsMouseCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseCaptureWithin<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsMouseCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsMouseDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsMouseDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsMouseOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsMouseOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsStylusCaptured"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptured<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsStylusCapturedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsStylusCaptureWithin"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusCaptureWithin<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsStylusCaptureWithinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsStylusDirectlyOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusDirectlyOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsStylusDirectlyOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsStylusOver"/></summary>
        public static DependencyProperty<TTarget, bool> IsStylusOver<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsStylusOverProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.IsVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsVisible<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, bool>.Get(target, Windows.UIElement3D.IsVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.UIElement3D.Visibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> Visibility<TTarget>(this TTarget target) where TTarget : UIElement3D
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.UIElement3D.VisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // GestureRecognizer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Ink.GestureRecognizer"/></summary>
        public static GestureRecognizer GestureRecognizer()
        {
            var ui = new Windows.Ink.GestureRecognizer();
            return global::CSharpMarkup.Wpf.GestureRecognizer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Ink.GestureRecognizer"/></summary>
        public static GestureRecognizer GestureRecognizer(IEnumerable<Windows.Ink.ApplicationGesture> enabledApplicationGestures)
        {
            var ui = new Windows.Ink.GestureRecognizer(enabledApplicationGestures);
            return global::CSharpMarkup.Wpf.GestureRecognizer.StartChain(ui);
        }
    }

    public partial class GestureRecognizer : DependencyObject, IUI<System.Windows.Ink.GestureRecognizer>
    {
        static GestureRecognizer instance;

        internal static GestureRecognizer StartChain(Windows.Ink.GestureRecognizer ui)
        {
            if (instance == null) instance = new GestureRecognizer();
            instance.UI = ui;
            return instance;
        }

        Windows.Ink.GestureRecognizer ui;

        public new Windows.Ink.GestureRecognizer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Ink.GestureRecognizer(GestureRecognizer view) => view?.UI;

        public static implicit operator GestureRecognizer(Windows.Ink.GestureRecognizer ui) => GestureRecognizer.StartChain(ui);

        protected GestureRecognizer() { }
    }
}

namespace CSharpMarkup.Wpf // D3DImage
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Interop.D3DImage"/></summary>
        public static D3DImage D3DImage()
        {
            var ui = new Windows.Interop.D3DImage();
            return global::CSharpMarkup.Wpf.D3DImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Interop.D3DImage"/></summary>
        public static D3DImage D3DImage(double dpiX, double dpiY)
        {
            var ui = new Windows.Interop.D3DImage(dpiX, dpiY);
            return global::CSharpMarkup.Wpf.D3DImage.StartChain(ui);
        }
    }

    public partial class D3DImage : ImageSource, IUI<System.Windows.Interop.D3DImage>
    {
        static D3DImage instance;

        internal static D3DImage StartChain(Windows.Interop.D3DImage ui)
        {
            if (instance == null) instance = new D3DImage();
            instance.UI = ui;
            return instance;
        }

        Windows.Interop.D3DImage ui;

        public new Windows.Interop.D3DImage UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Interop.D3DImage(D3DImage view) => view?.UI;

        public static implicit operator D3DImage(Windows.Interop.D3DImage ui) => D3DImage.StartChain(ui);

        protected D3DImage() { }
    }

    public static partial class D3DImageExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Interop.D3DImage.IsFrontBufferAvailable"/></summary>
        public static DependencyProperty<TTarget, bool> IsFrontBufferAvailable<TTarget>(this TTarget target) where TTarget : D3DImage
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Interop.D3DImage.IsFrontBufferAvailableProperty);
    }
}

namespace CSharpMarkup.Wpf // InteropBitmap
{
    public partial class InteropBitmap : BitmapSource, IUI<System.Windows.Interop.InteropBitmap>
    {
        Windows.Interop.InteropBitmap ui;

        public new Windows.Interop.InteropBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected InteropBitmap() { }
    }
}

namespace CSharpMarkup.Wpf // ArcSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.ArcSegment"/></summary>
        public static ArcSegment ArcSegment(O<bool> IsLargeArc = default, O<Windows.Point> Point = default, O<double> RotationAngle = default, O<Windows.Size> Size = default, O<Windows.Media.SweepDirection> SweepDirection = default)
        {
            var ui = new Windows.Media.ArcSegment();
            if (IsLargeArc.HasValue) ui.IsLargeArc = IsLargeArc.Value;
            if (Point.HasValue) ui.Point = Point.Value;
            if (RotationAngle.HasValue) ui.RotationAngle = RotationAngle.Value;
            if (Size.HasValue) ui.Size = Size.Value;
            if (SweepDirection.HasValue) ui.SweepDirection = SweepDirection.Value;
            return global::CSharpMarkup.Wpf.ArcSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ArcSegment"/></summary>
        public static ArcSegment ArcSegment()
        {
            var ui = new Windows.Media.ArcSegment();
            return global::CSharpMarkup.Wpf.ArcSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ArcSegment"/></summary>
        public static ArcSegment ArcSegment(Windows.Point point, Windows.Size size, double rotationAngle, bool isLargeArc, Windows.Media.SweepDirection sweepDirection, bool isStroked)
        {
            var ui = new Windows.Media.ArcSegment(point, size, rotationAngle, isLargeArc, sweepDirection, isStroked);
            return global::CSharpMarkup.Wpf.ArcSegment.StartChain(ui);
        }
    }

    public partial class ArcSegment : PathSegment, IUI<System.Windows.Media.ArcSegment>
    {
        static ArcSegment instance;

        internal static ArcSegment StartChain(Windows.Media.ArcSegment ui)
        {
            if (instance == null) instance = new ArcSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.ArcSegment ui;

        public new Windows.Media.ArcSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.ArcSegment(ArcSegment view) => view?.UI;

        public static implicit operator ArcSegment(Windows.Media.ArcSegment ui) => ArcSegment.StartChain(ui);

        protected ArcSegment() { }
    }

    public static partial class ArcSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.ArcSegment.IsLargeArc"/></summary>
        public static TView IsLargeArc<TView>(this TView view, bool value) where TView : ArcSegment { view.UI.IsLargeArc = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ArcSegment.Point"/></summary>
        public static TView Point<TView>(this TView view, Windows.Point value) where TView : ArcSegment { view.UI.Point = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ArcSegment.RotationAngle"/></summary>
        public static TView RotationAngle<TView>(this TView view, double value) where TView : ArcSegment { view.UI.RotationAngle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ArcSegment.Size"/></summary>
        public static TView Size<TView>(this TView view, Windows.Size value) where TView : ArcSegment { view.UI.Size = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ArcSegment.SweepDirection"/></summary>
        public static TView SweepDirection<TView>(this TView view, Windows.Media.SweepDirection value) where TView : ArcSegment { view.UI.SweepDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ArcSegment.IsLargeArc"/></summary>
        public static DependencyProperty<TTarget, bool> IsLargeArc<TTarget>(this TTarget target) where TTarget : ArcSegment
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.ArcSegment.IsLargeArcProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ArcSegment.Point"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point<TTarget>(this TTarget target) where TTarget : ArcSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.ArcSegment.PointProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ArcSegment.RotationAngle"/></summary>
        public static DependencyProperty<TTarget, double> RotationAngle<TTarget>(this TTarget target) where TTarget : ArcSegment
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.ArcSegment.RotationAngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ArcSegment.Size"/></summary>
        public static DependencyProperty<TTarget, Windows.Size> Size<TTarget>(this TTarget target) where TTarget : ArcSegment
        => DependencyProperty<TTarget, Windows.Size>.Get(target, Windows.Media.ArcSegment.SizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ArcSegment.SweepDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.SweepDirection> SweepDirection<TTarget>(this TTarget target) where TTarget : ArcSegment
        => DependencyProperty<TTarget, Windows.Media.SweepDirection>.Get(target, Windows.Media.ArcSegment.SweepDirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // BezierSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.BezierSegment"/></summary>
        public static BezierSegment BezierSegment(O<Windows.Point> Point1 = default, O<Windows.Point> Point2 = default, O<Windows.Point> Point3 = default)
        {
            var ui = new Windows.Media.BezierSegment();
            if (Point1.HasValue) ui.Point1 = Point1.Value;
            if (Point2.HasValue) ui.Point2 = Point2.Value;
            if (Point3.HasValue) ui.Point3 = Point3.Value;
            return global::CSharpMarkup.Wpf.BezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BezierSegment"/></summary>
        public static BezierSegment BezierSegment()
        {
            var ui = new Windows.Media.BezierSegment();
            return global::CSharpMarkup.Wpf.BezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BezierSegment"/></summary>
        public static BezierSegment BezierSegment(Windows.Point point1, Windows.Point point2, Windows.Point point3, bool isStroked)
        {
            var ui = new Windows.Media.BezierSegment(point1, point2, point3, isStroked);
            return global::CSharpMarkup.Wpf.BezierSegment.StartChain(ui);
        }
    }

    public partial class BezierSegment : PathSegment, IUI<System.Windows.Media.BezierSegment>
    {
        static BezierSegment instance;

        internal static BezierSegment StartChain(Windows.Media.BezierSegment ui)
        {
            if (instance == null) instance = new BezierSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.BezierSegment ui;

        public new Windows.Media.BezierSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.BezierSegment(BezierSegment view) => view?.UI;

        public static implicit operator BezierSegment(Windows.Media.BezierSegment ui) => BezierSegment.StartChain(ui);

        protected BezierSegment() { }
    }

    public static partial class BezierSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.BezierSegment.Point1"/></summary>
        public static TView Point1<TView>(this TView view, Windows.Point value) where TView : BezierSegment { view.UI.Point1 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BezierSegment.Point2"/></summary>
        public static TView Point2<TView>(this TView view, Windows.Point value) where TView : BezierSegment { view.UI.Point2 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BezierSegment.Point3"/></summary>
        public static TView Point3<TView>(this TView view, Windows.Point value) where TView : BezierSegment { view.UI.Point3 = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BezierSegment.Point1"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point1<TTarget>(this TTarget target) where TTarget : BezierSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.BezierSegment.Point1Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BezierSegment.Point2"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point2<TTarget>(this TTarget target) where TTarget : BezierSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.BezierSegment.Point2Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BezierSegment.Point3"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point3<TTarget>(this TTarget target) where TTarget : BezierSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.BezierSegment.Point3Property);
    }
}

namespace CSharpMarkup.Wpf // BitmapCache
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.BitmapCache"/></summary>
        public static BitmapCache BitmapCache(O<bool> EnableClearType = default, O<double> RenderAtScale = default, O<bool> SnapsToDevicePixels = default)
        {
            var ui = new Windows.Media.BitmapCache();
            if (EnableClearType.HasValue) ui.EnableClearType = EnableClearType.Value;
            if (RenderAtScale.HasValue) ui.RenderAtScale = RenderAtScale.Value;
            if (SnapsToDevicePixels.HasValue) ui.SnapsToDevicePixels = SnapsToDevicePixels.Value;
            return global::CSharpMarkup.Wpf.BitmapCache.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BitmapCache"/></summary>
        public static BitmapCache BitmapCache()
        {
            var ui = new Windows.Media.BitmapCache();
            return global::CSharpMarkup.Wpf.BitmapCache.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BitmapCache"/></summary>
        public static BitmapCache BitmapCache(double renderAtScale)
        {
            var ui = new Windows.Media.BitmapCache(renderAtScale);
            return global::CSharpMarkup.Wpf.BitmapCache.StartChain(ui);
        }
    }

    public partial class BitmapCache : CacheMode, IUI<System.Windows.Media.BitmapCache>
    {
        static BitmapCache instance;

        internal static BitmapCache StartChain(Windows.Media.BitmapCache ui)
        {
            if (instance == null) instance = new BitmapCache();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.BitmapCache ui;

        public new Windows.Media.BitmapCache UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.BitmapCache(BitmapCache view) => view?.UI;

        public static implicit operator BitmapCache(Windows.Media.BitmapCache ui) => BitmapCache.StartChain(ui);

        protected BitmapCache() { }
    }

    public static partial class BitmapCacheExtensions
    {
        /// <summary>Set <see cref="Windows.Media.BitmapCache.EnableClearType"/></summary>
        public static TView EnableClearType<TView>(this TView view, bool value) where TView : BitmapCache { view.UI.EnableClearType = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BitmapCache.RenderAtScale"/></summary>
        public static TView RenderAtScale<TView>(this TView view, double value) where TView : BitmapCache { view.UI.RenderAtScale = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BitmapCache.SnapsToDevicePixels"/></summary>
        public static TView SnapsToDevicePixels<TView>(this TView view, bool value) where TView : BitmapCache { view.UI.SnapsToDevicePixels = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCache.EnableClearType"/></summary>
        public static DependencyProperty<TTarget, bool> EnableClearType<TTarget>(this TTarget target) where TTarget : BitmapCache
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.BitmapCache.EnableClearTypeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCache.RenderAtScale"/></summary>
        public static DependencyProperty<TTarget, double> RenderAtScale<TTarget>(this TTarget target) where TTarget : BitmapCache
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.BitmapCache.RenderAtScaleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCache.SnapsToDevicePixels"/></summary>
        public static DependencyProperty<TTarget, bool> SnapsToDevicePixels<TTarget>(this TTarget target) where TTarget : BitmapCache
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.BitmapCache.SnapsToDevicePixelsProperty);
    }
}

namespace CSharpMarkup.Wpf // BitmapCacheBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.BitmapCacheBrush"/></summary>
        public static BitmapCacheBrush BitmapCacheBrush(O<bool> AutoLayoutContent = default, O<Windows.Media.BitmapCache> BitmapCache = default, O<Windows.Media.Visual> Target = default)
        {
            var ui = new Windows.Media.BitmapCacheBrush();
            if (AutoLayoutContent.HasValue) ui.AutoLayoutContent = AutoLayoutContent.Value;
            if (BitmapCache.HasValue) ui.BitmapCache = BitmapCache.Value;
            if (Target.HasValue) ui.Target = Target.Value;
            return global::CSharpMarkup.Wpf.BitmapCacheBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BitmapCacheBrush"/></summary>
        public static BitmapCacheBrush BitmapCacheBrush()
        {
            var ui = new Windows.Media.BitmapCacheBrush();
            return global::CSharpMarkup.Wpf.BitmapCacheBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.BitmapCacheBrush"/></summary>
        public static BitmapCacheBrush BitmapCacheBrush(Windows.Media.Visual visual)
        {
            var ui = new Windows.Media.BitmapCacheBrush(visual);
            return global::CSharpMarkup.Wpf.BitmapCacheBrush.StartChain(ui);
        }
    }

    public partial class BitmapCacheBrush : Brush, IUI<System.Windows.Media.BitmapCacheBrush>
    {
        static BitmapCacheBrush instance;

        internal static BitmapCacheBrush StartChain(Windows.Media.BitmapCacheBrush ui)
        {
            if (instance == null) instance = new BitmapCacheBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.BitmapCacheBrush ui;

        public new Windows.Media.BitmapCacheBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.BitmapCacheBrush(BitmapCacheBrush view) => view?.UI;

        public static implicit operator BitmapCacheBrush(Windows.Media.BitmapCacheBrush ui) => BitmapCacheBrush.StartChain(ui);

        protected BitmapCacheBrush() { }
    }

    public static partial class BitmapCacheBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.BitmapCacheBrush.AutoLayoutContent"/></summary>
        public static TView AutoLayoutContent<TView>(this TView view, bool value) where TView : BitmapCacheBrush { view.UI.AutoLayoutContent = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BitmapCacheBrush.BitmapCache"/></summary>
        public static TView BitmapCache<TView>(this TView view, Windows.Media.BitmapCache value) where TView : BitmapCacheBrush { view.UI.BitmapCache = value; return view; }

        /// <summary>Set <see cref="Windows.Media.BitmapCacheBrush.Target"/></summary>
        public static TView Target<TView>(this TView view, Windows.Media.Visual value) where TView : BitmapCacheBrush { view.UI.Target = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCacheBrush.AutoLayoutContent"/></summary>
        public static DependencyProperty<TTarget, bool> AutoLayoutContent<TTarget>(this TTarget target) where TTarget : BitmapCacheBrush
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.BitmapCacheBrush.AutoLayoutContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCacheBrush.BitmapCache"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.BitmapCache> BitmapCache<TTarget>(this TTarget target) where TTarget : BitmapCacheBrush
        => DependencyProperty<TTarget, Windows.Media.BitmapCache>.Get(target, Windows.Media.BitmapCacheBrush.BitmapCacheProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.BitmapCacheBrush.Target"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Visual> Target<TTarget>(this TTarget target) where TTarget : BitmapCacheBrush
        => DependencyProperty<TTarget, Windows.Media.Visual>.Get(target, Windows.Media.BitmapCacheBrush.TargetProperty);
    }
}

namespace CSharpMarkup.Wpf // Brush
{
    public partial class Brush : Animatable, IUI<System.Windows.Media.Brush>
    {
        Windows.Media.Brush ui;

        public new Windows.Media.Brush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Brush() { }
    }

    public static partial class BrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Brush.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : Brush { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Brush.RelativeTransform"/></summary>
        public static TView RelativeTransform<TView>(this TView view, Windows.Media.Transform value) where TView : Brush { view.UI.RelativeTransform = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Brush.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : Brush { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Brush.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : Brush
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Brush.OpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Brush.RelativeTransform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> RelativeTransform<TTarget>(this TTarget target) where TTarget : Brush
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.Brush.RelativeTransformProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Brush.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> Transform<TTarget>(this TTarget target) where TTarget : Brush
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.Brush.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // CacheMode
{
    public partial class CacheMode : Animatable, IUI<System.Windows.Media.CacheMode>
    {
        Windows.Media.CacheMode ui;

        public new Windows.Media.CacheMode UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected CacheMode() { }
    }
}

namespace CSharpMarkup.Wpf // CombinedGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.CombinedGeometry"/></summary>
        public static CombinedGeometry CombinedGeometry(O<Windows.Media.Geometry> Geometry1 = default, O<Windows.Media.Geometry> Geometry2 = default, O<Windows.Media.GeometryCombineMode> GeometryCombineMode = default)
        {
            var ui = new Windows.Media.CombinedGeometry();
            if (Geometry1.HasValue) ui.Geometry1 = Geometry1.Value;
            if (Geometry2.HasValue) ui.Geometry2 = Geometry2.Value;
            if (GeometryCombineMode.HasValue) ui.GeometryCombineMode = GeometryCombineMode.Value;
            return global::CSharpMarkup.Wpf.CombinedGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.CombinedGeometry"/></summary>
        public static CombinedGeometry CombinedGeometry()
        {
            var ui = new Windows.Media.CombinedGeometry();
            return global::CSharpMarkup.Wpf.CombinedGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.CombinedGeometry"/></summary>
        public static CombinedGeometry CombinedGeometry(Windows.Media.Geometry geometry1, Windows.Media.Geometry geometry2)
        {
            var ui = new Windows.Media.CombinedGeometry(geometry1, geometry2);
            return global::CSharpMarkup.Wpf.CombinedGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.CombinedGeometry"/></summary>
        public static CombinedGeometry CombinedGeometry(Windows.Media.GeometryCombineMode geometryCombineMode, Windows.Media.Geometry geometry1, Windows.Media.Geometry geometry2)
        {
            var ui = new Windows.Media.CombinedGeometry(geometryCombineMode, geometry1, geometry2);
            return global::CSharpMarkup.Wpf.CombinedGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.CombinedGeometry"/></summary>
        public static CombinedGeometry CombinedGeometry(Windows.Media.GeometryCombineMode geometryCombineMode, Windows.Media.Geometry geometry1, Windows.Media.Geometry geometry2, Windows.Media.Transform transform)
        {
            var ui = new Windows.Media.CombinedGeometry(geometryCombineMode, geometry1, geometry2, transform);
            return global::CSharpMarkup.Wpf.CombinedGeometry.StartChain(ui);
        }
    }

    public partial class CombinedGeometry : Geometry, IUI<System.Windows.Media.CombinedGeometry>
    {
        static CombinedGeometry instance;

        internal static CombinedGeometry StartChain(Windows.Media.CombinedGeometry ui)
        {
            if (instance == null) instance = new CombinedGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.CombinedGeometry ui;

        public new Windows.Media.CombinedGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.CombinedGeometry(CombinedGeometry view) => view?.UI;

        public static implicit operator CombinedGeometry(Windows.Media.CombinedGeometry ui) => CombinedGeometry.StartChain(ui);

        protected CombinedGeometry() { }
    }

    public static partial class CombinedGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.CombinedGeometry.Geometry1"/></summary>
        public static TView Geometry1<TView>(this TView view, Windows.Media.Geometry value) where TView : CombinedGeometry { view.UI.Geometry1 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.CombinedGeometry.Geometry2"/></summary>
        public static TView Geometry2<TView>(this TView view, Windows.Media.Geometry value) where TView : CombinedGeometry { view.UI.Geometry2 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.CombinedGeometry.GeometryCombineMode"/></summary>
        public static TView GeometryCombineMode<TView>(this TView view, Windows.Media.GeometryCombineMode value) where TView : CombinedGeometry { view.UI.GeometryCombineMode = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.CombinedGeometry.Geometry1"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Geometry1<TTarget>(this TTarget target) where TTarget : CombinedGeometry
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Media.CombinedGeometry.Geometry1Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.CombinedGeometry.Geometry2"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Geometry2<TTarget>(this TTarget target) where TTarget : CombinedGeometry
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Media.CombinedGeometry.Geometry2Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.CombinedGeometry.GeometryCombineMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GeometryCombineMode> GeometryCombineMode<TTarget>(this TTarget target) where TTarget : CombinedGeometry
        => DependencyProperty<TTarget, Windows.Media.GeometryCombineMode>.Get(target, Windows.Media.CombinedGeometry.GeometryCombineModeProperty);
    }
}

namespace CSharpMarkup.Wpf // ContainerVisual
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.ContainerVisual"/></summary>
        public static ContainerVisual ContainerVisual(O<Windows.Media.Effects.BitmapEffect> BitmapEffect = default, O<Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput = default, O<Windows.Media.CacheMode> CacheMode = default, O<Windows.Media.Geometry> Clip = default, O<Windows.Media.Effects.Effect> Effect = default, O<Windows.Vector> Offset = default, O<double> Opacity = default, O<Windows.Media.Brush> OpacityMask = default, O<Windows.Media.Transform> Transform = default, O<Windows.Media.DoubleCollection> XSnappingGuidelines = default, O<Windows.Media.DoubleCollection> YSnappingGuidelines = default)
        {
            var ui = new Windows.Media.ContainerVisual();
            if (BitmapEffect.HasValue) ui.BitmapEffect = BitmapEffect.Value;
            if (BitmapEffectInput.HasValue) ui.BitmapEffectInput = BitmapEffectInput.Value;
            if (CacheMode.HasValue) ui.CacheMode = CacheMode.Value;
            if (Clip.HasValue) ui.Clip = Clip.Value;
            if (Effect.HasValue) ui.Effect = Effect.Value;
            if (Offset.HasValue) ui.Offset = Offset.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (OpacityMask.HasValue) ui.OpacityMask = OpacityMask.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            if (XSnappingGuidelines.HasValue) ui.XSnappingGuidelines = XSnappingGuidelines.Value;
            if (YSnappingGuidelines.HasValue) ui.YSnappingGuidelines = YSnappingGuidelines.Value;
            return global::CSharpMarkup.Wpf.ContainerVisual.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ContainerVisual"/></summary>
        public static ContainerVisual ContainerVisual()
        {
            var ui = new Windows.Media.ContainerVisual();
            return global::CSharpMarkup.Wpf.ContainerVisual.StartChain(ui);
        }
    }

    public partial class ContainerVisual : Visual, IUI<System.Windows.Media.ContainerVisual>
    {
        static ContainerVisual instance;

        internal static ContainerVisual StartChain(Windows.Media.ContainerVisual ui)
        {
            if (instance == null) instance = new ContainerVisual();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.ContainerVisual ui;

        public new Windows.Media.ContainerVisual UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.ContainerVisual(ContainerVisual view) => view?.UI;

        public static implicit operator ContainerVisual(Windows.Media.ContainerVisual ui) => ContainerVisual.StartChain(ui);

        protected ContainerVisual() { }
    }

    public static partial class ContainerVisualExtensions
    {
        /// <summary>Set <see cref="Windows.Media.ContainerVisual.BitmapEffect"/></summary>
        public static TView BitmapEffect<TView>(this TView view, Windows.Media.Effects.BitmapEffect value) where TView : ContainerVisual { view.UI.BitmapEffect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.BitmapEffectInput"/></summary>
        public static TView BitmapEffectInput<TView>(this TView view, Windows.Media.Effects.BitmapEffectInput value) where TView : ContainerVisual { view.UI.BitmapEffectInput = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.CacheMode"/></summary>
        public static TView CacheMode<TView>(this TView view, Windows.Media.CacheMode value) where TView : ContainerVisual { view.UI.CacheMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.Clip"/></summary>
        public static TView Clip<TView>(this TView view, Windows.Media.Geometry value) where TView : ContainerVisual { view.UI.Clip = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.Effect"/></summary>
        public static TView Effect<TView>(this TView view, Windows.Media.Effects.Effect value) where TView : ContainerVisual { view.UI.Effect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.Offset"/></summary>
        public static TView Offset<TView>(this TView view, Windows.Vector value) where TView : ContainerVisual { view.UI.Offset = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : ContainerVisual { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Windows.Media.Brush value) where TView : ContainerVisual { view.UI.OpacityMask = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Color value) where TView : ContainerVisual { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, string color) where TView : ContainerVisual { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : ContainerVisual { view.UI.Transform = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.XSnappingGuidelines"/></summary>
        public static TView XSnappingGuidelines<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : ContainerVisual { view.UI.XSnappingGuidelines = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ContainerVisual.YSnappingGuidelines"/></summary>
        public static TView YSnappingGuidelines<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : ContainerVisual { view.UI.YSnappingGuidelines = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // DashStyle
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DashStyle"/></summary>
        public static DashStyle DashStyle(O<Windows.Media.DoubleCollection> Dashes = default, O<double> Offset = default)
        {
            var ui = new Windows.Media.DashStyle();
            if (Dashes.HasValue) ui.Dashes = Dashes.Value;
            if (Offset.HasValue) ui.Offset = Offset.Value;
            return global::CSharpMarkup.Wpf.DashStyle.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DashStyle"/></summary>
        public static DashStyle DashStyle()
        {
            var ui = new Windows.Media.DashStyle();
            return global::CSharpMarkup.Wpf.DashStyle.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DashStyle"/></summary>
        public static DashStyle DashStyle(IEnumerable<double> dashes, double offset)
        {
            var ui = new Windows.Media.DashStyle(dashes, offset);
            return global::CSharpMarkup.Wpf.DashStyle.StartChain(ui);
        }
    }

    public partial class DashStyle : Animatable, IUI<System.Windows.Media.DashStyle>
    {
        static DashStyle instance;

        internal static DashStyle StartChain(Windows.Media.DashStyle ui)
        {
            if (instance == null) instance = new DashStyle();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DashStyle ui;

        public new Windows.Media.DashStyle UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DashStyle(DashStyle view) => view?.UI;

        public static implicit operator DashStyle(Windows.Media.DashStyle ui) => DashStyle.StartChain(ui);

        protected DashStyle() { }
    }

    public static partial class DashStyleExtensions
    {
        /// <summary>Set <see cref="Windows.Media.DashStyle.Dashes"/></summary>
        public static TView Dashes<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : DashStyle { view.UI.Dashes = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DashStyle.Offset"/></summary>
        public static TView Offset<TView>(this TView view, double value) where TView : DashStyle { view.UI.Offset = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DashStyle.Dashes"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> Dashes<TTarget>(this TTarget target) where TTarget : DashStyle
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Media.DashStyle.DashesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DashStyle.Offset"/></summary>
        public static DependencyProperty<TTarget, double> Offset<TTarget>(this TTarget target) where TTarget : DashStyle
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.DashStyle.OffsetProperty);
    }
}

namespace CSharpMarkup.Wpf // DoubleCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DoubleCollection"/></summary>
        public static DoubleCollection DoubleCollection()
        {
            var ui = new Windows.Media.DoubleCollection();
            return global::CSharpMarkup.Wpf.DoubleCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DoubleCollection"/></summary>
        public static DoubleCollection DoubleCollection(IEnumerable<double> collection)
        {
            var ui = new Windows.Media.DoubleCollection(collection);
            return global::CSharpMarkup.Wpf.DoubleCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DoubleCollection"/></summary>
        public static DoubleCollection DoubleCollection(int capacity)
        {
            var ui = new Windows.Media.DoubleCollection(capacity);
            return global::CSharpMarkup.Wpf.DoubleCollection.StartChain(ui);
        }
    }

    public partial class DoubleCollection : Freezable, IUI<System.Windows.Media.DoubleCollection>
    {
        static DoubleCollection instance;

        internal static DoubleCollection StartChain(Windows.Media.DoubleCollection ui)
        {
            if (instance == null) instance = new DoubleCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DoubleCollection ui;

        public new Windows.Media.DoubleCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DoubleCollection(DoubleCollection view) => view?.UI;

        public static implicit operator DoubleCollection(Windows.Media.DoubleCollection ui) => DoubleCollection.StartChain(ui);

        protected DoubleCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Drawing
{
    public partial class Drawing : Animatable, IUI<System.Windows.Media.Drawing>
    {
        Windows.Media.Drawing ui;

        public new Windows.Media.Drawing UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Drawing() { }
    }
}

namespace CSharpMarkup.Wpf // DrawingBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DrawingBrush"/></summary>
        public static DrawingBrush DrawingBrush(O<Windows.Media.Drawing> Drawing = default)
        {
            var ui = new Windows.Media.DrawingBrush();
            if (Drawing.HasValue) ui.Drawing = Drawing.Value;
            return global::CSharpMarkup.Wpf.DrawingBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingBrush"/></summary>
        public static DrawingBrush DrawingBrush()
        {
            var ui = new Windows.Media.DrawingBrush();
            return global::CSharpMarkup.Wpf.DrawingBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingBrush"/></summary>
        public static DrawingBrush DrawingBrush(Windows.Media.Drawing drawing)
        {
            var ui = new Windows.Media.DrawingBrush(drawing);
            return global::CSharpMarkup.Wpf.DrawingBrush.StartChain(ui);
        }
    }

    public partial class DrawingBrush : TileBrush, IUI<System.Windows.Media.DrawingBrush>
    {
        static DrawingBrush instance;

        internal static DrawingBrush StartChain(Windows.Media.DrawingBrush ui)
        {
            if (instance == null) instance = new DrawingBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DrawingBrush ui;

        public new Windows.Media.DrawingBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DrawingBrush(DrawingBrush view) => view?.UI;

        public static implicit operator DrawingBrush(Windows.Media.DrawingBrush ui) => DrawingBrush.StartChain(ui);

        protected DrawingBrush() { }
    }

    public static partial class DrawingBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.DrawingBrush.Drawing"/></summary>
        public static TView Drawing<TView>(this TView view, Windows.Media.Drawing value) where TView : DrawingBrush { view.UI.Drawing = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingBrush.Drawing"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Drawing> Drawing<TTarget>(this TTarget target) where TTarget : DrawingBrush
        => DependencyProperty<TTarget, Windows.Media.Drawing>.Get(target, Windows.Media.DrawingBrush.DrawingProperty);
    }
}

namespace CSharpMarkup.Wpf // DrawingCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DrawingCollection"/></summary>
        public static DrawingCollection DrawingCollection()
        {
            var ui = new Windows.Media.DrawingCollection();
            return global::CSharpMarkup.Wpf.DrawingCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingCollection"/></summary>
        public static DrawingCollection DrawingCollection(IEnumerable<Windows.Media.Drawing> collection)
        {
            var ui = new Windows.Media.DrawingCollection(collection);
            return global::CSharpMarkup.Wpf.DrawingCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingCollection"/></summary>
        public static DrawingCollection DrawingCollection(int capacity)
        {
            var ui = new Windows.Media.DrawingCollection(capacity);
            return global::CSharpMarkup.Wpf.DrawingCollection.StartChain(ui);
        }
    }

    public partial class DrawingCollection : Animatable, IUI<System.Windows.Media.DrawingCollection>
    {
        static DrawingCollection instance;

        internal static DrawingCollection StartChain(Windows.Media.DrawingCollection ui)
        {
            if (instance == null) instance = new DrawingCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DrawingCollection ui;

        public new Windows.Media.DrawingCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DrawingCollection(DrawingCollection view) => view?.UI;

        public static implicit operator DrawingCollection(Windows.Media.DrawingCollection ui) => DrawingCollection.StartChain(ui);

        protected DrawingCollection() { }
    }
}

namespace CSharpMarkup.Wpf // DrawingGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DrawingGroup"/></summary>
        public static DrawingGroup DrawingGroup(
            params System.Windows.Media.Drawing[] Children
)
        {
            var ui = new Windows.Media.DrawingGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.DrawingGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingGroup"/></summary>
        public static DrawingGroup DrawingGroup(O<Windows.Media.Effects.BitmapEffect> BitmapEffect = default, O<Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput = default, O<Windows.Media.DrawingCollection> Children = default, O<Windows.Media.Geometry> ClipGeometry = default, O<Windows.Media.GuidelineSet> GuidelineSet = default, O<double> Opacity = default, O<Windows.Media.Brush> OpacityMask = default, O<Windows.Media.Transform> Transform = default)
        {
            var ui = new Windows.Media.DrawingGroup();
            if (BitmapEffect.HasValue) ui.BitmapEffect = BitmapEffect.Value;
            if (BitmapEffectInput.HasValue) ui.BitmapEffectInput = BitmapEffectInput.Value;
            if (Children.HasValue) ui.Children = Children.Value;
            if (ClipGeometry.HasValue) ui.ClipGeometry = ClipGeometry.Value;
            if (GuidelineSet.HasValue) ui.GuidelineSet = GuidelineSet.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (OpacityMask.HasValue) ui.OpacityMask = OpacityMask.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            return global::CSharpMarkup.Wpf.DrawingGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingGroup"/></summary>
        public static DrawingGroup DrawingGroup()
        {
            var ui = new Windows.Media.DrawingGroup();
            return global::CSharpMarkup.Wpf.DrawingGroup.StartChain(ui);
        }
    }

    public partial class DrawingGroup : Drawing, IUI<System.Windows.Media.DrawingGroup>
    {
        static DrawingGroup instance;

        internal static DrawingGroup StartChain(Windows.Media.DrawingGroup ui)
        {
            if (instance == null) instance = new DrawingGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DrawingGroup ui;

        public new Windows.Media.DrawingGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DrawingGroup(DrawingGroup view) => view?.UI;

        public static implicit operator DrawingGroup(Windows.Media.DrawingGroup ui) => DrawingGroup.StartChain(ui);

        protected DrawingGroup() { }
    }

    public static partial class DrawingGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.DrawingGroup.BitmapEffect"/></summary>
        public static TView BitmapEffect<TView>(this TView view, Windows.Media.Effects.BitmapEffect value) where TView : DrawingGroup { view.UI.BitmapEffect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.BitmapEffectInput"/></summary>
        public static TView BitmapEffectInput<TView>(this TView view, Windows.Media.Effects.BitmapEffectInput value) where TView : DrawingGroup { view.UI.BitmapEffectInput = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.DrawingCollection value) where TView : DrawingGroup { view.UI.Children = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.ClipGeometry"/></summary>
        public static TView ClipGeometry<TView>(this TView view, Windows.Media.Geometry value) where TView : DrawingGroup { view.UI.ClipGeometry = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.GuidelineSet"/></summary>
        public static TView GuidelineSet<TView>(this TView view, Windows.Media.GuidelineSet value) where TView : DrawingGroup { view.UI.GuidelineSet = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : DrawingGroup { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Windows.Media.Brush value) where TView : DrawingGroup { view.UI.OpacityMask = value; return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Color value) where TView : DrawingGroup { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, string color) where TView : DrawingGroup { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.DrawingGroup.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : DrawingGroup { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.BitmapEffectInput"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectInput>.Get(target, Windows.Media.DrawingGroup.BitmapEffectInputProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.BitmapEffect"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffect> BitmapEffect<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffect>.Get(target, Windows.Media.DrawingGroup.BitmapEffectProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DrawingCollection> Children<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.DrawingCollection>.Get(target, Windows.Media.DrawingGroup.ChildrenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.ClipGeometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> ClipGeometry<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Media.DrawingGroup.ClipGeometryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.GuidelineSet"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GuidelineSet> GuidelineSet<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.GuidelineSet>.Get(target, Windows.Media.DrawingGroup.GuidelineSetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.OpacityMask"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> OpacityMask<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.DrawingGroup.OpacityMaskProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.DrawingGroup.OpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingGroup.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> Transform<TTarget>(this TTarget target) where TTarget : DrawingGroup
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.DrawingGroup.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // DrawingImage
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DrawingImage"/></summary>
        public static DrawingImage DrawingImage(O<Windows.Media.Drawing> Drawing = default)
        {
            var ui = new Windows.Media.DrawingImage();
            if (Drawing.HasValue) ui.Drawing = Drawing.Value;
            return global::CSharpMarkup.Wpf.DrawingImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingImage"/></summary>
        public static DrawingImage DrawingImage()
        {
            var ui = new Windows.Media.DrawingImage();
            return global::CSharpMarkup.Wpf.DrawingImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.DrawingImage"/></summary>
        public static DrawingImage DrawingImage(Windows.Media.Drawing drawing)
        {
            var ui = new Windows.Media.DrawingImage(drawing);
            return global::CSharpMarkup.Wpf.DrawingImage.StartChain(ui);
        }
    }

    public partial class DrawingImage : ImageSource, IUI<System.Windows.Media.DrawingImage>
    {
        static DrawingImage instance;

        internal static DrawingImage StartChain(Windows.Media.DrawingImage ui)
        {
            if (instance == null) instance = new DrawingImage();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DrawingImage ui;

        public new Windows.Media.DrawingImage UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DrawingImage(DrawingImage view) => view?.UI;

        public static implicit operator DrawingImage(Windows.Media.DrawingImage ui) => DrawingImage.StartChain(ui);

        protected DrawingImage() { }
    }

    public static partial class DrawingImageExtensions
    {
        /// <summary>Set <see cref="Windows.Media.DrawingImage.Drawing"/></summary>
        public static TView Drawing<TView>(this TView view, Windows.Media.Drawing value) where TView : DrawingImage { view.UI.Drawing = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.DrawingImage.Drawing"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Drawing> Drawing<TTarget>(this TTarget target) where TTarget : DrawingImage
        => DependencyProperty<TTarget, Windows.Media.Drawing>.Get(target, Windows.Media.DrawingImage.DrawingProperty);
    }
}

namespace CSharpMarkup.Wpf // DrawingVisual
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.DrawingVisual"/></summary>
        public static DrawingVisual DrawingVisual()
        {
            var ui = new Windows.Media.DrawingVisual();
            return global::CSharpMarkup.Wpf.DrawingVisual.StartChain(ui);
        }
    }

    public partial class DrawingVisual : ContainerVisual, IUI<System.Windows.Media.DrawingVisual>
    {
        static DrawingVisual instance;

        internal static DrawingVisual StartChain(Windows.Media.DrawingVisual ui)
        {
            if (instance == null) instance = new DrawingVisual();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.DrawingVisual ui;

        public new Windows.Media.DrawingVisual UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.DrawingVisual(DrawingVisual view) => view?.UI;

        public static implicit operator DrawingVisual(Windows.Media.DrawingVisual ui) => DrawingVisual.StartChain(ui);

        protected DrawingVisual() { }
    }
}

namespace CSharpMarkup.Wpf // EllipseGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.EllipseGeometry"/></summary>
        public static EllipseGeometry EllipseGeometry(O<Windows.Point> Center = default, O<double> RadiusX = default, O<double> RadiusY = default)
        {
            var ui = new Windows.Media.EllipseGeometry();
            if (Center.HasValue) ui.Center = Center.Value;
            if (RadiusX.HasValue) ui.RadiusX = RadiusX.Value;
            if (RadiusY.HasValue) ui.RadiusY = RadiusY.Value;
            return global::CSharpMarkup.Wpf.EllipseGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.EllipseGeometry"/></summary>
        public static EllipseGeometry EllipseGeometry()
        {
            var ui = new Windows.Media.EllipseGeometry();
            return global::CSharpMarkup.Wpf.EllipseGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.EllipseGeometry"/></summary>
        public static EllipseGeometry EllipseGeometry(Windows.Point center, double radiusX, double radiusY)
        {
            var ui = new Windows.Media.EllipseGeometry(center, radiusX, radiusY);
            return global::CSharpMarkup.Wpf.EllipseGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.EllipseGeometry"/></summary>
        public static EllipseGeometry EllipseGeometry(Windows.Point center, double radiusX, double radiusY, Windows.Media.Transform transform)
        {
            var ui = new Windows.Media.EllipseGeometry(center, radiusX, radiusY, transform);
            return global::CSharpMarkup.Wpf.EllipseGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.EllipseGeometry"/></summary>
        public static EllipseGeometry EllipseGeometry(Windows.Rect rect)
        {
            var ui = new Windows.Media.EllipseGeometry(rect);
            return global::CSharpMarkup.Wpf.EllipseGeometry.StartChain(ui);
        }
    }

    public partial class EllipseGeometry : Geometry, IUI<System.Windows.Media.EllipseGeometry>
    {
        static EllipseGeometry instance;

        internal static EllipseGeometry StartChain(Windows.Media.EllipseGeometry ui)
        {
            if (instance == null) instance = new EllipseGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.EllipseGeometry ui;

        public new Windows.Media.EllipseGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.EllipseGeometry(EllipseGeometry view) => view?.UI;

        public static implicit operator EllipseGeometry(Windows.Media.EllipseGeometry ui) => EllipseGeometry.StartChain(ui);

        protected EllipseGeometry() { }
    }

    public static partial class EllipseGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.EllipseGeometry.Center"/></summary>
        public static TView Center<TView>(this TView view, Windows.Point value) where TView : EllipseGeometry { view.UI.Center = value; return view; }

        /// <summary>Set <see cref="Windows.Media.EllipseGeometry.RadiusX"/></summary>
        public static TView RadiusX<TView>(this TView view, double value) where TView : EllipseGeometry { view.UI.RadiusX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.EllipseGeometry.RadiusY"/></summary>
        public static TView RadiusY<TView>(this TView view, double value) where TView : EllipseGeometry { view.UI.RadiusY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.EllipseGeometry.Center"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Center<TTarget>(this TTarget target) where TTarget : EllipseGeometry
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.EllipseGeometry.CenterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.EllipseGeometry.RadiusX"/></summary>
        public static DependencyProperty<TTarget, double> RadiusX<TTarget>(this TTarget target) where TTarget : EllipseGeometry
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.EllipseGeometry.RadiusXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.EllipseGeometry.RadiusY"/></summary>
        public static DependencyProperty<TTarget, double> RadiusY<TTarget>(this TTarget target) where TTarget : EllipseGeometry
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.EllipseGeometry.RadiusYProperty);
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform
{
    public partial class GeneralTransform : Animatable, IUI<System.Windows.Media.GeneralTransform>
    {
        Windows.Media.GeneralTransform ui;

        public new Windows.Media.GeneralTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected GeneralTransform() { }
    }
}

namespace CSharpMarkup.Wpf // GeneralTransformCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GeneralTransformCollection"/></summary>
        public static GeneralTransformCollection GeneralTransformCollection()
        {
            var ui = new Windows.Media.GeneralTransformCollection();
            return global::CSharpMarkup.Wpf.GeneralTransformCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeneralTransformCollection"/></summary>
        public static GeneralTransformCollection GeneralTransformCollection(IEnumerable<Windows.Media.GeneralTransform> collection)
        {
            var ui = new Windows.Media.GeneralTransformCollection(collection);
            return global::CSharpMarkup.Wpf.GeneralTransformCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeneralTransformCollection"/></summary>
        public static GeneralTransformCollection GeneralTransformCollection(int capacity)
        {
            var ui = new Windows.Media.GeneralTransformCollection(capacity);
            return global::CSharpMarkup.Wpf.GeneralTransformCollection.StartChain(ui);
        }
    }

    public partial class GeneralTransformCollection : Animatable, IUI<System.Windows.Media.GeneralTransformCollection>
    {
        static GeneralTransformCollection instance;

        internal static GeneralTransformCollection StartChain(Windows.Media.GeneralTransformCollection ui)
        {
            if (instance == null) instance = new GeneralTransformCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GeneralTransformCollection ui;

        public new Windows.Media.GeneralTransformCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GeneralTransformCollection(GeneralTransformCollection view) => view?.UI;

        public static implicit operator GeneralTransformCollection(Windows.Media.GeneralTransformCollection ui) => GeneralTransformCollection.StartChain(ui);

        protected GeneralTransformCollection() { }
    }
}

namespace CSharpMarkup.Wpf // GeneralTransformGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GeneralTransformGroup"/></summary>
        public static GeneralTransformGroup GeneralTransformGroup(
            params System.Windows.Media.GeneralTransform[] Children
)
        {
            var ui = new Windows.Media.GeneralTransformGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.GeneralTransformGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeneralTransformGroup"/></summary>
        public static GeneralTransformGroup GeneralTransformGroup(O<Windows.Media.GeneralTransformCollection> Children = default)
        {
            var ui = new Windows.Media.GeneralTransformGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.GeneralTransformGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeneralTransformGroup"/></summary>
        public static GeneralTransformGroup GeneralTransformGroup()
        {
            var ui = new Windows.Media.GeneralTransformGroup();
            return global::CSharpMarkup.Wpf.GeneralTransformGroup.StartChain(ui);
        }
    }

    public partial class GeneralTransformGroup : GeneralTransform, IUI<System.Windows.Media.GeneralTransformGroup>
    {
        static GeneralTransformGroup instance;

        internal static GeneralTransformGroup StartChain(Windows.Media.GeneralTransformGroup ui)
        {
            if (instance == null) instance = new GeneralTransformGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GeneralTransformGroup ui;

        public new Windows.Media.GeneralTransformGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GeneralTransformGroup(GeneralTransformGroup view) => view?.UI;

        public static implicit operator GeneralTransformGroup(Windows.Media.GeneralTransformGroup ui) => GeneralTransformGroup.StartChain(ui);

        protected GeneralTransformGroup() { }
    }

    public static partial class GeneralTransformGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GeneralTransformGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.GeneralTransformCollection value) where TView : GeneralTransformGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeneralTransformGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GeneralTransformCollection> Children<TTarget>(this TTarget target) where TTarget : GeneralTransformGroup
        => DependencyProperty<TTarget, Windows.Media.GeneralTransformCollection>.Get(target, Windows.Media.GeneralTransformGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // Geometry
{
    public partial class Geometry : Animatable, IUI<System.Windows.Media.Geometry>
    {
        Windows.Media.Geometry ui;

        public new Windows.Media.Geometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Geometry() { }
    }

    public static partial class GeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Geometry.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : Geometry { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Geometry.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> Transform<TTarget>(this TTarget target) where TTarget : Geometry
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.Geometry.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // GeometryCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GeometryCollection"/></summary>
        public static GeometryCollection GeometryCollection()
        {
            var ui = new Windows.Media.GeometryCollection();
            return global::CSharpMarkup.Wpf.GeometryCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryCollection"/></summary>
        public static GeometryCollection GeometryCollection(IEnumerable<Windows.Media.Geometry> collection)
        {
            var ui = new Windows.Media.GeometryCollection(collection);
            return global::CSharpMarkup.Wpf.GeometryCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryCollection"/></summary>
        public static GeometryCollection GeometryCollection(int capacity)
        {
            var ui = new Windows.Media.GeometryCollection(capacity);
            return global::CSharpMarkup.Wpf.GeometryCollection.StartChain(ui);
        }
    }

    public partial class GeometryCollection : Animatable, IUI<System.Windows.Media.GeometryCollection>
    {
        static GeometryCollection instance;

        internal static GeometryCollection StartChain(Windows.Media.GeometryCollection ui)
        {
            if (instance == null) instance = new GeometryCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GeometryCollection ui;

        public new Windows.Media.GeometryCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GeometryCollection(GeometryCollection view) => view?.UI;

        public static implicit operator GeometryCollection(Windows.Media.GeometryCollection ui) => GeometryCollection.StartChain(ui);

        protected GeometryCollection() { }
    }
}

namespace CSharpMarkup.Wpf // GeometryDrawing
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GeometryDrawing"/></summary>
        public static GeometryDrawing GeometryDrawing(O<Windows.Media.Brush> Brush = default, O<Windows.Media.Geometry> Geometry = default, O<Windows.Media.Pen> Pen = default)
        {
            var ui = new Windows.Media.GeometryDrawing();
            if (Brush.HasValue) ui.Brush = Brush.Value;
            if (Geometry.HasValue) ui.Geometry = Geometry.Value;
            if (Pen.HasValue) ui.Pen = Pen.Value;
            return global::CSharpMarkup.Wpf.GeometryDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryDrawing"/></summary>
        public static GeometryDrawing GeometryDrawing()
        {
            var ui = new Windows.Media.GeometryDrawing();
            return global::CSharpMarkup.Wpf.GeometryDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryDrawing"/></summary>
        public static GeometryDrawing GeometryDrawing(Windows.Media.Brush brush, Windows.Media.Pen pen, Windows.Media.Geometry geometry)
        {
            var ui = new Windows.Media.GeometryDrawing(brush, pen, geometry);
            return global::CSharpMarkup.Wpf.GeometryDrawing.StartChain(ui);
        }
    }

    public partial class GeometryDrawing : Drawing, IUI<System.Windows.Media.GeometryDrawing>
    {
        static GeometryDrawing instance;

        internal static GeometryDrawing StartChain(Windows.Media.GeometryDrawing ui)
        {
            if (instance == null) instance = new GeometryDrawing();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GeometryDrawing ui;

        public new Windows.Media.GeometryDrawing UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GeometryDrawing(GeometryDrawing view) => view?.UI;

        public static implicit operator GeometryDrawing(Windows.Media.GeometryDrawing ui) => GeometryDrawing.StartChain(ui);

        protected GeometryDrawing() { }
    }

    public static partial class GeometryDrawingExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GeometryDrawing.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Windows.Media.Brush value) where TView : GeometryDrawing { view.UI.Brush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GeometryDrawing.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Color value) where TView : GeometryDrawing { view.UI.Brush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.GeometryDrawing.Brush"/></summary>
        public static TView Brush<TView>(this TView view, string color) where TView : GeometryDrawing { view.UI.Brush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.GeometryDrawing.Geometry"/></summary>
        public static TView Geometry<TView>(this TView view, Windows.Media.Geometry value) where TView : GeometryDrawing { view.UI.Geometry = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GeometryDrawing.Pen"/></summary>
        public static TView Pen<TView>(this TView view, Windows.Media.Pen value) where TView : GeometryDrawing { view.UI.Pen = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeometryDrawing.Brush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Brush<TTarget>(this TTarget target) where TTarget : GeometryDrawing
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.GeometryDrawing.BrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeometryDrawing.Geometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Geometry<TTarget>(this TTarget target) where TTarget : GeometryDrawing
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Media.GeometryDrawing.GeometryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeometryDrawing.Pen"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Pen> Pen<TTarget>(this TTarget target) where TTarget : GeometryDrawing
        => DependencyProperty<TTarget, Windows.Media.Pen>.Get(target, Windows.Media.GeometryDrawing.PenProperty);
    }
}

namespace CSharpMarkup.Wpf // GeometryGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GeometryGroup"/></summary>
        public static GeometryGroup GeometryGroup(
            params System.Windows.Media.Geometry[] Children
)
        {
            var ui = new Windows.Media.GeometryGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.GeometryGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryGroup"/></summary>
        public static GeometryGroup GeometryGroup(O<Windows.Media.GeometryCollection> Children = default, O<Windows.Media.FillRule> FillRule = default)
        {
            var ui = new Windows.Media.GeometryGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            if (FillRule.HasValue) ui.FillRule = FillRule.Value;
            return global::CSharpMarkup.Wpf.GeometryGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GeometryGroup"/></summary>
        public static GeometryGroup GeometryGroup()
        {
            var ui = new Windows.Media.GeometryGroup();
            return global::CSharpMarkup.Wpf.GeometryGroup.StartChain(ui);
        }
    }

    public partial class GeometryGroup : Geometry, IUI<System.Windows.Media.GeometryGroup>
    {
        static GeometryGroup instance;

        internal static GeometryGroup StartChain(Windows.Media.GeometryGroup ui)
        {
            if (instance == null) instance = new GeometryGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GeometryGroup ui;

        public new Windows.Media.GeometryGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GeometryGroup(GeometryGroup view) => view?.UI;

        public static implicit operator GeometryGroup(Windows.Media.GeometryGroup ui) => GeometryGroup.StartChain(ui);

        protected GeometryGroup() { }
    }

    public static partial class GeometryGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GeometryGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.GeometryCollection value) where TView : GeometryGroup { view.UI.Children = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GeometryGroup.FillRule"/></summary>
        public static TView FillRule<TView>(this TView view, Windows.Media.FillRule value) where TView : GeometryGroup { view.UI.FillRule = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeometryGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GeometryCollection> Children<TTarget>(this TTarget target) where TTarget : GeometryGroup
        => DependencyProperty<TTarget, Windows.Media.GeometryCollection>.Get(target, Windows.Media.GeometryGroup.ChildrenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GeometryGroup.FillRule"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FillRule> FillRule<TTarget>(this TTarget target) where TTarget : GeometryGroup
        => DependencyProperty<TTarget, Windows.Media.FillRule>.Get(target, Windows.Media.GeometryGroup.FillRuleProperty);
    }
}

namespace CSharpMarkup.Wpf // GlyphRunDrawing
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GlyphRunDrawing"/></summary>
        public static GlyphRunDrawing GlyphRunDrawing(O<Windows.Media.Brush> ForegroundBrush = default, O<Windows.Media.GlyphRun> GlyphRun = default)
        {
            var ui = new Windows.Media.GlyphRunDrawing();
            if (ForegroundBrush.HasValue) ui.ForegroundBrush = ForegroundBrush.Value;
            if (GlyphRun.HasValue) ui.GlyphRun = GlyphRun.Value;
            return global::CSharpMarkup.Wpf.GlyphRunDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GlyphRunDrawing"/></summary>
        public static GlyphRunDrawing GlyphRunDrawing()
        {
            var ui = new Windows.Media.GlyphRunDrawing();
            return global::CSharpMarkup.Wpf.GlyphRunDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GlyphRunDrawing"/></summary>
        public static GlyphRunDrawing GlyphRunDrawing(Windows.Media.Brush foregroundBrush, Windows.Media.GlyphRun glyphRun)
        {
            var ui = new Windows.Media.GlyphRunDrawing(foregroundBrush, glyphRun);
            return global::CSharpMarkup.Wpf.GlyphRunDrawing.StartChain(ui);
        }
    }

    public partial class GlyphRunDrawing : Drawing, IUI<System.Windows.Media.GlyphRunDrawing>
    {
        static GlyphRunDrawing instance;

        internal static GlyphRunDrawing StartChain(Windows.Media.GlyphRunDrawing ui)
        {
            if (instance == null) instance = new GlyphRunDrawing();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GlyphRunDrawing ui;

        public new Windows.Media.GlyphRunDrawing UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GlyphRunDrawing(GlyphRunDrawing view) => view?.UI;

        public static implicit operator GlyphRunDrawing(Windows.Media.GlyphRunDrawing ui) => GlyphRunDrawing.StartChain(ui);

        protected GlyphRunDrawing() { }
    }

    public static partial class GlyphRunDrawingExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GlyphRunDrawing.ForegroundBrush"/></summary>
        public static TView ForegroundBrush<TView>(this TView view, Windows.Media.Brush value) where TView : GlyphRunDrawing { view.UI.ForegroundBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GlyphRunDrawing.ForegroundBrush"/></summary>
        public static TView ForegroundBrush<TView>(this TView view, Color value) where TView : GlyphRunDrawing { view.UI.ForegroundBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.GlyphRunDrawing.ForegroundBrush"/></summary>
        public static TView ForegroundBrush<TView>(this TView view, string color) where TView : GlyphRunDrawing { view.UI.ForegroundBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.GlyphRunDrawing.GlyphRun"/></summary>
        public static TView GlyphRun<TView>(this TView view, Windows.Media.GlyphRun value) where TView : GlyphRunDrawing { view.UI.GlyphRun = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GlyphRunDrawing.ForegroundBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> ForegroundBrush<TTarget>(this TTarget target) where TTarget : GlyphRunDrawing
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.GlyphRunDrawing.ForegroundBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GlyphRunDrawing.GlyphRun"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GlyphRun> GlyphRun<TTarget>(this TTarget target) where TTarget : GlyphRunDrawing
        => DependencyProperty<TTarget, Windows.Media.GlyphRun>.Get(target, Windows.Media.GlyphRunDrawing.GlyphRunProperty);
    }
}

namespace CSharpMarkup.Wpf // GradientBrush
{
    public partial class GradientBrush : Brush, IUI<System.Windows.Media.GradientBrush>
    {
        Windows.Media.GradientBrush ui;

        public new Windows.Media.GradientBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected GradientBrush() { }
    }

    public static partial class GradientBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GradientBrush.ColorInterpolationMode"/></summary>
        public static TView ColorInterpolationMode<TView>(this TView view, Windows.Media.ColorInterpolationMode value) where TView : GradientBrush { view.UI.ColorInterpolationMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GradientBrush.GradientStops"/></summary>
        public static TView GradientStops<TView>(this TView view, Windows.Media.GradientStopCollection value) where TView : GradientBrush { view.UI.GradientStops = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GradientBrush.MappingMode"/></summary>
        public static TView MappingMode<TView>(this TView view, Windows.Media.BrushMappingMode value) where TView : GradientBrush { view.UI.MappingMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GradientBrush.SpreadMethod"/></summary>
        public static TView SpreadMethod<TView>(this TView view, Windows.Media.GradientSpreadMethod value) where TView : GradientBrush { view.UI.SpreadMethod = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientBrush.ColorInterpolationMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ColorInterpolationMode> ColorInterpolationMode<TTarget>(this TTarget target) where TTarget : GradientBrush
        => DependencyProperty<TTarget, Windows.Media.ColorInterpolationMode>.Get(target, Windows.Media.GradientBrush.ColorInterpolationModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientBrush.GradientStops"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GradientStopCollection> GradientStops<TTarget>(this TTarget target) where TTarget : GradientBrush
        => DependencyProperty<TTarget, Windows.Media.GradientStopCollection>.Get(target, Windows.Media.GradientBrush.GradientStopsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientBrush.MappingMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.BrushMappingMode> MappingMode<TTarget>(this TTarget target) where TTarget : GradientBrush
        => DependencyProperty<TTarget, Windows.Media.BrushMappingMode>.Get(target, Windows.Media.GradientBrush.MappingModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientBrush.SpreadMethod"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.GradientSpreadMethod> SpreadMethod<TTarget>(this TTarget target) where TTarget : GradientBrush
        => DependencyProperty<TTarget, Windows.Media.GradientSpreadMethod>.Get(target, Windows.Media.GradientBrush.SpreadMethodProperty);
    }
}

namespace CSharpMarkup.Wpf // GradientStop
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GradientStop"/></summary>
        public static GradientStop GradientStop(O<Color> Color = default, O<double> Offset = default)
        {
            var ui = new Windows.Media.GradientStop();
            if (Color.HasValue) ui.Color = Color.Value;
            if (Offset.HasValue) ui.Offset = Offset.Value;
            return global::CSharpMarkup.Wpf.GradientStop.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GradientStop"/></summary>
        public static GradientStop GradientStop()
        {
            var ui = new Windows.Media.GradientStop();
            return global::CSharpMarkup.Wpf.GradientStop.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GradientStop"/></summary>
        public static GradientStop GradientStop(Color color, double offset)
        {
            var ui = new Windows.Media.GradientStop(color, offset);
            return global::CSharpMarkup.Wpf.GradientStop.StartChain(ui);
        }
    }

    public partial class GradientStop : Animatable, IUI<System.Windows.Media.GradientStop>
    {
        static GradientStop instance;

        internal static GradientStop StartChain(Windows.Media.GradientStop ui)
        {
            if (instance == null) instance = new GradientStop();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GradientStop ui;

        public new Windows.Media.GradientStop UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GradientStop(GradientStop view) => view?.UI;

        public static implicit operator GradientStop(Windows.Media.GradientStop ui) => GradientStop.StartChain(ui);

        protected GradientStop() { }
    }

    public static partial class GradientStopExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GradientStop.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : GradientStop { view.UI.Color = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GradientStop.Offset"/></summary>
        public static TView Offset<TView>(this TView view, double value) where TView : GradientStop { view.UI.Offset = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientStop.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : GradientStop
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.GradientStop.ColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GradientStop.Offset"/></summary>
        public static DependencyProperty<TTarget, double> Offset<TTarget>(this TTarget target) where TTarget : GradientStop
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.GradientStop.OffsetProperty);
    }
}

namespace CSharpMarkup.Wpf // GradientStopCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GradientStopCollection"/></summary>
        public static GradientStopCollection GradientStopCollection()
        {
            var ui = new Windows.Media.GradientStopCollection();
            return global::CSharpMarkup.Wpf.GradientStopCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GradientStopCollection"/></summary>
        public static GradientStopCollection GradientStopCollection(IEnumerable<Windows.Media.GradientStop> collection)
        {
            var ui = new Windows.Media.GradientStopCollection(collection);
            return global::CSharpMarkup.Wpf.GradientStopCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GradientStopCollection"/></summary>
        public static GradientStopCollection GradientStopCollection(int capacity)
        {
            var ui = new Windows.Media.GradientStopCollection(capacity);
            return global::CSharpMarkup.Wpf.GradientStopCollection.StartChain(ui);
        }
    }

    public partial class GradientStopCollection : Animatable, IUI<System.Windows.Media.GradientStopCollection>
    {
        static GradientStopCollection instance;

        internal static GradientStopCollection StartChain(Windows.Media.GradientStopCollection ui)
        {
            if (instance == null) instance = new GradientStopCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GradientStopCollection ui;

        public new Windows.Media.GradientStopCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GradientStopCollection(GradientStopCollection view) => view?.UI;

        public static implicit operator GradientStopCollection(Windows.Media.GradientStopCollection ui) => GradientStopCollection.StartChain(ui);

        protected GradientStopCollection() { }
    }
}

namespace CSharpMarkup.Wpf // GuidelineSet
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.GuidelineSet"/></summary>
        public static GuidelineSet GuidelineSet(O<Windows.Media.DoubleCollection> GuidelinesX = default, O<Windows.Media.DoubleCollection> GuidelinesY = default)
        {
            var ui = new Windows.Media.GuidelineSet();
            if (GuidelinesX.HasValue) ui.GuidelinesX = GuidelinesX.Value;
            if (GuidelinesY.HasValue) ui.GuidelinesY = GuidelinesY.Value;
            return global::CSharpMarkup.Wpf.GuidelineSet.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GuidelineSet"/></summary>
        public static GuidelineSet GuidelineSet()
        {
            var ui = new Windows.Media.GuidelineSet();
            return global::CSharpMarkup.Wpf.GuidelineSet.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.GuidelineSet"/></summary>
        public static GuidelineSet GuidelineSet(double[] guidelinesX, double[] guidelinesY)
        {
            var ui = new Windows.Media.GuidelineSet(guidelinesX, guidelinesY);
            return global::CSharpMarkup.Wpf.GuidelineSet.StartChain(ui);
        }
    }

    public partial class GuidelineSet : Animatable, IUI<System.Windows.Media.GuidelineSet>
    {
        static GuidelineSet instance;

        internal static GuidelineSet StartChain(Windows.Media.GuidelineSet ui)
        {
            if (instance == null) instance = new GuidelineSet();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.GuidelineSet ui;

        public new Windows.Media.GuidelineSet UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.GuidelineSet(GuidelineSet view) => view?.UI;

        public static implicit operator GuidelineSet(Windows.Media.GuidelineSet ui) => GuidelineSet.StartChain(ui);

        protected GuidelineSet() { }
    }

    public static partial class GuidelineSetExtensions
    {
        /// <summary>Set <see cref="Windows.Media.GuidelineSet.GuidelinesX"/></summary>
        public static TView GuidelinesX<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : GuidelineSet { view.UI.GuidelinesX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.GuidelineSet.GuidelinesY"/></summary>
        public static TView GuidelinesY<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : GuidelineSet { view.UI.GuidelinesY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GuidelineSet.GuidelinesX"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> GuidelinesX<TTarget>(this TTarget target) where TTarget : GuidelineSet
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Media.GuidelineSet.GuidelinesXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.GuidelineSet.GuidelinesY"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> GuidelinesY<TTarget>(this TTarget target) where TTarget : GuidelineSet
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Media.GuidelineSet.GuidelinesYProperty);
    }
}

namespace CSharpMarkup.Wpf // HostVisual
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.HostVisual"/></summary>
        public static HostVisual HostVisual()
        {
            var ui = new Windows.Media.HostVisual();
            return global::CSharpMarkup.Wpf.HostVisual.StartChain(ui);
        }
    }

    public partial class HostVisual : ContainerVisual, IUI<System.Windows.Media.HostVisual>
    {
        static HostVisual instance;

        internal static HostVisual StartChain(Windows.Media.HostVisual ui)
        {
            if (instance == null) instance = new HostVisual();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.HostVisual ui;

        public new Windows.Media.HostVisual UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.HostVisual(HostVisual view) => view?.UI;

        public static implicit operator HostVisual(Windows.Media.HostVisual ui) => HostVisual.StartChain(ui);

        protected HostVisual() { }
    }
}

namespace CSharpMarkup.Wpf // ImageBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.ImageBrush"/></summary>
        public static ImageBrush ImageBrush(O<Windows.Media.ImageSource> ImageSource = default)
        {
            var ui = new Windows.Media.ImageBrush();
            if (ImageSource.HasValue) ui.ImageSource = ImageSource.Value;
            return global::CSharpMarkup.Wpf.ImageBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ImageBrush"/></summary>
        public static ImageBrush ImageBrush()
        {
            var ui = new Windows.Media.ImageBrush();
            return global::CSharpMarkup.Wpf.ImageBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ImageBrush"/></summary>
        public static ImageBrush ImageBrush(Windows.Media.ImageSource image)
        {
            var ui = new Windows.Media.ImageBrush(image);
            return global::CSharpMarkup.Wpf.ImageBrush.StartChain(ui);
        }
    }

    public partial class ImageBrush : TileBrush, IUI<System.Windows.Media.ImageBrush>
    {
        static ImageBrush instance;

        internal static ImageBrush StartChain(Windows.Media.ImageBrush ui)
        {
            if (instance == null) instance = new ImageBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.ImageBrush ui;

        public new Windows.Media.ImageBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.ImageBrush(ImageBrush view) => view?.UI;

        public static implicit operator ImageBrush(Windows.Media.ImageBrush ui) => ImageBrush.StartChain(ui);

        protected ImageBrush() { }
    }

    public static partial class ImageBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.ImageBrush.ImageSource"/></summary>
        public static TView ImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : ImageBrush { view.UI.ImageSource = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ImageBrush.ImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ImageSource<TTarget>(this TTarget target) where TTarget : ImageBrush
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Media.ImageBrush.ImageSourceProperty);
    }
}

namespace CSharpMarkup.Wpf // ImageDrawing
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.ImageDrawing"/></summary>
        public static ImageDrawing ImageDrawing(O<Windows.Media.ImageSource> ImageSource = default, O<Windows.Rect> Rect = default)
        {
            var ui = new Windows.Media.ImageDrawing();
            if (ImageSource.HasValue) ui.ImageSource = ImageSource.Value;
            if (Rect.HasValue) ui.Rect = Rect.Value;
            return global::CSharpMarkup.Wpf.ImageDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ImageDrawing"/></summary>
        public static ImageDrawing ImageDrawing()
        {
            var ui = new Windows.Media.ImageDrawing();
            return global::CSharpMarkup.Wpf.ImageDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ImageDrawing"/></summary>
        public static ImageDrawing ImageDrawing(Windows.Media.ImageSource imageSource, Windows.Rect rect)
        {
            var ui = new Windows.Media.ImageDrawing(imageSource, rect);
            return global::CSharpMarkup.Wpf.ImageDrawing.StartChain(ui);
        }
    }

    public partial class ImageDrawing : Drawing, IUI<System.Windows.Media.ImageDrawing>
    {
        static ImageDrawing instance;

        internal static ImageDrawing StartChain(Windows.Media.ImageDrawing ui)
        {
            if (instance == null) instance = new ImageDrawing();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.ImageDrawing ui;

        public new Windows.Media.ImageDrawing UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.ImageDrawing(ImageDrawing view) => view?.UI;

        public static implicit operator ImageDrawing(Windows.Media.ImageDrawing ui) => ImageDrawing.StartChain(ui);

        protected ImageDrawing() { }
    }

    public static partial class ImageDrawingExtensions
    {
        /// <summary>Set <see cref="Windows.Media.ImageDrawing.ImageSource"/></summary>
        public static TView ImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : ImageDrawing { view.UI.ImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ImageDrawing.Rect"/></summary>
        public static TView Rect<TView>(this TView view, Windows.Rect value) where TView : ImageDrawing { view.UI.Rect = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ImageDrawing.ImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ImageSource<TTarget>(this TTarget target) where TTarget : ImageDrawing
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Media.ImageDrawing.ImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ImageDrawing.Rect"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Rect<TTarget>(this TTarget target) where TTarget : ImageDrawing
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.ImageDrawing.RectProperty);
    }
}

namespace CSharpMarkup.Wpf // ImageMetadata
{
    public partial class ImageMetadata : Freezable, IUI<System.Windows.Media.ImageMetadata>
    {
        Windows.Media.ImageMetadata ui;

        public new Windows.Media.ImageMetadata UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ImageMetadata() { }
    }
}

namespace CSharpMarkup.Wpf // ImageSource
{
    public partial class ImageSource : Animatable, IUI<System.Windows.Media.ImageSource>
    {
        Windows.Media.ImageSource ui;

        public new Windows.Media.ImageSource UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ImageSource() { }
    }
}

namespace CSharpMarkup.Wpf // Int32Collection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Int32Collection"/></summary>
        public static Int32Collection Int32Collection()
        {
            var ui = new Windows.Media.Int32Collection();
            return global::CSharpMarkup.Wpf.Int32Collection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Int32Collection"/></summary>
        public static Int32Collection Int32Collection(IEnumerable<int> collection)
        {
            var ui = new Windows.Media.Int32Collection(collection);
            return global::CSharpMarkup.Wpf.Int32Collection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Int32Collection"/></summary>
        public static Int32Collection Int32Collection(int capacity)
        {
            var ui = new Windows.Media.Int32Collection(capacity);
            return global::CSharpMarkup.Wpf.Int32Collection.StartChain(ui);
        }
    }

    public partial class Int32Collection : Freezable, IUI<System.Windows.Media.Int32Collection>
    {
        static Int32Collection instance;

        internal static Int32Collection StartChain(Windows.Media.Int32Collection ui)
        {
            if (instance == null) instance = new Int32Collection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Int32Collection ui;

        public new Windows.Media.Int32Collection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Int32Collection(Int32Collection view) => view?.UI;

        public static implicit operator Int32Collection(Windows.Media.Int32Collection ui) => Int32Collection.StartChain(ui);

        protected Int32Collection() { }
    }
}

namespace CSharpMarkup.Wpf // LinearGradientBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(
            params System.Windows.Media.GradientStop[] GradientStops
)
        {
            var ui = new Windows.Media.LinearGradientBrush();
            foreach (var child in GradientStops) if (child is not null) ui.GradientStops.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.GradientStops);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(O<Windows.Point> EndPoint = default, O<Windows.Point> StartPoint = default)
        {
            var ui = new Windows.Media.LinearGradientBrush();
            if (EndPoint.HasValue) ui.EndPoint = EndPoint.Value;
            if (StartPoint.HasValue) ui.StartPoint = StartPoint.Value;
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush()
        {
            var ui = new Windows.Media.LinearGradientBrush();
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(Color startColor, Color endColor, double angle)
        {
            var ui = new Windows.Media.LinearGradientBrush(startColor, endColor, angle);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(Color startColor, Color endColor, Windows.Point startPoint, Windows.Point endPoint)
        {
            var ui = new Windows.Media.LinearGradientBrush(startColor, endColor, startPoint, endPoint);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(Windows.Media.GradientStopCollection gradientStopCollection)
        {
            var ui = new Windows.Media.LinearGradientBrush(gradientStopCollection);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(Windows.Media.GradientStopCollection gradientStopCollection, double angle)
        {
            var ui = new Windows.Media.LinearGradientBrush(gradientStopCollection, angle);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LinearGradientBrush"/></summary>
        public static LinearGradientBrush LinearGradientBrush(Windows.Media.GradientStopCollection gradientStopCollection, Windows.Point startPoint, Windows.Point endPoint)
        {
            var ui = new Windows.Media.LinearGradientBrush(gradientStopCollection, startPoint, endPoint);
            return global::CSharpMarkup.Wpf.LinearGradientBrush.StartChain(ui);
        }
    }

    public partial class LinearGradientBrush : GradientBrush, IUI<System.Windows.Media.LinearGradientBrush>
    {
        static LinearGradientBrush instance;

        internal static LinearGradientBrush StartChain(Windows.Media.LinearGradientBrush ui)
        {
            if (instance == null) instance = new LinearGradientBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.LinearGradientBrush ui;

        public new Windows.Media.LinearGradientBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.LinearGradientBrush(LinearGradientBrush view) => view?.UI;

        public static implicit operator LinearGradientBrush(Windows.Media.LinearGradientBrush ui) => LinearGradientBrush.StartChain(ui);

        protected LinearGradientBrush() { }
    }

    public static partial class LinearGradientBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.LinearGradientBrush.EndPoint"/></summary>
        public static TView EndPoint<TView>(this TView view, Windows.Point value) where TView : LinearGradientBrush { view.UI.EndPoint = value; return view; }

        /// <summary>Set <see cref="Windows.Media.LinearGradientBrush.StartPoint"/></summary>
        public static TView StartPoint<TView>(this TView view, Windows.Point value) where TView : LinearGradientBrush { view.UI.StartPoint = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.LinearGradientBrush.EndPoint"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> EndPoint<TTarget>(this TTarget target) where TTarget : LinearGradientBrush
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.LinearGradientBrush.EndPointProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.LinearGradientBrush.StartPoint"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> StartPoint<TTarget>(this TTarget target) where TTarget : LinearGradientBrush
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.LinearGradientBrush.StartPointProperty);
    }
}

namespace CSharpMarkup.Wpf // LineGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.LineGeometry"/></summary>
        public static LineGeometry LineGeometry(O<Windows.Point> EndPoint = default, O<Windows.Point> StartPoint = default)
        {
            var ui = new Windows.Media.LineGeometry();
            if (EndPoint.HasValue) ui.EndPoint = EndPoint.Value;
            if (StartPoint.HasValue) ui.StartPoint = StartPoint.Value;
            return global::CSharpMarkup.Wpf.LineGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LineGeometry"/></summary>
        public static LineGeometry LineGeometry()
        {
            var ui = new Windows.Media.LineGeometry();
            return global::CSharpMarkup.Wpf.LineGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LineGeometry"/></summary>
        public static LineGeometry LineGeometry(Windows.Point startPoint, Windows.Point endPoint)
        {
            var ui = new Windows.Media.LineGeometry(startPoint, endPoint);
            return global::CSharpMarkup.Wpf.LineGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LineGeometry"/></summary>
        public static LineGeometry LineGeometry(Windows.Point startPoint, Windows.Point endPoint, Windows.Media.Transform transform)
        {
            var ui = new Windows.Media.LineGeometry(startPoint, endPoint, transform);
            return global::CSharpMarkup.Wpf.LineGeometry.StartChain(ui);
        }
    }

    public partial class LineGeometry : Geometry, IUI<System.Windows.Media.LineGeometry>
    {
        static LineGeometry instance;

        internal static LineGeometry StartChain(Windows.Media.LineGeometry ui)
        {
            if (instance == null) instance = new LineGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.LineGeometry ui;

        public new Windows.Media.LineGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.LineGeometry(LineGeometry view) => view?.UI;

        public static implicit operator LineGeometry(Windows.Media.LineGeometry ui) => LineGeometry.StartChain(ui);

        protected LineGeometry() { }
    }

    public static partial class LineGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.LineGeometry.EndPoint"/></summary>
        public static TView EndPoint<TView>(this TView view, Windows.Point value) where TView : LineGeometry { view.UI.EndPoint = value; return view; }

        /// <summary>Set <see cref="Windows.Media.LineGeometry.StartPoint"/></summary>
        public static TView StartPoint<TView>(this TView view, Windows.Point value) where TView : LineGeometry { view.UI.StartPoint = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.LineGeometry.EndPoint"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> EndPoint<TTarget>(this TTarget target) where TTarget : LineGeometry
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.LineGeometry.EndPointProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.LineGeometry.StartPoint"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> StartPoint<TTarget>(this TTarget target) where TTarget : LineGeometry
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.LineGeometry.StartPointProperty);
    }
}

namespace CSharpMarkup.Wpf // LineSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.LineSegment"/></summary>
        public static LineSegment LineSegment(O<Windows.Point> Point = default)
        {
            var ui = new Windows.Media.LineSegment();
            if (Point.HasValue) ui.Point = Point.Value;
            return global::CSharpMarkup.Wpf.LineSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LineSegment"/></summary>
        public static LineSegment LineSegment()
        {
            var ui = new Windows.Media.LineSegment();
            return global::CSharpMarkup.Wpf.LineSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.LineSegment"/></summary>
        public static LineSegment LineSegment(Windows.Point point, bool isStroked)
        {
            var ui = new Windows.Media.LineSegment(point, isStroked);
            return global::CSharpMarkup.Wpf.LineSegment.StartChain(ui);
        }
    }

    public partial class LineSegment : PathSegment, IUI<System.Windows.Media.LineSegment>
    {
        static LineSegment instance;

        internal static LineSegment StartChain(Windows.Media.LineSegment ui)
        {
            if (instance == null) instance = new LineSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.LineSegment ui;

        public new Windows.Media.LineSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.LineSegment(LineSegment view) => view?.UI;

        public static implicit operator LineSegment(Windows.Media.LineSegment ui) => LineSegment.StartChain(ui);

        protected LineSegment() { }
    }

    public static partial class LineSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.LineSegment.Point"/></summary>
        public static TView Point<TView>(this TView view, Windows.Point value) where TView : LineSegment { view.UI.Point = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.LineSegment.Point"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point<TTarget>(this TTarget target) where TTarget : LineSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.LineSegment.PointProperty);
    }
}

namespace CSharpMarkup.Wpf // MatrixTransform
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.MatrixTransform"/></summary>
        public static MatrixTransform MatrixTransform(O<Windows.Media.Matrix> Matrix = default)
        {
            var ui = new Windows.Media.MatrixTransform();
            if (Matrix.HasValue) ui.Matrix = Matrix.Value;
            return global::CSharpMarkup.Wpf.MatrixTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MatrixTransform"/></summary>
        public static MatrixTransform MatrixTransform()
        {
            var ui = new Windows.Media.MatrixTransform();
            return global::CSharpMarkup.Wpf.MatrixTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MatrixTransform"/></summary>
        public static MatrixTransform MatrixTransform(double m11, double m12, double m21, double m22, double offsetX, double offsetY)
        {
            var ui = new Windows.Media.MatrixTransform(m11, m12, m21, m22, offsetX, offsetY);
            return global::CSharpMarkup.Wpf.MatrixTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MatrixTransform"/></summary>
        public static MatrixTransform MatrixTransform(Windows.Media.Matrix matrix)
        {
            var ui = new Windows.Media.MatrixTransform(matrix);
            return global::CSharpMarkup.Wpf.MatrixTransform.StartChain(ui);
        }
    }

    public partial class MatrixTransform : Transform, IUI<System.Windows.Media.MatrixTransform>
    {
        static MatrixTransform instance;

        internal static MatrixTransform StartChain(Windows.Media.MatrixTransform ui)
        {
            if (instance == null) instance = new MatrixTransform();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.MatrixTransform ui;

        public new Windows.Media.MatrixTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.MatrixTransform(MatrixTransform view) => view?.UI;

        public static implicit operator MatrixTransform(Windows.Media.MatrixTransform ui) => MatrixTransform.StartChain(ui);

        protected MatrixTransform() { }
    }

    public static partial class MatrixTransformExtensions
    {
        /// <summary>Set <see cref="Windows.Media.MatrixTransform.Matrix"/></summary>
        public static TView Matrix<TView>(this TView view, Windows.Media.Matrix value) where TView : MatrixTransform { view.UI.Matrix = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.MatrixTransform.Matrix"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Matrix> Matrix<TTarget>(this TTarget target) where TTarget : MatrixTransform
        => DependencyProperty<TTarget, Windows.Media.Matrix>.Get(target, Windows.Media.MatrixTransform.MatrixProperty);
    }
}

namespace CSharpMarkup.Wpf // MediaPlayer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.MediaPlayer"/></summary>
        public static MediaPlayer MediaPlayer(O<double> Balance = default, O<Windows.Media.MediaClock> Clock = default, O<bool> IsMuted = default, O<TimeSpan> Position = default, O<bool> ScrubbingEnabled = default, O<double> SpeedRatio = default, O<double> Volume = default)
        {
            var ui = new Windows.Media.MediaPlayer();
            if (Balance.HasValue) ui.Balance = Balance.Value;
            if (Clock.HasValue) ui.Clock = Clock.Value;
            if (IsMuted.HasValue) ui.IsMuted = IsMuted.Value;
            if (Position.HasValue) ui.Position = Position.Value;
            if (ScrubbingEnabled.HasValue) ui.ScrubbingEnabled = ScrubbingEnabled.Value;
            if (SpeedRatio.HasValue) ui.SpeedRatio = SpeedRatio.Value;
            if (Volume.HasValue) ui.Volume = Volume.Value;
            return global::CSharpMarkup.Wpf.MediaPlayer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaPlayer"/></summary>
        public static MediaPlayer MediaPlayer()
        {
            var ui = new Windows.Media.MediaPlayer();
            return global::CSharpMarkup.Wpf.MediaPlayer.StartChain(ui);
        }
    }

    public partial class MediaPlayer : Animatable, IUI<System.Windows.Media.MediaPlayer>
    {
        static MediaPlayer instance;

        internal static MediaPlayer StartChain(Windows.Media.MediaPlayer ui)
        {
            if (instance == null) instance = new MediaPlayer();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.MediaPlayer ui;

        public new Windows.Media.MediaPlayer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.MediaPlayer(MediaPlayer view) => view?.UI;

        public static implicit operator MediaPlayer(Windows.Media.MediaPlayer ui) => MediaPlayer.StartChain(ui);

        protected MediaPlayer() { }
    }

    public static partial class MediaPlayerExtensions
    {
        /// <summary>Set <see cref="Windows.Media.MediaPlayer.Balance"/></summary>
        public static TView Balance<TView>(this TView view, double value) where TView : MediaPlayer { view.UI.Balance = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.Clock"/></summary>
        public static TView Clock<TView>(this TView view, Windows.Media.MediaClock value) where TView : MediaPlayer { view.UI.Clock = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.IsMuted"/></summary>
        public static TView IsMuted<TView>(this TView view, bool value) where TView : MediaPlayer { view.UI.IsMuted = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.Position"/></summary>
        public static TView Position<TView>(this TView view, TimeSpan value) where TView : MediaPlayer { view.UI.Position = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.ScrubbingEnabled"/></summary>
        public static TView ScrubbingEnabled<TView>(this TView view, bool value) where TView : MediaPlayer { view.UI.ScrubbingEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.SpeedRatio"/></summary>
        public static TView SpeedRatio<TView>(this TView view, double value) where TView : MediaPlayer { view.UI.SpeedRatio = value; return view; }

        /// <summary>Set <see cref="Windows.Media.MediaPlayer.Volume"/></summary>
        public static TView Volume<TView>(this TView view, double value) where TView : MediaPlayer { view.UI.Volume = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // MediaTimeline
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline(O<Uri> Source = default)
        {
            var ui = new Windows.Media.MediaTimeline();
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline()
        {
            var ui = new Windows.Media.MediaTimeline();
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline(TimeSpan? beginTime)
        {
            var ui = new Windows.Media.MediaTimeline(beginTime);
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline(TimeSpan? beginTime, Windows.Duration duration)
        {
            var ui = new Windows.Media.MediaTimeline(beginTime, duration);
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline(TimeSpan? beginTime, Windows.Duration duration, Windows.Media.Animation.RepeatBehavior repeatBehavior)
        {
            var ui = new Windows.Media.MediaTimeline(beginTime, duration, repeatBehavior);
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.MediaTimeline"/></summary>
        public static MediaTimeline MediaTimeline(Uri source)
        {
            var ui = new Windows.Media.MediaTimeline(source);
            return global::CSharpMarkup.Wpf.MediaTimeline.StartChain(ui);
        }
    }

    public partial class MediaTimeline : Timeline, IUI<System.Windows.Media.MediaTimeline>
    {
        static MediaTimeline instance;

        internal static MediaTimeline StartChain(Windows.Media.MediaTimeline ui)
        {
            if (instance == null) instance = new MediaTimeline();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.MediaTimeline ui;

        public new Windows.Media.MediaTimeline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.MediaTimeline(MediaTimeline view) => view?.UI;

        public static implicit operator MediaTimeline(Windows.Media.MediaTimeline ui) => MediaTimeline.StartChain(ui);

        protected MediaTimeline() { }
    }

    public static partial class MediaTimelineExtensions
    {
        /// <summary>Set <see cref="Windows.Media.MediaTimeline.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : MediaTimeline { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.MediaTimeline.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : MediaTimeline
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Media.MediaTimeline.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // PathFigure
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PathFigure"/></summary>
        public static PathFigure PathFigure(
            params System.Windows.Media.PathSegment[] Segments
)
        {
            var ui = new Windows.Media.PathFigure();
            foreach (var child in Segments) if (child is not null) ui.Segments.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Segments);
            return global::CSharpMarkup.Wpf.PathFigure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathFigure"/></summary>
        public static PathFigure PathFigure(O<bool> IsClosed = default, O<bool> IsFilled = default, O<Windows.Media.PathSegmentCollection> Segments = default, O<Windows.Point> StartPoint = default)
        {
            var ui = new Windows.Media.PathFigure();
            if (IsClosed.HasValue) ui.IsClosed = IsClosed.Value;
            if (IsFilled.HasValue) ui.IsFilled = IsFilled.Value;
            if (Segments.HasValue) ui.Segments = Segments.Value;
            if (StartPoint.HasValue) ui.StartPoint = StartPoint.Value;
            return global::CSharpMarkup.Wpf.PathFigure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathFigure"/></summary>
        public static PathFigure PathFigure()
        {
            var ui = new Windows.Media.PathFigure();
            return global::CSharpMarkup.Wpf.PathFigure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathFigure"/></summary>
        public static PathFigure PathFigure(Windows.Point start, IEnumerable<Windows.Media.PathSegment> segments, bool closed)
        {
            var ui = new Windows.Media.PathFigure(start, segments, closed);
            return global::CSharpMarkup.Wpf.PathFigure.StartChain(ui);
        }
    }

    public partial class PathFigure : Animatable, IUI<System.Windows.Media.PathFigure>
    {
        static PathFigure instance;

        internal static PathFigure StartChain(Windows.Media.PathFigure ui)
        {
            if (instance == null) instance = new PathFigure();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PathFigure ui;

        public new Windows.Media.PathFigure UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PathFigure(PathFigure view) => view?.UI;

        public static implicit operator PathFigure(Windows.Media.PathFigure ui) => PathFigure.StartChain(ui);

        protected PathFigure() { }
    }

    public static partial class PathFigureExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PathFigure.IsClosed"/></summary>
        public static TView IsClosed<TView>(this TView view, bool value) where TView : PathFigure { view.UI.IsClosed = value; return view; }

        /// <summary>Set <see cref="Windows.Media.PathFigure.IsFilled"/></summary>
        public static TView IsFilled<TView>(this TView view, bool value) where TView : PathFigure { view.UI.IsFilled = value; return view; }

        /// <summary>Set <see cref="Windows.Media.PathFigure.Segments"/></summary>
        public static TView Segments<TView>(this TView view, Windows.Media.PathSegmentCollection value) where TView : PathFigure { view.UI.Segments = value; return view; }

        /// <summary>Set <see cref="Windows.Media.PathFigure.StartPoint"/></summary>
        public static TView StartPoint<TView>(this TView view, Windows.Point value) where TView : PathFigure { view.UI.StartPoint = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathFigure.IsClosed"/></summary>
        public static DependencyProperty<TTarget, bool> IsClosed<TTarget>(this TTarget target) where TTarget : PathFigure
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.PathFigure.IsClosedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathFigure.IsFilled"/></summary>
        public static DependencyProperty<TTarget, bool> IsFilled<TTarget>(this TTarget target) where TTarget : PathFigure
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.PathFigure.IsFilledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathFigure.Segments"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PathSegmentCollection> Segments<TTarget>(this TTarget target) where TTarget : PathFigure
        => DependencyProperty<TTarget, Windows.Media.PathSegmentCollection>.Get(target, Windows.Media.PathFigure.SegmentsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathFigure.StartPoint"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> StartPoint<TTarget>(this TTarget target) where TTarget : PathFigure
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.PathFigure.StartPointProperty);
    }
}

namespace CSharpMarkup.Wpf // PathFigureCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PathFigureCollection"/></summary>
        public static PathFigureCollection PathFigureCollection()
        {
            var ui = new Windows.Media.PathFigureCollection();
            return global::CSharpMarkup.Wpf.PathFigureCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathFigureCollection"/></summary>
        public static PathFigureCollection PathFigureCollection(IEnumerable<Windows.Media.PathFigure> collection)
        {
            var ui = new Windows.Media.PathFigureCollection(collection);
            return global::CSharpMarkup.Wpf.PathFigureCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathFigureCollection"/></summary>
        public static PathFigureCollection PathFigureCollection(int capacity)
        {
            var ui = new Windows.Media.PathFigureCollection(capacity);
            return global::CSharpMarkup.Wpf.PathFigureCollection.StartChain(ui);
        }
    }

    public partial class PathFigureCollection : Animatable, IUI<System.Windows.Media.PathFigureCollection>
    {
        static PathFigureCollection instance;

        internal static PathFigureCollection StartChain(Windows.Media.PathFigureCollection ui)
        {
            if (instance == null) instance = new PathFigureCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PathFigureCollection ui;

        public new Windows.Media.PathFigureCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PathFigureCollection(PathFigureCollection view) => view?.UI;

        public static implicit operator PathFigureCollection(Windows.Media.PathFigureCollection ui) => PathFigureCollection.StartChain(ui);

        protected PathFigureCollection() { }
    }
}

namespace CSharpMarkup.Wpf // PathGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PathGeometry"/></summary>
        public static PathGeometry PathGeometry(
            params System.Windows.Media.PathFigure[] Figures
)
        {
            var ui = new Windows.Media.PathGeometry();
            foreach (var child in Figures) if (child is not null) ui.Figures.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Figures);
            return global::CSharpMarkup.Wpf.PathGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathGeometry"/></summary>
        public static PathGeometry PathGeometry(O<Windows.Media.PathFigureCollection> Figures = default, O<Windows.Media.FillRule> FillRule = default)
        {
            var ui = new Windows.Media.PathGeometry();
            if (Figures.HasValue) ui.Figures = Figures.Value;
            if (FillRule.HasValue) ui.FillRule = FillRule.Value;
            return global::CSharpMarkup.Wpf.PathGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathGeometry"/></summary>
        public static PathGeometry PathGeometry()
        {
            var ui = new Windows.Media.PathGeometry();
            return global::CSharpMarkup.Wpf.PathGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathGeometry"/></summary>
        public static PathGeometry PathGeometry(IEnumerable<Windows.Media.PathFigure> figures)
        {
            var ui = new Windows.Media.PathGeometry(figures);
            return global::CSharpMarkup.Wpf.PathGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathGeometry"/></summary>
        public static PathGeometry PathGeometry(IEnumerable<Windows.Media.PathFigure> figures, Windows.Media.FillRule fillRule, Windows.Media.Transform transform)
        {
            var ui = new Windows.Media.PathGeometry(figures, fillRule, transform);
            return global::CSharpMarkup.Wpf.PathGeometry.StartChain(ui);
        }
    }

    public partial class PathGeometry : Geometry, IUI<System.Windows.Media.PathGeometry>
    {
        static PathGeometry instance;

        internal static PathGeometry StartChain(Windows.Media.PathGeometry ui)
        {
            if (instance == null) instance = new PathGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PathGeometry ui;

        public new Windows.Media.PathGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PathGeometry(PathGeometry view) => view?.UI;

        public static implicit operator PathGeometry(Windows.Media.PathGeometry ui) => PathGeometry.StartChain(ui);

        protected PathGeometry() { }
    }

    public static partial class PathGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PathGeometry.Figures"/></summary>
        public static TView Figures<TView>(this TView view, Windows.Media.PathFigureCollection value) where TView : PathGeometry { view.UI.Figures = value; return view; }

        /// <summary>Set <see cref="Windows.Media.PathGeometry.FillRule"/></summary>
        public static TView FillRule<TView>(this TView view, Windows.Media.FillRule value) where TView : PathGeometry { view.UI.FillRule = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathGeometry.Figures"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PathFigureCollection> Figures<TTarget>(this TTarget target) where TTarget : PathGeometry
        => DependencyProperty<TTarget, Windows.Media.PathFigureCollection>.Get(target, Windows.Media.PathGeometry.FiguresProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathGeometry.FillRule"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FillRule> FillRule<TTarget>(this TTarget target) where TTarget : PathGeometry
        => DependencyProperty<TTarget, Windows.Media.FillRule>.Get(target, Windows.Media.PathGeometry.FillRuleProperty);
    }
}

namespace CSharpMarkup.Wpf // PathSegment
{
    public partial class PathSegment : Animatable, IUI<System.Windows.Media.PathSegment>
    {
        Windows.Media.PathSegment ui;

        public new Windows.Media.PathSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected PathSegment() { }
    }

    public static partial class PathSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PathSegment.IsSmoothJoin"/></summary>
        public static TView IsSmoothJoin<TView>(this TView view, bool value) where TView : PathSegment { view.UI.IsSmoothJoin = value; return view; }

        /// <summary>Set <see cref="Windows.Media.PathSegment.IsStroked"/></summary>
        public static TView IsStroked<TView>(this TView view, bool value) where TView : PathSegment { view.UI.IsStroked = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathSegment.IsSmoothJoin"/></summary>
        public static DependencyProperty<TTarget, bool> IsSmoothJoin<TTarget>(this TTarget target) where TTarget : PathSegment
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.PathSegment.IsSmoothJoinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PathSegment.IsStroked"/></summary>
        public static DependencyProperty<TTarget, bool> IsStroked<TTarget>(this TTarget target) where TTarget : PathSegment
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.PathSegment.IsStrokedProperty);
    }
}

namespace CSharpMarkup.Wpf // PathSegmentCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PathSegmentCollection"/></summary>
        public static PathSegmentCollection PathSegmentCollection()
        {
            var ui = new Windows.Media.PathSegmentCollection();
            return global::CSharpMarkup.Wpf.PathSegmentCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathSegmentCollection"/></summary>
        public static PathSegmentCollection PathSegmentCollection(IEnumerable<Windows.Media.PathSegment> collection)
        {
            var ui = new Windows.Media.PathSegmentCollection(collection);
            return global::CSharpMarkup.Wpf.PathSegmentCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PathSegmentCollection"/></summary>
        public static PathSegmentCollection PathSegmentCollection(int capacity)
        {
            var ui = new Windows.Media.PathSegmentCollection(capacity);
            return global::CSharpMarkup.Wpf.PathSegmentCollection.StartChain(ui);
        }
    }

    public partial class PathSegmentCollection : Animatable, IUI<System.Windows.Media.PathSegmentCollection>
    {
        static PathSegmentCollection instance;

        internal static PathSegmentCollection StartChain(Windows.Media.PathSegmentCollection ui)
        {
            if (instance == null) instance = new PathSegmentCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PathSegmentCollection ui;

        public new Windows.Media.PathSegmentCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PathSegmentCollection(PathSegmentCollection view) => view?.UI;

        public static implicit operator PathSegmentCollection(Windows.Media.PathSegmentCollection ui) => PathSegmentCollection.StartChain(ui);

        protected PathSegmentCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Pen
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Pen"/></summary>
        public static Pen Pen(O<Windows.Media.Brush> Brush = default, O<Windows.Media.PenLineCap> DashCap = default, O<Windows.Media.DashStyle> DashStyle = default, O<Windows.Media.PenLineCap> EndLineCap = default, O<Windows.Media.PenLineJoin> LineJoin = default, O<double> MiterLimit = default, O<Windows.Media.PenLineCap> StartLineCap = default, O<double> Thickness = default)
        {
            var ui = new Windows.Media.Pen();
            if (Brush.HasValue) ui.Brush = Brush.Value;
            if (DashCap.HasValue) ui.DashCap = DashCap.Value;
            if (DashStyle.HasValue) ui.DashStyle = DashStyle.Value;
            if (EndLineCap.HasValue) ui.EndLineCap = EndLineCap.Value;
            if (LineJoin.HasValue) ui.LineJoin = LineJoin.Value;
            if (MiterLimit.HasValue) ui.MiterLimit = MiterLimit.Value;
            if (StartLineCap.HasValue) ui.StartLineCap = StartLineCap.Value;
            if (Thickness.HasValue) ui.Thickness = Thickness.Value;
            return global::CSharpMarkup.Wpf.Pen.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Pen"/></summary>
        public static Pen Pen()
        {
            var ui = new Windows.Media.Pen();
            return global::CSharpMarkup.Wpf.Pen.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Pen"/></summary>
        public static Pen Pen(Windows.Media.Brush brush, double thickness)
        {
            var ui = new Windows.Media.Pen(brush, thickness);
            return global::CSharpMarkup.Wpf.Pen.StartChain(ui);
        }
    }

    public partial class Pen : Animatable, IUI<System.Windows.Media.Pen>
    {
        static Pen instance;

        internal static Pen StartChain(Windows.Media.Pen ui)
        {
            if (instance == null) instance = new Pen();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Pen ui;

        public new Windows.Media.Pen UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Pen(Pen view) => view?.UI;

        public static implicit operator Pen(Windows.Media.Pen ui) => Pen.StartChain(ui);

        protected Pen() { }
    }

    public static partial class PenExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Pen.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Windows.Media.Brush value) where TView : Pen { view.UI.Brush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Color value) where TView : Pen { view.UI.Brush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.Brush"/></summary>
        public static TView Brush<TView>(this TView view, string color) where TView : Pen { view.UI.Brush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.DashCap"/></summary>
        public static TView DashCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Pen { view.UI.DashCap = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.DashStyle"/></summary>
        public static TView DashStyle<TView>(this TView view, Windows.Media.DashStyle value) where TView : Pen { view.UI.DashStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.EndLineCap"/></summary>
        public static TView EndLineCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Pen { view.UI.EndLineCap = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.LineJoin"/></summary>
        public static TView LineJoin<TView>(this TView view, Windows.Media.PenLineJoin value) where TView : Pen { view.UI.LineJoin = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.MiterLimit"/></summary>
        public static TView MiterLimit<TView>(this TView view, double value) where TView : Pen { view.UI.MiterLimit = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.StartLineCap"/></summary>
        public static TView StartLineCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Pen { view.UI.StartLineCap = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Pen.Thickness"/></summary>
        public static TView Thickness<TView>(this TView view, double value) where TView : Pen { view.UI.Thickness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.Brush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Brush<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.Pen.BrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.DashCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> DashCap<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Media.Pen.DashCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.DashStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DashStyle> DashStyle<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.DashStyle>.Get(target, Windows.Media.Pen.DashStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.EndLineCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> EndLineCap<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Media.Pen.EndLineCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.LineJoin"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineJoin> LineJoin<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.PenLineJoin>.Get(target, Windows.Media.Pen.LineJoinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.MiterLimit"/></summary>
        public static DependencyProperty<TTarget, double> MiterLimit<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Pen.MiterLimitProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.StartLineCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> StartLineCap<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Media.Pen.StartLineCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Pen.Thickness"/></summary>
        public static DependencyProperty<TTarget, double> Thickness<TTarget>(this TTarget target) where TTarget : Pen
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Pen.ThicknessProperty);
    }
}

namespace CSharpMarkup.Wpf // PointCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PointCollection"/></summary>
        public static PointCollection PointCollection()
        {
            var ui = new Windows.Media.PointCollection();
            return global::CSharpMarkup.Wpf.PointCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PointCollection"/></summary>
        public static PointCollection PointCollection(IEnumerable<Windows.Point> collection)
        {
            var ui = new Windows.Media.PointCollection(collection);
            return global::CSharpMarkup.Wpf.PointCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PointCollection"/></summary>
        public static PointCollection PointCollection(int capacity)
        {
            var ui = new Windows.Media.PointCollection(capacity);
            return global::CSharpMarkup.Wpf.PointCollection.StartChain(ui);
        }
    }

    public partial class PointCollection : Freezable, IUI<System.Windows.Media.PointCollection>
    {
        static PointCollection instance;

        internal static PointCollection StartChain(Windows.Media.PointCollection ui)
        {
            if (instance == null) instance = new PointCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PointCollection ui;

        public new Windows.Media.PointCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PointCollection(PointCollection view) => view?.UI;

        public static implicit operator PointCollection(Windows.Media.PointCollection ui) => PointCollection.StartChain(ui);

        protected PointCollection() { }
    }
}

namespace CSharpMarkup.Wpf // PolyBezierSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PolyBezierSegment"/></summary>
        public static PolyBezierSegment PolyBezierSegment(O<Windows.Media.PointCollection> Points = default)
        {
            var ui = new Windows.Media.PolyBezierSegment();
            if (Points.HasValue) ui.Points = Points.Value;
            return global::CSharpMarkup.Wpf.PolyBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyBezierSegment"/></summary>
        public static PolyBezierSegment PolyBezierSegment()
        {
            var ui = new Windows.Media.PolyBezierSegment();
            return global::CSharpMarkup.Wpf.PolyBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyBezierSegment"/></summary>
        public static PolyBezierSegment PolyBezierSegment(IEnumerable<Windows.Point> points, bool isStroked)
        {
            var ui = new Windows.Media.PolyBezierSegment(points, isStroked);
            return global::CSharpMarkup.Wpf.PolyBezierSegment.StartChain(ui);
        }
    }

    public partial class PolyBezierSegment : PathSegment, IUI<System.Windows.Media.PolyBezierSegment>
    {
        static PolyBezierSegment instance;

        internal static PolyBezierSegment StartChain(Windows.Media.PolyBezierSegment ui)
        {
            if (instance == null) instance = new PolyBezierSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PolyBezierSegment ui;

        public new Windows.Media.PolyBezierSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PolyBezierSegment(PolyBezierSegment view) => view?.UI;

        public static implicit operator PolyBezierSegment(Windows.Media.PolyBezierSegment ui) => PolyBezierSegment.StartChain(ui);

        protected PolyBezierSegment() { }
    }

    public static partial class PolyBezierSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PolyBezierSegment.Points"/></summary>
        public static TView Points<TView>(this TView view, Windows.Media.PointCollection value) where TView : PolyBezierSegment { view.UI.Points = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PolyBezierSegment.Points"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> Points<TTarget>(this TTarget target) where TTarget : PolyBezierSegment
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Media.PolyBezierSegment.PointsProperty);
    }
}

namespace CSharpMarkup.Wpf // PolyLineSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PolyLineSegment"/></summary>
        public static PolyLineSegment PolyLineSegment(O<Windows.Media.PointCollection> Points = default)
        {
            var ui = new Windows.Media.PolyLineSegment();
            if (Points.HasValue) ui.Points = Points.Value;
            return global::CSharpMarkup.Wpf.PolyLineSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyLineSegment"/></summary>
        public static PolyLineSegment PolyLineSegment()
        {
            var ui = new Windows.Media.PolyLineSegment();
            return global::CSharpMarkup.Wpf.PolyLineSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyLineSegment"/></summary>
        public static PolyLineSegment PolyLineSegment(IEnumerable<Windows.Point> points, bool isStroked)
        {
            var ui = new Windows.Media.PolyLineSegment(points, isStroked);
            return global::CSharpMarkup.Wpf.PolyLineSegment.StartChain(ui);
        }
    }

    public partial class PolyLineSegment : PathSegment, IUI<System.Windows.Media.PolyLineSegment>
    {
        static PolyLineSegment instance;

        internal static PolyLineSegment StartChain(Windows.Media.PolyLineSegment ui)
        {
            if (instance == null) instance = new PolyLineSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PolyLineSegment ui;

        public new Windows.Media.PolyLineSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PolyLineSegment(PolyLineSegment view) => view?.UI;

        public static implicit operator PolyLineSegment(Windows.Media.PolyLineSegment ui) => PolyLineSegment.StartChain(ui);

        protected PolyLineSegment() { }
    }

    public static partial class PolyLineSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PolyLineSegment.Points"/></summary>
        public static TView Points<TView>(this TView view, Windows.Media.PointCollection value) where TView : PolyLineSegment { view.UI.Points = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PolyLineSegment.Points"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> Points<TTarget>(this TTarget target) where TTarget : PolyLineSegment
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Media.PolyLineSegment.PointsProperty);
    }
}

namespace CSharpMarkup.Wpf // PolyQuadraticBezierSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.PolyQuadraticBezierSegment"/></summary>
        public static PolyQuadraticBezierSegment PolyQuadraticBezierSegment(O<Windows.Media.PointCollection> Points = default)
        {
            var ui = new Windows.Media.PolyQuadraticBezierSegment();
            if (Points.HasValue) ui.Points = Points.Value;
            return global::CSharpMarkup.Wpf.PolyQuadraticBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyQuadraticBezierSegment"/></summary>
        public static PolyQuadraticBezierSegment PolyQuadraticBezierSegment()
        {
            var ui = new Windows.Media.PolyQuadraticBezierSegment();
            return global::CSharpMarkup.Wpf.PolyQuadraticBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.PolyQuadraticBezierSegment"/></summary>
        public static PolyQuadraticBezierSegment PolyQuadraticBezierSegment(IEnumerable<Windows.Point> points, bool isStroked)
        {
            var ui = new Windows.Media.PolyQuadraticBezierSegment(points, isStroked);
            return global::CSharpMarkup.Wpf.PolyQuadraticBezierSegment.StartChain(ui);
        }
    }

    public partial class PolyQuadraticBezierSegment : PathSegment, IUI<System.Windows.Media.PolyQuadraticBezierSegment>
    {
        static PolyQuadraticBezierSegment instance;

        internal static PolyQuadraticBezierSegment StartChain(Windows.Media.PolyQuadraticBezierSegment ui)
        {
            if (instance == null) instance = new PolyQuadraticBezierSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.PolyQuadraticBezierSegment ui;

        public new Windows.Media.PolyQuadraticBezierSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.PolyQuadraticBezierSegment(PolyQuadraticBezierSegment view) => view?.UI;

        public static implicit operator PolyQuadraticBezierSegment(Windows.Media.PolyQuadraticBezierSegment ui) => PolyQuadraticBezierSegment.StartChain(ui);

        protected PolyQuadraticBezierSegment() { }
    }

    public static partial class PolyQuadraticBezierSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.PolyQuadraticBezierSegment.Points"/></summary>
        public static TView Points<TView>(this TView view, Windows.Media.PointCollection value) where TView : PolyQuadraticBezierSegment { view.UI.Points = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.PolyQuadraticBezierSegment.Points"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> Points<TTarget>(this TTarget target) where TTarget : PolyQuadraticBezierSegment
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Media.PolyQuadraticBezierSegment.PointsProperty);
    }
}

namespace CSharpMarkup.Wpf // QuadraticBezierSegment
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.QuadraticBezierSegment"/></summary>
        public static QuadraticBezierSegment QuadraticBezierSegment(O<Windows.Point> Point1 = default, O<Windows.Point> Point2 = default)
        {
            var ui = new Windows.Media.QuadraticBezierSegment();
            if (Point1.HasValue) ui.Point1 = Point1.Value;
            if (Point2.HasValue) ui.Point2 = Point2.Value;
            return global::CSharpMarkup.Wpf.QuadraticBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.QuadraticBezierSegment"/></summary>
        public static QuadraticBezierSegment QuadraticBezierSegment()
        {
            var ui = new Windows.Media.QuadraticBezierSegment();
            return global::CSharpMarkup.Wpf.QuadraticBezierSegment.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.QuadraticBezierSegment"/></summary>
        public static QuadraticBezierSegment QuadraticBezierSegment(Windows.Point point1, Windows.Point point2, bool isStroked)
        {
            var ui = new Windows.Media.QuadraticBezierSegment(point1, point2, isStroked);
            return global::CSharpMarkup.Wpf.QuadraticBezierSegment.StartChain(ui);
        }
    }

    public partial class QuadraticBezierSegment : PathSegment, IUI<System.Windows.Media.QuadraticBezierSegment>
    {
        static QuadraticBezierSegment instance;

        internal static QuadraticBezierSegment StartChain(Windows.Media.QuadraticBezierSegment ui)
        {
            if (instance == null) instance = new QuadraticBezierSegment();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.QuadraticBezierSegment ui;

        public new Windows.Media.QuadraticBezierSegment UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.QuadraticBezierSegment(QuadraticBezierSegment view) => view?.UI;

        public static implicit operator QuadraticBezierSegment(Windows.Media.QuadraticBezierSegment ui) => QuadraticBezierSegment.StartChain(ui);

        protected QuadraticBezierSegment() { }
    }

    public static partial class QuadraticBezierSegmentExtensions
    {
        /// <summary>Set <see cref="Windows.Media.QuadraticBezierSegment.Point1"/></summary>
        public static TView Point1<TView>(this TView view, Windows.Point value) where TView : QuadraticBezierSegment { view.UI.Point1 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.QuadraticBezierSegment.Point2"/></summary>
        public static TView Point2<TView>(this TView view, Windows.Point value) where TView : QuadraticBezierSegment { view.UI.Point2 = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.QuadraticBezierSegment.Point1"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point1<TTarget>(this TTarget target) where TTarget : QuadraticBezierSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.QuadraticBezierSegment.Point1Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.QuadraticBezierSegment.Point2"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Point2<TTarget>(this TTarget target) where TTarget : QuadraticBezierSegment
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.QuadraticBezierSegment.Point2Property);
    }
}

namespace CSharpMarkup.Wpf // RadialGradientBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.RadialGradientBrush"/></summary>
        public static RadialGradientBrush RadialGradientBrush(
            params System.Windows.Media.GradientStop[] GradientStops
)
        {
            var ui = new Windows.Media.RadialGradientBrush();
            foreach (var child in GradientStops) if (child is not null) ui.GradientStops.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.GradientStops);
            return global::CSharpMarkup.Wpf.RadialGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RadialGradientBrush"/></summary>
        public static RadialGradientBrush RadialGradientBrush(O<Windows.Point> Center = default, O<Windows.Point> GradientOrigin = default, O<double> RadiusX = default, O<double> RadiusY = default)
        {
            var ui = new Windows.Media.RadialGradientBrush();
            if (Center.HasValue) ui.Center = Center.Value;
            if (GradientOrigin.HasValue) ui.GradientOrigin = GradientOrigin.Value;
            if (RadiusX.HasValue) ui.RadiusX = RadiusX.Value;
            if (RadiusY.HasValue) ui.RadiusY = RadiusY.Value;
            return global::CSharpMarkup.Wpf.RadialGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RadialGradientBrush"/></summary>
        public static RadialGradientBrush RadialGradientBrush()
        {
            var ui = new Windows.Media.RadialGradientBrush();
            return global::CSharpMarkup.Wpf.RadialGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RadialGradientBrush"/></summary>
        public static RadialGradientBrush RadialGradientBrush(Color startColor, Color endColor)
        {
            var ui = new Windows.Media.RadialGradientBrush(startColor, endColor);
            return global::CSharpMarkup.Wpf.RadialGradientBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RadialGradientBrush"/></summary>
        public static RadialGradientBrush RadialGradientBrush(Windows.Media.GradientStopCollection gradientStopCollection)
        {
            var ui = new Windows.Media.RadialGradientBrush(gradientStopCollection);
            return global::CSharpMarkup.Wpf.RadialGradientBrush.StartChain(ui);
        }
    }

    public partial class RadialGradientBrush : GradientBrush, IUI<System.Windows.Media.RadialGradientBrush>
    {
        static RadialGradientBrush instance;

        internal static RadialGradientBrush StartChain(Windows.Media.RadialGradientBrush ui)
        {
            if (instance == null) instance = new RadialGradientBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.RadialGradientBrush ui;

        public new Windows.Media.RadialGradientBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.RadialGradientBrush(RadialGradientBrush view) => view?.UI;

        public static implicit operator RadialGradientBrush(Windows.Media.RadialGradientBrush ui) => RadialGradientBrush.StartChain(ui);

        protected RadialGradientBrush() { }
    }

    public static partial class RadialGradientBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.RadialGradientBrush.Center"/></summary>
        public static TView Center<TView>(this TView view, Windows.Point value) where TView : RadialGradientBrush { view.UI.Center = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RadialGradientBrush.GradientOrigin"/></summary>
        public static TView GradientOrigin<TView>(this TView view, Windows.Point value) where TView : RadialGradientBrush { view.UI.GradientOrigin = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RadialGradientBrush.RadiusX"/></summary>
        public static TView RadiusX<TView>(this TView view, double value) where TView : RadialGradientBrush { view.UI.RadiusX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RadialGradientBrush.RadiusY"/></summary>
        public static TView RadiusY<TView>(this TView view, double value) where TView : RadialGradientBrush { view.UI.RadiusY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RadialGradientBrush.Center"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Center<TTarget>(this TTarget target) where TTarget : RadialGradientBrush
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.RadialGradientBrush.CenterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RadialGradientBrush.GradientOrigin"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> GradientOrigin<TTarget>(this TTarget target) where TTarget : RadialGradientBrush
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.RadialGradientBrush.GradientOriginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RadialGradientBrush.RadiusX"/></summary>
        public static DependencyProperty<TTarget, double> RadiusX<TTarget>(this TTarget target) where TTarget : RadialGradientBrush
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RadialGradientBrush.RadiusXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RadialGradientBrush.RadiusY"/></summary>
        public static DependencyProperty<TTarget, double> RadiusY<TTarget>(this TTarget target) where TTarget : RadialGradientBrush
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RadialGradientBrush.RadiusYProperty);
    }
}

namespace CSharpMarkup.Wpf // RectangleGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.RectangleGeometry"/></summary>
        public static RectangleGeometry RectangleGeometry(O<double> RadiusX = default, O<double> RadiusY = default, O<Windows.Rect> Rect = default)
        {
            var ui = new Windows.Media.RectangleGeometry();
            if (RadiusX.HasValue) ui.RadiusX = RadiusX.Value;
            if (RadiusY.HasValue) ui.RadiusY = RadiusY.Value;
            if (Rect.HasValue) ui.Rect = Rect.Value;
            return global::CSharpMarkup.Wpf.RectangleGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RectangleGeometry"/></summary>
        public static RectangleGeometry RectangleGeometry()
        {
            var ui = new Windows.Media.RectangleGeometry();
            return global::CSharpMarkup.Wpf.RectangleGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RectangleGeometry"/></summary>
        public static RectangleGeometry RectangleGeometry(Windows.Rect rect)
        {
            var ui = new Windows.Media.RectangleGeometry(rect);
            return global::CSharpMarkup.Wpf.RectangleGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RectangleGeometry"/></summary>
        public static RectangleGeometry RectangleGeometry(Windows.Rect rect, double radiusX, double radiusY)
        {
            var ui = new Windows.Media.RectangleGeometry(rect, radiusX, radiusY);
            return global::CSharpMarkup.Wpf.RectangleGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RectangleGeometry"/></summary>
        public static RectangleGeometry RectangleGeometry(Windows.Rect rect, double radiusX, double radiusY, Windows.Media.Transform transform)
        {
            var ui = new Windows.Media.RectangleGeometry(rect, radiusX, radiusY, transform);
            return global::CSharpMarkup.Wpf.RectangleGeometry.StartChain(ui);
        }
    }

    public partial class RectangleGeometry : Geometry, IUI<System.Windows.Media.RectangleGeometry>
    {
        static RectangleGeometry instance;

        internal static RectangleGeometry StartChain(Windows.Media.RectangleGeometry ui)
        {
            if (instance == null) instance = new RectangleGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.RectangleGeometry ui;

        public new Windows.Media.RectangleGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.RectangleGeometry(RectangleGeometry view) => view?.UI;

        public static implicit operator RectangleGeometry(Windows.Media.RectangleGeometry ui) => RectangleGeometry.StartChain(ui);

        protected RectangleGeometry() { }
    }

    public static partial class RectangleGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.RectangleGeometry.RadiusX"/></summary>
        public static TView RadiusX<TView>(this TView view, double value) where TView : RectangleGeometry { view.UI.RadiusX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RectangleGeometry.RadiusY"/></summary>
        public static TView RadiusY<TView>(this TView view, double value) where TView : RectangleGeometry { view.UI.RadiusY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RectangleGeometry.Rect"/></summary>
        public static TView Rect<TView>(this TView view, Windows.Rect value) where TView : RectangleGeometry { view.UI.Rect = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RectangleGeometry.RadiusX"/></summary>
        public static DependencyProperty<TTarget, double> RadiusX<TTarget>(this TTarget target) where TTarget : RectangleGeometry
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RectangleGeometry.RadiusXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RectangleGeometry.RadiusY"/></summary>
        public static DependencyProperty<TTarget, double> RadiusY<TTarget>(this TTarget target) where TTarget : RectangleGeometry
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RectangleGeometry.RadiusYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RectangleGeometry.Rect"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Rect<TTarget>(this TTarget target) where TTarget : RectangleGeometry
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.RectangleGeometry.RectProperty);
    }
}

namespace CSharpMarkup.Wpf // RotateTransform
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.RotateTransform"/></summary>
        public static RotateTransform RotateTransform(O<double> Angle = default, O<double> CenterX = default, O<double> CenterY = default)
        {
            var ui = new Windows.Media.RotateTransform();
            if (Angle.HasValue) ui.Angle = Angle.Value;
            if (CenterX.HasValue) ui.CenterX = CenterX.Value;
            if (CenterY.HasValue) ui.CenterY = CenterY.Value;
            return global::CSharpMarkup.Wpf.RotateTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RotateTransform"/></summary>
        public static RotateTransform RotateTransform()
        {
            var ui = new Windows.Media.RotateTransform();
            return global::CSharpMarkup.Wpf.RotateTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RotateTransform"/></summary>
        public static RotateTransform RotateTransform(double angle)
        {
            var ui = new Windows.Media.RotateTransform(angle);
            return global::CSharpMarkup.Wpf.RotateTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.RotateTransform"/></summary>
        public static RotateTransform RotateTransform(double angle, double centerX, double centerY)
        {
            var ui = new Windows.Media.RotateTransform(angle, centerX, centerY);
            return global::CSharpMarkup.Wpf.RotateTransform.StartChain(ui);
        }
    }

    public partial class RotateTransform : Transform, IUI<System.Windows.Media.RotateTransform>
    {
        static RotateTransform instance;

        internal static RotateTransform StartChain(Windows.Media.RotateTransform ui)
        {
            if (instance == null) instance = new RotateTransform();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.RotateTransform ui;

        public new Windows.Media.RotateTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.RotateTransform(RotateTransform view) => view?.UI;

        public static implicit operator RotateTransform(Windows.Media.RotateTransform ui) => RotateTransform.StartChain(ui);

        protected RotateTransform() { }
    }

    public static partial class RotateTransformExtensions
    {
        /// <summary>Set <see cref="Windows.Media.RotateTransform.Angle"/></summary>
        public static TView Angle<TView>(this TView view, double value) where TView : RotateTransform { view.UI.Angle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RotateTransform.CenterX"/></summary>
        public static TView CenterX<TView>(this TView view, double value) where TView : RotateTransform { view.UI.CenterX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.RotateTransform.CenterY"/></summary>
        public static TView CenterY<TView>(this TView view, double value) where TView : RotateTransform { view.UI.CenterY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RotateTransform.Angle"/></summary>
        public static DependencyProperty<TTarget, double> Angle<TTarget>(this TTarget target) where TTarget : RotateTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RotateTransform.AngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RotateTransform.CenterX"/></summary>
        public static DependencyProperty<TTarget, double> CenterX<TTarget>(this TTarget target) where TTarget : RotateTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RotateTransform.CenterXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.RotateTransform.CenterY"/></summary>
        public static DependencyProperty<TTarget, double> CenterY<TTarget>(this TTarget target) where TTarget : RotateTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.RotateTransform.CenterYProperty);
    }
}

namespace CSharpMarkup.Wpf // ScaleTransform
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.ScaleTransform"/></summary>
        public static ScaleTransform ScaleTransform(O<double> CenterX = default, O<double> CenterY = default, O<double> ScaleX = default, O<double> ScaleY = default)
        {
            var ui = new Windows.Media.ScaleTransform();
            if (CenterX.HasValue) ui.CenterX = CenterX.Value;
            if (CenterY.HasValue) ui.CenterY = CenterY.Value;
            if (ScaleX.HasValue) ui.ScaleX = ScaleX.Value;
            if (ScaleY.HasValue) ui.ScaleY = ScaleY.Value;
            return global::CSharpMarkup.Wpf.ScaleTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ScaleTransform"/></summary>
        public static ScaleTransform ScaleTransform()
        {
            var ui = new Windows.Media.ScaleTransform();
            return global::CSharpMarkup.Wpf.ScaleTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ScaleTransform"/></summary>
        public static ScaleTransform ScaleTransform(double scaleX, double scaleY)
        {
            var ui = new Windows.Media.ScaleTransform(scaleX, scaleY);
            return global::CSharpMarkup.Wpf.ScaleTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.ScaleTransform"/></summary>
        public static ScaleTransform ScaleTransform(double scaleX, double scaleY, double centerX, double centerY)
        {
            var ui = new Windows.Media.ScaleTransform(scaleX, scaleY, centerX, centerY);
            return global::CSharpMarkup.Wpf.ScaleTransform.StartChain(ui);
        }
    }

    public partial class ScaleTransform : Transform, IUI<System.Windows.Media.ScaleTransform>
    {
        static ScaleTransform instance;

        internal static ScaleTransform StartChain(Windows.Media.ScaleTransform ui)
        {
            if (instance == null) instance = new ScaleTransform();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.ScaleTransform ui;

        public new Windows.Media.ScaleTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.ScaleTransform(ScaleTransform view) => view?.UI;

        public static implicit operator ScaleTransform(Windows.Media.ScaleTransform ui) => ScaleTransform.StartChain(ui);

        protected ScaleTransform() { }
    }

    public static partial class ScaleTransformExtensions
    {
        /// <summary>Set <see cref="Windows.Media.ScaleTransform.CenterX"/></summary>
        public static TView CenterX<TView>(this TView view, double value) where TView : ScaleTransform { view.UI.CenterX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ScaleTransform.CenterY"/></summary>
        public static TView CenterY<TView>(this TView view, double value) where TView : ScaleTransform { view.UI.CenterY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ScaleTransform.ScaleX"/></summary>
        public static TView ScaleX<TView>(this TView view, double value) where TView : ScaleTransform { view.UI.ScaleX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.ScaleTransform.ScaleY"/></summary>
        public static TView ScaleY<TView>(this TView view, double value) where TView : ScaleTransform { view.UI.ScaleY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ScaleTransform.CenterX"/></summary>
        public static DependencyProperty<TTarget, double> CenterX<TTarget>(this TTarget target) where TTarget : ScaleTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.ScaleTransform.CenterXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ScaleTransform.CenterY"/></summary>
        public static DependencyProperty<TTarget, double> CenterY<TTarget>(this TTarget target) where TTarget : ScaleTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.ScaleTransform.CenterYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ScaleTransform.ScaleX"/></summary>
        public static DependencyProperty<TTarget, double> ScaleX<TTarget>(this TTarget target) where TTarget : ScaleTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.ScaleTransform.ScaleXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.ScaleTransform.ScaleY"/></summary>
        public static DependencyProperty<TTarget, double> ScaleY<TTarget>(this TTarget target) where TTarget : ScaleTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.ScaleTransform.ScaleYProperty);
    }
}

namespace CSharpMarkup.Wpf // SkewTransform
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.SkewTransform"/></summary>
        public static SkewTransform SkewTransform(O<double> AngleX = default, O<double> AngleY = default, O<double> CenterX = default, O<double> CenterY = default)
        {
            var ui = new Windows.Media.SkewTransform();
            if (AngleX.HasValue) ui.AngleX = AngleX.Value;
            if (AngleY.HasValue) ui.AngleY = AngleY.Value;
            if (CenterX.HasValue) ui.CenterX = CenterX.Value;
            if (CenterY.HasValue) ui.CenterY = CenterY.Value;
            return global::CSharpMarkup.Wpf.SkewTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.SkewTransform"/></summary>
        public static SkewTransform SkewTransform()
        {
            var ui = new Windows.Media.SkewTransform();
            return global::CSharpMarkup.Wpf.SkewTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.SkewTransform"/></summary>
        public static SkewTransform SkewTransform(double angleX, double angleY)
        {
            var ui = new Windows.Media.SkewTransform(angleX, angleY);
            return global::CSharpMarkup.Wpf.SkewTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.SkewTransform"/></summary>
        public static SkewTransform SkewTransform(double angleX, double angleY, double centerX, double centerY)
        {
            var ui = new Windows.Media.SkewTransform(angleX, angleY, centerX, centerY);
            return global::CSharpMarkup.Wpf.SkewTransform.StartChain(ui);
        }
    }

    public partial class SkewTransform : Transform, IUI<System.Windows.Media.SkewTransform>
    {
        static SkewTransform instance;

        internal static SkewTransform StartChain(Windows.Media.SkewTransform ui)
        {
            if (instance == null) instance = new SkewTransform();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.SkewTransform ui;

        public new Windows.Media.SkewTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.SkewTransform(SkewTransform view) => view?.UI;

        public static implicit operator SkewTransform(Windows.Media.SkewTransform ui) => SkewTransform.StartChain(ui);

        protected SkewTransform() { }
    }

    public static partial class SkewTransformExtensions
    {
        /// <summary>Set <see cref="Windows.Media.SkewTransform.AngleX"/></summary>
        public static TView AngleX<TView>(this TView view, double value) where TView : SkewTransform { view.UI.AngleX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.SkewTransform.AngleY"/></summary>
        public static TView AngleY<TView>(this TView view, double value) where TView : SkewTransform { view.UI.AngleY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.SkewTransform.CenterX"/></summary>
        public static TView CenterX<TView>(this TView view, double value) where TView : SkewTransform { view.UI.CenterX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.SkewTransform.CenterY"/></summary>
        public static TView CenterY<TView>(this TView view, double value) where TView : SkewTransform { view.UI.CenterY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.SkewTransform.AngleX"/></summary>
        public static DependencyProperty<TTarget, double> AngleX<TTarget>(this TTarget target) where TTarget : SkewTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.SkewTransform.AngleXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.SkewTransform.AngleY"/></summary>
        public static DependencyProperty<TTarget, double> AngleY<TTarget>(this TTarget target) where TTarget : SkewTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.SkewTransform.AngleYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.SkewTransform.CenterX"/></summary>
        public static DependencyProperty<TTarget, double> CenterX<TTarget>(this TTarget target) where TTarget : SkewTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.SkewTransform.CenterXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.SkewTransform.CenterY"/></summary>
        public static DependencyProperty<TTarget, double> CenterY<TTarget>(this TTarget target) where TTarget : SkewTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.SkewTransform.CenterYProperty);
    }
}

namespace CSharpMarkup.Wpf // SolidColorBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.SolidColorBrush"/></summary>
        /// <remarks>Remark: SolidColorBrush().Bind() binds to <see cref="Windows.Media.SolidColorBrush.ColorProperty"/></remarks>
        public static SolidColorBrush SolidColorBrush(O<Color> Color = default)
        {
            var ui = new Windows.Media.SolidColorBrush();
            if (Color.HasValue) ui.Color = Color.Value;
            return global::CSharpMarkup.Wpf.SolidColorBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.SolidColorBrush"/></summary>
        /// <remarks>Remark: SolidColorBrush().Bind() binds to <see cref="Windows.Media.SolidColorBrush.ColorProperty"/></remarks>
        public static SolidColorBrush SolidColorBrush()
        {
            var ui = new Windows.Media.SolidColorBrush();
            return global::CSharpMarkup.Wpf.SolidColorBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.SolidColorBrush"/></summary>
        /// <remarks>Remark: SolidColorBrush().Bind() binds to <see cref="Windows.Media.SolidColorBrush.ColorProperty"/></remarks>
        public static SolidColorBrush SolidColorBrush(Color color)
        {
            var ui = new Windows.Media.SolidColorBrush(color);
            return global::CSharpMarkup.Wpf.SolidColorBrush.StartChain(ui);
        }
    }

    public partial class SolidColorBrush : Brush, IUI<System.Windows.Media.SolidColorBrush>, IDefaultBindProperty
    {
        static SolidColorBrush instance;

        internal static SolidColorBrush StartChain(Windows.Media.SolidColorBrush ui)
        {
            if (instance == null) instance = new SolidColorBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.SolidColorBrush ui;

        public new Windows.Media.SolidColorBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Media.SolidColorBrush.ColorProperty"/></summary>
        public Windows.DependencyProperty DefaultBindProperty => Windows.Media.SolidColorBrush.ColorProperty;

        public static implicit operator Windows.Media.SolidColorBrush(SolidColorBrush view) => view?.UI;

        public static implicit operator SolidColorBrush(Windows.Media.SolidColorBrush ui) => SolidColorBrush.StartChain(ui);

        protected SolidColorBrush() { }
    }

    public static partial class SolidColorBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.SolidColorBrush.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : SolidColorBrush { view.UI.Color = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.SolidColorBrush.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : SolidColorBrush
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.SolidColorBrush.ColorProperty);
    }
}

namespace CSharpMarkup.Wpf // StreamGeometry
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.StreamGeometry"/></summary>
        public static StreamGeometry StreamGeometry(O<Windows.Media.FillRule> FillRule = default)
        {
            var ui = new Windows.Media.StreamGeometry();
            if (FillRule.HasValue) ui.FillRule = FillRule.Value;
            return global::CSharpMarkup.Wpf.StreamGeometry.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.StreamGeometry"/></summary>
        public static StreamGeometry StreamGeometry()
        {
            var ui = new Windows.Media.StreamGeometry();
            return global::CSharpMarkup.Wpf.StreamGeometry.StartChain(ui);
        }
    }

    public partial class StreamGeometry : Geometry, IUI<System.Windows.Media.StreamGeometry>
    {
        static StreamGeometry instance;

        internal static StreamGeometry StartChain(Windows.Media.StreamGeometry ui)
        {
            if (instance == null) instance = new StreamGeometry();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.StreamGeometry ui;

        public new Windows.Media.StreamGeometry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.StreamGeometry(StreamGeometry view) => view?.UI;

        public static implicit operator StreamGeometry(Windows.Media.StreamGeometry ui) => StreamGeometry.StartChain(ui);

        protected StreamGeometry() { }
    }

    public static partial class StreamGeometryExtensions
    {
        /// <summary>Set <see cref="Windows.Media.StreamGeometry.FillRule"/></summary>
        public static TView FillRule<TView>(this TView view, Windows.Media.FillRule value) where TView : StreamGeometry { view.UI.FillRule = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.StreamGeometry.FillRule"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FillRule> FillRule<TTarget>(this TTarget target) where TTarget : StreamGeometry
        => DependencyProperty<TTarget, Windows.Media.FillRule>.Get(target, Windows.Media.StreamGeometry.FillRuleProperty);
    }
}

namespace CSharpMarkup.Wpf // TextEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.TextEffect"/></summary>
        public static TextEffect TextEffect(O<Windows.Media.Geometry> Clip = default, O<Windows.Media.Brush> Foreground = default, O<int> PositionCount = default, O<int> PositionStart = default, O<Windows.Media.Transform> Transform = default)
        {
            var ui = new Windows.Media.TextEffect();
            if (Clip.HasValue) ui.Clip = Clip.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (PositionCount.HasValue) ui.PositionCount = PositionCount.Value;
            if (PositionStart.HasValue) ui.PositionStart = PositionStart.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            return global::CSharpMarkup.Wpf.TextEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TextEffect"/></summary>
        public static TextEffect TextEffect()
        {
            var ui = new Windows.Media.TextEffect();
            return global::CSharpMarkup.Wpf.TextEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TextEffect"/></summary>
        public static TextEffect TextEffect(Windows.Media.Transform transform, Windows.Media.Brush foreground, Windows.Media.Geometry clip, int positionStart, int positionCount)
        {
            var ui = new Windows.Media.TextEffect(transform, foreground, clip, positionStart, positionCount);
            return global::CSharpMarkup.Wpf.TextEffect.StartChain(ui);
        }
    }

    public partial class TextEffect : Animatable, IUI<System.Windows.Media.TextEffect>
    {
        static TextEffect instance;

        internal static TextEffect StartChain(Windows.Media.TextEffect ui)
        {
            if (instance == null) instance = new TextEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.TextEffect ui;

        public new Windows.Media.TextEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.TextEffect(TextEffect view) => view?.UI;

        public static implicit operator TextEffect(Windows.Media.TextEffect ui) => TextEffect.StartChain(ui);

        protected TextEffect() { }
    }

    public static partial class TextEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.TextEffect.Clip"/></summary>
        public static TView Clip<TView>(this TView view, Windows.Media.Geometry value) where TView : TextEffect { view.UI.Clip = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : TextEffect { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : TextEffect { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : TextEffect { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.PositionCount"/></summary>
        public static TView PositionCount<TView>(this TView view, int value) where TView : TextEffect { view.UI.PositionCount = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.PositionStart"/></summary>
        public static TView PositionStart<TView>(this TView view, int value) where TView : TextEffect { view.UI.PositionStart = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TextEffect.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : TextEffect { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TextEffect.Clip"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Clip<TTarget>(this TTarget target) where TTarget : TextEffect
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Media.TextEffect.ClipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TextEffect.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : TextEffect
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.TextEffect.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TextEffect.PositionCount"/></summary>
        public static DependencyProperty<TTarget, int> PositionCount<TTarget>(this TTarget target) where TTarget : TextEffect
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.TextEffect.PositionCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TextEffect.PositionStart"/></summary>
        public static DependencyProperty<TTarget, int> PositionStart<TTarget>(this TTarget target) where TTarget : TextEffect
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.TextEffect.PositionStartProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TextEffect.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> Transform<TTarget>(this TTarget target) where TTarget : TextEffect
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.TextEffect.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // TextEffectCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.TextEffectCollection"/></summary>
        public static TextEffectCollection TextEffectCollection()
        {
            var ui = new Windows.Media.TextEffectCollection();
            return global::CSharpMarkup.Wpf.TextEffectCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TextEffectCollection"/></summary>
        public static TextEffectCollection TextEffectCollection(IEnumerable<Windows.Media.TextEffect> collection)
        {
            var ui = new Windows.Media.TextEffectCollection(collection);
            return global::CSharpMarkup.Wpf.TextEffectCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TextEffectCollection"/></summary>
        public static TextEffectCollection TextEffectCollection(int capacity)
        {
            var ui = new Windows.Media.TextEffectCollection(capacity);
            return global::CSharpMarkup.Wpf.TextEffectCollection.StartChain(ui);
        }
    }

    public partial class TextEffectCollection : Animatable, IUI<System.Windows.Media.TextEffectCollection>
    {
        static TextEffectCollection instance;

        internal static TextEffectCollection StartChain(Windows.Media.TextEffectCollection ui)
        {
            if (instance == null) instance = new TextEffectCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.TextEffectCollection ui;

        public new Windows.Media.TextEffectCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.TextEffectCollection(TextEffectCollection view) => view?.UI;

        public static implicit operator TextEffectCollection(Windows.Media.TextEffectCollection ui) => TextEffectCollection.StartChain(ui);

        protected TextEffectCollection() { }
    }
}

namespace CSharpMarkup.Wpf // TileBrush
{
    public partial class TileBrush : Brush, IUI<System.Windows.Media.TileBrush>
    {
        Windows.Media.TileBrush ui;

        public new Windows.Media.TileBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TileBrush() { }
    }

    public static partial class TileBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.TileBrush.AlignmentX"/></summary>
        public static TView AlignmentX<TView>(this TView view, Windows.Media.AlignmentX value) where TView : TileBrush { view.UI.AlignmentX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.AlignmentY"/></summary>
        public static TView AlignmentY<TView>(this TView view, Windows.Media.AlignmentY value) where TView : TileBrush { view.UI.AlignmentY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : TileBrush { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.TileMode"/></summary>
        public static TView TileMode<TView>(this TView view, Windows.Media.TileMode value) where TView : TileBrush { view.UI.TileMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.Viewbox"/></summary>
        public static TView Viewbox<TView>(this TView view, Windows.Rect value) where TView : TileBrush { view.UI.Viewbox = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.ViewboxUnits"/></summary>
        public static TView ViewboxUnits<TView>(this TView view, Windows.Media.BrushMappingMode value) where TView : TileBrush { view.UI.ViewboxUnits = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.Viewport"/></summary>
        public static TView Viewport<TView>(this TView view, Windows.Rect value) where TView : TileBrush { view.UI.Viewport = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TileBrush.ViewportUnits"/></summary>
        public static TView ViewportUnits<TView>(this TView view, Windows.Media.BrushMappingMode value) where TView : TileBrush { view.UI.ViewportUnits = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.AlignmentX"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.AlignmentX> AlignmentX<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.AlignmentX>.Get(target, Windows.Media.TileBrush.AlignmentXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.AlignmentY"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.AlignmentY> AlignmentY<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.AlignmentY>.Get(target, Windows.Media.TileBrush.AlignmentYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Media.TileBrush.StretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.TileMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TileMode> TileMode<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.TileMode>.Get(target, Windows.Media.TileBrush.TileModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.Viewbox"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Viewbox<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.TileBrush.ViewboxProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.ViewboxUnits"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.BrushMappingMode> ViewboxUnits<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.BrushMappingMode>.Get(target, Windows.Media.TileBrush.ViewboxUnitsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.Viewport"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Viewport<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.TileBrush.ViewportProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TileBrush.ViewportUnits"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.BrushMappingMode> ViewportUnits<TTarget>(this TTarget target) where TTarget : TileBrush
        => DependencyProperty<TTarget, Windows.Media.BrushMappingMode>.Get(target, Windows.Media.TileBrush.ViewportUnitsProperty);
    }
}

namespace CSharpMarkup.Wpf // Transform
{
    public partial class Transform : GeneralTransform, IUI<System.Windows.Media.Transform>
    {
        Windows.Media.Transform ui;

        public new Windows.Media.Transform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Transform() { }
    }
}

namespace CSharpMarkup.Wpf // TransformCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.TransformCollection"/></summary>
        public static TransformCollection TransformCollection()
        {
            var ui = new Windows.Media.TransformCollection();
            return global::CSharpMarkup.Wpf.TransformCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TransformCollection"/></summary>
        public static TransformCollection TransformCollection(IEnumerable<Windows.Media.Transform> collection)
        {
            var ui = new Windows.Media.TransformCollection(collection);
            return global::CSharpMarkup.Wpf.TransformCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TransformCollection"/></summary>
        public static TransformCollection TransformCollection(int capacity)
        {
            var ui = new Windows.Media.TransformCollection(capacity);
            return global::CSharpMarkup.Wpf.TransformCollection.StartChain(ui);
        }
    }

    public partial class TransformCollection : Animatable, IUI<System.Windows.Media.TransformCollection>
    {
        static TransformCollection instance;

        internal static TransformCollection StartChain(Windows.Media.TransformCollection ui)
        {
            if (instance == null) instance = new TransformCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.TransformCollection ui;

        public new Windows.Media.TransformCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.TransformCollection(TransformCollection view) => view?.UI;

        public static implicit operator TransformCollection(Windows.Media.TransformCollection ui) => TransformCollection.StartChain(ui);

        protected TransformCollection() { }
    }
}

namespace CSharpMarkup.Wpf // TransformGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.TransformGroup"/></summary>
        public static TransformGroup TransformGroup(
            params System.Windows.Media.Transform[] Children
)
        {
            var ui = new Windows.Media.TransformGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.TransformGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TransformGroup"/></summary>
        public static TransformGroup TransformGroup(O<Windows.Media.TransformCollection> Children = default)
        {
            var ui = new Windows.Media.TransformGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.TransformGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TransformGroup"/></summary>
        public static TransformGroup TransformGroup()
        {
            var ui = new Windows.Media.TransformGroup();
            return global::CSharpMarkup.Wpf.TransformGroup.StartChain(ui);
        }
    }

    public partial class TransformGroup : Transform, IUI<System.Windows.Media.TransformGroup>
    {
        static TransformGroup instance;

        internal static TransformGroup StartChain(Windows.Media.TransformGroup ui)
        {
            if (instance == null) instance = new TransformGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.TransformGroup ui;

        public new Windows.Media.TransformGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.TransformGroup(TransformGroup view) => view?.UI;

        public static implicit operator TransformGroup(Windows.Media.TransformGroup ui) => TransformGroup.StartChain(ui);

        protected TransformGroup() { }
    }

    public static partial class TransformGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.TransformGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.TransformCollection value) where TView : TransformGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TransformGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TransformCollection> Children<TTarget>(this TTarget target) where TTarget : TransformGroup
        => DependencyProperty<TTarget, Windows.Media.TransformCollection>.Get(target, Windows.Media.TransformGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // TranslateTransform
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.TranslateTransform"/></summary>
        public static TranslateTransform TranslateTransform(O<double> X = default, O<double> Y = default)
        {
            var ui = new Windows.Media.TranslateTransform();
            if (X.HasValue) ui.X = X.Value;
            if (Y.HasValue) ui.Y = Y.Value;
            return global::CSharpMarkup.Wpf.TranslateTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TranslateTransform"/></summary>
        public static TranslateTransform TranslateTransform()
        {
            var ui = new Windows.Media.TranslateTransform();
            return global::CSharpMarkup.Wpf.TranslateTransform.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.TranslateTransform"/></summary>
        public static TranslateTransform TranslateTransform(double offsetX, double offsetY)
        {
            var ui = new Windows.Media.TranslateTransform(offsetX, offsetY);
            return global::CSharpMarkup.Wpf.TranslateTransform.StartChain(ui);
        }
    }

    public partial class TranslateTransform : Transform, IUI<System.Windows.Media.TranslateTransform>
    {
        static TranslateTransform instance;

        internal static TranslateTransform StartChain(Windows.Media.TranslateTransform ui)
        {
            if (instance == null) instance = new TranslateTransform();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.TranslateTransform ui;

        public new Windows.Media.TranslateTransform UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.TranslateTransform(TranslateTransform view) => view?.UI;

        public static implicit operator TranslateTransform(Windows.Media.TranslateTransform ui) => TranslateTransform.StartChain(ui);

        protected TranslateTransform() { }
    }

    public static partial class TranslateTransformExtensions
    {
        /// <summary>Set <see cref="Windows.Media.TranslateTransform.X"/></summary>
        public static TView X<TView>(this TView view, double value) where TView : TranslateTransform { view.UI.X = value; return view; }

        /// <summary>Set <see cref="Windows.Media.TranslateTransform.Y"/></summary>
        public static TView Y<TView>(this TView view, double value) where TView : TranslateTransform { view.UI.Y = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TranslateTransform.X"/></summary>
        public static DependencyProperty<TTarget, double> X<TTarget>(this TTarget target) where TTarget : TranslateTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.TranslateTransform.XProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.TranslateTransform.Y"/></summary>
        public static DependencyProperty<TTarget, double> Y<TTarget>(this TTarget target) where TTarget : TranslateTransform
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.TranslateTransform.YProperty);
    }
}

namespace CSharpMarkup.Wpf // VectorCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.VectorCollection"/></summary>
        public static VectorCollection VectorCollection()
        {
            var ui = new Windows.Media.VectorCollection();
            return global::CSharpMarkup.Wpf.VectorCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.VectorCollection"/></summary>
        public static VectorCollection VectorCollection(IEnumerable<Windows.Vector> collection)
        {
            var ui = new Windows.Media.VectorCollection(collection);
            return global::CSharpMarkup.Wpf.VectorCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.VectorCollection"/></summary>
        public static VectorCollection VectorCollection(int capacity)
        {
            var ui = new Windows.Media.VectorCollection(capacity);
            return global::CSharpMarkup.Wpf.VectorCollection.StartChain(ui);
        }
    }

    public partial class VectorCollection : Freezable, IUI<System.Windows.Media.VectorCollection>
    {
        static VectorCollection instance;

        internal static VectorCollection StartChain(Windows.Media.VectorCollection ui)
        {
            if (instance == null) instance = new VectorCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.VectorCollection ui;

        public new Windows.Media.VectorCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.VectorCollection(VectorCollection view) => view?.UI;

        public static implicit operator VectorCollection(Windows.Media.VectorCollection ui) => VectorCollection.StartChain(ui);

        protected VectorCollection() { }
    }
}

namespace CSharpMarkup.Wpf // VideoDrawing
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.VideoDrawing"/></summary>
        public static VideoDrawing VideoDrawing(O<Windows.Media.MediaPlayer> Player = default, O<Windows.Rect> Rect = default)
        {
            var ui = new Windows.Media.VideoDrawing();
            if (Player.HasValue) ui.Player = Player.Value;
            if (Rect.HasValue) ui.Rect = Rect.Value;
            return global::CSharpMarkup.Wpf.VideoDrawing.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.VideoDrawing"/></summary>
        public static VideoDrawing VideoDrawing()
        {
            var ui = new Windows.Media.VideoDrawing();
            return global::CSharpMarkup.Wpf.VideoDrawing.StartChain(ui);
        }
    }

    public partial class VideoDrawing : Drawing, IUI<System.Windows.Media.VideoDrawing>
    {
        static VideoDrawing instance;

        internal static VideoDrawing StartChain(Windows.Media.VideoDrawing ui)
        {
            if (instance == null) instance = new VideoDrawing();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.VideoDrawing ui;

        public new Windows.Media.VideoDrawing UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.VideoDrawing(VideoDrawing view) => view?.UI;

        public static implicit operator VideoDrawing(Windows.Media.VideoDrawing ui) => VideoDrawing.StartChain(ui);

        protected VideoDrawing() { }
    }

    public static partial class VideoDrawingExtensions
    {
        /// <summary>Set <see cref="Windows.Media.VideoDrawing.Player"/></summary>
        public static TView Player<TView>(this TView view, Windows.Media.MediaPlayer value) where TView : VideoDrawing { view.UI.Player = value; return view; }

        /// <summary>Set <see cref="Windows.Media.VideoDrawing.Rect"/></summary>
        public static TView Rect<TView>(this TView view, Windows.Rect value) where TView : VideoDrawing { view.UI.Rect = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.VideoDrawing.Player"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.MediaPlayer> Player<TTarget>(this TTarget target) where TTarget : VideoDrawing
        => DependencyProperty<TTarget, Windows.Media.MediaPlayer>.Get(target, Windows.Media.VideoDrawing.PlayerProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.VideoDrawing.Rect"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Rect<TTarget>(this TTarget target) where TTarget : VideoDrawing
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.VideoDrawing.RectProperty);
    }
}

namespace CSharpMarkup.Wpf // Visual
{
    public partial class Visual : DependencyObject, IUI<System.Windows.Media.Visual>
    {
        Windows.Media.Visual ui;

        public new Windows.Media.Visual UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Visual() { }
    }
}

namespace CSharpMarkup.Wpf // VisualBrush
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.VisualBrush"/></summary>
        public static VisualBrush VisualBrush(O<bool> AutoLayoutContent = default, O<Windows.Media.Visual> Visual = default)
        {
            var ui = new Windows.Media.VisualBrush();
            if (AutoLayoutContent.HasValue) ui.AutoLayoutContent = AutoLayoutContent.Value;
            if (Visual.HasValue) ui.Visual = Visual.Value;
            return global::CSharpMarkup.Wpf.VisualBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.VisualBrush"/></summary>
        public static VisualBrush VisualBrush()
        {
            var ui = new Windows.Media.VisualBrush();
            return global::CSharpMarkup.Wpf.VisualBrush.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.VisualBrush"/></summary>
        public static VisualBrush VisualBrush(Windows.Media.Visual visual)
        {
            var ui = new Windows.Media.VisualBrush(visual);
            return global::CSharpMarkup.Wpf.VisualBrush.StartChain(ui);
        }
    }

    public partial class VisualBrush : TileBrush, IUI<System.Windows.Media.VisualBrush>
    {
        static VisualBrush instance;

        internal static VisualBrush StartChain(Windows.Media.VisualBrush ui)
        {
            if (instance == null) instance = new VisualBrush();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.VisualBrush ui;

        public new Windows.Media.VisualBrush UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.VisualBrush(VisualBrush view) => view?.UI;

        public static implicit operator VisualBrush(Windows.Media.VisualBrush ui) => VisualBrush.StartChain(ui);

        protected VisualBrush() { }
    }

    public static partial class VisualBrushExtensions
    {
        /// <summary>Set <see cref="Windows.Media.VisualBrush.AutoLayoutContent"/></summary>
        public static TView AutoLayoutContent<TView>(this TView view, bool value) where TView : VisualBrush { view.UI.AutoLayoutContent = value; return view; }

        /// <summary>Set <see cref="Windows.Media.VisualBrush.Visual"/></summary>
        public static TView Visual<TView>(this TView view, Windows.Media.Visual value) where TView : VisualBrush { view.UI.Visual = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.VisualBrush.AutoLayoutContent"/></summary>
        public static DependencyProperty<TTarget, bool> AutoLayoutContent<TTarget>(this TTarget target) where TTarget : VisualBrush
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.VisualBrush.AutoLayoutContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.VisualBrush.Visual"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Visual> Visual<TTarget>(this TTarget target) where TTarget : VisualBrush
        => DependencyProperty<TTarget, Windows.Media.Visual>.Get(target, Windows.Media.VisualBrush.VisualProperty);
    }
}

namespace CSharpMarkup.Wpf // Animatable
{
    public partial class Animatable : Freezable, IUI<System.Windows.Media.Animation.Animatable>
    {
        Windows.Media.Animation.Animatable ui;

        public new Windows.Media.Animation.Animatable UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Animatable() { }
    }
}

namespace CSharpMarkup.Wpf // AnimationTimeline
{
    public partial class AnimationTimeline : Timeline, IUI<System.Windows.Media.Animation.AnimationTimeline>
    {
        Windows.Media.Animation.AnimationTimeline ui;

        public new Windows.Media.Animation.AnimationTimeline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected AnimationTimeline() { }
    }
}

namespace CSharpMarkup.Wpf // BackEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.BackEase"/></summary>
        public static BackEase BackEase(O<double> Amplitude = default)
        {
            var ui = new Windows.Media.Animation.BackEase();
            if (Amplitude.HasValue) ui.Amplitude = Amplitude.Value;
            return global::CSharpMarkup.Wpf.BackEase.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BackEase"/></summary>
        public static BackEase BackEase()
        {
            var ui = new Windows.Media.Animation.BackEase();
            return global::CSharpMarkup.Wpf.BackEase.StartChain(ui);
        }
    }

    public partial class BackEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.BackEase>
    {
        static BackEase instance;

        internal static BackEase StartChain(Windows.Media.Animation.BackEase ui)
        {
            if (instance == null) instance = new BackEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.BackEase ui;

        public new Windows.Media.Animation.BackEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.BackEase(BackEase view) => view?.UI;

        public static implicit operator BackEase(Windows.Media.Animation.BackEase ui) => BackEase.StartChain(ui);

        protected BackEase() { }
    }

    public static partial class BackEaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.BackEase.Amplitude"/></summary>
        public static TView Amplitude<TView>(this TView view, double value) where TView : BackEase { view.UI.Amplitude = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BackEase.Amplitude"/></summary>
        public static DependencyProperty<TTarget, double> Amplitude<TTarget>(this TTarget target) where TTarget : BackEase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.BackEase.AmplitudeProperty);
    }
}

namespace CSharpMarkup.Wpf // BooleanAnimationBase
{
    public partial class BooleanAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.BooleanAnimationBase>
    {
        Windows.Media.Animation.BooleanAnimationBase ui;

        public new Windows.Media.Animation.BooleanAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BooleanAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // BooleanAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.BooleanAnimationUsingKeyFrames"/></summary>
        public static BooleanAnimationUsingKeyFrames BooleanAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.BooleanKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.BooleanAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.BooleanAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BooleanAnimationUsingKeyFrames"/></summary>
        public static BooleanAnimationUsingKeyFrames BooleanAnimationUsingKeyFrames(O<Windows.Media.Animation.BooleanKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.BooleanAnimationUsingKeyFrames();
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.BooleanAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BooleanAnimationUsingKeyFrames"/></summary>
        public static BooleanAnimationUsingKeyFrames BooleanAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.BooleanAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.BooleanAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class BooleanAnimationUsingKeyFrames : BooleanAnimationBase, IUI<System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames>
    {
        static BooleanAnimationUsingKeyFrames instance;

        internal static BooleanAnimationUsingKeyFrames StartChain(Windows.Media.Animation.BooleanAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new BooleanAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.BooleanAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.BooleanAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.BooleanAnimationUsingKeyFrames(BooleanAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator BooleanAnimationUsingKeyFrames(Windows.Media.Animation.BooleanAnimationUsingKeyFrames ui) => BooleanAnimationUsingKeyFrames.StartChain(ui);

        protected BooleanAnimationUsingKeyFrames() { }
    }

    public static partial class BooleanAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.BooleanAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.BooleanKeyFrameCollection value) where TView : BooleanAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // BooleanKeyFrame
{
    public partial class BooleanKeyFrame : Freezable, IUI<System.Windows.Media.Animation.BooleanKeyFrame>
    {
        Windows.Media.Animation.BooleanKeyFrame ui;

        public new Windows.Media.Animation.BooleanKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BooleanKeyFrame() { }
    }

    public static partial class BooleanKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.BooleanKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : BooleanKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.BooleanKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, bool value) where TView : BooleanKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BooleanKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : BooleanKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.BooleanKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BooleanKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, bool> Value<TTarget>(this TTarget target) where TTarget : BooleanKeyFrame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.BooleanKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // BooleanKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.BooleanKeyFrameCollection"/></summary>
        public static BooleanKeyFrameCollection BooleanKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.BooleanKeyFrameCollection();
            return global::CSharpMarkup.Wpf.BooleanKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class BooleanKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.BooleanKeyFrameCollection>
    {
        static BooleanKeyFrameCollection instance;

        internal static BooleanKeyFrameCollection StartChain(Windows.Media.Animation.BooleanKeyFrameCollection ui)
        {
            if (instance == null) instance = new BooleanKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.BooleanKeyFrameCollection ui;

        public new Windows.Media.Animation.BooleanKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.BooleanKeyFrameCollection(BooleanKeyFrameCollection view) => view?.UI;

        public static implicit operator BooleanKeyFrameCollection(Windows.Media.Animation.BooleanKeyFrameCollection ui) => BooleanKeyFrameCollection.StartChain(ui);

        protected BooleanKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // BounceEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.BounceEase"/></summary>
        public static BounceEase BounceEase(O<int> Bounces = default, O<double> Bounciness = default)
        {
            var ui = new Windows.Media.Animation.BounceEase();
            if (Bounces.HasValue) ui.Bounces = Bounces.Value;
            if (Bounciness.HasValue) ui.Bounciness = Bounciness.Value;
            return global::CSharpMarkup.Wpf.BounceEase.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BounceEase"/></summary>
        public static BounceEase BounceEase()
        {
            var ui = new Windows.Media.Animation.BounceEase();
            return global::CSharpMarkup.Wpf.BounceEase.StartChain(ui);
        }
    }

    public partial class BounceEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.BounceEase>
    {
        static BounceEase instance;

        internal static BounceEase StartChain(Windows.Media.Animation.BounceEase ui)
        {
            if (instance == null) instance = new BounceEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.BounceEase ui;

        public new Windows.Media.Animation.BounceEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.BounceEase(BounceEase view) => view?.UI;

        public static implicit operator BounceEase(Windows.Media.Animation.BounceEase ui) => BounceEase.StartChain(ui);

        protected BounceEase() { }
    }

    public static partial class BounceEaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.BounceEase.Bounces"/></summary>
        public static TView Bounces<TView>(this TView view, int value) where TView : BounceEase { view.UI.Bounces = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.BounceEase.Bounciness"/></summary>
        public static TView Bounciness<TView>(this TView view, double value) where TView : BounceEase { view.UI.Bounciness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BounceEase.Bounces"/></summary>
        public static DependencyProperty<TTarget, int> Bounces<TTarget>(this TTarget target) where TTarget : BounceEase
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.Animation.BounceEase.BouncesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BounceEase.Bounciness"/></summary>
        public static DependencyProperty<TTarget, double> Bounciness<TTarget>(this TTarget target) where TTarget : BounceEase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.BounceEase.BouncinessProperty);
    }
}

namespace CSharpMarkup.Wpf // ByteAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation(O<byte?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<byte?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<byte?> To = default)
        {
            var ui = new Windows.Media.Animation.ByteAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation()
        {
            var ui = new Windows.Media.Animation.ByteAnimation();
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation(byte fromValue, byte toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ByteAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation(byte fromValue, byte toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ByteAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation(byte toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ByteAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimation"/></summary>
        public static ByteAnimation ByteAnimation(byte toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ByteAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ByteAnimation.StartChain(ui);
        }
    }

    public partial class ByteAnimation : ByteAnimationBase, IUI<System.Windows.Media.Animation.ByteAnimation>
    {
        static ByteAnimation instance;

        internal static ByteAnimation StartChain(Windows.Media.Animation.ByteAnimation ui)
        {
            if (instance == null) instance = new ByteAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ByteAnimation ui;

        public new Windows.Media.Animation.ByteAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ByteAnimation(ByteAnimation view) => view?.UI;

        public static implicit operator ByteAnimation(Windows.Media.Animation.ByteAnimation ui) => ByteAnimation.StartChain(ui);

        protected ByteAnimation() { }
    }

    public static partial class ByteAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.By"/></summary>
        public static TView By<TView>(this TView view, byte? value) where TView : ByteAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : ByteAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.From"/></summary>
        public static TView From<TView>(this TView view, byte? value) where TView : ByteAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ByteAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ByteAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimation.To"/></summary>
        public static TView To<TView>(this TView view, byte? value) where TView : ByteAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteAnimation.By"/></summary>
        public static DependencyProperty<TTarget, byte?> By<TTarget>(this TTarget target) where TTarget : ByteAnimation
        => DependencyProperty<TTarget, byte?>.Get(target, Windows.Media.Animation.ByteAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : ByteAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.ByteAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteAnimation.From"/></summary>
        public static DependencyProperty<TTarget, byte?> From<TTarget>(this TTarget target) where TTarget : ByteAnimation
        => DependencyProperty<TTarget, byte?>.Get(target, Windows.Media.Animation.ByteAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteAnimation.To"/></summary>
        public static DependencyProperty<TTarget, byte?> To<TTarget>(this TTarget target) where TTarget : ByteAnimation
        => DependencyProperty<TTarget, byte?>.Get(target, Windows.Media.Animation.ByteAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // ByteAnimationBase
{
    public partial class ByteAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.ByteAnimationBase>
    {
        Windows.Media.Animation.ByteAnimationBase ui;

        public new Windows.Media.Animation.ByteAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ByteAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // ByteAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames"/></summary>
        public static ByteAnimationUsingKeyFrames ByteAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.ByteKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.ByteAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.ByteAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames"/></summary>
        public static ByteAnimationUsingKeyFrames ByteAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.ByteKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.ByteAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.ByteAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames"/></summary>
        public static ByteAnimationUsingKeyFrames ByteAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.ByteAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.ByteAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class ByteAnimationUsingKeyFrames : ByteAnimationBase, IUI<System.Windows.Media.Animation.ByteAnimationUsingKeyFrames>
    {
        static ByteAnimationUsingKeyFrames instance;

        internal static ByteAnimationUsingKeyFrames StartChain(Windows.Media.Animation.ByteAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new ByteAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ByteAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.ByteAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ByteAnimationUsingKeyFrames(ByteAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator ByteAnimationUsingKeyFrames(Windows.Media.Animation.ByteAnimationUsingKeyFrames ui) => ByteAnimationUsingKeyFrames.StartChain(ui);

        protected ByteAnimationUsingKeyFrames() { }
    }

    public static partial class ByteAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ByteAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ByteAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.ByteKeyFrameCollection value) where TView : ByteAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // ByteKeyFrame
{
    public partial class ByteKeyFrame : Freezable, IUI<System.Windows.Media.Animation.ByteKeyFrame>
    {
        Windows.Media.Animation.ByteKeyFrame ui;

        public new Windows.Media.Animation.ByteKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ByteKeyFrame() { }
    }

    public static partial class ByteKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ByteKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : ByteKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ByteKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, byte value) where TView : ByteKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : ByteKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.ByteKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ByteKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, byte> Value<TTarget>(this TTarget target) where TTarget : ByteKeyFrame
        => DependencyProperty<TTarget, byte>.Get(target, Windows.Media.Animation.ByteKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // ByteKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ByteKeyFrameCollection"/></summary>
        public static ByteKeyFrameCollection ByteKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.ByteKeyFrameCollection();
            return global::CSharpMarkup.Wpf.ByteKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class ByteKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.ByteKeyFrameCollection>
    {
        static ByteKeyFrameCollection instance;

        internal static ByteKeyFrameCollection StartChain(Windows.Media.Animation.ByteKeyFrameCollection ui)
        {
            if (instance == null) instance = new ByteKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ByteKeyFrameCollection ui;

        public new Windows.Media.Animation.ByteKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ByteKeyFrameCollection(ByteKeyFrameCollection view) => view?.UI;

        public static implicit operator ByteKeyFrameCollection(Windows.Media.Animation.ByteKeyFrameCollection ui) => ByteKeyFrameCollection.StartChain(ui);

        protected ByteKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // CharAnimationBase
{
    public partial class CharAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.CharAnimationBase>
    {
        Windows.Media.Animation.CharAnimationBase ui;

        public new Windows.Media.Animation.CharAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected CharAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // CharAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.CharAnimationUsingKeyFrames"/></summary>
        public static CharAnimationUsingKeyFrames CharAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.CharKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.CharAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.CharAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.CharAnimationUsingKeyFrames"/></summary>
        public static CharAnimationUsingKeyFrames CharAnimationUsingKeyFrames(O<Windows.Media.Animation.CharKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.CharAnimationUsingKeyFrames();
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.CharAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.CharAnimationUsingKeyFrames"/></summary>
        public static CharAnimationUsingKeyFrames CharAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.CharAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.CharAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class CharAnimationUsingKeyFrames : CharAnimationBase, IUI<System.Windows.Media.Animation.CharAnimationUsingKeyFrames>
    {
        static CharAnimationUsingKeyFrames instance;

        internal static CharAnimationUsingKeyFrames StartChain(Windows.Media.Animation.CharAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new CharAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.CharAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.CharAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.CharAnimationUsingKeyFrames(CharAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator CharAnimationUsingKeyFrames(Windows.Media.Animation.CharAnimationUsingKeyFrames ui) => CharAnimationUsingKeyFrames.StartChain(ui);

        protected CharAnimationUsingKeyFrames() { }
    }

    public static partial class CharAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.CharAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.CharKeyFrameCollection value) where TView : CharAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // CharKeyFrame
{
    public partial class CharKeyFrame : Freezable, IUI<System.Windows.Media.Animation.CharKeyFrame>
    {
        Windows.Media.Animation.CharKeyFrame ui;

        public new Windows.Media.Animation.CharKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected CharKeyFrame() { }
    }

    public static partial class CharKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.CharKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : CharKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.CharKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, char value) where TView : CharKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.CharKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : CharKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.CharKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.CharKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, char> Value<TTarget>(this TTarget target) where TTarget : CharKeyFrame
        => DependencyProperty<TTarget, char>.Get(target, Windows.Media.Animation.CharKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // CharKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.CharKeyFrameCollection"/></summary>
        public static CharKeyFrameCollection CharKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.CharKeyFrameCollection();
            return global::CSharpMarkup.Wpf.CharKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class CharKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.CharKeyFrameCollection>
    {
        static CharKeyFrameCollection instance;

        internal static CharKeyFrameCollection StartChain(Windows.Media.Animation.CharKeyFrameCollection ui)
        {
            if (instance == null) instance = new CharKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.CharKeyFrameCollection ui;

        public new Windows.Media.Animation.CharKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.CharKeyFrameCollection(CharKeyFrameCollection view) => view?.UI;

        public static implicit operator CharKeyFrameCollection(Windows.Media.Animation.CharKeyFrameCollection ui) => CharKeyFrameCollection.StartChain(ui);

        protected CharKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // CircleEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.CircleEase"/></summary>
        public static CircleEase CircleEase()
        {
            var ui = new Windows.Media.Animation.CircleEase();
            return global::CSharpMarkup.Wpf.CircleEase.StartChain(ui);
        }
    }

    public partial class CircleEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.CircleEase>
    {
        static CircleEase instance;

        internal static CircleEase StartChain(Windows.Media.Animation.CircleEase ui)
        {
            if (instance == null) instance = new CircleEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.CircleEase ui;

        public new Windows.Media.Animation.CircleEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.CircleEase(CircleEase view) => view?.UI;

        public static implicit operator CircleEase(Windows.Media.Animation.CircleEase ui) => CircleEase.StartChain(ui);

        protected CircleEase() { }
    }
}

namespace CSharpMarkup.Wpf // ColorAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation(O<Color?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Color?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Color?> To = default)
        {
            var ui = new Windows.Media.Animation.ColorAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation()
        {
            var ui = new Windows.Media.Animation.ColorAnimation();
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation(Color toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ColorAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation(Color toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ColorAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation(Color fromValue, Color toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ColorAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimation"/></summary>
        public static ColorAnimation ColorAnimation(Color fromValue, Color toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ColorAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ColorAnimation.StartChain(ui);
        }
    }

    public partial class ColorAnimation : ColorAnimationBase, IUI<System.Windows.Media.Animation.ColorAnimation>
    {
        static ColorAnimation instance;

        internal static ColorAnimation StartChain(Windows.Media.Animation.ColorAnimation ui)
        {
            if (instance == null) instance = new ColorAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ColorAnimation ui;

        public new Windows.Media.Animation.ColorAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ColorAnimation(ColorAnimation view) => view?.UI;

        public static implicit operator ColorAnimation(Windows.Media.Animation.ColorAnimation ui) => ColorAnimation.StartChain(ui);

        protected ColorAnimation() { }
    }

    public static partial class ColorAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Color? value) where TView : ColorAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : ColorAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Color? value) where TView : ColorAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ColorAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ColorAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Color? value) where TView : ColorAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Color?> By<TTarget>(this TTarget target) where TTarget : ColorAnimation
        => DependencyProperty<TTarget, Color?>.Get(target, Windows.Media.Animation.ColorAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : ColorAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.ColorAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Color?> From<TTarget>(this TTarget target) where TTarget : ColorAnimation
        => DependencyProperty<TTarget, Color?>.Get(target, Windows.Media.Animation.ColorAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Color?> To<TTarget>(this TTarget target) where TTarget : ColorAnimation
        => DependencyProperty<TTarget, Color?>.Get(target, Windows.Media.Animation.ColorAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // ColorAnimationBase
{
    public partial class ColorAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.ColorAnimationBase>
    {
        Windows.Media.Animation.ColorAnimationBase ui;

        public new Windows.Media.Animation.ColorAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ColorAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // ColorAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames"/></summary>
        public static ColorAnimationUsingKeyFrames ColorAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.ColorKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.ColorAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.ColorAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames"/></summary>
        public static ColorAnimationUsingKeyFrames ColorAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.ColorKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.ColorAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.ColorAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames"/></summary>
        public static ColorAnimationUsingKeyFrames ColorAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.ColorAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.ColorAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class ColorAnimationUsingKeyFrames : ColorAnimationBase, IUI<System.Windows.Media.Animation.ColorAnimationUsingKeyFrames>
    {
        static ColorAnimationUsingKeyFrames instance;

        internal static ColorAnimationUsingKeyFrames StartChain(Windows.Media.Animation.ColorAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new ColorAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ColorAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.ColorAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ColorAnimationUsingKeyFrames(ColorAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator ColorAnimationUsingKeyFrames(Windows.Media.Animation.ColorAnimationUsingKeyFrames ui) => ColorAnimationUsingKeyFrames.StartChain(ui);

        protected ColorAnimationUsingKeyFrames() { }
    }

    public static partial class ColorAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ColorAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ColorAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.ColorKeyFrameCollection value) where TView : ColorAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // ColorKeyFrame
{
    public partial class ColorKeyFrame : Freezable, IUI<System.Windows.Media.Animation.ColorKeyFrame>
    {
        Windows.Media.Animation.ColorKeyFrame ui;

        public new Windows.Media.Animation.ColorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ColorKeyFrame() { }
    }

    public static partial class ColorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ColorKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : ColorKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ColorKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Color value) where TView : ColorKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : ColorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.ColorKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ColorKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Color> Value<TTarget>(this TTarget target) where TTarget : ColorKeyFrame
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Animation.ColorKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // ColorKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ColorKeyFrameCollection"/></summary>
        public static ColorKeyFrameCollection ColorKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.ColorKeyFrameCollection();
            return global::CSharpMarkup.Wpf.ColorKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class ColorKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.ColorKeyFrameCollection>
    {
        static ColorKeyFrameCollection instance;

        internal static ColorKeyFrameCollection StartChain(Windows.Media.Animation.ColorKeyFrameCollection ui)
        {
            if (instance == null) instance = new ColorKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ColorKeyFrameCollection ui;

        public new Windows.Media.Animation.ColorKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ColorKeyFrameCollection(ColorKeyFrameCollection view) => view?.UI;

        public static implicit operator ColorKeyFrameCollection(Windows.Media.Animation.ColorKeyFrameCollection ui) => ColorKeyFrameCollection.StartChain(ui);

        protected ColorKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // CubicEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.CubicEase"/></summary>
        public static CubicEase CubicEase()
        {
            var ui = new Windows.Media.Animation.CubicEase();
            return global::CSharpMarkup.Wpf.CubicEase.StartChain(ui);
        }
    }

    public partial class CubicEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.CubicEase>
    {
        static CubicEase instance;

        internal static CubicEase StartChain(Windows.Media.Animation.CubicEase ui)
        {
            if (instance == null) instance = new CubicEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.CubicEase ui;

        public new Windows.Media.Animation.CubicEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.CubicEase(CubicEase view) => view?.UI;

        public static implicit operator CubicEase(Windows.Media.Animation.CubicEase ui) => CubicEase.StartChain(ui);

        protected CubicEase() { }
    }
}

namespace CSharpMarkup.Wpf // DecimalAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation(O<decimal?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<decimal?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<decimal?> To = default)
        {
            var ui = new Windows.Media.Animation.DecimalAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation()
        {
            var ui = new Windows.Media.Animation.DecimalAnimation();
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation(decimal fromValue, decimal toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.DecimalAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation(decimal fromValue, decimal toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.DecimalAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation(decimal toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.DecimalAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimation"/></summary>
        public static DecimalAnimation DecimalAnimation(decimal toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.DecimalAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.DecimalAnimation.StartChain(ui);
        }
    }

    public partial class DecimalAnimation : DecimalAnimationBase, IUI<System.Windows.Media.Animation.DecimalAnimation>
    {
        static DecimalAnimation instance;

        internal static DecimalAnimation StartChain(Windows.Media.Animation.DecimalAnimation ui)
        {
            if (instance == null) instance = new DecimalAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DecimalAnimation ui;

        public new Windows.Media.Animation.DecimalAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DecimalAnimation(DecimalAnimation view) => view?.UI;

        public static implicit operator DecimalAnimation(Windows.Media.Animation.DecimalAnimation ui) => DecimalAnimation.StartChain(ui);

        protected DecimalAnimation() { }
    }

    public static partial class DecimalAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.By"/></summary>
        public static TView By<TView>(this TView view, decimal? value) where TView : DecimalAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : DecimalAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.From"/></summary>
        public static TView From<TView>(this TView view, decimal? value) where TView : DecimalAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : DecimalAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : DecimalAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimation.To"/></summary>
        public static TView To<TView>(this TView view, decimal? value) where TView : DecimalAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalAnimation.By"/></summary>
        public static DependencyProperty<TTarget, decimal?> By<TTarget>(this TTarget target) where TTarget : DecimalAnimation
        => DependencyProperty<TTarget, decimal?>.Get(target, Windows.Media.Animation.DecimalAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : DecimalAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.DecimalAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalAnimation.From"/></summary>
        public static DependencyProperty<TTarget, decimal?> From<TTarget>(this TTarget target) where TTarget : DecimalAnimation
        => DependencyProperty<TTarget, decimal?>.Get(target, Windows.Media.Animation.DecimalAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalAnimation.To"/></summary>
        public static DependencyProperty<TTarget, decimal?> To<TTarget>(this TTarget target) where TTarget : DecimalAnimation
        => DependencyProperty<TTarget, decimal?>.Get(target, Windows.Media.Animation.DecimalAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // DecimalAnimationBase
{
    public partial class DecimalAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.DecimalAnimationBase>
    {
        Windows.Media.Animation.DecimalAnimationBase ui;

        public new Windows.Media.Animation.DecimalAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DecimalAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // DecimalAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames"/></summary>
        public static DecimalAnimationUsingKeyFrames DecimalAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.DecimalKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.DecimalAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.DecimalAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames"/></summary>
        public static DecimalAnimationUsingKeyFrames DecimalAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.DecimalKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.DecimalAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.DecimalAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames"/></summary>
        public static DecimalAnimationUsingKeyFrames DecimalAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.DecimalAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.DecimalAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class DecimalAnimationUsingKeyFrames : DecimalAnimationBase, IUI<System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames>
    {
        static DecimalAnimationUsingKeyFrames instance;

        internal static DecimalAnimationUsingKeyFrames StartChain(Windows.Media.Animation.DecimalAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new DecimalAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DecimalAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.DecimalAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DecimalAnimationUsingKeyFrames(DecimalAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator DecimalAnimationUsingKeyFrames(Windows.Media.Animation.DecimalAnimationUsingKeyFrames ui) => DecimalAnimationUsingKeyFrames.StartChain(ui);

        protected DecimalAnimationUsingKeyFrames() { }
    }

    public static partial class DecimalAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : DecimalAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : DecimalAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.DecimalKeyFrameCollection value) where TView : DecimalAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // DecimalKeyFrame
{
    public partial class DecimalKeyFrame : Freezable, IUI<System.Windows.Media.Animation.DecimalKeyFrame>
    {
        Windows.Media.Animation.DecimalKeyFrame ui;

        public new Windows.Media.Animation.DecimalKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DecimalKeyFrame() { }
    }

    public static partial class DecimalKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DecimalKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : DecimalKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DecimalKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, decimal value) where TView : DecimalKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : DecimalKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.DecimalKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DecimalKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, decimal> Value<TTarget>(this TTarget target) where TTarget : DecimalKeyFrame
        => DependencyProperty<TTarget, decimal>.Get(target, Windows.Media.Animation.DecimalKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // DecimalKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DecimalKeyFrameCollection"/></summary>
        public static DecimalKeyFrameCollection DecimalKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.DecimalKeyFrameCollection();
            return global::CSharpMarkup.Wpf.DecimalKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class DecimalKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.DecimalKeyFrameCollection>
    {
        static DecimalKeyFrameCollection instance;

        internal static DecimalKeyFrameCollection StartChain(Windows.Media.Animation.DecimalKeyFrameCollection ui)
        {
            if (instance == null) instance = new DecimalKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DecimalKeyFrameCollection ui;

        public new Windows.Media.Animation.DecimalKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DecimalKeyFrameCollection(DecimalKeyFrameCollection view) => view?.UI;

        public static implicit operator DecimalKeyFrameCollection(Windows.Media.Animation.DecimalKeyFrameCollection ui) => DecimalKeyFrameCollection.StartChain(ui);

        protected DecimalKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteBooleanKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteBooleanKeyFrame"/></summary>
        public static DiscreteBooleanKeyFrame DiscreteBooleanKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteBooleanKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteBooleanKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteBooleanKeyFrame"/></summary>
        public static DiscreteBooleanKeyFrame DiscreteBooleanKeyFrame(bool value)
        {
            var ui = new Windows.Media.Animation.DiscreteBooleanKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteBooleanKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteBooleanKeyFrame"/></summary>
        public static DiscreteBooleanKeyFrame DiscreteBooleanKeyFrame(bool value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteBooleanKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteBooleanKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteBooleanKeyFrame : BooleanKeyFrame, IUI<System.Windows.Media.Animation.DiscreteBooleanKeyFrame>
    {
        static DiscreteBooleanKeyFrame instance;

        internal static DiscreteBooleanKeyFrame StartChain(Windows.Media.Animation.DiscreteBooleanKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteBooleanKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteBooleanKeyFrame ui;

        public new Windows.Media.Animation.DiscreteBooleanKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteBooleanKeyFrame(DiscreteBooleanKeyFrame view) => view?.UI;

        public static implicit operator DiscreteBooleanKeyFrame(Windows.Media.Animation.DiscreteBooleanKeyFrame ui) => DiscreteBooleanKeyFrame.StartChain(ui);

        protected DiscreteBooleanKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteByteKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteByteKeyFrame"/></summary>
        public static DiscreteByteKeyFrame DiscreteByteKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteByteKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteByteKeyFrame"/></summary>
        public static DiscreteByteKeyFrame DiscreteByteKeyFrame(byte value)
        {
            var ui = new Windows.Media.Animation.DiscreteByteKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteByteKeyFrame"/></summary>
        public static DiscreteByteKeyFrame DiscreteByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteByteKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteByteKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteByteKeyFrame : ByteKeyFrame, IUI<System.Windows.Media.Animation.DiscreteByteKeyFrame>
    {
        static DiscreteByteKeyFrame instance;

        internal static DiscreteByteKeyFrame StartChain(Windows.Media.Animation.DiscreteByteKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteByteKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteByteKeyFrame ui;

        public new Windows.Media.Animation.DiscreteByteKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteByteKeyFrame(DiscreteByteKeyFrame view) => view?.UI;

        public static implicit operator DiscreteByteKeyFrame(Windows.Media.Animation.DiscreteByteKeyFrame ui) => DiscreteByteKeyFrame.StartChain(ui);

        protected DiscreteByteKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteCharKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteCharKeyFrame"/></summary>
        public static DiscreteCharKeyFrame DiscreteCharKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteCharKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteCharKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteCharKeyFrame"/></summary>
        public static DiscreteCharKeyFrame DiscreteCharKeyFrame(char value)
        {
            var ui = new Windows.Media.Animation.DiscreteCharKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteCharKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteCharKeyFrame"/></summary>
        public static DiscreteCharKeyFrame DiscreteCharKeyFrame(char value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteCharKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteCharKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteCharKeyFrame : CharKeyFrame, IUI<System.Windows.Media.Animation.DiscreteCharKeyFrame>
    {
        static DiscreteCharKeyFrame instance;

        internal static DiscreteCharKeyFrame StartChain(Windows.Media.Animation.DiscreteCharKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteCharKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteCharKeyFrame ui;

        public new Windows.Media.Animation.DiscreteCharKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteCharKeyFrame(DiscreteCharKeyFrame view) => view?.UI;

        public static implicit operator DiscreteCharKeyFrame(Windows.Media.Animation.DiscreteCharKeyFrame ui) => DiscreteCharKeyFrame.StartChain(ui);

        protected DiscreteCharKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteColorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteColorKeyFrame"/></summary>
        public static DiscreteColorKeyFrame DiscreteColorKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteColorKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteColorKeyFrame"/></summary>
        public static DiscreteColorKeyFrame DiscreteColorKeyFrame(Color value)
        {
            var ui = new Windows.Media.Animation.DiscreteColorKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteColorKeyFrame"/></summary>
        public static DiscreteColorKeyFrame DiscreteColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteColorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteColorKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteColorKeyFrame : ColorKeyFrame, IUI<System.Windows.Media.Animation.DiscreteColorKeyFrame>
    {
        static DiscreteColorKeyFrame instance;

        internal static DiscreteColorKeyFrame StartChain(Windows.Media.Animation.DiscreteColorKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteColorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteColorKeyFrame ui;

        public new Windows.Media.Animation.DiscreteColorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteColorKeyFrame(DiscreteColorKeyFrame view) => view?.UI;

        public static implicit operator DiscreteColorKeyFrame(Windows.Media.Animation.DiscreteColorKeyFrame ui) => DiscreteColorKeyFrame.StartChain(ui);

        protected DiscreteColorKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteDecimalKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDecimalKeyFrame"/></summary>
        public static DiscreteDecimalKeyFrame DiscreteDecimalKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteDecimalKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDecimalKeyFrame"/></summary>
        public static DiscreteDecimalKeyFrame DiscreteDecimalKeyFrame(decimal value)
        {
            var ui = new Windows.Media.Animation.DiscreteDecimalKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDecimalKeyFrame"/></summary>
        public static DiscreteDecimalKeyFrame DiscreteDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteDecimalKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteDecimalKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteDecimalKeyFrame : DecimalKeyFrame, IUI<System.Windows.Media.Animation.DiscreteDecimalKeyFrame>
    {
        static DiscreteDecimalKeyFrame instance;

        internal static DiscreteDecimalKeyFrame StartChain(Windows.Media.Animation.DiscreteDecimalKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteDecimalKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteDecimalKeyFrame ui;

        public new Windows.Media.Animation.DiscreteDecimalKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteDecimalKeyFrame(DiscreteDecimalKeyFrame view) => view?.UI;

        public static implicit operator DiscreteDecimalKeyFrame(Windows.Media.Animation.DiscreteDecimalKeyFrame ui) => DiscreteDecimalKeyFrame.StartChain(ui);

        protected DiscreteDecimalKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteDoubleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDoubleKeyFrame"/></summary>
        public static DiscreteDoubleKeyFrame DiscreteDoubleKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteDoubleKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDoubleKeyFrame"/></summary>
        public static DiscreteDoubleKeyFrame DiscreteDoubleKeyFrame(double value)
        {
            var ui = new Windows.Media.Animation.DiscreteDoubleKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteDoubleKeyFrame"/></summary>
        public static DiscreteDoubleKeyFrame DiscreteDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteDoubleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteDoubleKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteDoubleKeyFrame : DoubleKeyFrame, IUI<System.Windows.Media.Animation.DiscreteDoubleKeyFrame>
    {
        static DiscreteDoubleKeyFrame instance;

        internal static DiscreteDoubleKeyFrame StartChain(Windows.Media.Animation.DiscreteDoubleKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteDoubleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteDoubleKeyFrame ui;

        public new Windows.Media.Animation.DiscreteDoubleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteDoubleKeyFrame(DiscreteDoubleKeyFrame view) => view?.UI;

        public static implicit operator DiscreteDoubleKeyFrame(Windows.Media.Animation.DiscreteDoubleKeyFrame ui) => DiscreteDoubleKeyFrame.StartChain(ui);

        protected DiscreteDoubleKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteInt16KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt16KeyFrame"/></summary>
        public static DiscreteInt16KeyFrame DiscreteInt16KeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteInt16KeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt16KeyFrame"/></summary>
        public static DiscreteInt16KeyFrame DiscreteInt16KeyFrame(short value)
        {
            var ui = new Windows.Media.Animation.DiscreteInt16KeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt16KeyFrame"/></summary>
        public static DiscreteInt16KeyFrame DiscreteInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteInt16KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteInt16KeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteInt16KeyFrame : Int16KeyFrame, IUI<System.Windows.Media.Animation.DiscreteInt16KeyFrame>
    {
        static DiscreteInt16KeyFrame instance;

        internal static DiscreteInt16KeyFrame StartChain(Windows.Media.Animation.DiscreteInt16KeyFrame ui)
        {
            if (instance == null) instance = new DiscreteInt16KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteInt16KeyFrame ui;

        public new Windows.Media.Animation.DiscreteInt16KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteInt16KeyFrame(DiscreteInt16KeyFrame view) => view?.UI;

        public static implicit operator DiscreteInt16KeyFrame(Windows.Media.Animation.DiscreteInt16KeyFrame ui) => DiscreteInt16KeyFrame.StartChain(ui);

        protected DiscreteInt16KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteInt32KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt32KeyFrame"/></summary>
        public static DiscreteInt32KeyFrame DiscreteInt32KeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteInt32KeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt32KeyFrame"/></summary>
        public static DiscreteInt32KeyFrame DiscreteInt32KeyFrame(int value)
        {
            var ui = new Windows.Media.Animation.DiscreteInt32KeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt32KeyFrame"/></summary>
        public static DiscreteInt32KeyFrame DiscreteInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteInt32KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteInt32KeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteInt32KeyFrame : Int32KeyFrame, IUI<System.Windows.Media.Animation.DiscreteInt32KeyFrame>
    {
        static DiscreteInt32KeyFrame instance;

        internal static DiscreteInt32KeyFrame StartChain(Windows.Media.Animation.DiscreteInt32KeyFrame ui)
        {
            if (instance == null) instance = new DiscreteInt32KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteInt32KeyFrame ui;

        public new Windows.Media.Animation.DiscreteInt32KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteInt32KeyFrame(DiscreteInt32KeyFrame view) => view?.UI;

        public static implicit operator DiscreteInt32KeyFrame(Windows.Media.Animation.DiscreteInt32KeyFrame ui) => DiscreteInt32KeyFrame.StartChain(ui);

        protected DiscreteInt32KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteInt64KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt64KeyFrame"/></summary>
        public static DiscreteInt64KeyFrame DiscreteInt64KeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteInt64KeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt64KeyFrame"/></summary>
        public static DiscreteInt64KeyFrame DiscreteInt64KeyFrame(long value)
        {
            var ui = new Windows.Media.Animation.DiscreteInt64KeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteInt64KeyFrame"/></summary>
        public static DiscreteInt64KeyFrame DiscreteInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteInt64KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteInt64KeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteInt64KeyFrame : Int64KeyFrame, IUI<System.Windows.Media.Animation.DiscreteInt64KeyFrame>
    {
        static DiscreteInt64KeyFrame instance;

        internal static DiscreteInt64KeyFrame StartChain(Windows.Media.Animation.DiscreteInt64KeyFrame ui)
        {
            if (instance == null) instance = new DiscreteInt64KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteInt64KeyFrame ui;

        public new Windows.Media.Animation.DiscreteInt64KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteInt64KeyFrame(DiscreteInt64KeyFrame view) => view?.UI;

        public static implicit operator DiscreteInt64KeyFrame(Windows.Media.Animation.DiscreteInt64KeyFrame ui) => DiscreteInt64KeyFrame.StartChain(ui);

        protected DiscreteInt64KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteMatrixKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteMatrixKeyFrame"/></summary>
        public static DiscreteMatrixKeyFrame DiscreteMatrixKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteMatrixKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteMatrixKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteMatrixKeyFrame"/></summary>
        public static DiscreteMatrixKeyFrame DiscreteMatrixKeyFrame(Windows.Media.Matrix value)
        {
            var ui = new Windows.Media.Animation.DiscreteMatrixKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteMatrixKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteMatrixKeyFrame"/></summary>
        public static DiscreteMatrixKeyFrame DiscreteMatrixKeyFrame(Windows.Media.Matrix value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteMatrixKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteMatrixKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteMatrixKeyFrame : MatrixKeyFrame, IUI<System.Windows.Media.Animation.DiscreteMatrixKeyFrame>
    {
        static DiscreteMatrixKeyFrame instance;

        internal static DiscreteMatrixKeyFrame StartChain(Windows.Media.Animation.DiscreteMatrixKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteMatrixKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteMatrixKeyFrame ui;

        public new Windows.Media.Animation.DiscreteMatrixKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteMatrixKeyFrame(DiscreteMatrixKeyFrame view) => view?.UI;

        public static implicit operator DiscreteMatrixKeyFrame(Windows.Media.Animation.DiscreteMatrixKeyFrame ui) => DiscreteMatrixKeyFrame.StartChain(ui);

        protected DiscreteMatrixKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteObjectKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteObjectKeyFrame"/></summary>
        public static DiscreteObjectKeyFrame DiscreteObjectKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteObjectKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteObjectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteObjectKeyFrame"/></summary>
        public static DiscreteObjectKeyFrame DiscreteObjectKeyFrame(object value)
        {
            var ui = new Windows.Media.Animation.DiscreteObjectKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteObjectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteObjectKeyFrame"/></summary>
        public static DiscreteObjectKeyFrame DiscreteObjectKeyFrame(object value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteObjectKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteObjectKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteObjectKeyFrame : ObjectKeyFrame, IUI<System.Windows.Media.Animation.DiscreteObjectKeyFrame>
    {
        static DiscreteObjectKeyFrame instance;

        internal static DiscreteObjectKeyFrame StartChain(Windows.Media.Animation.DiscreteObjectKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteObjectKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteObjectKeyFrame ui;

        public new Windows.Media.Animation.DiscreteObjectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteObjectKeyFrame(DiscreteObjectKeyFrame view) => view?.UI;

        public static implicit operator DiscreteObjectKeyFrame(Windows.Media.Animation.DiscreteObjectKeyFrame ui) => DiscreteObjectKeyFrame.StartChain(ui);

        protected DiscreteObjectKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscretePoint3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePoint3DKeyFrame"/></summary>
        public static DiscretePoint3DKeyFrame DiscretePoint3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscretePoint3DKeyFrame();
            return global::CSharpMarkup.Wpf.DiscretePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePoint3DKeyFrame"/></summary>
        public static DiscretePoint3DKeyFrame DiscretePoint3DKeyFrame(Windows.Media.Media3D.Point3D value)
        {
            var ui = new Windows.Media.Animation.DiscretePoint3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscretePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePoint3DKeyFrame"/></summary>
        public static DiscretePoint3DKeyFrame DiscretePoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscretePoint3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscretePoint3DKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscretePoint3DKeyFrame : Point3DKeyFrame, IUI<System.Windows.Media.Animation.DiscretePoint3DKeyFrame>
    {
        static DiscretePoint3DKeyFrame instance;

        internal static DiscretePoint3DKeyFrame StartChain(Windows.Media.Animation.DiscretePoint3DKeyFrame ui)
        {
            if (instance == null) instance = new DiscretePoint3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscretePoint3DKeyFrame ui;

        public new Windows.Media.Animation.DiscretePoint3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscretePoint3DKeyFrame(DiscretePoint3DKeyFrame view) => view?.UI;

        public static implicit operator DiscretePoint3DKeyFrame(Windows.Media.Animation.DiscretePoint3DKeyFrame ui) => DiscretePoint3DKeyFrame.StartChain(ui);

        protected DiscretePoint3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscretePointKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePointKeyFrame"/></summary>
        public static DiscretePointKeyFrame DiscretePointKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscretePointKeyFrame();
            return global::CSharpMarkup.Wpf.DiscretePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePointKeyFrame"/></summary>
        public static DiscretePointKeyFrame DiscretePointKeyFrame(Windows.Point value)
        {
            var ui = new Windows.Media.Animation.DiscretePointKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscretePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscretePointKeyFrame"/></summary>
        public static DiscretePointKeyFrame DiscretePointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscretePointKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscretePointKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscretePointKeyFrame : PointKeyFrame, IUI<System.Windows.Media.Animation.DiscretePointKeyFrame>
    {
        static DiscretePointKeyFrame instance;

        internal static DiscretePointKeyFrame StartChain(Windows.Media.Animation.DiscretePointKeyFrame ui)
        {
            if (instance == null) instance = new DiscretePointKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscretePointKeyFrame ui;

        public new Windows.Media.Animation.DiscretePointKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscretePointKeyFrame(DiscretePointKeyFrame view) => view?.UI;

        public static implicit operator DiscretePointKeyFrame(Windows.Media.Animation.DiscretePointKeyFrame ui) => DiscretePointKeyFrame.StartChain(ui);

        protected DiscretePointKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteQuaternionKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteQuaternionKeyFrame"/></summary>
        public static DiscreteQuaternionKeyFrame DiscreteQuaternionKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteQuaternionKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteQuaternionKeyFrame"/></summary>
        public static DiscreteQuaternionKeyFrame DiscreteQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value)
        {
            var ui = new Windows.Media.Animation.DiscreteQuaternionKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteQuaternionKeyFrame"/></summary>
        public static DiscreteQuaternionKeyFrame DiscreteQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteQuaternionKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteQuaternionKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteQuaternionKeyFrame : QuaternionKeyFrame, IUI<System.Windows.Media.Animation.DiscreteQuaternionKeyFrame>
    {
        static DiscreteQuaternionKeyFrame instance;

        internal static DiscreteQuaternionKeyFrame StartChain(Windows.Media.Animation.DiscreteQuaternionKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteQuaternionKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteQuaternionKeyFrame ui;

        public new Windows.Media.Animation.DiscreteQuaternionKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteQuaternionKeyFrame(DiscreteQuaternionKeyFrame view) => view?.UI;

        public static implicit operator DiscreteQuaternionKeyFrame(Windows.Media.Animation.DiscreteQuaternionKeyFrame ui) => DiscreteQuaternionKeyFrame.StartChain(ui);

        protected DiscreteQuaternionKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteRectKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRectKeyFrame"/></summary>
        public static DiscreteRectKeyFrame DiscreteRectKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteRectKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRectKeyFrame"/></summary>
        public static DiscreteRectKeyFrame DiscreteRectKeyFrame(Windows.Rect value)
        {
            var ui = new Windows.Media.Animation.DiscreteRectKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRectKeyFrame"/></summary>
        public static DiscreteRectKeyFrame DiscreteRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteRectKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteRectKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteRectKeyFrame : RectKeyFrame, IUI<System.Windows.Media.Animation.DiscreteRectKeyFrame>
    {
        static DiscreteRectKeyFrame instance;

        internal static DiscreteRectKeyFrame StartChain(Windows.Media.Animation.DiscreteRectKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteRectKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteRectKeyFrame ui;

        public new Windows.Media.Animation.DiscreteRectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteRectKeyFrame(DiscreteRectKeyFrame view) => view?.UI;

        public static implicit operator DiscreteRectKeyFrame(Windows.Media.Animation.DiscreteRectKeyFrame ui) => DiscreteRectKeyFrame.StartChain(ui);

        protected DiscreteRectKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteRotation3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRotation3DKeyFrame"/></summary>
        public static DiscreteRotation3DKeyFrame DiscreteRotation3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteRotation3DKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRotation3DKeyFrame"/></summary>
        public static DiscreteRotation3DKeyFrame DiscreteRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value)
        {
            var ui = new Windows.Media.Animation.DiscreteRotation3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteRotation3DKeyFrame"/></summary>
        public static DiscreteRotation3DKeyFrame DiscreteRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteRotation3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteRotation3DKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteRotation3DKeyFrame : Rotation3DKeyFrame, IUI<System.Windows.Media.Animation.DiscreteRotation3DKeyFrame>
    {
        static DiscreteRotation3DKeyFrame instance;

        internal static DiscreteRotation3DKeyFrame StartChain(Windows.Media.Animation.DiscreteRotation3DKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteRotation3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteRotation3DKeyFrame ui;

        public new Windows.Media.Animation.DiscreteRotation3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteRotation3DKeyFrame(DiscreteRotation3DKeyFrame view) => view?.UI;

        public static implicit operator DiscreteRotation3DKeyFrame(Windows.Media.Animation.DiscreteRotation3DKeyFrame ui) => DiscreteRotation3DKeyFrame.StartChain(ui);

        protected DiscreteRotation3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteSingleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSingleKeyFrame"/></summary>
        public static DiscreteSingleKeyFrame DiscreteSingleKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteSingleKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSingleKeyFrame"/></summary>
        public static DiscreteSingleKeyFrame DiscreteSingleKeyFrame(float value)
        {
            var ui = new Windows.Media.Animation.DiscreteSingleKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSingleKeyFrame"/></summary>
        public static DiscreteSingleKeyFrame DiscreteSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteSingleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteSingleKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteSingleKeyFrame : SingleKeyFrame, IUI<System.Windows.Media.Animation.DiscreteSingleKeyFrame>
    {
        static DiscreteSingleKeyFrame instance;

        internal static DiscreteSingleKeyFrame StartChain(Windows.Media.Animation.DiscreteSingleKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteSingleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteSingleKeyFrame ui;

        public new Windows.Media.Animation.DiscreteSingleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteSingleKeyFrame(DiscreteSingleKeyFrame view) => view?.UI;

        public static implicit operator DiscreteSingleKeyFrame(Windows.Media.Animation.DiscreteSingleKeyFrame ui) => DiscreteSingleKeyFrame.StartChain(ui);

        protected DiscreteSingleKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteSizeKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSizeKeyFrame"/></summary>
        public static DiscreteSizeKeyFrame DiscreteSizeKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteSizeKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSizeKeyFrame"/></summary>
        public static DiscreteSizeKeyFrame DiscreteSizeKeyFrame(Windows.Size value)
        {
            var ui = new Windows.Media.Animation.DiscreteSizeKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteSizeKeyFrame"/></summary>
        public static DiscreteSizeKeyFrame DiscreteSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteSizeKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteSizeKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteSizeKeyFrame : SizeKeyFrame, IUI<System.Windows.Media.Animation.DiscreteSizeKeyFrame>
    {
        static DiscreteSizeKeyFrame instance;

        internal static DiscreteSizeKeyFrame StartChain(Windows.Media.Animation.DiscreteSizeKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteSizeKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteSizeKeyFrame ui;

        public new Windows.Media.Animation.DiscreteSizeKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteSizeKeyFrame(DiscreteSizeKeyFrame view) => view?.UI;

        public static implicit operator DiscreteSizeKeyFrame(Windows.Media.Animation.DiscreteSizeKeyFrame ui) => DiscreteSizeKeyFrame.StartChain(ui);

        protected DiscreteSizeKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteStringKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteStringKeyFrame"/></summary>
        public static DiscreteStringKeyFrame DiscreteStringKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteStringKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteStringKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteStringKeyFrame"/></summary>
        public static DiscreteStringKeyFrame DiscreteStringKeyFrame(string value)
        {
            var ui = new Windows.Media.Animation.DiscreteStringKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteStringKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteStringKeyFrame"/></summary>
        public static DiscreteStringKeyFrame DiscreteStringKeyFrame(string value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteStringKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteStringKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteStringKeyFrame : StringKeyFrame, IUI<System.Windows.Media.Animation.DiscreteStringKeyFrame>
    {
        static DiscreteStringKeyFrame instance;

        internal static DiscreteStringKeyFrame StartChain(Windows.Media.Animation.DiscreteStringKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteStringKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteStringKeyFrame ui;

        public new Windows.Media.Animation.DiscreteStringKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteStringKeyFrame(DiscreteStringKeyFrame view) => view?.UI;

        public static implicit operator DiscreteStringKeyFrame(Windows.Media.Animation.DiscreteStringKeyFrame ui) => DiscreteStringKeyFrame.StartChain(ui);

        protected DiscreteStringKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteVector3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVector3DKeyFrame"/></summary>
        public static DiscreteVector3DKeyFrame DiscreteVector3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteVector3DKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVector3DKeyFrame"/></summary>
        public static DiscreteVector3DKeyFrame DiscreteVector3DKeyFrame(Windows.Media.Media3D.Vector3D value)
        {
            var ui = new Windows.Media.Animation.DiscreteVector3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVector3DKeyFrame"/></summary>
        public static DiscreteVector3DKeyFrame DiscreteVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteVector3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteVector3DKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteVector3DKeyFrame : Vector3DKeyFrame, IUI<System.Windows.Media.Animation.DiscreteVector3DKeyFrame>
    {
        static DiscreteVector3DKeyFrame instance;

        internal static DiscreteVector3DKeyFrame StartChain(Windows.Media.Animation.DiscreteVector3DKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteVector3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteVector3DKeyFrame ui;

        public new Windows.Media.Animation.DiscreteVector3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteVector3DKeyFrame(DiscreteVector3DKeyFrame view) => view?.UI;

        public static implicit operator DiscreteVector3DKeyFrame(Windows.Media.Animation.DiscreteVector3DKeyFrame ui) => DiscreteVector3DKeyFrame.StartChain(ui);

        protected DiscreteVector3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DiscreteVectorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVectorKeyFrame"/></summary>
        public static DiscreteVectorKeyFrame DiscreteVectorKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteVectorKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVectorKeyFrame"/></summary>
        public static DiscreteVectorKeyFrame DiscreteVectorKeyFrame(Windows.Vector value)
        {
            var ui = new Windows.Media.Animation.DiscreteVectorKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteVectorKeyFrame"/></summary>
        public static DiscreteVectorKeyFrame DiscreteVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteVectorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteVectorKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteVectorKeyFrame : VectorKeyFrame, IUI<System.Windows.Media.Animation.DiscreteVectorKeyFrame>
    {
        static DiscreteVectorKeyFrame instance;

        internal static DiscreteVectorKeyFrame StartChain(Windows.Media.Animation.DiscreteVectorKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteVectorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteVectorKeyFrame ui;

        public new Windows.Media.Animation.DiscreteVectorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteVectorKeyFrame(DiscreteVectorKeyFrame view) => view?.UI;

        public static implicit operator DiscreteVectorKeyFrame(Windows.Media.Animation.DiscreteVectorKeyFrame ui) => DiscreteVectorKeyFrame.StartChain(ui);

        protected DiscreteVectorKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // DoubleAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation(O<double?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<double?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<double?> To = default)
        {
            var ui = new Windows.Media.Animation.DoubleAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation()
        {
            var ui = new Windows.Media.Animation.DoubleAnimation();
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation(double fromValue, double toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.DoubleAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation(double fromValue, double toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.DoubleAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation(double toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.DoubleAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimation"/></summary>
        public static DoubleAnimation DoubleAnimation(double toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.DoubleAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.DoubleAnimation.StartChain(ui);
        }
    }

    public partial class DoubleAnimation : DoubleAnimationBase, IUI<System.Windows.Media.Animation.DoubleAnimation>
    {
        static DoubleAnimation instance;

        internal static DoubleAnimation StartChain(Windows.Media.Animation.DoubleAnimation ui)
        {
            if (instance == null) instance = new DoubleAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DoubleAnimation ui;

        public new Windows.Media.Animation.DoubleAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DoubleAnimation(DoubleAnimation view) => view?.UI;

        public static implicit operator DoubleAnimation(Windows.Media.Animation.DoubleAnimation ui) => DoubleAnimation.StartChain(ui);

        protected DoubleAnimation() { }
    }

    public static partial class DoubleAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.By"/></summary>
        public static TView By<TView>(this TView view, double? value) where TView : DoubleAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : DoubleAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.From"/></summary>
        public static TView From<TView>(this TView view, double? value) where TView : DoubleAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : DoubleAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : DoubleAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimation.To"/></summary>
        public static TView To<TView>(this TView view, double? value) where TView : DoubleAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimation.By"/></summary>
        public static DependencyProperty<TTarget, double?> By<TTarget>(this TTarget target) where TTarget : DoubleAnimation
        => DependencyProperty<TTarget, double?>.Get(target, Windows.Media.Animation.DoubleAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : DoubleAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.DoubleAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimation.From"/></summary>
        public static DependencyProperty<TTarget, double?> From<TTarget>(this TTarget target) where TTarget : DoubleAnimation
        => DependencyProperty<TTarget, double?>.Get(target, Windows.Media.Animation.DoubleAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimation.To"/></summary>
        public static DependencyProperty<TTarget, double?> To<TTarget>(this TTarget target) where TTarget : DoubleAnimation
        => DependencyProperty<TTarget, double?>.Get(target, Windows.Media.Animation.DoubleAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // DoubleAnimationBase
{
    public partial class DoubleAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.DoubleAnimationBase>
    {
        Windows.Media.Animation.DoubleAnimationBase ui;

        public new Windows.Media.Animation.DoubleAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DoubleAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // DoubleAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames"/></summary>
        public static DoubleAnimationUsingKeyFrames DoubleAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.DoubleKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.DoubleAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.DoubleAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames"/></summary>
        public static DoubleAnimationUsingKeyFrames DoubleAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.DoubleKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.DoubleAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.DoubleAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames"/></summary>
        public static DoubleAnimationUsingKeyFrames DoubleAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.DoubleAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.DoubleAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class DoubleAnimationUsingKeyFrames : DoubleAnimationBase, IUI<System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames>
    {
        static DoubleAnimationUsingKeyFrames instance;

        internal static DoubleAnimationUsingKeyFrames StartChain(Windows.Media.Animation.DoubleAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new DoubleAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DoubleAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.DoubleAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DoubleAnimationUsingKeyFrames(DoubleAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator DoubleAnimationUsingKeyFrames(Windows.Media.Animation.DoubleAnimationUsingKeyFrames ui) => DoubleAnimationUsingKeyFrames.StartChain(ui);

        protected DoubleAnimationUsingKeyFrames() { }
    }

    public static partial class DoubleAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : DoubleAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : DoubleAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.DoubleKeyFrameCollection value) where TView : DoubleAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // DoubleAnimationUsingPath
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimationUsingPath"/></summary>
        public static DoubleAnimationUsingPath DoubleAnimationUsingPath(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.PathGeometry> PathGeometry = default, O<Windows.Media.Animation.PathAnimationSource> Source = default)
        {
            var ui = new Windows.Media.Animation.DoubleAnimationUsingPath();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (PathGeometry.HasValue) ui.PathGeometry = PathGeometry.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.DoubleAnimationUsingPath.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleAnimationUsingPath"/></summary>
        public static DoubleAnimationUsingPath DoubleAnimationUsingPath()
        {
            var ui = new Windows.Media.Animation.DoubleAnimationUsingPath();
            return global::CSharpMarkup.Wpf.DoubleAnimationUsingPath.StartChain(ui);
        }
    }

    public partial class DoubleAnimationUsingPath : DoubleAnimationBase, IUI<System.Windows.Media.Animation.DoubleAnimationUsingPath>
    {
        static DoubleAnimationUsingPath instance;

        internal static DoubleAnimationUsingPath StartChain(Windows.Media.Animation.DoubleAnimationUsingPath ui)
        {
            if (instance == null) instance = new DoubleAnimationUsingPath();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DoubleAnimationUsingPath ui;

        public new Windows.Media.Animation.DoubleAnimationUsingPath UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DoubleAnimationUsingPath(DoubleAnimationUsingPath view) => view?.UI;

        public static implicit operator DoubleAnimationUsingPath(Windows.Media.Animation.DoubleAnimationUsingPath ui) => DoubleAnimationUsingPath.StartChain(ui);

        protected DoubleAnimationUsingPath() { }
    }

    public static partial class DoubleAnimationUsingPathExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : DoubleAnimationUsingPath { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : DoubleAnimationUsingPath { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.PathGeometry"/></summary>
        public static TView PathGeometry<TView>(this TView view, Windows.Media.PathGeometry value) where TView : DoubleAnimationUsingPath { view.UI.PathGeometry = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.Animation.PathAnimationSource value) where TView : DoubleAnimationUsingPath { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.PathGeometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PathGeometry> PathGeometry<TTarget>(this TTarget target) where TTarget : DoubleAnimationUsingPath
        => DependencyProperty<TTarget, Windows.Media.PathGeometry>.Get(target, Windows.Media.Animation.DoubleAnimationUsingPath.PathGeometryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleAnimationUsingPath.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.PathAnimationSource> Source<TTarget>(this TTarget target) where TTarget : DoubleAnimationUsingPath
        => DependencyProperty<TTarget, Windows.Media.Animation.PathAnimationSource>.Get(target, Windows.Media.Animation.DoubleAnimationUsingPath.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // DoubleKeyFrame
{
    public partial class DoubleKeyFrame : Freezable, IUI<System.Windows.Media.Animation.DoubleKeyFrame>
    {
        Windows.Media.Animation.DoubleKeyFrame ui;

        public new Windows.Media.Animation.DoubleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DoubleKeyFrame() { }
    }

    public static partial class DoubleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.DoubleKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : DoubleKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.DoubleKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, double value) where TView : DoubleKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : DoubleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.DoubleKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.DoubleKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, double> Value<TTarget>(this TTarget target) where TTarget : DoubleKeyFrame
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.DoubleKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // DoubleKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DoubleKeyFrameCollection"/></summary>
        public static DoubleKeyFrameCollection DoubleKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.DoubleKeyFrameCollection();
            return global::CSharpMarkup.Wpf.DoubleKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class DoubleKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.DoubleKeyFrameCollection>
    {
        static DoubleKeyFrameCollection instance;

        internal static DoubleKeyFrameCollection StartChain(Windows.Media.Animation.DoubleKeyFrameCollection ui)
        {
            if (instance == null) instance = new DoubleKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DoubleKeyFrameCollection ui;

        public new Windows.Media.Animation.DoubleKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DoubleKeyFrameCollection(DoubleKeyFrameCollection view) => view?.UI;

        public static implicit operator DoubleKeyFrameCollection(Windows.Media.Animation.DoubleKeyFrameCollection ui) => DoubleKeyFrameCollection.StartChain(ui);

        protected DoubleKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // EasingByteKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingByteKeyFrame"/></summary>
        public static EasingByteKeyFrame EasingByteKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingByteKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingByteKeyFrame"/></summary>
        public static EasingByteKeyFrame EasingByteKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingByteKeyFrame();
            return global::CSharpMarkup.Wpf.EasingByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingByteKeyFrame"/></summary>
        public static EasingByteKeyFrame EasingByteKeyFrame(byte value)
        {
            var ui = new Windows.Media.Animation.EasingByteKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingByteKeyFrame"/></summary>
        public static EasingByteKeyFrame EasingByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingByteKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingByteKeyFrame"/></summary>
        public static EasingByteKeyFrame EasingByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingByteKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingByteKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingByteKeyFrame : ByteKeyFrame, IUI<System.Windows.Media.Animation.EasingByteKeyFrame>
    {
        static EasingByteKeyFrame instance;

        internal static EasingByteKeyFrame StartChain(Windows.Media.Animation.EasingByteKeyFrame ui)
        {
            if (instance == null) instance = new EasingByteKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingByteKeyFrame ui;

        public new Windows.Media.Animation.EasingByteKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingByteKeyFrame(EasingByteKeyFrame view) => view?.UI;

        public static implicit operator EasingByteKeyFrame(Windows.Media.Animation.EasingByteKeyFrame ui) => EasingByteKeyFrame.StartChain(ui);

        protected EasingByteKeyFrame() { }
    }

    public static partial class EasingByteKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingByteKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingByteKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingByteKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingByteKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingByteKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingColorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingColorKeyFrame"/></summary>
        public static EasingColorKeyFrame EasingColorKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingColorKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingColorKeyFrame"/></summary>
        public static EasingColorKeyFrame EasingColorKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingColorKeyFrame();
            return global::CSharpMarkup.Wpf.EasingColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingColorKeyFrame"/></summary>
        public static EasingColorKeyFrame EasingColorKeyFrame(Color value)
        {
            var ui = new Windows.Media.Animation.EasingColorKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingColorKeyFrame"/></summary>
        public static EasingColorKeyFrame EasingColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingColorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingColorKeyFrame"/></summary>
        public static EasingColorKeyFrame EasingColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingColorKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingColorKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingColorKeyFrame : ColorKeyFrame, IUI<System.Windows.Media.Animation.EasingColorKeyFrame>
    {
        static EasingColorKeyFrame instance;

        internal static EasingColorKeyFrame StartChain(Windows.Media.Animation.EasingColorKeyFrame ui)
        {
            if (instance == null) instance = new EasingColorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingColorKeyFrame ui;

        public new Windows.Media.Animation.EasingColorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingColorKeyFrame(EasingColorKeyFrame view) => view?.UI;

        public static implicit operator EasingColorKeyFrame(Windows.Media.Animation.EasingColorKeyFrame ui) => EasingColorKeyFrame.StartChain(ui);

        protected EasingColorKeyFrame() { }
    }

    public static partial class EasingColorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingColorKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingColorKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingColorKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingColorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingColorKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingDecimalKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDecimalKeyFrame"/></summary>
        public static EasingDecimalKeyFrame EasingDecimalKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingDecimalKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDecimalKeyFrame"/></summary>
        public static EasingDecimalKeyFrame EasingDecimalKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingDecimalKeyFrame();
            return global::CSharpMarkup.Wpf.EasingDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDecimalKeyFrame"/></summary>
        public static EasingDecimalKeyFrame EasingDecimalKeyFrame(decimal value)
        {
            var ui = new Windows.Media.Animation.EasingDecimalKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDecimalKeyFrame"/></summary>
        public static EasingDecimalKeyFrame EasingDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingDecimalKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDecimalKeyFrame"/></summary>
        public static EasingDecimalKeyFrame EasingDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingDecimalKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingDecimalKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingDecimalKeyFrame : DecimalKeyFrame, IUI<System.Windows.Media.Animation.EasingDecimalKeyFrame>
    {
        static EasingDecimalKeyFrame instance;

        internal static EasingDecimalKeyFrame StartChain(Windows.Media.Animation.EasingDecimalKeyFrame ui)
        {
            if (instance == null) instance = new EasingDecimalKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingDecimalKeyFrame ui;

        public new Windows.Media.Animation.EasingDecimalKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingDecimalKeyFrame(EasingDecimalKeyFrame view) => view?.UI;

        public static implicit operator EasingDecimalKeyFrame(Windows.Media.Animation.EasingDecimalKeyFrame ui) => EasingDecimalKeyFrame.StartChain(ui);

        protected EasingDecimalKeyFrame() { }
    }

    public static partial class EasingDecimalKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingDecimalKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingDecimalKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingDecimalKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingDecimalKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingDecimalKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingDoubleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDoubleKeyFrame"/></summary>
        public static EasingDoubleKeyFrame EasingDoubleKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingDoubleKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDoubleKeyFrame"/></summary>
        public static EasingDoubleKeyFrame EasingDoubleKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingDoubleKeyFrame();
            return global::CSharpMarkup.Wpf.EasingDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDoubleKeyFrame"/></summary>
        public static EasingDoubleKeyFrame EasingDoubleKeyFrame(double value)
        {
            var ui = new Windows.Media.Animation.EasingDoubleKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDoubleKeyFrame"/></summary>
        public static EasingDoubleKeyFrame EasingDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingDoubleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingDoubleKeyFrame"/></summary>
        public static EasingDoubleKeyFrame EasingDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingDoubleKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingDoubleKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingDoubleKeyFrame : DoubleKeyFrame, IUI<System.Windows.Media.Animation.EasingDoubleKeyFrame>
    {
        static EasingDoubleKeyFrame instance;

        internal static EasingDoubleKeyFrame StartChain(Windows.Media.Animation.EasingDoubleKeyFrame ui)
        {
            if (instance == null) instance = new EasingDoubleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingDoubleKeyFrame ui;

        public new Windows.Media.Animation.EasingDoubleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingDoubleKeyFrame(EasingDoubleKeyFrame view) => view?.UI;

        public static implicit operator EasingDoubleKeyFrame(Windows.Media.Animation.EasingDoubleKeyFrame ui) => EasingDoubleKeyFrame.StartChain(ui);

        protected EasingDoubleKeyFrame() { }
    }

    public static partial class EasingDoubleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingDoubleKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingDoubleKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingDoubleKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingDoubleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingDoubleKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingFunctionBase
{
    public partial class EasingFunctionBase : Freezable, IUI<System.Windows.Media.Animation.EasingFunctionBase>
    {
        Windows.Media.Animation.EasingFunctionBase ui;

        public new Windows.Media.Animation.EasingFunctionBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected EasingFunctionBase() { }
    }

    public static partial class EasingFunctionBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingFunctionBase.EasingMode"/></summary>
        public static TView EasingMode<TView>(this TView view, Windows.Media.Animation.EasingMode value) where TView : EasingFunctionBase { view.UI.EasingMode = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingFunctionBase.EasingMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.EasingMode> EasingMode<TTarget>(this TTarget target) where TTarget : EasingFunctionBase
        => DependencyProperty<TTarget, Windows.Media.Animation.EasingMode>.Get(target, Windows.Media.Animation.EasingFunctionBase.EasingModeProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingInt16KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt16KeyFrame"/></summary>
        public static EasingInt16KeyFrame EasingInt16KeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingInt16KeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt16KeyFrame"/></summary>
        public static EasingInt16KeyFrame EasingInt16KeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingInt16KeyFrame();
            return global::CSharpMarkup.Wpf.EasingInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt16KeyFrame"/></summary>
        public static EasingInt16KeyFrame EasingInt16KeyFrame(short value)
        {
            var ui = new Windows.Media.Animation.EasingInt16KeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt16KeyFrame"/></summary>
        public static EasingInt16KeyFrame EasingInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingInt16KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt16KeyFrame"/></summary>
        public static EasingInt16KeyFrame EasingInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingInt16KeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingInt16KeyFrame.StartChain(ui);
        }
    }

    public partial class EasingInt16KeyFrame : Int16KeyFrame, IUI<System.Windows.Media.Animation.EasingInt16KeyFrame>
    {
        static EasingInt16KeyFrame instance;

        internal static EasingInt16KeyFrame StartChain(Windows.Media.Animation.EasingInt16KeyFrame ui)
        {
            if (instance == null) instance = new EasingInt16KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingInt16KeyFrame ui;

        public new Windows.Media.Animation.EasingInt16KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingInt16KeyFrame(EasingInt16KeyFrame view) => view?.UI;

        public static implicit operator EasingInt16KeyFrame(Windows.Media.Animation.EasingInt16KeyFrame ui) => EasingInt16KeyFrame.StartChain(ui);

        protected EasingInt16KeyFrame() { }
    }

    public static partial class EasingInt16KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingInt16KeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingInt16KeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingInt16KeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingInt16KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingInt16KeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingInt32KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt32KeyFrame"/></summary>
        public static EasingInt32KeyFrame EasingInt32KeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingInt32KeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt32KeyFrame"/></summary>
        public static EasingInt32KeyFrame EasingInt32KeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingInt32KeyFrame();
            return global::CSharpMarkup.Wpf.EasingInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt32KeyFrame"/></summary>
        public static EasingInt32KeyFrame EasingInt32KeyFrame(int value)
        {
            var ui = new Windows.Media.Animation.EasingInt32KeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt32KeyFrame"/></summary>
        public static EasingInt32KeyFrame EasingInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingInt32KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt32KeyFrame"/></summary>
        public static EasingInt32KeyFrame EasingInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingInt32KeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingInt32KeyFrame.StartChain(ui);
        }
    }

    public partial class EasingInt32KeyFrame : Int32KeyFrame, IUI<System.Windows.Media.Animation.EasingInt32KeyFrame>
    {
        static EasingInt32KeyFrame instance;

        internal static EasingInt32KeyFrame StartChain(Windows.Media.Animation.EasingInt32KeyFrame ui)
        {
            if (instance == null) instance = new EasingInt32KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingInt32KeyFrame ui;

        public new Windows.Media.Animation.EasingInt32KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingInt32KeyFrame(EasingInt32KeyFrame view) => view?.UI;

        public static implicit operator EasingInt32KeyFrame(Windows.Media.Animation.EasingInt32KeyFrame ui) => EasingInt32KeyFrame.StartChain(ui);

        protected EasingInt32KeyFrame() { }
    }

    public static partial class EasingInt32KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingInt32KeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingInt32KeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingInt32KeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingInt32KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingInt32KeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingInt64KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt64KeyFrame"/></summary>
        public static EasingInt64KeyFrame EasingInt64KeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingInt64KeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt64KeyFrame"/></summary>
        public static EasingInt64KeyFrame EasingInt64KeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingInt64KeyFrame();
            return global::CSharpMarkup.Wpf.EasingInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt64KeyFrame"/></summary>
        public static EasingInt64KeyFrame EasingInt64KeyFrame(long value)
        {
            var ui = new Windows.Media.Animation.EasingInt64KeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt64KeyFrame"/></summary>
        public static EasingInt64KeyFrame EasingInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingInt64KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingInt64KeyFrame"/></summary>
        public static EasingInt64KeyFrame EasingInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingInt64KeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingInt64KeyFrame.StartChain(ui);
        }
    }

    public partial class EasingInt64KeyFrame : Int64KeyFrame, IUI<System.Windows.Media.Animation.EasingInt64KeyFrame>
    {
        static EasingInt64KeyFrame instance;

        internal static EasingInt64KeyFrame StartChain(Windows.Media.Animation.EasingInt64KeyFrame ui)
        {
            if (instance == null) instance = new EasingInt64KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingInt64KeyFrame ui;

        public new Windows.Media.Animation.EasingInt64KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingInt64KeyFrame(EasingInt64KeyFrame view) => view?.UI;

        public static implicit operator EasingInt64KeyFrame(Windows.Media.Animation.EasingInt64KeyFrame ui) => EasingInt64KeyFrame.StartChain(ui);

        protected EasingInt64KeyFrame() { }
    }

    public static partial class EasingInt64KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingInt64KeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingInt64KeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingInt64KeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingInt64KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingInt64KeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingPoint3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame"/></summary>
        public static EasingPoint3DKeyFrame EasingPoint3DKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingPoint3DKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame"/></summary>
        public static EasingPoint3DKeyFrame EasingPoint3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingPoint3DKeyFrame();
            return global::CSharpMarkup.Wpf.EasingPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame"/></summary>
        public static EasingPoint3DKeyFrame EasingPoint3DKeyFrame(Windows.Media.Media3D.Point3D value)
        {
            var ui = new Windows.Media.Animation.EasingPoint3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame"/></summary>
        public static EasingPoint3DKeyFrame EasingPoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingPoint3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame"/></summary>
        public static EasingPoint3DKeyFrame EasingPoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingPoint3DKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingPoint3DKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingPoint3DKeyFrame : Point3DKeyFrame, IUI<System.Windows.Media.Animation.EasingPoint3DKeyFrame>
    {
        static EasingPoint3DKeyFrame instance;

        internal static EasingPoint3DKeyFrame StartChain(Windows.Media.Animation.EasingPoint3DKeyFrame ui)
        {
            if (instance == null) instance = new EasingPoint3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingPoint3DKeyFrame ui;

        public new Windows.Media.Animation.EasingPoint3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingPoint3DKeyFrame(EasingPoint3DKeyFrame view) => view?.UI;

        public static implicit operator EasingPoint3DKeyFrame(Windows.Media.Animation.EasingPoint3DKeyFrame ui) => EasingPoint3DKeyFrame.StartChain(ui);

        protected EasingPoint3DKeyFrame() { }
    }

    public static partial class EasingPoint3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingPoint3DKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingPoint3DKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingPoint3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingPoint3DKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingPointKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPointKeyFrame"/></summary>
        public static EasingPointKeyFrame EasingPointKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingPointKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPointKeyFrame"/></summary>
        public static EasingPointKeyFrame EasingPointKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingPointKeyFrame();
            return global::CSharpMarkup.Wpf.EasingPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPointKeyFrame"/></summary>
        public static EasingPointKeyFrame EasingPointKeyFrame(Windows.Point value)
        {
            var ui = new Windows.Media.Animation.EasingPointKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPointKeyFrame"/></summary>
        public static EasingPointKeyFrame EasingPointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingPointKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingPointKeyFrame"/></summary>
        public static EasingPointKeyFrame EasingPointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingPointKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingPointKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingPointKeyFrame : PointKeyFrame, IUI<System.Windows.Media.Animation.EasingPointKeyFrame>
    {
        static EasingPointKeyFrame instance;

        internal static EasingPointKeyFrame StartChain(Windows.Media.Animation.EasingPointKeyFrame ui)
        {
            if (instance == null) instance = new EasingPointKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingPointKeyFrame ui;

        public new Windows.Media.Animation.EasingPointKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingPointKeyFrame(EasingPointKeyFrame view) => view?.UI;

        public static implicit operator EasingPointKeyFrame(Windows.Media.Animation.EasingPointKeyFrame ui) => EasingPointKeyFrame.StartChain(ui);

        protected EasingPointKeyFrame() { }
    }

    public static partial class EasingPointKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingPointKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingPointKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingPointKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingPointKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingPointKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingQuaternionKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame"/></summary>
        public static EasingQuaternionKeyFrame EasingQuaternionKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<bool> UseShortestPath = default)
        {
            var ui = new Windows.Media.Animation.EasingQuaternionKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (UseShortestPath.HasValue) ui.UseShortestPath = UseShortestPath.Value;
            return global::CSharpMarkup.Wpf.EasingQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame"/></summary>
        public static EasingQuaternionKeyFrame EasingQuaternionKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingQuaternionKeyFrame();
            return global::CSharpMarkup.Wpf.EasingQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame"/></summary>
        public static EasingQuaternionKeyFrame EasingQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value)
        {
            var ui = new Windows.Media.Animation.EasingQuaternionKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame"/></summary>
        public static EasingQuaternionKeyFrame EasingQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingQuaternionKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame"/></summary>
        public static EasingQuaternionKeyFrame EasingQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingQuaternionKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingQuaternionKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingQuaternionKeyFrame : QuaternionKeyFrame, IUI<System.Windows.Media.Animation.EasingQuaternionKeyFrame>
    {
        static EasingQuaternionKeyFrame instance;

        internal static EasingQuaternionKeyFrame StartChain(Windows.Media.Animation.EasingQuaternionKeyFrame ui)
        {
            if (instance == null) instance = new EasingQuaternionKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingQuaternionKeyFrame ui;

        public new Windows.Media.Animation.EasingQuaternionKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingQuaternionKeyFrame(EasingQuaternionKeyFrame view) => view?.UI;

        public static implicit operator EasingQuaternionKeyFrame(Windows.Media.Animation.EasingQuaternionKeyFrame ui) => EasingQuaternionKeyFrame.StartChain(ui);

        protected EasingQuaternionKeyFrame() { }
    }

    public static partial class EasingQuaternionKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingQuaternionKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame.UseShortestPath"/></summary>
        public static TView UseShortestPath<TView>(this TView view, bool value) where TView : EasingQuaternionKeyFrame { view.UI.UseShortestPath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingQuaternionKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingQuaternionKeyFrame.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingQuaternionKeyFrame.UseShortestPath"/></summary>
        public static DependencyProperty<TTarget, bool> UseShortestPath<TTarget>(this TTarget target) where TTarget : EasingQuaternionKeyFrame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.EasingQuaternionKeyFrame.UseShortestPathProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingRectKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRectKeyFrame"/></summary>
        public static EasingRectKeyFrame EasingRectKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingRectKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRectKeyFrame"/></summary>
        public static EasingRectKeyFrame EasingRectKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingRectKeyFrame();
            return global::CSharpMarkup.Wpf.EasingRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRectKeyFrame"/></summary>
        public static EasingRectKeyFrame EasingRectKeyFrame(Windows.Rect value)
        {
            var ui = new Windows.Media.Animation.EasingRectKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRectKeyFrame"/></summary>
        public static EasingRectKeyFrame EasingRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingRectKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRectKeyFrame"/></summary>
        public static EasingRectKeyFrame EasingRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingRectKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingRectKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingRectKeyFrame : RectKeyFrame, IUI<System.Windows.Media.Animation.EasingRectKeyFrame>
    {
        static EasingRectKeyFrame instance;

        internal static EasingRectKeyFrame StartChain(Windows.Media.Animation.EasingRectKeyFrame ui)
        {
            if (instance == null) instance = new EasingRectKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingRectKeyFrame ui;

        public new Windows.Media.Animation.EasingRectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingRectKeyFrame(EasingRectKeyFrame view) => view?.UI;

        public static implicit operator EasingRectKeyFrame(Windows.Media.Animation.EasingRectKeyFrame ui) => EasingRectKeyFrame.StartChain(ui);

        protected EasingRectKeyFrame() { }
    }

    public static partial class EasingRectKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingRectKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingRectKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingRectKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingRectKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingRectKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingRotation3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame"/></summary>
        public static EasingRotation3DKeyFrame EasingRotation3DKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingRotation3DKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame"/></summary>
        public static EasingRotation3DKeyFrame EasingRotation3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingRotation3DKeyFrame();
            return global::CSharpMarkup.Wpf.EasingRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame"/></summary>
        public static EasingRotation3DKeyFrame EasingRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value)
        {
            var ui = new Windows.Media.Animation.EasingRotation3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame"/></summary>
        public static EasingRotation3DKeyFrame EasingRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingRotation3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame"/></summary>
        public static EasingRotation3DKeyFrame EasingRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingRotation3DKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingRotation3DKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingRotation3DKeyFrame : Rotation3DKeyFrame, IUI<System.Windows.Media.Animation.EasingRotation3DKeyFrame>
    {
        static EasingRotation3DKeyFrame instance;

        internal static EasingRotation3DKeyFrame StartChain(Windows.Media.Animation.EasingRotation3DKeyFrame ui)
        {
            if (instance == null) instance = new EasingRotation3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingRotation3DKeyFrame ui;

        public new Windows.Media.Animation.EasingRotation3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingRotation3DKeyFrame(EasingRotation3DKeyFrame view) => view?.UI;

        public static implicit operator EasingRotation3DKeyFrame(Windows.Media.Animation.EasingRotation3DKeyFrame ui) => EasingRotation3DKeyFrame.StartChain(ui);

        protected EasingRotation3DKeyFrame() { }
    }

    public static partial class EasingRotation3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingRotation3DKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingRotation3DKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingRotation3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingRotation3DKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingSingleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSingleKeyFrame"/></summary>
        public static EasingSingleKeyFrame EasingSingleKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingSingleKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSingleKeyFrame"/></summary>
        public static EasingSingleKeyFrame EasingSingleKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingSingleKeyFrame();
            return global::CSharpMarkup.Wpf.EasingSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSingleKeyFrame"/></summary>
        public static EasingSingleKeyFrame EasingSingleKeyFrame(float value)
        {
            var ui = new Windows.Media.Animation.EasingSingleKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSingleKeyFrame"/></summary>
        public static EasingSingleKeyFrame EasingSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingSingleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSingleKeyFrame"/></summary>
        public static EasingSingleKeyFrame EasingSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingSingleKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingSingleKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingSingleKeyFrame : SingleKeyFrame, IUI<System.Windows.Media.Animation.EasingSingleKeyFrame>
    {
        static EasingSingleKeyFrame instance;

        internal static EasingSingleKeyFrame StartChain(Windows.Media.Animation.EasingSingleKeyFrame ui)
        {
            if (instance == null) instance = new EasingSingleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingSingleKeyFrame ui;

        public new Windows.Media.Animation.EasingSingleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingSingleKeyFrame(EasingSingleKeyFrame view) => view?.UI;

        public static implicit operator EasingSingleKeyFrame(Windows.Media.Animation.EasingSingleKeyFrame ui) => EasingSingleKeyFrame.StartChain(ui);

        protected EasingSingleKeyFrame() { }
    }

    public static partial class EasingSingleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingSingleKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingSingleKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingSingleKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingSingleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingSingleKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingSizeKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSizeKeyFrame"/></summary>
        public static EasingSizeKeyFrame EasingSizeKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingSizeKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSizeKeyFrame"/></summary>
        public static EasingSizeKeyFrame EasingSizeKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingSizeKeyFrame();
            return global::CSharpMarkup.Wpf.EasingSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSizeKeyFrame"/></summary>
        public static EasingSizeKeyFrame EasingSizeKeyFrame(Windows.Size value)
        {
            var ui = new Windows.Media.Animation.EasingSizeKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSizeKeyFrame"/></summary>
        public static EasingSizeKeyFrame EasingSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingSizeKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingSizeKeyFrame"/></summary>
        public static EasingSizeKeyFrame EasingSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingSizeKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingSizeKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingSizeKeyFrame : SizeKeyFrame, IUI<System.Windows.Media.Animation.EasingSizeKeyFrame>
    {
        static EasingSizeKeyFrame instance;

        internal static EasingSizeKeyFrame StartChain(Windows.Media.Animation.EasingSizeKeyFrame ui)
        {
            if (instance == null) instance = new EasingSizeKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingSizeKeyFrame ui;

        public new Windows.Media.Animation.EasingSizeKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingSizeKeyFrame(EasingSizeKeyFrame view) => view?.UI;

        public static implicit operator EasingSizeKeyFrame(Windows.Media.Animation.EasingSizeKeyFrame ui) => EasingSizeKeyFrame.StartChain(ui);

        protected EasingSizeKeyFrame() { }
    }

    public static partial class EasingSizeKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingSizeKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingSizeKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingSizeKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingSizeKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingSizeKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingVector3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVector3DKeyFrame"/></summary>
        public static EasingVector3DKeyFrame EasingVector3DKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingVector3DKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVector3DKeyFrame"/></summary>
        public static EasingVector3DKeyFrame EasingVector3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingVector3DKeyFrame();
            return global::CSharpMarkup.Wpf.EasingVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVector3DKeyFrame"/></summary>
        public static EasingVector3DKeyFrame EasingVector3DKeyFrame(Windows.Media.Media3D.Vector3D value)
        {
            var ui = new Windows.Media.Animation.EasingVector3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVector3DKeyFrame"/></summary>
        public static EasingVector3DKeyFrame EasingVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingVector3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVector3DKeyFrame"/></summary>
        public static EasingVector3DKeyFrame EasingVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingVector3DKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingVector3DKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingVector3DKeyFrame : Vector3DKeyFrame, IUI<System.Windows.Media.Animation.EasingVector3DKeyFrame>
    {
        static EasingVector3DKeyFrame instance;

        internal static EasingVector3DKeyFrame StartChain(Windows.Media.Animation.EasingVector3DKeyFrame ui)
        {
            if (instance == null) instance = new EasingVector3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingVector3DKeyFrame ui;

        public new Windows.Media.Animation.EasingVector3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingVector3DKeyFrame(EasingVector3DKeyFrame view) => view?.UI;

        public static implicit operator EasingVector3DKeyFrame(Windows.Media.Animation.EasingVector3DKeyFrame ui) => EasingVector3DKeyFrame.StartChain(ui);

        protected EasingVector3DKeyFrame() { }
    }

    public static partial class EasingVector3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingVector3DKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingVector3DKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingVector3DKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingVector3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingVector3DKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // EasingVectorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVectorKeyFrame"/></summary>
        public static EasingVectorKeyFrame EasingVectorKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingVectorKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVectorKeyFrame"/></summary>
        public static EasingVectorKeyFrame EasingVectorKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingVectorKeyFrame();
            return global::CSharpMarkup.Wpf.EasingVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVectorKeyFrame"/></summary>
        public static EasingVectorKeyFrame EasingVectorKeyFrame(Windows.Vector value)
        {
            var ui = new Windows.Media.Animation.EasingVectorKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVectorKeyFrame"/></summary>
        public static EasingVectorKeyFrame EasingVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingVectorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingVectorKeyFrame"/></summary>
        public static EasingVectorKeyFrame EasingVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingVectorKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingVectorKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingVectorKeyFrame : VectorKeyFrame, IUI<System.Windows.Media.Animation.EasingVectorKeyFrame>
    {
        static EasingVectorKeyFrame instance;

        internal static EasingVectorKeyFrame StartChain(Windows.Media.Animation.EasingVectorKeyFrame ui)
        {
            if (instance == null) instance = new EasingVectorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingVectorKeyFrame ui;

        public new Windows.Media.Animation.EasingVectorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingVectorKeyFrame(EasingVectorKeyFrame view) => view?.UI;

        public static implicit operator EasingVectorKeyFrame(Windows.Media.Animation.EasingVectorKeyFrame ui) => EasingVectorKeyFrame.StartChain(ui);

        protected EasingVectorKeyFrame() { }
    }

    public static partial class EasingVectorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingVectorKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingVectorKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingVectorKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingVectorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingVectorKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // ElasticEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ElasticEase"/></summary>
        public static ElasticEase ElasticEase(O<int> Oscillations = default, O<double> Springiness = default)
        {
            var ui = new Windows.Media.Animation.ElasticEase();
            if (Oscillations.HasValue) ui.Oscillations = Oscillations.Value;
            if (Springiness.HasValue) ui.Springiness = Springiness.Value;
            return global::CSharpMarkup.Wpf.ElasticEase.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ElasticEase"/></summary>
        public static ElasticEase ElasticEase()
        {
            var ui = new Windows.Media.Animation.ElasticEase();
            return global::CSharpMarkup.Wpf.ElasticEase.StartChain(ui);
        }
    }

    public partial class ElasticEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.ElasticEase>
    {
        static ElasticEase instance;

        internal static ElasticEase StartChain(Windows.Media.Animation.ElasticEase ui)
        {
            if (instance == null) instance = new ElasticEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ElasticEase ui;

        public new Windows.Media.Animation.ElasticEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ElasticEase(ElasticEase view) => view?.UI;

        public static implicit operator ElasticEase(Windows.Media.Animation.ElasticEase ui) => ElasticEase.StartChain(ui);

        protected ElasticEase() { }
    }

    public static partial class ElasticEaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ElasticEase.Oscillations"/></summary>
        public static TView Oscillations<TView>(this TView view, int value) where TView : ElasticEase { view.UI.Oscillations = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ElasticEase.Springiness"/></summary>
        public static TView Springiness<TView>(this TView view, double value) where TView : ElasticEase { view.UI.Springiness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ElasticEase.Oscillations"/></summary>
        public static DependencyProperty<TTarget, int> Oscillations<TTarget>(this TTarget target) where TTarget : ElasticEase
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.Animation.ElasticEase.OscillationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ElasticEase.Springiness"/></summary>
        public static DependencyProperty<TTarget, double> Springiness<TTarget>(this TTarget target) where TTarget : ElasticEase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.ElasticEase.SpringinessProperty);
    }
}

namespace CSharpMarkup.Wpf // ExponentialEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ExponentialEase"/></summary>
        public static ExponentialEase ExponentialEase(O<double> Exponent = default)
        {
            var ui = new Windows.Media.Animation.ExponentialEase();
            if (Exponent.HasValue) ui.Exponent = Exponent.Value;
            return global::CSharpMarkup.Wpf.ExponentialEase.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ExponentialEase"/></summary>
        public static ExponentialEase ExponentialEase()
        {
            var ui = new Windows.Media.Animation.ExponentialEase();
            return global::CSharpMarkup.Wpf.ExponentialEase.StartChain(ui);
        }
    }

    public partial class ExponentialEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.ExponentialEase>
    {
        static ExponentialEase instance;

        internal static ExponentialEase StartChain(Windows.Media.Animation.ExponentialEase ui)
        {
            if (instance == null) instance = new ExponentialEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ExponentialEase ui;

        public new Windows.Media.Animation.ExponentialEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ExponentialEase(ExponentialEase view) => view?.UI;

        public static implicit operator ExponentialEase(Windows.Media.Animation.ExponentialEase ui) => ExponentialEase.StartChain(ui);

        protected ExponentialEase() { }
    }

    public static partial class ExponentialEaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ExponentialEase.Exponent"/></summary>
        public static TView Exponent<TView>(this TView view, double value) where TView : ExponentialEase { view.UI.Exponent = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ExponentialEase.Exponent"/></summary>
        public static DependencyProperty<TTarget, double> Exponent<TTarget>(this TTarget target) where TTarget : ExponentialEase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.ExponentialEase.ExponentProperty);
    }
}

namespace CSharpMarkup.Wpf // Int16Animation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation(O<short?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<short?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<short?> To = default)
        {
            var ui = new Windows.Media.Animation.Int16Animation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation()
        {
            var ui = new Windows.Media.Animation.Int16Animation();
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation(short fromValue, short toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int16Animation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation(short fromValue, short toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int16Animation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation(short toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int16Animation(toValue, duration);
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16Animation"/></summary>
        public static Int16Animation Int16Animation(short toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int16Animation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int16Animation.StartChain(ui);
        }
    }

    public partial class Int16Animation : Int16AnimationBase, IUI<System.Windows.Media.Animation.Int16Animation>
    {
        static Int16Animation instance;

        internal static Int16Animation StartChain(Windows.Media.Animation.Int16Animation ui)
        {
            if (instance == null) instance = new Int16Animation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int16Animation ui;

        public new Windows.Media.Animation.Int16Animation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int16Animation(Int16Animation view) => view?.UI;

        public static implicit operator Int16Animation(Windows.Media.Animation.Int16Animation ui) => Int16Animation.StartChain(ui);

        protected Int16Animation() { }
    }

    public static partial class Int16AnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.By"/></summary>
        public static TView By<TView>(this TView view, short? value) where TView : Int16Animation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Int16Animation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.From"/></summary>
        public static TView From<TView>(this TView view, short? value) where TView : Int16Animation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int16Animation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int16Animation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16Animation.To"/></summary>
        public static TView To<TView>(this TView view, short? value) where TView : Int16Animation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16Animation.By"/></summary>
        public static DependencyProperty<TTarget, short?> By<TTarget>(this TTarget target) where TTarget : Int16Animation
        => DependencyProperty<TTarget, short?>.Get(target, Windows.Media.Animation.Int16Animation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16Animation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Int16Animation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Int16Animation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16Animation.From"/></summary>
        public static DependencyProperty<TTarget, short?> From<TTarget>(this TTarget target) where TTarget : Int16Animation
        => DependencyProperty<TTarget, short?>.Get(target, Windows.Media.Animation.Int16Animation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16Animation.To"/></summary>
        public static DependencyProperty<TTarget, short?> To<TTarget>(this TTarget target) where TTarget : Int16Animation
        => DependencyProperty<TTarget, short?>.Get(target, Windows.Media.Animation.Int16Animation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Int16AnimationBase
{
    public partial class Int16AnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Int16AnimationBase>
    {
        Windows.Media.Animation.Int16AnimationBase ui;

        public new Windows.Media.Animation.Int16AnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int16AnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Int16AnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames"/></summary>
        public static Int16AnimationUsingKeyFrames Int16AnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Int16KeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Int16AnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Int16AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames"/></summary>
        public static Int16AnimationUsingKeyFrames Int16AnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Int16KeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Int16AnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Int16AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames"/></summary>
        public static Int16AnimationUsingKeyFrames Int16AnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Int16AnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Int16AnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Int16AnimationUsingKeyFrames : Int16AnimationBase, IUI<System.Windows.Media.Animation.Int16AnimationUsingKeyFrames>
    {
        static Int16AnimationUsingKeyFrames instance;

        internal static Int16AnimationUsingKeyFrames StartChain(Windows.Media.Animation.Int16AnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Int16AnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int16AnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Int16AnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int16AnimationUsingKeyFrames(Int16AnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Int16AnimationUsingKeyFrames(Windows.Media.Animation.Int16AnimationUsingKeyFrames ui) => Int16AnimationUsingKeyFrames.StartChain(ui);

        protected Int16AnimationUsingKeyFrames() { }
    }

    public static partial class Int16AnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int16AnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int16AnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16AnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Int16KeyFrameCollection value) where TView : Int16AnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Int16KeyFrame
{
    public partial class Int16KeyFrame : Freezable, IUI<System.Windows.Media.Animation.Int16KeyFrame>
    {
        Windows.Media.Animation.Int16KeyFrame ui;

        public new Windows.Media.Animation.Int16KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int16KeyFrame() { }
    }

    public static partial class Int16KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int16KeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Int16KeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int16KeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, short value) where TView : Int16KeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16KeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Int16KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Int16KeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int16KeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, short> Value<TTarget>(this TTarget target) where TTarget : Int16KeyFrame
        => DependencyProperty<TTarget, short>.Get(target, Windows.Media.Animation.Int16KeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Int16KeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int16KeyFrameCollection"/></summary>
        public static Int16KeyFrameCollection Int16KeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Int16KeyFrameCollection();
            return global::CSharpMarkup.Wpf.Int16KeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Int16KeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Int16KeyFrameCollection>
    {
        static Int16KeyFrameCollection instance;

        internal static Int16KeyFrameCollection StartChain(Windows.Media.Animation.Int16KeyFrameCollection ui)
        {
            if (instance == null) instance = new Int16KeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int16KeyFrameCollection ui;

        public new Windows.Media.Animation.Int16KeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int16KeyFrameCollection(Int16KeyFrameCollection view) => view?.UI;

        public static implicit operator Int16KeyFrameCollection(Windows.Media.Animation.Int16KeyFrameCollection ui) => Int16KeyFrameCollection.StartChain(ui);

        protected Int16KeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Int32Animation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation(O<int?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<int?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<int?> To = default)
        {
            var ui = new Windows.Media.Animation.Int32Animation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation()
        {
            var ui = new Windows.Media.Animation.Int32Animation();
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation(int fromValue, int toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int32Animation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation(int fromValue, int toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int32Animation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation(int toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int32Animation(toValue, duration);
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32Animation"/></summary>
        public static Int32Animation Int32Animation(int toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int32Animation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int32Animation.StartChain(ui);
        }
    }

    public partial class Int32Animation : Int32AnimationBase, IUI<System.Windows.Media.Animation.Int32Animation>
    {
        static Int32Animation instance;

        internal static Int32Animation StartChain(Windows.Media.Animation.Int32Animation ui)
        {
            if (instance == null) instance = new Int32Animation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int32Animation ui;

        public new Windows.Media.Animation.Int32Animation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int32Animation(Int32Animation view) => view?.UI;

        public static implicit operator Int32Animation(Windows.Media.Animation.Int32Animation ui) => Int32Animation.StartChain(ui);

        protected Int32Animation() { }
    }

    public static partial class Int32AnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.By"/></summary>
        public static TView By<TView>(this TView view, int? value) where TView : Int32Animation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Int32Animation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.From"/></summary>
        public static TView From<TView>(this TView view, int? value) where TView : Int32Animation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int32Animation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int32Animation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32Animation.To"/></summary>
        public static TView To<TView>(this TView view, int? value) where TView : Int32Animation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32Animation.By"/></summary>
        public static DependencyProperty<TTarget, int?> By<TTarget>(this TTarget target) where TTarget : Int32Animation
        => DependencyProperty<TTarget, int?>.Get(target, Windows.Media.Animation.Int32Animation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32Animation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Int32Animation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Int32Animation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32Animation.From"/></summary>
        public static DependencyProperty<TTarget, int?> From<TTarget>(this TTarget target) where TTarget : Int32Animation
        => DependencyProperty<TTarget, int?>.Get(target, Windows.Media.Animation.Int32Animation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32Animation.To"/></summary>
        public static DependencyProperty<TTarget, int?> To<TTarget>(this TTarget target) where TTarget : Int32Animation
        => DependencyProperty<TTarget, int?>.Get(target, Windows.Media.Animation.Int32Animation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Int32AnimationBase
{
    public partial class Int32AnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Int32AnimationBase>
    {
        Windows.Media.Animation.Int32AnimationBase ui;

        public new Windows.Media.Animation.Int32AnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int32AnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Int32AnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames"/></summary>
        public static Int32AnimationUsingKeyFrames Int32AnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Int32KeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Int32AnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Int32AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames"/></summary>
        public static Int32AnimationUsingKeyFrames Int32AnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Int32KeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Int32AnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Int32AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames"/></summary>
        public static Int32AnimationUsingKeyFrames Int32AnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Int32AnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Int32AnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Int32AnimationUsingKeyFrames : Int32AnimationBase, IUI<System.Windows.Media.Animation.Int32AnimationUsingKeyFrames>
    {
        static Int32AnimationUsingKeyFrames instance;

        internal static Int32AnimationUsingKeyFrames StartChain(Windows.Media.Animation.Int32AnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Int32AnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int32AnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Int32AnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int32AnimationUsingKeyFrames(Int32AnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Int32AnimationUsingKeyFrames(Windows.Media.Animation.Int32AnimationUsingKeyFrames ui) => Int32AnimationUsingKeyFrames.StartChain(ui);

        protected Int32AnimationUsingKeyFrames() { }
    }

    public static partial class Int32AnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int32AnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int32AnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32AnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Int32KeyFrameCollection value) where TView : Int32AnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Int32KeyFrame
{
    public partial class Int32KeyFrame : Freezable, IUI<System.Windows.Media.Animation.Int32KeyFrame>
    {
        Windows.Media.Animation.Int32KeyFrame ui;

        public new Windows.Media.Animation.Int32KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int32KeyFrame() { }
    }

    public static partial class Int32KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int32KeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Int32KeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int32KeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, int value) where TView : Int32KeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32KeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Int32KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Int32KeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int32KeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, int> Value<TTarget>(this TTarget target) where TTarget : Int32KeyFrame
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.Animation.Int32KeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Int32KeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int32KeyFrameCollection"/></summary>
        public static Int32KeyFrameCollection Int32KeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Int32KeyFrameCollection();
            return global::CSharpMarkup.Wpf.Int32KeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Int32KeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Int32KeyFrameCollection>
    {
        static Int32KeyFrameCollection instance;

        internal static Int32KeyFrameCollection StartChain(Windows.Media.Animation.Int32KeyFrameCollection ui)
        {
            if (instance == null) instance = new Int32KeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int32KeyFrameCollection ui;

        public new Windows.Media.Animation.Int32KeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int32KeyFrameCollection(Int32KeyFrameCollection view) => view?.UI;

        public static implicit operator Int32KeyFrameCollection(Windows.Media.Animation.Int32KeyFrameCollection ui) => Int32KeyFrameCollection.StartChain(ui);

        protected Int32KeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Int64Animation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation(O<long?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<long?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<long?> To = default)
        {
            var ui = new Windows.Media.Animation.Int64Animation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation()
        {
            var ui = new Windows.Media.Animation.Int64Animation();
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation(long fromValue, long toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int64Animation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation(long fromValue, long toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int64Animation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation(long toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Int64Animation(toValue, duration);
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64Animation"/></summary>
        public static Int64Animation Int64Animation(long toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Int64Animation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Int64Animation.StartChain(ui);
        }
    }

    public partial class Int64Animation : Int64AnimationBase, IUI<System.Windows.Media.Animation.Int64Animation>
    {
        static Int64Animation instance;

        internal static Int64Animation StartChain(Windows.Media.Animation.Int64Animation ui)
        {
            if (instance == null) instance = new Int64Animation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int64Animation ui;

        public new Windows.Media.Animation.Int64Animation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int64Animation(Int64Animation view) => view?.UI;

        public static implicit operator Int64Animation(Windows.Media.Animation.Int64Animation ui) => Int64Animation.StartChain(ui);

        protected Int64Animation() { }
    }

    public static partial class Int64AnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.By"/></summary>
        public static TView By<TView>(this TView view, long? value) where TView : Int64Animation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Int64Animation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.From"/></summary>
        public static TView From<TView>(this TView view, long? value) where TView : Int64Animation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int64Animation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int64Animation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64Animation.To"/></summary>
        public static TView To<TView>(this TView view, long? value) where TView : Int64Animation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64Animation.By"/></summary>
        public static DependencyProperty<TTarget, long?> By<TTarget>(this TTarget target) where TTarget : Int64Animation
        => DependencyProperty<TTarget, long?>.Get(target, Windows.Media.Animation.Int64Animation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64Animation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Int64Animation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Int64Animation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64Animation.From"/></summary>
        public static DependencyProperty<TTarget, long?> From<TTarget>(this TTarget target) where TTarget : Int64Animation
        => DependencyProperty<TTarget, long?>.Get(target, Windows.Media.Animation.Int64Animation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64Animation.To"/></summary>
        public static DependencyProperty<TTarget, long?> To<TTarget>(this TTarget target) where TTarget : Int64Animation
        => DependencyProperty<TTarget, long?>.Get(target, Windows.Media.Animation.Int64Animation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Int64AnimationBase
{
    public partial class Int64AnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Int64AnimationBase>
    {
        Windows.Media.Animation.Int64AnimationBase ui;

        public new Windows.Media.Animation.Int64AnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int64AnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Int64AnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames"/></summary>
        public static Int64AnimationUsingKeyFrames Int64AnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Int64KeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Int64AnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Int64AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames"/></summary>
        public static Int64AnimationUsingKeyFrames Int64AnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Int64KeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Int64AnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Int64AnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames"/></summary>
        public static Int64AnimationUsingKeyFrames Int64AnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Int64AnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Int64AnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Int64AnimationUsingKeyFrames : Int64AnimationBase, IUI<System.Windows.Media.Animation.Int64AnimationUsingKeyFrames>
    {
        static Int64AnimationUsingKeyFrames instance;

        internal static Int64AnimationUsingKeyFrames StartChain(Windows.Media.Animation.Int64AnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Int64AnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int64AnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Int64AnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int64AnimationUsingKeyFrames(Int64AnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Int64AnimationUsingKeyFrames(Windows.Media.Animation.Int64AnimationUsingKeyFrames ui) => Int64AnimationUsingKeyFrames.StartChain(ui);

        protected Int64AnimationUsingKeyFrames() { }
    }

    public static partial class Int64AnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Int64AnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Int64AnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64AnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Int64KeyFrameCollection value) where TView : Int64AnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Int64KeyFrame
{
    public partial class Int64KeyFrame : Freezable, IUI<System.Windows.Media.Animation.Int64KeyFrame>
    {
        Windows.Media.Animation.Int64KeyFrame ui;

        public new Windows.Media.Animation.Int64KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Int64KeyFrame() { }
    }

    public static partial class Int64KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Int64KeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Int64KeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Int64KeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, long value) where TView : Int64KeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64KeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Int64KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Int64KeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Int64KeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, long> Value<TTarget>(this TTarget target) where TTarget : Int64KeyFrame
        => DependencyProperty<TTarget, long>.Get(target, Windows.Media.Animation.Int64KeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Int64KeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Int64KeyFrameCollection"/></summary>
        public static Int64KeyFrameCollection Int64KeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Int64KeyFrameCollection();
            return global::CSharpMarkup.Wpf.Int64KeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Int64KeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Int64KeyFrameCollection>
    {
        static Int64KeyFrameCollection instance;

        internal static Int64KeyFrameCollection StartChain(Windows.Media.Animation.Int64KeyFrameCollection ui)
        {
            if (instance == null) instance = new Int64KeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Int64KeyFrameCollection ui;

        public new Windows.Media.Animation.Int64KeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Int64KeyFrameCollection(Int64KeyFrameCollection view) => view?.UI;

        public static implicit operator Int64KeyFrameCollection(Windows.Media.Animation.Int64KeyFrameCollection ui) => Int64KeyFrameCollection.StartChain(ui);

        protected Int64KeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // KeySpline
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.KeySpline"/></summary>
        public static KeySpline KeySpline(O<Windows.Point> ControlPoint1 = default, O<Windows.Point> ControlPoint2 = default)
        {
            var ui = new Windows.Media.Animation.KeySpline();
            if (ControlPoint1.HasValue) ui.ControlPoint1 = ControlPoint1.Value;
            if (ControlPoint2.HasValue) ui.ControlPoint2 = ControlPoint2.Value;
            return global::CSharpMarkup.Wpf.KeySpline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.KeySpline"/></summary>
        public static KeySpline KeySpline()
        {
            var ui = new Windows.Media.Animation.KeySpline();
            return global::CSharpMarkup.Wpf.KeySpline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.KeySpline"/></summary>
        public static KeySpline KeySpline(double x1, double y1, double x2, double y2)
        {
            var ui = new Windows.Media.Animation.KeySpline(x1, y1, x2, y2);
            return global::CSharpMarkup.Wpf.KeySpline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.KeySpline"/></summary>
        public static KeySpline KeySpline(Windows.Point controlPoint1, Windows.Point controlPoint2)
        {
            var ui = new Windows.Media.Animation.KeySpline(controlPoint1, controlPoint2);
            return global::CSharpMarkup.Wpf.KeySpline.StartChain(ui);
        }
    }

    public partial class KeySpline : Freezable, IUI<System.Windows.Media.Animation.KeySpline>
    {
        static KeySpline instance;

        internal static KeySpline StartChain(Windows.Media.Animation.KeySpline ui)
        {
            if (instance == null) instance = new KeySpline();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.KeySpline ui;

        public new Windows.Media.Animation.KeySpline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.KeySpline(KeySpline view) => view?.UI;

        public static implicit operator KeySpline(Windows.Media.Animation.KeySpline ui) => KeySpline.StartChain(ui);

        protected KeySpline() { }
    }

    public static partial class KeySplineExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.KeySpline.ControlPoint1"/></summary>
        public static TView ControlPoint1<TView>(this TView view, Windows.Point value) where TView : KeySpline { view.UI.ControlPoint1 = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.KeySpline.ControlPoint2"/></summary>
        public static TView ControlPoint2<TView>(this TView view, Windows.Point value) where TView : KeySpline { view.UI.ControlPoint2 = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // LinearByteKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearByteKeyFrame"/></summary>
        public static LinearByteKeyFrame LinearByteKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearByteKeyFrame();
            return global::CSharpMarkup.Wpf.LinearByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearByteKeyFrame"/></summary>
        public static LinearByteKeyFrame LinearByteKeyFrame(byte value)
        {
            var ui = new Windows.Media.Animation.LinearByteKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearByteKeyFrame"/></summary>
        public static LinearByteKeyFrame LinearByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearByteKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearByteKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearByteKeyFrame : ByteKeyFrame, IUI<System.Windows.Media.Animation.LinearByteKeyFrame>
    {
        static LinearByteKeyFrame instance;

        internal static LinearByteKeyFrame StartChain(Windows.Media.Animation.LinearByteKeyFrame ui)
        {
            if (instance == null) instance = new LinearByteKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearByteKeyFrame ui;

        public new Windows.Media.Animation.LinearByteKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearByteKeyFrame(LinearByteKeyFrame view) => view?.UI;

        public static implicit operator LinearByteKeyFrame(Windows.Media.Animation.LinearByteKeyFrame ui) => LinearByteKeyFrame.StartChain(ui);

        protected LinearByteKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearColorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearColorKeyFrame"/></summary>
        public static LinearColorKeyFrame LinearColorKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearColorKeyFrame();
            return global::CSharpMarkup.Wpf.LinearColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearColorKeyFrame"/></summary>
        public static LinearColorKeyFrame LinearColorKeyFrame(Color value)
        {
            var ui = new Windows.Media.Animation.LinearColorKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearColorKeyFrame"/></summary>
        public static LinearColorKeyFrame LinearColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearColorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearColorKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearColorKeyFrame : ColorKeyFrame, IUI<System.Windows.Media.Animation.LinearColorKeyFrame>
    {
        static LinearColorKeyFrame instance;

        internal static LinearColorKeyFrame StartChain(Windows.Media.Animation.LinearColorKeyFrame ui)
        {
            if (instance == null) instance = new LinearColorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearColorKeyFrame ui;

        public new Windows.Media.Animation.LinearColorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearColorKeyFrame(LinearColorKeyFrame view) => view?.UI;

        public static implicit operator LinearColorKeyFrame(Windows.Media.Animation.LinearColorKeyFrame ui) => LinearColorKeyFrame.StartChain(ui);

        protected LinearColorKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearDecimalKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDecimalKeyFrame"/></summary>
        public static LinearDecimalKeyFrame LinearDecimalKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearDecimalKeyFrame();
            return global::CSharpMarkup.Wpf.LinearDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDecimalKeyFrame"/></summary>
        public static LinearDecimalKeyFrame LinearDecimalKeyFrame(decimal value)
        {
            var ui = new Windows.Media.Animation.LinearDecimalKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDecimalKeyFrame"/></summary>
        public static LinearDecimalKeyFrame LinearDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearDecimalKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearDecimalKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearDecimalKeyFrame : DecimalKeyFrame, IUI<System.Windows.Media.Animation.LinearDecimalKeyFrame>
    {
        static LinearDecimalKeyFrame instance;

        internal static LinearDecimalKeyFrame StartChain(Windows.Media.Animation.LinearDecimalKeyFrame ui)
        {
            if (instance == null) instance = new LinearDecimalKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearDecimalKeyFrame ui;

        public new Windows.Media.Animation.LinearDecimalKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearDecimalKeyFrame(LinearDecimalKeyFrame view) => view?.UI;

        public static implicit operator LinearDecimalKeyFrame(Windows.Media.Animation.LinearDecimalKeyFrame ui) => LinearDecimalKeyFrame.StartChain(ui);

        protected LinearDecimalKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearDoubleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDoubleKeyFrame"/></summary>
        public static LinearDoubleKeyFrame LinearDoubleKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearDoubleKeyFrame();
            return global::CSharpMarkup.Wpf.LinearDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDoubleKeyFrame"/></summary>
        public static LinearDoubleKeyFrame LinearDoubleKeyFrame(double value)
        {
            var ui = new Windows.Media.Animation.LinearDoubleKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearDoubleKeyFrame"/></summary>
        public static LinearDoubleKeyFrame LinearDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearDoubleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearDoubleKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearDoubleKeyFrame : DoubleKeyFrame, IUI<System.Windows.Media.Animation.LinearDoubleKeyFrame>
    {
        static LinearDoubleKeyFrame instance;

        internal static LinearDoubleKeyFrame StartChain(Windows.Media.Animation.LinearDoubleKeyFrame ui)
        {
            if (instance == null) instance = new LinearDoubleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearDoubleKeyFrame ui;

        public new Windows.Media.Animation.LinearDoubleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearDoubleKeyFrame(LinearDoubleKeyFrame view) => view?.UI;

        public static implicit operator LinearDoubleKeyFrame(Windows.Media.Animation.LinearDoubleKeyFrame ui) => LinearDoubleKeyFrame.StartChain(ui);

        protected LinearDoubleKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearInt16KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt16KeyFrame"/></summary>
        public static LinearInt16KeyFrame LinearInt16KeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearInt16KeyFrame();
            return global::CSharpMarkup.Wpf.LinearInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt16KeyFrame"/></summary>
        public static LinearInt16KeyFrame LinearInt16KeyFrame(short value)
        {
            var ui = new Windows.Media.Animation.LinearInt16KeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt16KeyFrame"/></summary>
        public static LinearInt16KeyFrame LinearInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearInt16KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearInt16KeyFrame.StartChain(ui);
        }
    }

    public partial class LinearInt16KeyFrame : Int16KeyFrame, IUI<System.Windows.Media.Animation.LinearInt16KeyFrame>
    {
        static LinearInt16KeyFrame instance;

        internal static LinearInt16KeyFrame StartChain(Windows.Media.Animation.LinearInt16KeyFrame ui)
        {
            if (instance == null) instance = new LinearInt16KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearInt16KeyFrame ui;

        public new Windows.Media.Animation.LinearInt16KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearInt16KeyFrame(LinearInt16KeyFrame view) => view?.UI;

        public static implicit operator LinearInt16KeyFrame(Windows.Media.Animation.LinearInt16KeyFrame ui) => LinearInt16KeyFrame.StartChain(ui);

        protected LinearInt16KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearInt32KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt32KeyFrame"/></summary>
        public static LinearInt32KeyFrame LinearInt32KeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearInt32KeyFrame();
            return global::CSharpMarkup.Wpf.LinearInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt32KeyFrame"/></summary>
        public static LinearInt32KeyFrame LinearInt32KeyFrame(int value)
        {
            var ui = new Windows.Media.Animation.LinearInt32KeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt32KeyFrame"/></summary>
        public static LinearInt32KeyFrame LinearInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearInt32KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearInt32KeyFrame.StartChain(ui);
        }
    }

    public partial class LinearInt32KeyFrame : Int32KeyFrame, IUI<System.Windows.Media.Animation.LinearInt32KeyFrame>
    {
        static LinearInt32KeyFrame instance;

        internal static LinearInt32KeyFrame StartChain(Windows.Media.Animation.LinearInt32KeyFrame ui)
        {
            if (instance == null) instance = new LinearInt32KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearInt32KeyFrame ui;

        public new Windows.Media.Animation.LinearInt32KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearInt32KeyFrame(LinearInt32KeyFrame view) => view?.UI;

        public static implicit operator LinearInt32KeyFrame(Windows.Media.Animation.LinearInt32KeyFrame ui) => LinearInt32KeyFrame.StartChain(ui);

        protected LinearInt32KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearInt64KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt64KeyFrame"/></summary>
        public static LinearInt64KeyFrame LinearInt64KeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearInt64KeyFrame();
            return global::CSharpMarkup.Wpf.LinearInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt64KeyFrame"/></summary>
        public static LinearInt64KeyFrame LinearInt64KeyFrame(long value)
        {
            var ui = new Windows.Media.Animation.LinearInt64KeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearInt64KeyFrame"/></summary>
        public static LinearInt64KeyFrame LinearInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearInt64KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearInt64KeyFrame.StartChain(ui);
        }
    }

    public partial class LinearInt64KeyFrame : Int64KeyFrame, IUI<System.Windows.Media.Animation.LinearInt64KeyFrame>
    {
        static LinearInt64KeyFrame instance;

        internal static LinearInt64KeyFrame StartChain(Windows.Media.Animation.LinearInt64KeyFrame ui)
        {
            if (instance == null) instance = new LinearInt64KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearInt64KeyFrame ui;

        public new Windows.Media.Animation.LinearInt64KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearInt64KeyFrame(LinearInt64KeyFrame view) => view?.UI;

        public static implicit operator LinearInt64KeyFrame(Windows.Media.Animation.LinearInt64KeyFrame ui) => LinearInt64KeyFrame.StartChain(ui);

        protected LinearInt64KeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearPoint3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPoint3DKeyFrame"/></summary>
        public static LinearPoint3DKeyFrame LinearPoint3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearPoint3DKeyFrame();
            return global::CSharpMarkup.Wpf.LinearPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPoint3DKeyFrame"/></summary>
        public static LinearPoint3DKeyFrame LinearPoint3DKeyFrame(Windows.Media.Media3D.Point3D value)
        {
            var ui = new Windows.Media.Animation.LinearPoint3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearPoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPoint3DKeyFrame"/></summary>
        public static LinearPoint3DKeyFrame LinearPoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearPoint3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearPoint3DKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearPoint3DKeyFrame : Point3DKeyFrame, IUI<System.Windows.Media.Animation.LinearPoint3DKeyFrame>
    {
        static LinearPoint3DKeyFrame instance;

        internal static LinearPoint3DKeyFrame StartChain(Windows.Media.Animation.LinearPoint3DKeyFrame ui)
        {
            if (instance == null) instance = new LinearPoint3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearPoint3DKeyFrame ui;

        public new Windows.Media.Animation.LinearPoint3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearPoint3DKeyFrame(LinearPoint3DKeyFrame view) => view?.UI;

        public static implicit operator LinearPoint3DKeyFrame(Windows.Media.Animation.LinearPoint3DKeyFrame ui) => LinearPoint3DKeyFrame.StartChain(ui);

        protected LinearPoint3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearPointKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPointKeyFrame"/></summary>
        public static LinearPointKeyFrame LinearPointKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearPointKeyFrame();
            return global::CSharpMarkup.Wpf.LinearPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPointKeyFrame"/></summary>
        public static LinearPointKeyFrame LinearPointKeyFrame(Windows.Point value)
        {
            var ui = new Windows.Media.Animation.LinearPointKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearPointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearPointKeyFrame"/></summary>
        public static LinearPointKeyFrame LinearPointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearPointKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearPointKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearPointKeyFrame : PointKeyFrame, IUI<System.Windows.Media.Animation.LinearPointKeyFrame>
    {
        static LinearPointKeyFrame instance;

        internal static LinearPointKeyFrame StartChain(Windows.Media.Animation.LinearPointKeyFrame ui)
        {
            if (instance == null) instance = new LinearPointKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearPointKeyFrame ui;

        public new Windows.Media.Animation.LinearPointKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearPointKeyFrame(LinearPointKeyFrame view) => view?.UI;

        public static implicit operator LinearPointKeyFrame(Windows.Media.Animation.LinearPointKeyFrame ui) => LinearPointKeyFrame.StartChain(ui);

        protected LinearPointKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearQuaternionKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame"/></summary>
        public static LinearQuaternionKeyFrame LinearQuaternionKeyFrame(O<bool> UseShortestPath = default)
        {
            var ui = new Windows.Media.Animation.LinearQuaternionKeyFrame();
            if (UseShortestPath.HasValue) ui.UseShortestPath = UseShortestPath.Value;
            return global::CSharpMarkup.Wpf.LinearQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame"/></summary>
        public static LinearQuaternionKeyFrame LinearQuaternionKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearQuaternionKeyFrame();
            return global::CSharpMarkup.Wpf.LinearQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame"/></summary>
        public static LinearQuaternionKeyFrame LinearQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value)
        {
            var ui = new Windows.Media.Animation.LinearQuaternionKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame"/></summary>
        public static LinearQuaternionKeyFrame LinearQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearQuaternionKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearQuaternionKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearQuaternionKeyFrame : QuaternionKeyFrame, IUI<System.Windows.Media.Animation.LinearQuaternionKeyFrame>
    {
        static LinearQuaternionKeyFrame instance;

        internal static LinearQuaternionKeyFrame StartChain(Windows.Media.Animation.LinearQuaternionKeyFrame ui)
        {
            if (instance == null) instance = new LinearQuaternionKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearQuaternionKeyFrame ui;

        public new Windows.Media.Animation.LinearQuaternionKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearQuaternionKeyFrame(LinearQuaternionKeyFrame view) => view?.UI;

        public static implicit operator LinearQuaternionKeyFrame(Windows.Media.Animation.LinearQuaternionKeyFrame ui) => LinearQuaternionKeyFrame.StartChain(ui);

        protected LinearQuaternionKeyFrame() { }
    }

    public static partial class LinearQuaternionKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame.UseShortestPath"/></summary>
        public static TView UseShortestPath<TView>(this TView view, bool value) where TView : LinearQuaternionKeyFrame { view.UI.UseShortestPath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.LinearQuaternionKeyFrame.UseShortestPath"/></summary>
        public static DependencyProperty<TTarget, bool> UseShortestPath<TTarget>(this TTarget target) where TTarget : LinearQuaternionKeyFrame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.LinearQuaternionKeyFrame.UseShortestPathProperty);
    }
}

namespace CSharpMarkup.Wpf // LinearRectKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRectKeyFrame"/></summary>
        public static LinearRectKeyFrame LinearRectKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearRectKeyFrame();
            return global::CSharpMarkup.Wpf.LinearRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRectKeyFrame"/></summary>
        public static LinearRectKeyFrame LinearRectKeyFrame(Windows.Rect value)
        {
            var ui = new Windows.Media.Animation.LinearRectKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRectKeyFrame"/></summary>
        public static LinearRectKeyFrame LinearRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearRectKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearRectKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearRectKeyFrame : RectKeyFrame, IUI<System.Windows.Media.Animation.LinearRectKeyFrame>
    {
        static LinearRectKeyFrame instance;

        internal static LinearRectKeyFrame StartChain(Windows.Media.Animation.LinearRectKeyFrame ui)
        {
            if (instance == null) instance = new LinearRectKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearRectKeyFrame ui;

        public new Windows.Media.Animation.LinearRectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearRectKeyFrame(LinearRectKeyFrame view) => view?.UI;

        public static implicit operator LinearRectKeyFrame(Windows.Media.Animation.LinearRectKeyFrame ui) => LinearRectKeyFrame.StartChain(ui);

        protected LinearRectKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearRotation3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRotation3DKeyFrame"/></summary>
        public static LinearRotation3DKeyFrame LinearRotation3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearRotation3DKeyFrame();
            return global::CSharpMarkup.Wpf.LinearRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRotation3DKeyFrame"/></summary>
        public static LinearRotation3DKeyFrame LinearRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value)
        {
            var ui = new Windows.Media.Animation.LinearRotation3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearRotation3DKeyFrame"/></summary>
        public static LinearRotation3DKeyFrame LinearRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearRotation3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearRotation3DKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearRotation3DKeyFrame : Rotation3DKeyFrame, IUI<System.Windows.Media.Animation.LinearRotation3DKeyFrame>
    {
        static LinearRotation3DKeyFrame instance;

        internal static LinearRotation3DKeyFrame StartChain(Windows.Media.Animation.LinearRotation3DKeyFrame ui)
        {
            if (instance == null) instance = new LinearRotation3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearRotation3DKeyFrame ui;

        public new Windows.Media.Animation.LinearRotation3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearRotation3DKeyFrame(LinearRotation3DKeyFrame view) => view?.UI;

        public static implicit operator LinearRotation3DKeyFrame(Windows.Media.Animation.LinearRotation3DKeyFrame ui) => LinearRotation3DKeyFrame.StartChain(ui);

        protected LinearRotation3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearSingleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSingleKeyFrame"/></summary>
        public static LinearSingleKeyFrame LinearSingleKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearSingleKeyFrame();
            return global::CSharpMarkup.Wpf.LinearSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSingleKeyFrame"/></summary>
        public static LinearSingleKeyFrame LinearSingleKeyFrame(float value)
        {
            var ui = new Windows.Media.Animation.LinearSingleKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSingleKeyFrame"/></summary>
        public static LinearSingleKeyFrame LinearSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearSingleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearSingleKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearSingleKeyFrame : SingleKeyFrame, IUI<System.Windows.Media.Animation.LinearSingleKeyFrame>
    {
        static LinearSingleKeyFrame instance;

        internal static LinearSingleKeyFrame StartChain(Windows.Media.Animation.LinearSingleKeyFrame ui)
        {
            if (instance == null) instance = new LinearSingleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearSingleKeyFrame ui;

        public new Windows.Media.Animation.LinearSingleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearSingleKeyFrame(LinearSingleKeyFrame view) => view?.UI;

        public static implicit operator LinearSingleKeyFrame(Windows.Media.Animation.LinearSingleKeyFrame ui) => LinearSingleKeyFrame.StartChain(ui);

        protected LinearSingleKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearSizeKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSizeKeyFrame"/></summary>
        public static LinearSizeKeyFrame LinearSizeKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearSizeKeyFrame();
            return global::CSharpMarkup.Wpf.LinearSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSizeKeyFrame"/></summary>
        public static LinearSizeKeyFrame LinearSizeKeyFrame(Windows.Size value)
        {
            var ui = new Windows.Media.Animation.LinearSizeKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearSizeKeyFrame"/></summary>
        public static LinearSizeKeyFrame LinearSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearSizeKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearSizeKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearSizeKeyFrame : SizeKeyFrame, IUI<System.Windows.Media.Animation.LinearSizeKeyFrame>
    {
        static LinearSizeKeyFrame instance;

        internal static LinearSizeKeyFrame StartChain(Windows.Media.Animation.LinearSizeKeyFrame ui)
        {
            if (instance == null) instance = new LinearSizeKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearSizeKeyFrame ui;

        public new Windows.Media.Animation.LinearSizeKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearSizeKeyFrame(LinearSizeKeyFrame view) => view?.UI;

        public static implicit operator LinearSizeKeyFrame(Windows.Media.Animation.LinearSizeKeyFrame ui) => LinearSizeKeyFrame.StartChain(ui);

        protected LinearSizeKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearVector3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVector3DKeyFrame"/></summary>
        public static LinearVector3DKeyFrame LinearVector3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearVector3DKeyFrame();
            return global::CSharpMarkup.Wpf.LinearVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVector3DKeyFrame"/></summary>
        public static LinearVector3DKeyFrame LinearVector3DKeyFrame(Windows.Media.Media3D.Vector3D value)
        {
            var ui = new Windows.Media.Animation.LinearVector3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVector3DKeyFrame"/></summary>
        public static LinearVector3DKeyFrame LinearVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearVector3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearVector3DKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearVector3DKeyFrame : Vector3DKeyFrame, IUI<System.Windows.Media.Animation.LinearVector3DKeyFrame>
    {
        static LinearVector3DKeyFrame instance;

        internal static LinearVector3DKeyFrame StartChain(Windows.Media.Animation.LinearVector3DKeyFrame ui)
        {
            if (instance == null) instance = new LinearVector3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearVector3DKeyFrame ui;

        public new Windows.Media.Animation.LinearVector3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearVector3DKeyFrame(LinearVector3DKeyFrame view) => view?.UI;

        public static implicit operator LinearVector3DKeyFrame(Windows.Media.Animation.LinearVector3DKeyFrame ui) => LinearVector3DKeyFrame.StartChain(ui);

        protected LinearVector3DKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // LinearVectorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVectorKeyFrame"/></summary>
        public static LinearVectorKeyFrame LinearVectorKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearVectorKeyFrame();
            return global::CSharpMarkup.Wpf.LinearVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVectorKeyFrame"/></summary>
        public static LinearVectorKeyFrame LinearVectorKeyFrame(Windows.Vector value)
        {
            var ui = new Windows.Media.Animation.LinearVectorKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearVectorKeyFrame"/></summary>
        public static LinearVectorKeyFrame LinearVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearVectorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearVectorKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearVectorKeyFrame : VectorKeyFrame, IUI<System.Windows.Media.Animation.LinearVectorKeyFrame>
    {
        static LinearVectorKeyFrame instance;

        internal static LinearVectorKeyFrame StartChain(Windows.Media.Animation.LinearVectorKeyFrame ui)
        {
            if (instance == null) instance = new LinearVectorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearVectorKeyFrame ui;

        public new Windows.Media.Animation.LinearVectorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearVectorKeyFrame(LinearVectorKeyFrame view) => view?.UI;

        public static implicit operator LinearVectorKeyFrame(Windows.Media.Animation.LinearVectorKeyFrame ui) => LinearVectorKeyFrame.StartChain(ui);

        protected LinearVectorKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // MatrixAnimationBase
{
    public partial class MatrixAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.MatrixAnimationBase>
    {
        Windows.Media.Animation.MatrixAnimationBase ui;

        public new Windows.Media.Animation.MatrixAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected MatrixAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // MatrixAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixAnimationUsingKeyFrames"/></summary>
        public static MatrixAnimationUsingKeyFrames MatrixAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.MatrixKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.MatrixAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.MatrixAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixAnimationUsingKeyFrames"/></summary>
        public static MatrixAnimationUsingKeyFrames MatrixAnimationUsingKeyFrames(O<Windows.Media.Animation.MatrixKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.MatrixAnimationUsingKeyFrames();
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.MatrixAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixAnimationUsingKeyFrames"/></summary>
        public static MatrixAnimationUsingKeyFrames MatrixAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.MatrixAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.MatrixAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class MatrixAnimationUsingKeyFrames : MatrixAnimationBase, IUI<System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames>
    {
        static MatrixAnimationUsingKeyFrames instance;

        internal static MatrixAnimationUsingKeyFrames StartChain(Windows.Media.Animation.MatrixAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new MatrixAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.MatrixAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.MatrixAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.MatrixAnimationUsingKeyFrames(MatrixAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator MatrixAnimationUsingKeyFrames(Windows.Media.Animation.MatrixAnimationUsingKeyFrames ui) => MatrixAnimationUsingKeyFrames.StartChain(ui);

        protected MatrixAnimationUsingKeyFrames() { }
    }

    public static partial class MatrixAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.MatrixKeyFrameCollection value) where TView : MatrixAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // MatrixAnimationUsingPath
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixAnimationUsingPath"/></summary>
        public static MatrixAnimationUsingPath MatrixAnimationUsingPath(O<bool> DoesRotateWithTangent = default, O<bool> IsAdditive = default, O<bool> IsAngleCumulative = default, O<bool> IsOffsetCumulative = default, O<Windows.Media.PathGeometry> PathGeometry = default)
        {
            var ui = new Windows.Media.Animation.MatrixAnimationUsingPath();
            if (DoesRotateWithTangent.HasValue) ui.DoesRotateWithTangent = DoesRotateWithTangent.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsAngleCumulative.HasValue) ui.IsAngleCumulative = IsAngleCumulative.Value;
            if (IsOffsetCumulative.HasValue) ui.IsOffsetCumulative = IsOffsetCumulative.Value;
            if (PathGeometry.HasValue) ui.PathGeometry = PathGeometry.Value;
            return global::CSharpMarkup.Wpf.MatrixAnimationUsingPath.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixAnimationUsingPath"/></summary>
        public static MatrixAnimationUsingPath MatrixAnimationUsingPath()
        {
            var ui = new Windows.Media.Animation.MatrixAnimationUsingPath();
            return global::CSharpMarkup.Wpf.MatrixAnimationUsingPath.StartChain(ui);
        }
    }

    public partial class MatrixAnimationUsingPath : MatrixAnimationBase, IUI<System.Windows.Media.Animation.MatrixAnimationUsingPath>
    {
        static MatrixAnimationUsingPath instance;

        internal static MatrixAnimationUsingPath StartChain(Windows.Media.Animation.MatrixAnimationUsingPath ui)
        {
            if (instance == null) instance = new MatrixAnimationUsingPath();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.MatrixAnimationUsingPath ui;

        public new Windows.Media.Animation.MatrixAnimationUsingPath UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.MatrixAnimationUsingPath(MatrixAnimationUsingPath view) => view?.UI;

        public static implicit operator MatrixAnimationUsingPath(Windows.Media.Animation.MatrixAnimationUsingPath ui) => MatrixAnimationUsingPath.StartChain(ui);

        protected MatrixAnimationUsingPath() { }
    }

    public static partial class MatrixAnimationUsingPathExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.DoesRotateWithTangent"/></summary>
        public static TView DoesRotateWithTangent<TView>(this TView view, bool value) where TView : MatrixAnimationUsingPath { view.UI.DoesRotateWithTangent = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : MatrixAnimationUsingPath { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.IsAngleCumulative"/></summary>
        public static TView IsAngleCumulative<TView>(this TView view, bool value) where TView : MatrixAnimationUsingPath { view.UI.IsAngleCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.IsOffsetCumulative"/></summary>
        public static TView IsOffsetCumulative<TView>(this TView view, bool value) where TView : MatrixAnimationUsingPath { view.UI.IsOffsetCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.PathGeometry"/></summary>
        public static TView PathGeometry<TView>(this TView view, Windows.Media.PathGeometry value) where TView : MatrixAnimationUsingPath { view.UI.PathGeometry = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.DoesRotateWithTangent"/></summary>
        public static DependencyProperty<TTarget, bool> DoesRotateWithTangent<TTarget>(this TTarget target) where TTarget : MatrixAnimationUsingPath
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.MatrixAnimationUsingPath.DoesRotateWithTangentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.IsAngleCumulative"/></summary>
        public static DependencyProperty<TTarget, bool> IsAngleCumulative<TTarget>(this TTarget target) where TTarget : MatrixAnimationUsingPath
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.MatrixAnimationUsingPath.IsAngleCumulativeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.IsOffsetCumulative"/></summary>
        public static DependencyProperty<TTarget, bool> IsOffsetCumulative<TTarget>(this TTarget target) where TTarget : MatrixAnimationUsingPath
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.MatrixAnimationUsingPath.IsOffsetCumulativeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixAnimationUsingPath.PathGeometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PathGeometry> PathGeometry<TTarget>(this TTarget target) where TTarget : MatrixAnimationUsingPath
        => DependencyProperty<TTarget, Windows.Media.PathGeometry>.Get(target, Windows.Media.Animation.MatrixAnimationUsingPath.PathGeometryProperty);
    }
}

namespace CSharpMarkup.Wpf // MatrixKeyFrame
{
    public partial class MatrixKeyFrame : Freezable, IUI<System.Windows.Media.Animation.MatrixKeyFrame>
    {
        Windows.Media.Animation.MatrixKeyFrame ui;

        public new Windows.Media.Animation.MatrixKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected MatrixKeyFrame() { }
    }

    public static partial class MatrixKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.MatrixKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : MatrixKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.MatrixKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Media.Matrix value) where TView : MatrixKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : MatrixKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.MatrixKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.MatrixKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Matrix> Value<TTarget>(this TTarget target) where TTarget : MatrixKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Matrix>.Get(target, Windows.Media.Animation.MatrixKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // MatrixKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.MatrixKeyFrameCollection"/></summary>
        public static MatrixKeyFrameCollection MatrixKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.MatrixKeyFrameCollection();
            return global::CSharpMarkup.Wpf.MatrixKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class MatrixKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.MatrixKeyFrameCollection>
    {
        static MatrixKeyFrameCollection instance;

        internal static MatrixKeyFrameCollection StartChain(Windows.Media.Animation.MatrixKeyFrameCollection ui)
        {
            if (instance == null) instance = new MatrixKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.MatrixKeyFrameCollection ui;

        public new Windows.Media.Animation.MatrixKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.MatrixKeyFrameCollection(MatrixKeyFrameCollection view) => view?.UI;

        public static implicit operator MatrixKeyFrameCollection(Windows.Media.Animation.MatrixKeyFrameCollection ui) => MatrixKeyFrameCollection.StartChain(ui);

        protected MatrixKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // ObjectAnimationBase
{
    public partial class ObjectAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.ObjectAnimationBase>
    {
        Windows.Media.Animation.ObjectAnimationBase ui;

        public new Windows.Media.Animation.ObjectAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ObjectAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // ObjectAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ObjectAnimationUsingKeyFrames"/></summary>
        public static ObjectAnimationUsingKeyFrames ObjectAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.ObjectKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.ObjectAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.ObjectAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ObjectAnimationUsingKeyFrames"/></summary>
        public static ObjectAnimationUsingKeyFrames ObjectAnimationUsingKeyFrames(O<Windows.Media.Animation.ObjectKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.ObjectAnimationUsingKeyFrames();
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.ObjectAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ObjectAnimationUsingKeyFrames"/></summary>
        public static ObjectAnimationUsingKeyFrames ObjectAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.ObjectAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.ObjectAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class ObjectAnimationUsingKeyFrames : ObjectAnimationBase, IUI<System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames>
    {
        static ObjectAnimationUsingKeyFrames instance;

        internal static ObjectAnimationUsingKeyFrames StartChain(Windows.Media.Animation.ObjectAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new ObjectAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ObjectAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.ObjectAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ObjectAnimationUsingKeyFrames(ObjectAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator ObjectAnimationUsingKeyFrames(Windows.Media.Animation.ObjectAnimationUsingKeyFrames ui) => ObjectAnimationUsingKeyFrames.StartChain(ui);

        protected ObjectAnimationUsingKeyFrames() { }
    }

    public static partial class ObjectAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ObjectAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.ObjectKeyFrameCollection value) where TView : ObjectAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // ObjectKeyFrame
{
    public partial class ObjectKeyFrame : Freezable, IUI<System.Windows.Media.Animation.ObjectKeyFrame>
    {
        Windows.Media.Animation.ObjectKeyFrame ui;

        public new Windows.Media.Animation.ObjectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ObjectKeyFrame() { }
    }

    public static partial class ObjectKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ObjectKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : ObjectKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ObjectKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, object value) where TView : ObjectKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ObjectKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : ObjectKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.ObjectKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ObjectKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, object> Value<TTarget>(this TTarget target) where TTarget : ObjectKeyFrame
        => DependencyProperty<TTarget, object>.Get(target, Windows.Media.Animation.ObjectKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // ObjectKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ObjectKeyFrameCollection"/></summary>
        public static ObjectKeyFrameCollection ObjectKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.ObjectKeyFrameCollection();
            return global::CSharpMarkup.Wpf.ObjectKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class ObjectKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.ObjectKeyFrameCollection>
    {
        static ObjectKeyFrameCollection instance;

        internal static ObjectKeyFrameCollection StartChain(Windows.Media.Animation.ObjectKeyFrameCollection ui)
        {
            if (instance == null) instance = new ObjectKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ObjectKeyFrameCollection ui;

        public new Windows.Media.Animation.ObjectKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ObjectKeyFrameCollection(ObjectKeyFrameCollection view) => view?.UI;

        public static implicit operator ObjectKeyFrameCollection(Windows.Media.Animation.ObjectKeyFrameCollection ui) => ObjectKeyFrameCollection.StartChain(ui);

        protected ObjectKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // ParallelTimeline
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline(
            params System.Windows.Media.Animation.Timeline[] Children
)
        {
            var ui = new Windows.Media.Animation.ParallelTimeline();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline(O<Windows.Media.Animation.SlipBehavior> SlipBehavior = default)
        {
            var ui = new Windows.Media.Animation.ParallelTimeline();
            if (SlipBehavior.HasValue) ui.SlipBehavior = SlipBehavior.Value;
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline()
        {
            var ui = new Windows.Media.Animation.ParallelTimeline();
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline(TimeSpan? beginTime)
        {
            var ui = new Windows.Media.Animation.ParallelTimeline(beginTime);
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline(TimeSpan? beginTime, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ParallelTimeline(beginTime, duration);
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ParallelTimeline"/></summary>
        public static ParallelTimeline ParallelTimeline(TimeSpan? beginTime, Windows.Duration duration, Windows.Media.Animation.RepeatBehavior repeatBehavior)
        {
            var ui = new Windows.Media.Animation.ParallelTimeline(beginTime, duration, repeatBehavior);
            return global::CSharpMarkup.Wpf.ParallelTimeline.StartChain(ui);
        }
    }

    public partial class ParallelTimeline : TimelineGroup, IUI<System.Windows.Media.Animation.ParallelTimeline>
    {
        static ParallelTimeline instance;

        internal static ParallelTimeline StartChain(Windows.Media.Animation.ParallelTimeline ui)
        {
            if (instance == null) instance = new ParallelTimeline();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ParallelTimeline ui;

        public new Windows.Media.Animation.ParallelTimeline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ParallelTimeline(ParallelTimeline view) => view?.UI;

        public static implicit operator ParallelTimeline(Windows.Media.Animation.ParallelTimeline ui) => ParallelTimeline.StartChain(ui);

        protected ParallelTimeline() { }
    }

    public static partial class ParallelTimelineExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ParallelTimeline.SlipBehavior"/></summary>
        public static TView SlipBehavior<TView>(this TView view, Windows.Media.Animation.SlipBehavior value) where TView : ParallelTimeline { view.UI.SlipBehavior = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ParallelTimeline.SlipBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.SlipBehavior> SlipBehavior<TTarget>(this TTarget target) where TTarget : ParallelTimeline
        => DependencyProperty<TTarget, Windows.Media.Animation.SlipBehavior>.Get(target, Windows.Media.Animation.ParallelTimeline.SlipBehaviorProperty);
    }
}

namespace CSharpMarkup.Wpf // Point3DAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation(O<Windows.Media.Media3D.Point3D?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Media.Media3D.Point3D?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Media3D.Point3D?> To = default)
        {
            var ui = new Windows.Media.Animation.Point3DAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation()
        {
            var ui = new Windows.Media.Animation.Point3DAnimation();
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation(Windows.Media.Media3D.Point3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Point3DAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation(Windows.Media.Media3D.Point3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Point3DAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation(Windows.Media.Media3D.Point3D fromValue, Windows.Media.Media3D.Point3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Point3DAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimation"/></summary>
        public static Point3DAnimation Point3DAnimation(Windows.Media.Media3D.Point3D fromValue, Windows.Media.Media3D.Point3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Point3DAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Point3DAnimation.StartChain(ui);
        }
    }

    public partial class Point3DAnimation : Point3DAnimationBase, IUI<System.Windows.Media.Animation.Point3DAnimation>
    {
        static Point3DAnimation instance;

        internal static Point3DAnimation StartChain(Windows.Media.Animation.Point3DAnimation ui)
        {
            if (instance == null) instance = new Point3DAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Point3DAnimation ui;

        public new Windows.Media.Animation.Point3DAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Point3DAnimation(Point3DAnimation view) => view?.UI;

        public static implicit operator Point3DAnimation(Windows.Media.Animation.Point3DAnimation ui) => Point3DAnimation.StartChain(ui);

        protected Point3DAnimation() { }
    }

    public static partial class Point3DAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Media.Media3D.Point3D? value) where TView : Point3DAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Point3DAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Media.Media3D.Point3D? value) where TView : Point3DAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Point3DAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Point3DAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Media.Media3D.Point3D? value) where TView : Point3DAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?> By<TTarget>(this TTarget target) where TTarget : Point3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?>.Get(target, Windows.Media.Animation.Point3DAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Point3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Point3DAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?> From<TTarget>(this TTarget target) where TTarget : Point3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?>.Get(target, Windows.Media.Animation.Point3DAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?> To<TTarget>(this TTarget target) where TTarget : Point3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D?>.Get(target, Windows.Media.Animation.Point3DAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Point3DAnimationBase
{
    public partial class Point3DAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Point3DAnimationBase>
    {
        Windows.Media.Animation.Point3DAnimationBase ui;

        public new Windows.Media.Animation.Point3DAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Point3DAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Point3DAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames"/></summary>
        public static Point3DAnimationUsingKeyFrames Point3DAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Point3DKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Point3DAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Point3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames"/></summary>
        public static Point3DAnimationUsingKeyFrames Point3DAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Point3DKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Point3DAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Point3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames"/></summary>
        public static Point3DAnimationUsingKeyFrames Point3DAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Point3DAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Point3DAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Point3DAnimationUsingKeyFrames : Point3DAnimationBase, IUI<System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames>
    {
        static Point3DAnimationUsingKeyFrames instance;

        internal static Point3DAnimationUsingKeyFrames StartChain(Windows.Media.Animation.Point3DAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Point3DAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Point3DAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Point3DAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Point3DAnimationUsingKeyFrames(Point3DAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Point3DAnimationUsingKeyFrames(Windows.Media.Animation.Point3DAnimationUsingKeyFrames ui) => Point3DAnimationUsingKeyFrames.StartChain(ui);

        protected Point3DAnimationUsingKeyFrames() { }
    }

    public static partial class Point3DAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Point3DAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Point3DAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Point3DKeyFrameCollection value) where TView : Point3DAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Point3DKeyFrame
{
    public partial class Point3DKeyFrame : Freezable, IUI<System.Windows.Media.Animation.Point3DKeyFrame>
    {
        Windows.Media.Animation.Point3DKeyFrame ui;

        public new Windows.Media.Animation.Point3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Point3DKeyFrame() { }
    }

    public static partial class Point3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Point3DKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Point3DKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Point3DKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Media.Media3D.Point3D value) where TView : Point3DKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Point3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Point3DKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Point3DKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D> Value<TTarget>(this TTarget target) where TTarget : Point3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D>.Get(target, Windows.Media.Animation.Point3DKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Point3DKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Point3DKeyFrameCollection"/></summary>
        public static Point3DKeyFrameCollection Point3DKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Point3DKeyFrameCollection();
            return global::CSharpMarkup.Wpf.Point3DKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Point3DKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Point3DKeyFrameCollection>
    {
        static Point3DKeyFrameCollection instance;

        internal static Point3DKeyFrameCollection StartChain(Windows.Media.Animation.Point3DKeyFrameCollection ui)
        {
            if (instance == null) instance = new Point3DKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Point3DKeyFrameCollection ui;

        public new Windows.Media.Animation.Point3DKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Point3DKeyFrameCollection(Point3DKeyFrameCollection view) => view?.UI;

        public static implicit operator Point3DKeyFrameCollection(Windows.Media.Animation.Point3DKeyFrameCollection ui) => Point3DKeyFrameCollection.StartChain(ui);

        protected Point3DKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // PointAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation(O<Windows.Point?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Point?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Point?> To = default)
        {
            var ui = new Windows.Media.Animation.PointAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation()
        {
            var ui = new Windows.Media.Animation.PointAnimation();
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation(Windows.Point toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.PointAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation(Windows.Point toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.PointAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation(Windows.Point fromValue, Windows.Point toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.PointAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimation"/></summary>
        public static PointAnimation PointAnimation(Windows.Point fromValue, Windows.Point toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.PointAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.PointAnimation.StartChain(ui);
        }
    }

    public partial class PointAnimation : PointAnimationBase, IUI<System.Windows.Media.Animation.PointAnimation>
    {
        static PointAnimation instance;

        internal static PointAnimation StartChain(Windows.Media.Animation.PointAnimation ui)
        {
            if (instance == null) instance = new PointAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PointAnimation ui;

        public new Windows.Media.Animation.PointAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PointAnimation(PointAnimation view) => view?.UI;

        public static implicit operator PointAnimation(Windows.Media.Animation.PointAnimation ui) => PointAnimation.StartChain(ui);

        protected PointAnimation() { }
    }

    public static partial class PointAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Point? value) where TView : PointAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : PointAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Point? value) where TView : PointAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : PointAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : PointAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Point? value) where TView : PointAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Point?> By<TTarget>(this TTarget target) where TTarget : PointAnimation
        => DependencyProperty<TTarget, Windows.Point?>.Get(target, Windows.Media.Animation.PointAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : PointAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.PointAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Point?> From<TTarget>(this TTarget target) where TTarget : PointAnimation
        => DependencyProperty<TTarget, Windows.Point?>.Get(target, Windows.Media.Animation.PointAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Point?> To<TTarget>(this TTarget target) where TTarget : PointAnimation
        => DependencyProperty<TTarget, Windows.Point?>.Get(target, Windows.Media.Animation.PointAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // PointAnimationBase
{
    public partial class PointAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.PointAnimationBase>
    {
        Windows.Media.Animation.PointAnimationBase ui;

        public new Windows.Media.Animation.PointAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected PointAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // PointAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames"/></summary>
        public static PointAnimationUsingKeyFrames PointAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.PointKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.PointAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.PointAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames"/></summary>
        public static PointAnimationUsingKeyFrames PointAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.PointKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.PointAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.PointAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames"/></summary>
        public static PointAnimationUsingKeyFrames PointAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.PointAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.PointAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class PointAnimationUsingKeyFrames : PointAnimationBase, IUI<System.Windows.Media.Animation.PointAnimationUsingKeyFrames>
    {
        static PointAnimationUsingKeyFrames instance;

        internal static PointAnimationUsingKeyFrames StartChain(Windows.Media.Animation.PointAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new PointAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PointAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.PointAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PointAnimationUsingKeyFrames(PointAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator PointAnimationUsingKeyFrames(Windows.Media.Animation.PointAnimationUsingKeyFrames ui) => PointAnimationUsingKeyFrames.StartChain(ui);

        protected PointAnimationUsingKeyFrames() { }
    }

    public static partial class PointAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : PointAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : PointAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.PointKeyFrameCollection value) where TView : PointAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // PointAnimationUsingPath
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimationUsingPath"/></summary>
        public static PointAnimationUsingPath PointAnimationUsingPath(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.PathGeometry> PathGeometry = default)
        {
            var ui = new Windows.Media.Animation.PointAnimationUsingPath();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (PathGeometry.HasValue) ui.PathGeometry = PathGeometry.Value;
            return global::CSharpMarkup.Wpf.PointAnimationUsingPath.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PointAnimationUsingPath"/></summary>
        public static PointAnimationUsingPath PointAnimationUsingPath()
        {
            var ui = new Windows.Media.Animation.PointAnimationUsingPath();
            return global::CSharpMarkup.Wpf.PointAnimationUsingPath.StartChain(ui);
        }
    }

    public partial class PointAnimationUsingPath : PointAnimationBase, IUI<System.Windows.Media.Animation.PointAnimationUsingPath>
    {
        static PointAnimationUsingPath instance;

        internal static PointAnimationUsingPath StartChain(Windows.Media.Animation.PointAnimationUsingPath ui)
        {
            if (instance == null) instance = new PointAnimationUsingPath();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PointAnimationUsingPath ui;

        public new Windows.Media.Animation.PointAnimationUsingPath UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PointAnimationUsingPath(PointAnimationUsingPath view) => view?.UI;

        public static implicit operator PointAnimationUsingPath(Windows.Media.Animation.PointAnimationUsingPath ui) => PointAnimationUsingPath.StartChain(ui);

        protected PointAnimationUsingPath() { }
    }

    public static partial class PointAnimationUsingPathExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingPath.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : PointAnimationUsingPath { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingPath.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : PointAnimationUsingPath { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointAnimationUsingPath.PathGeometry"/></summary>
        public static TView PathGeometry<TView>(this TView view, Windows.Media.PathGeometry value) where TView : PointAnimationUsingPath { view.UI.PathGeometry = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointAnimationUsingPath.PathGeometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PathGeometry> PathGeometry<TTarget>(this TTarget target) where TTarget : PointAnimationUsingPath
        => DependencyProperty<TTarget, Windows.Media.PathGeometry>.Get(target, Windows.Media.Animation.PointAnimationUsingPath.PathGeometryProperty);
    }
}

namespace CSharpMarkup.Wpf // PointKeyFrame
{
    public partial class PointKeyFrame : Freezable, IUI<System.Windows.Media.Animation.PointKeyFrame>
    {
        Windows.Media.Animation.PointKeyFrame ui;

        public new Windows.Media.Animation.PointKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected PointKeyFrame() { }
    }

    public static partial class PointKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.PointKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : PointKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.PointKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Point value) where TView : PointKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : PointKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.PointKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PointKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Point> Value<TTarget>(this TTarget target) where TTarget : PointKeyFrame
        => DependencyProperty<TTarget, Windows.Point>.Get(target, Windows.Media.Animation.PointKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // PointKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PointKeyFrameCollection"/></summary>
        public static PointKeyFrameCollection PointKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.PointKeyFrameCollection();
            return global::CSharpMarkup.Wpf.PointKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class PointKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.PointKeyFrameCollection>
    {
        static PointKeyFrameCollection instance;

        internal static PointKeyFrameCollection StartChain(Windows.Media.Animation.PointKeyFrameCollection ui)
        {
            if (instance == null) instance = new PointKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PointKeyFrameCollection ui;

        public new Windows.Media.Animation.PointKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PointKeyFrameCollection(PointKeyFrameCollection view) => view?.UI;

        public static implicit operator PointKeyFrameCollection(Windows.Media.Animation.PointKeyFrameCollection ui) => PointKeyFrameCollection.StartChain(ui);

        protected PointKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // PowerEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PowerEase"/></summary>
        public static PowerEase PowerEase(O<double> Power = default)
        {
            var ui = new Windows.Media.Animation.PowerEase();
            if (Power.HasValue) ui.Power = Power.Value;
            return global::CSharpMarkup.Wpf.PowerEase.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.PowerEase"/></summary>
        public static PowerEase PowerEase()
        {
            var ui = new Windows.Media.Animation.PowerEase();
            return global::CSharpMarkup.Wpf.PowerEase.StartChain(ui);
        }
    }

    public partial class PowerEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.PowerEase>
    {
        static PowerEase instance;

        internal static PowerEase StartChain(Windows.Media.Animation.PowerEase ui)
        {
            if (instance == null) instance = new PowerEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PowerEase ui;

        public new Windows.Media.Animation.PowerEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PowerEase(PowerEase view) => view?.UI;

        public static implicit operator PowerEase(Windows.Media.Animation.PowerEase ui) => PowerEase.StartChain(ui);

        protected PowerEase() { }
    }

    public static partial class PowerEaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.PowerEase.Power"/></summary>
        public static TView Power<TView>(this TView view, double value) where TView : PowerEase { view.UI.Power = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.PowerEase.Power"/></summary>
        public static DependencyProperty<TTarget, double> Power<TTarget>(this TTarget target) where TTarget : PowerEase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.PowerEase.PowerProperty);
    }
}

namespace CSharpMarkup.Wpf // QuadraticEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuadraticEase"/></summary>
        public static QuadraticEase QuadraticEase()
        {
            var ui = new Windows.Media.Animation.QuadraticEase();
            return global::CSharpMarkup.Wpf.QuadraticEase.StartChain(ui);
        }
    }

    public partial class QuadraticEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.QuadraticEase>
    {
        static QuadraticEase instance;

        internal static QuadraticEase StartChain(Windows.Media.Animation.QuadraticEase ui)
        {
            if (instance == null) instance = new QuadraticEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuadraticEase ui;

        public new Windows.Media.Animation.QuadraticEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuadraticEase(QuadraticEase view) => view?.UI;

        public static implicit operator QuadraticEase(Windows.Media.Animation.QuadraticEase ui) => QuadraticEase.StartChain(ui);

        protected QuadraticEase() { }
    }
}

namespace CSharpMarkup.Wpf // QuarticEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuarticEase"/></summary>
        public static QuarticEase QuarticEase()
        {
            var ui = new Windows.Media.Animation.QuarticEase();
            return global::CSharpMarkup.Wpf.QuarticEase.StartChain(ui);
        }
    }

    public partial class QuarticEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.QuarticEase>
    {
        static QuarticEase instance;

        internal static QuarticEase StartChain(Windows.Media.Animation.QuarticEase ui)
        {
            if (instance == null) instance = new QuarticEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuarticEase ui;

        public new Windows.Media.Animation.QuarticEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuarticEase(QuarticEase view) => view?.UI;

        public static implicit operator QuarticEase(Windows.Media.Animation.QuarticEase ui) => QuarticEase.StartChain(ui);

        protected QuarticEase() { }
    }
}

namespace CSharpMarkup.Wpf // QuaternionAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation(O<Windows.Media.Media3D.Quaternion?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Media.Media3D.Quaternion?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Media3D.Quaternion?> To = default, O<bool> UseShortestPath = default)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            if (UseShortestPath.HasValue) ui.UseShortestPath = UseShortestPath.Value;
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation()
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation();
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation(Windows.Media.Media3D.Quaternion toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation(Windows.Media.Media3D.Quaternion toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation(Windows.Media.Media3D.Quaternion fromValue, Windows.Media.Media3D.Quaternion toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimation"/></summary>
        public static QuaternionAnimation QuaternionAnimation(Windows.Media.Media3D.Quaternion fromValue, Windows.Media.Media3D.Quaternion toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.QuaternionAnimation.StartChain(ui);
        }
    }

    public partial class QuaternionAnimation : QuaternionAnimationBase, IUI<System.Windows.Media.Animation.QuaternionAnimation>
    {
        static QuaternionAnimation instance;

        internal static QuaternionAnimation StartChain(Windows.Media.Animation.QuaternionAnimation ui)
        {
            if (instance == null) instance = new QuaternionAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuaternionAnimation ui;

        public new Windows.Media.Animation.QuaternionAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuaternionAnimation(QuaternionAnimation view) => view?.UI;

        public static implicit operator QuaternionAnimation(Windows.Media.Animation.QuaternionAnimation ui) => QuaternionAnimation.StartChain(ui);

        protected QuaternionAnimation() { }
    }

    public static partial class QuaternionAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Media.Media3D.Quaternion? value) where TView : QuaternionAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : QuaternionAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Media.Media3D.Quaternion? value) where TView : QuaternionAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : QuaternionAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : QuaternionAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Media.Media3D.Quaternion? value) where TView : QuaternionAnimation { view.UI.To = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimation.UseShortestPath"/></summary>
        public static TView UseShortestPath<TView>(this TView view, bool value) where TView : QuaternionAnimation { view.UI.UseShortestPath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?> By<TTarget>(this TTarget target) where TTarget : QuaternionAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?>.Get(target, Windows.Media.Animation.QuaternionAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : QuaternionAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.QuaternionAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?> From<TTarget>(this TTarget target) where TTarget : QuaternionAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?>.Get(target, Windows.Media.Animation.QuaternionAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?> To<TTarget>(this TTarget target) where TTarget : QuaternionAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion?>.Get(target, Windows.Media.Animation.QuaternionAnimation.ToProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionAnimation.UseShortestPath"/></summary>
        public static DependencyProperty<TTarget, bool> UseShortestPath<TTarget>(this TTarget target) where TTarget : QuaternionAnimation
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.QuaternionAnimation.UseShortestPathProperty);
    }
}

namespace CSharpMarkup.Wpf // QuaternionAnimationBase
{
    public partial class QuaternionAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.QuaternionAnimationBase>
    {
        Windows.Media.Animation.QuaternionAnimationBase ui;

        public new Windows.Media.Animation.QuaternionAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected QuaternionAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // QuaternionAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames"/></summary>
        public static QuaternionAnimationUsingKeyFrames QuaternionAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.QuaternionKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.QuaternionAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames"/></summary>
        public static QuaternionAnimationUsingKeyFrames QuaternionAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.QuaternionKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.QuaternionAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.QuaternionAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames"/></summary>
        public static QuaternionAnimationUsingKeyFrames QuaternionAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.QuaternionAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.QuaternionAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class QuaternionAnimationUsingKeyFrames : QuaternionAnimationBase, IUI<System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames>
    {
        static QuaternionAnimationUsingKeyFrames instance;

        internal static QuaternionAnimationUsingKeyFrames StartChain(Windows.Media.Animation.QuaternionAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new QuaternionAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuaternionAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.QuaternionAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuaternionAnimationUsingKeyFrames(QuaternionAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator QuaternionAnimationUsingKeyFrames(Windows.Media.Animation.QuaternionAnimationUsingKeyFrames ui) => QuaternionAnimationUsingKeyFrames.StartChain(ui);

        protected QuaternionAnimationUsingKeyFrames() { }
    }

    public static partial class QuaternionAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : QuaternionAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : QuaternionAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.QuaternionKeyFrameCollection value) where TView : QuaternionAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // QuaternionKeyFrame
{
    public partial class QuaternionKeyFrame : Freezable, IUI<System.Windows.Media.Animation.QuaternionKeyFrame>
    {
        Windows.Media.Animation.QuaternionKeyFrame ui;

        public new Windows.Media.Animation.QuaternionKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected QuaternionKeyFrame() { }
    }

    public static partial class QuaternionKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : QuaternionKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.QuaternionKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Media.Media3D.Quaternion value) where TView : QuaternionKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : QuaternionKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.QuaternionKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.QuaternionKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion> Value<TTarget>(this TTarget target) where TTarget : QuaternionKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion>.Get(target, Windows.Media.Animation.QuaternionKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // QuaternionKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuaternionKeyFrameCollection"/></summary>
        public static QuaternionKeyFrameCollection QuaternionKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.QuaternionKeyFrameCollection();
            return global::CSharpMarkup.Wpf.QuaternionKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class QuaternionKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.QuaternionKeyFrameCollection>
    {
        static QuaternionKeyFrameCollection instance;

        internal static QuaternionKeyFrameCollection StartChain(Windows.Media.Animation.QuaternionKeyFrameCollection ui)
        {
            if (instance == null) instance = new QuaternionKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuaternionKeyFrameCollection ui;

        public new Windows.Media.Animation.QuaternionKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuaternionKeyFrameCollection(QuaternionKeyFrameCollection view) => view?.UI;

        public static implicit operator QuaternionKeyFrameCollection(Windows.Media.Animation.QuaternionKeyFrameCollection ui) => QuaternionKeyFrameCollection.StartChain(ui);

        protected QuaternionKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // QuinticEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.QuinticEase"/></summary>
        public static QuinticEase QuinticEase()
        {
            var ui = new Windows.Media.Animation.QuinticEase();
            return global::CSharpMarkup.Wpf.QuinticEase.StartChain(ui);
        }
    }

    public partial class QuinticEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.QuinticEase>
    {
        static QuinticEase instance;

        internal static QuinticEase StartChain(Windows.Media.Animation.QuinticEase ui)
        {
            if (instance == null) instance = new QuinticEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.QuinticEase ui;

        public new Windows.Media.Animation.QuinticEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.QuinticEase(QuinticEase view) => view?.UI;

        public static implicit operator QuinticEase(Windows.Media.Animation.QuinticEase ui) => QuinticEase.StartChain(ui);

        protected QuinticEase() { }
    }
}

namespace CSharpMarkup.Wpf // RectAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation(O<Windows.Rect?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Rect?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Rect?> To = default)
        {
            var ui = new Windows.Media.Animation.RectAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation()
        {
            var ui = new Windows.Media.Animation.RectAnimation();
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation(Windows.Rect toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.RectAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation(Windows.Rect toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.RectAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation(Windows.Rect fromValue, Windows.Rect toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.RectAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimation"/></summary>
        public static RectAnimation RectAnimation(Windows.Rect fromValue, Windows.Rect toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.RectAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.RectAnimation.StartChain(ui);
        }
    }

    public partial class RectAnimation : RectAnimationBase, IUI<System.Windows.Media.Animation.RectAnimation>
    {
        static RectAnimation instance;

        internal static RectAnimation StartChain(Windows.Media.Animation.RectAnimation ui)
        {
            if (instance == null) instance = new RectAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.RectAnimation ui;

        public new Windows.Media.Animation.RectAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.RectAnimation(RectAnimation view) => view?.UI;

        public static implicit operator RectAnimation(Windows.Media.Animation.RectAnimation ui) => RectAnimation.StartChain(ui);

        protected RectAnimation() { }
    }

    public static partial class RectAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Rect? value) where TView : RectAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : RectAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Rect? value) where TView : RectAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : RectAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : RectAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Rect? value) where TView : RectAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect?> By<TTarget>(this TTarget target) where TTarget : RectAnimation
        => DependencyProperty<TTarget, Windows.Rect?>.Get(target, Windows.Media.Animation.RectAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : RectAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.RectAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect?> From<TTarget>(this TTarget target) where TTarget : RectAnimation
        => DependencyProperty<TTarget, Windows.Rect?>.Get(target, Windows.Media.Animation.RectAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect?> To<TTarget>(this TTarget target) where TTarget : RectAnimation
        => DependencyProperty<TTarget, Windows.Rect?>.Get(target, Windows.Media.Animation.RectAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // RectAnimationBase
{
    public partial class RectAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.RectAnimationBase>
    {
        Windows.Media.Animation.RectAnimationBase ui;

        public new Windows.Media.Animation.RectAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected RectAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // RectAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames"/></summary>
        public static RectAnimationUsingKeyFrames RectAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.RectKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.RectAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.RectAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames"/></summary>
        public static RectAnimationUsingKeyFrames RectAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.RectKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.RectAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.RectAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames"/></summary>
        public static RectAnimationUsingKeyFrames RectAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.RectAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.RectAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class RectAnimationUsingKeyFrames : RectAnimationBase, IUI<System.Windows.Media.Animation.RectAnimationUsingKeyFrames>
    {
        static RectAnimationUsingKeyFrames instance;

        internal static RectAnimationUsingKeyFrames StartChain(Windows.Media.Animation.RectAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new RectAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.RectAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.RectAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.RectAnimationUsingKeyFrames(RectAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator RectAnimationUsingKeyFrames(Windows.Media.Animation.RectAnimationUsingKeyFrames ui) => RectAnimationUsingKeyFrames.StartChain(ui);

        protected RectAnimationUsingKeyFrames() { }
    }

    public static partial class RectAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : RectAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : RectAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.RectKeyFrameCollection value) where TView : RectAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // RectKeyFrame
{
    public partial class RectKeyFrame : Freezable, IUI<System.Windows.Media.Animation.RectKeyFrame>
    {
        Windows.Media.Animation.RectKeyFrame ui;

        public new Windows.Media.Animation.RectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected RectKeyFrame() { }
    }

    public static partial class RectKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.RectKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : RectKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.RectKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Rect value) where TView : RectKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : RectKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.RectKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.RectKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Value<TTarget>(this TTarget target) where TTarget : RectKeyFrame
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.Animation.RectKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // RectKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.RectKeyFrameCollection"/></summary>
        public static RectKeyFrameCollection RectKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.RectKeyFrameCollection();
            return global::CSharpMarkup.Wpf.RectKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class RectKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.RectKeyFrameCollection>
    {
        static RectKeyFrameCollection instance;

        internal static RectKeyFrameCollection StartChain(Windows.Media.Animation.RectKeyFrameCollection ui)
        {
            if (instance == null) instance = new RectKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.RectKeyFrameCollection ui;

        public new Windows.Media.Animation.RectKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.RectKeyFrameCollection(RectKeyFrameCollection view) => view?.UI;

        public static implicit operator RectKeyFrameCollection(Windows.Media.Animation.RectKeyFrameCollection ui) => RectKeyFrameCollection.StartChain(ui);

        protected RectKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Rotation3DAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation(O<Windows.Media.Media3D.Rotation3D> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Media.Media3D.Rotation3D> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Media3D.Rotation3D> To = default)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation()
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation();
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation(Windows.Media.Media3D.Rotation3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation(Windows.Media.Media3D.Rotation3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation(Windows.Media.Media3D.Rotation3D fromValue, Windows.Media.Media3D.Rotation3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimation"/></summary>
        public static Rotation3DAnimation Rotation3DAnimation(Windows.Media.Media3D.Rotation3D fromValue, Windows.Media.Media3D.Rotation3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Rotation3DAnimation.StartChain(ui);
        }
    }

    public partial class Rotation3DAnimation : Rotation3DAnimationBase, IUI<System.Windows.Media.Animation.Rotation3DAnimation>
    {
        static Rotation3DAnimation instance;

        internal static Rotation3DAnimation StartChain(Windows.Media.Animation.Rotation3DAnimation ui)
        {
            if (instance == null) instance = new Rotation3DAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Rotation3DAnimation ui;

        public new Windows.Media.Animation.Rotation3DAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Rotation3DAnimation(Rotation3DAnimation view) => view?.UI;

        public static implicit operator Rotation3DAnimation(Windows.Media.Animation.Rotation3DAnimation ui) => Rotation3DAnimation.StartChain(ui);

        protected Rotation3DAnimation() { }
    }

    public static partial class Rotation3DAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Media.Media3D.Rotation3D value) where TView : Rotation3DAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Rotation3DAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Media.Media3D.Rotation3D value) where TView : Rotation3DAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Rotation3DAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Rotation3DAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Media.Media3D.Rotation3D value) where TView : Rotation3DAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D> By<TTarget>(this TTarget target) where TTarget : Rotation3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D>.Get(target, Windows.Media.Animation.Rotation3DAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Rotation3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Rotation3DAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D> From<TTarget>(this TTarget target) where TTarget : Rotation3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D>.Get(target, Windows.Media.Animation.Rotation3DAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D> To<TTarget>(this TTarget target) where TTarget : Rotation3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D>.Get(target, Windows.Media.Animation.Rotation3DAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Rotation3DAnimationBase
{
    public partial class Rotation3DAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Rotation3DAnimationBase>
    {
        Windows.Media.Animation.Rotation3DAnimationBase ui;

        public new Windows.Media.Animation.Rotation3DAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Rotation3DAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Rotation3DAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames"/></summary>
        public static Rotation3DAnimationUsingKeyFrames Rotation3DAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Rotation3DKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Rotation3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames"/></summary>
        public static Rotation3DAnimationUsingKeyFrames Rotation3DAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Rotation3DKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Rotation3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames"/></summary>
        public static Rotation3DAnimationUsingKeyFrames Rotation3DAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Rotation3DAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Rotation3DAnimationUsingKeyFrames : Rotation3DAnimationBase, IUI<System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames>
    {
        static Rotation3DAnimationUsingKeyFrames instance;

        internal static Rotation3DAnimationUsingKeyFrames StartChain(Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Rotation3DAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames(Rotation3DAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Rotation3DAnimationUsingKeyFrames(Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames ui) => Rotation3DAnimationUsingKeyFrames.StartChain(ui);

        protected Rotation3DAnimationUsingKeyFrames() { }
    }

    public static partial class Rotation3DAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Rotation3DAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Rotation3DAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Rotation3DKeyFrameCollection value) where TView : Rotation3DAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Rotation3DKeyFrame
{
    public partial class Rotation3DKeyFrame : Freezable, IUI<System.Windows.Media.Animation.Rotation3DKeyFrame>
    {
        Windows.Media.Animation.Rotation3DKeyFrame ui;

        public new Windows.Media.Animation.Rotation3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Rotation3DKeyFrame() { }
    }

    public static partial class Rotation3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Rotation3DKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Rotation3DKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Media.Media3D.Rotation3D value) where TView : Rotation3DKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Rotation3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Rotation3DKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Rotation3DKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D> Value<TTarget>(this TTarget target) where TTarget : Rotation3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D>.Get(target, Windows.Media.Animation.Rotation3DKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Rotation3DKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Rotation3DKeyFrameCollection"/></summary>
        public static Rotation3DKeyFrameCollection Rotation3DKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Rotation3DKeyFrameCollection();
            return global::CSharpMarkup.Wpf.Rotation3DKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Rotation3DKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Rotation3DKeyFrameCollection>
    {
        static Rotation3DKeyFrameCollection instance;

        internal static Rotation3DKeyFrameCollection StartChain(Windows.Media.Animation.Rotation3DKeyFrameCollection ui)
        {
            if (instance == null) instance = new Rotation3DKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Rotation3DKeyFrameCollection ui;

        public new Windows.Media.Animation.Rotation3DKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Rotation3DKeyFrameCollection(Rotation3DKeyFrameCollection view) => view?.UI;

        public static implicit operator Rotation3DKeyFrameCollection(Windows.Media.Animation.Rotation3DKeyFrameCollection ui) => Rotation3DKeyFrameCollection.StartChain(ui);

        protected Rotation3DKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // SineEase
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SineEase"/></summary>
        public static SineEase SineEase()
        {
            var ui = new Windows.Media.Animation.SineEase();
            return global::CSharpMarkup.Wpf.SineEase.StartChain(ui);
        }
    }

    public partial class SineEase : EasingFunctionBase, IUI<System.Windows.Media.Animation.SineEase>
    {
        static SineEase instance;

        internal static SineEase StartChain(Windows.Media.Animation.SineEase ui)
        {
            if (instance == null) instance = new SineEase();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SineEase ui;

        public new Windows.Media.Animation.SineEase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SineEase(SineEase view) => view?.UI;

        public static implicit operator SineEase(Windows.Media.Animation.SineEase ui) => SineEase.StartChain(ui);

        protected SineEase() { }
    }
}

namespace CSharpMarkup.Wpf // SingleAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation(O<float?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<float?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<float?> To = default)
        {
            var ui = new Windows.Media.Animation.SingleAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation()
        {
            var ui = new Windows.Media.Animation.SingleAnimation();
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation(float fromValue, float toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.SingleAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation(float fromValue, float toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.SingleAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation(float toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.SingleAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimation"/></summary>
        public static SingleAnimation SingleAnimation(float toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.SingleAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.SingleAnimation.StartChain(ui);
        }
    }

    public partial class SingleAnimation : SingleAnimationBase, IUI<System.Windows.Media.Animation.SingleAnimation>
    {
        static SingleAnimation instance;

        internal static SingleAnimation StartChain(Windows.Media.Animation.SingleAnimation ui)
        {
            if (instance == null) instance = new SingleAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SingleAnimation ui;

        public new Windows.Media.Animation.SingleAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SingleAnimation(SingleAnimation view) => view?.UI;

        public static implicit operator SingleAnimation(Windows.Media.Animation.SingleAnimation ui) => SingleAnimation.StartChain(ui);

        protected SingleAnimation() { }
    }

    public static partial class SingleAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.By"/></summary>
        public static TView By<TView>(this TView view, float? value) where TView : SingleAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : SingleAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.From"/></summary>
        public static TView From<TView>(this TView view, float? value) where TView : SingleAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : SingleAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : SingleAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimation.To"/></summary>
        public static TView To<TView>(this TView view, float? value) where TView : SingleAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleAnimation.By"/></summary>
        public static DependencyProperty<TTarget, float?> By<TTarget>(this TTarget target) where TTarget : SingleAnimation
        => DependencyProperty<TTarget, float?>.Get(target, Windows.Media.Animation.SingleAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : SingleAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.SingleAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleAnimation.From"/></summary>
        public static DependencyProperty<TTarget, float?> From<TTarget>(this TTarget target) where TTarget : SingleAnimation
        => DependencyProperty<TTarget, float?>.Get(target, Windows.Media.Animation.SingleAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleAnimation.To"/></summary>
        public static DependencyProperty<TTarget, float?> To<TTarget>(this TTarget target) where TTarget : SingleAnimation
        => DependencyProperty<TTarget, float?>.Get(target, Windows.Media.Animation.SingleAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // SingleAnimationBase
{
    public partial class SingleAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.SingleAnimationBase>
    {
        Windows.Media.Animation.SingleAnimationBase ui;

        public new Windows.Media.Animation.SingleAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected SingleAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // SingleAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames"/></summary>
        public static SingleAnimationUsingKeyFrames SingleAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.SingleKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.SingleAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.SingleAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames"/></summary>
        public static SingleAnimationUsingKeyFrames SingleAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.SingleKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.SingleAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.SingleAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames"/></summary>
        public static SingleAnimationUsingKeyFrames SingleAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.SingleAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.SingleAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class SingleAnimationUsingKeyFrames : SingleAnimationBase, IUI<System.Windows.Media.Animation.SingleAnimationUsingKeyFrames>
    {
        static SingleAnimationUsingKeyFrames instance;

        internal static SingleAnimationUsingKeyFrames StartChain(Windows.Media.Animation.SingleAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new SingleAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SingleAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.SingleAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SingleAnimationUsingKeyFrames(SingleAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator SingleAnimationUsingKeyFrames(Windows.Media.Animation.SingleAnimationUsingKeyFrames ui) => SingleAnimationUsingKeyFrames.StartChain(ui);

        protected SingleAnimationUsingKeyFrames() { }
    }

    public static partial class SingleAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : SingleAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : SingleAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.SingleKeyFrameCollection value) where TView : SingleAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // SingleKeyFrame
{
    public partial class SingleKeyFrame : Freezable, IUI<System.Windows.Media.Animation.SingleKeyFrame>
    {
        Windows.Media.Animation.SingleKeyFrame ui;

        public new Windows.Media.Animation.SingleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected SingleKeyFrame() { }
    }

    public static partial class SingleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SingleKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : SingleKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SingleKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, float value) where TView : SingleKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : SingleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.SingleKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SingleKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, float> Value<TTarget>(this TTarget target) where TTarget : SingleKeyFrame
        => DependencyProperty<TTarget, float>.Get(target, Windows.Media.Animation.SingleKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // SingleKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SingleKeyFrameCollection"/></summary>
        public static SingleKeyFrameCollection SingleKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.SingleKeyFrameCollection();
            return global::CSharpMarkup.Wpf.SingleKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class SingleKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.SingleKeyFrameCollection>
    {
        static SingleKeyFrameCollection instance;

        internal static SingleKeyFrameCollection StartChain(Windows.Media.Animation.SingleKeyFrameCollection ui)
        {
            if (instance == null) instance = new SingleKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SingleKeyFrameCollection ui;

        public new Windows.Media.Animation.SingleKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SingleKeyFrameCollection(SingleKeyFrameCollection view) => view?.UI;

        public static implicit operator SingleKeyFrameCollection(Windows.Media.Animation.SingleKeyFrameCollection ui) => SingleKeyFrameCollection.StartChain(ui);

        protected SingleKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // SizeAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation(O<Windows.Size?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Size?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Size?> To = default)
        {
            var ui = new Windows.Media.Animation.SizeAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation()
        {
            var ui = new Windows.Media.Animation.SizeAnimation();
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation(Windows.Size toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.SizeAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation(Windows.Size toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.SizeAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation(Windows.Size fromValue, Windows.Size toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.SizeAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimation"/></summary>
        public static SizeAnimation SizeAnimation(Windows.Size fromValue, Windows.Size toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.SizeAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.SizeAnimation.StartChain(ui);
        }
    }

    public partial class SizeAnimation : SizeAnimationBase, IUI<System.Windows.Media.Animation.SizeAnimation>
    {
        static SizeAnimation instance;

        internal static SizeAnimation StartChain(Windows.Media.Animation.SizeAnimation ui)
        {
            if (instance == null) instance = new SizeAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SizeAnimation ui;

        public new Windows.Media.Animation.SizeAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SizeAnimation(SizeAnimation view) => view?.UI;

        public static implicit operator SizeAnimation(Windows.Media.Animation.SizeAnimation ui) => SizeAnimation.StartChain(ui);

        protected SizeAnimation() { }
    }

    public static partial class SizeAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Size? value) where TView : SizeAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : SizeAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Size? value) where TView : SizeAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : SizeAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : SizeAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Size? value) where TView : SizeAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Size?> By<TTarget>(this TTarget target) where TTarget : SizeAnimation
        => DependencyProperty<TTarget, Windows.Size?>.Get(target, Windows.Media.Animation.SizeAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : SizeAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.SizeAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Size?> From<TTarget>(this TTarget target) where TTarget : SizeAnimation
        => DependencyProperty<TTarget, Windows.Size?>.Get(target, Windows.Media.Animation.SizeAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Size?> To<TTarget>(this TTarget target) where TTarget : SizeAnimation
        => DependencyProperty<TTarget, Windows.Size?>.Get(target, Windows.Media.Animation.SizeAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // SizeAnimationBase
{
    public partial class SizeAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.SizeAnimationBase>
    {
        Windows.Media.Animation.SizeAnimationBase ui;

        public new Windows.Media.Animation.SizeAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected SizeAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // SizeAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames"/></summary>
        public static SizeAnimationUsingKeyFrames SizeAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.SizeKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.SizeAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.SizeAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames"/></summary>
        public static SizeAnimationUsingKeyFrames SizeAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.SizeKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.SizeAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.SizeAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames"/></summary>
        public static SizeAnimationUsingKeyFrames SizeAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.SizeAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.SizeAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class SizeAnimationUsingKeyFrames : SizeAnimationBase, IUI<System.Windows.Media.Animation.SizeAnimationUsingKeyFrames>
    {
        static SizeAnimationUsingKeyFrames instance;

        internal static SizeAnimationUsingKeyFrames StartChain(Windows.Media.Animation.SizeAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new SizeAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SizeAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.SizeAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SizeAnimationUsingKeyFrames(SizeAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator SizeAnimationUsingKeyFrames(Windows.Media.Animation.SizeAnimationUsingKeyFrames ui) => SizeAnimationUsingKeyFrames.StartChain(ui);

        protected SizeAnimationUsingKeyFrames() { }
    }

    public static partial class SizeAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : SizeAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : SizeAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.SizeKeyFrameCollection value) where TView : SizeAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // SizeKeyFrame
{
    public partial class SizeKeyFrame : Freezable, IUI<System.Windows.Media.Animation.SizeKeyFrame>
    {
        Windows.Media.Animation.SizeKeyFrame ui;

        public new Windows.Media.Animation.SizeKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected SizeKeyFrame() { }
    }

    public static partial class SizeKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SizeKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : SizeKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SizeKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Size value) where TView : SizeKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : SizeKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.SizeKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SizeKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Size> Value<TTarget>(this TTarget target) where TTarget : SizeKeyFrame
        => DependencyProperty<TTarget, Windows.Size>.Get(target, Windows.Media.Animation.SizeKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // SizeKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SizeKeyFrameCollection"/></summary>
        public static SizeKeyFrameCollection SizeKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.SizeKeyFrameCollection();
            return global::CSharpMarkup.Wpf.SizeKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class SizeKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.SizeKeyFrameCollection>
    {
        static SizeKeyFrameCollection instance;

        internal static SizeKeyFrameCollection StartChain(Windows.Media.Animation.SizeKeyFrameCollection ui)
        {
            if (instance == null) instance = new SizeKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SizeKeyFrameCollection ui;

        public new Windows.Media.Animation.SizeKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SizeKeyFrameCollection(SizeKeyFrameCollection view) => view?.UI;

        public static implicit operator SizeKeyFrameCollection(Windows.Media.Animation.SizeKeyFrameCollection ui) => SizeKeyFrameCollection.StartChain(ui);

        protected SizeKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // SplineByteKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineByteKeyFrame"/></summary>
        public static SplineByteKeyFrame SplineByteKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineByteKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineByteKeyFrame"/></summary>
        public static SplineByteKeyFrame SplineByteKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineByteKeyFrame();
            return global::CSharpMarkup.Wpf.SplineByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineByteKeyFrame"/></summary>
        public static SplineByteKeyFrame SplineByteKeyFrame(byte value)
        {
            var ui = new Windows.Media.Animation.SplineByteKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineByteKeyFrame"/></summary>
        public static SplineByteKeyFrame SplineByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineByteKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineByteKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineByteKeyFrame"/></summary>
        public static SplineByteKeyFrame SplineByteKeyFrame(byte value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineByteKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineByteKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineByteKeyFrame : ByteKeyFrame, IUI<System.Windows.Media.Animation.SplineByteKeyFrame>
    {
        static SplineByteKeyFrame instance;

        internal static SplineByteKeyFrame StartChain(Windows.Media.Animation.SplineByteKeyFrame ui)
        {
            if (instance == null) instance = new SplineByteKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineByteKeyFrame ui;

        public new Windows.Media.Animation.SplineByteKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineByteKeyFrame(SplineByteKeyFrame view) => view?.UI;

        public static implicit operator SplineByteKeyFrame(Windows.Media.Animation.SplineByteKeyFrame ui) => SplineByteKeyFrame.StartChain(ui);

        protected SplineByteKeyFrame() { }
    }

    public static partial class SplineByteKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineByteKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineByteKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineByteKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineByteKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineByteKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineColorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineColorKeyFrame"/></summary>
        public static SplineColorKeyFrame SplineColorKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineColorKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineColorKeyFrame"/></summary>
        public static SplineColorKeyFrame SplineColorKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineColorKeyFrame();
            return global::CSharpMarkup.Wpf.SplineColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineColorKeyFrame"/></summary>
        public static SplineColorKeyFrame SplineColorKeyFrame(Color value)
        {
            var ui = new Windows.Media.Animation.SplineColorKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineColorKeyFrame"/></summary>
        public static SplineColorKeyFrame SplineColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineColorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineColorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineColorKeyFrame"/></summary>
        public static SplineColorKeyFrame SplineColorKeyFrame(Color value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineColorKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineColorKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineColorKeyFrame : ColorKeyFrame, IUI<System.Windows.Media.Animation.SplineColorKeyFrame>
    {
        static SplineColorKeyFrame instance;

        internal static SplineColorKeyFrame StartChain(Windows.Media.Animation.SplineColorKeyFrame ui)
        {
            if (instance == null) instance = new SplineColorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineColorKeyFrame ui;

        public new Windows.Media.Animation.SplineColorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineColorKeyFrame(SplineColorKeyFrame view) => view?.UI;

        public static implicit operator SplineColorKeyFrame(Windows.Media.Animation.SplineColorKeyFrame ui) => SplineColorKeyFrame.StartChain(ui);

        protected SplineColorKeyFrame() { }
    }

    public static partial class SplineColorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineColorKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineColorKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineColorKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineColorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineColorKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineDecimalKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDecimalKeyFrame"/></summary>
        public static SplineDecimalKeyFrame SplineDecimalKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineDecimalKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDecimalKeyFrame"/></summary>
        public static SplineDecimalKeyFrame SplineDecimalKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineDecimalKeyFrame();
            return global::CSharpMarkup.Wpf.SplineDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDecimalKeyFrame"/></summary>
        public static SplineDecimalKeyFrame SplineDecimalKeyFrame(decimal value)
        {
            var ui = new Windows.Media.Animation.SplineDecimalKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDecimalKeyFrame"/></summary>
        public static SplineDecimalKeyFrame SplineDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineDecimalKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineDecimalKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDecimalKeyFrame"/></summary>
        public static SplineDecimalKeyFrame SplineDecimalKeyFrame(decimal value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineDecimalKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineDecimalKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineDecimalKeyFrame : DecimalKeyFrame, IUI<System.Windows.Media.Animation.SplineDecimalKeyFrame>
    {
        static SplineDecimalKeyFrame instance;

        internal static SplineDecimalKeyFrame StartChain(Windows.Media.Animation.SplineDecimalKeyFrame ui)
        {
            if (instance == null) instance = new SplineDecimalKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineDecimalKeyFrame ui;

        public new Windows.Media.Animation.SplineDecimalKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineDecimalKeyFrame(SplineDecimalKeyFrame view) => view?.UI;

        public static implicit operator SplineDecimalKeyFrame(Windows.Media.Animation.SplineDecimalKeyFrame ui) => SplineDecimalKeyFrame.StartChain(ui);

        protected SplineDecimalKeyFrame() { }
    }

    public static partial class SplineDecimalKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineDecimalKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineDecimalKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineDecimalKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineDecimalKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineDecimalKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineDoubleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDoubleKeyFrame"/></summary>
        public static SplineDoubleKeyFrame SplineDoubleKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineDoubleKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDoubleKeyFrame"/></summary>
        public static SplineDoubleKeyFrame SplineDoubleKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineDoubleKeyFrame();
            return global::CSharpMarkup.Wpf.SplineDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDoubleKeyFrame"/></summary>
        public static SplineDoubleKeyFrame SplineDoubleKeyFrame(double value)
        {
            var ui = new Windows.Media.Animation.SplineDoubleKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDoubleKeyFrame"/></summary>
        public static SplineDoubleKeyFrame SplineDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineDoubleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineDoubleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineDoubleKeyFrame"/></summary>
        public static SplineDoubleKeyFrame SplineDoubleKeyFrame(double value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineDoubleKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineDoubleKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineDoubleKeyFrame : DoubleKeyFrame, IUI<System.Windows.Media.Animation.SplineDoubleKeyFrame>
    {
        static SplineDoubleKeyFrame instance;

        internal static SplineDoubleKeyFrame StartChain(Windows.Media.Animation.SplineDoubleKeyFrame ui)
        {
            if (instance == null) instance = new SplineDoubleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineDoubleKeyFrame ui;

        public new Windows.Media.Animation.SplineDoubleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineDoubleKeyFrame(SplineDoubleKeyFrame view) => view?.UI;

        public static implicit operator SplineDoubleKeyFrame(Windows.Media.Animation.SplineDoubleKeyFrame ui) => SplineDoubleKeyFrame.StartChain(ui);

        protected SplineDoubleKeyFrame() { }
    }

    public static partial class SplineDoubleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineDoubleKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineDoubleKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineDoubleKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineDoubleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineDoubleKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineInt16KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt16KeyFrame"/></summary>
        public static SplineInt16KeyFrame SplineInt16KeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineInt16KeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt16KeyFrame"/></summary>
        public static SplineInt16KeyFrame SplineInt16KeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineInt16KeyFrame();
            return global::CSharpMarkup.Wpf.SplineInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt16KeyFrame"/></summary>
        public static SplineInt16KeyFrame SplineInt16KeyFrame(short value)
        {
            var ui = new Windows.Media.Animation.SplineInt16KeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt16KeyFrame"/></summary>
        public static SplineInt16KeyFrame SplineInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineInt16KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineInt16KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt16KeyFrame"/></summary>
        public static SplineInt16KeyFrame SplineInt16KeyFrame(short value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineInt16KeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineInt16KeyFrame.StartChain(ui);
        }
    }

    public partial class SplineInt16KeyFrame : Int16KeyFrame, IUI<System.Windows.Media.Animation.SplineInt16KeyFrame>
    {
        static SplineInt16KeyFrame instance;

        internal static SplineInt16KeyFrame StartChain(Windows.Media.Animation.SplineInt16KeyFrame ui)
        {
            if (instance == null) instance = new SplineInt16KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineInt16KeyFrame ui;

        public new Windows.Media.Animation.SplineInt16KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineInt16KeyFrame(SplineInt16KeyFrame view) => view?.UI;

        public static implicit operator SplineInt16KeyFrame(Windows.Media.Animation.SplineInt16KeyFrame ui) => SplineInt16KeyFrame.StartChain(ui);

        protected SplineInt16KeyFrame() { }
    }

    public static partial class SplineInt16KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineInt16KeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineInt16KeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineInt16KeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineInt16KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineInt16KeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineInt32KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt32KeyFrame"/></summary>
        public static SplineInt32KeyFrame SplineInt32KeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineInt32KeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt32KeyFrame"/></summary>
        public static SplineInt32KeyFrame SplineInt32KeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineInt32KeyFrame();
            return global::CSharpMarkup.Wpf.SplineInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt32KeyFrame"/></summary>
        public static SplineInt32KeyFrame SplineInt32KeyFrame(int value)
        {
            var ui = new Windows.Media.Animation.SplineInt32KeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt32KeyFrame"/></summary>
        public static SplineInt32KeyFrame SplineInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineInt32KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineInt32KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt32KeyFrame"/></summary>
        public static SplineInt32KeyFrame SplineInt32KeyFrame(int value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineInt32KeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineInt32KeyFrame.StartChain(ui);
        }
    }

    public partial class SplineInt32KeyFrame : Int32KeyFrame, IUI<System.Windows.Media.Animation.SplineInt32KeyFrame>
    {
        static SplineInt32KeyFrame instance;

        internal static SplineInt32KeyFrame StartChain(Windows.Media.Animation.SplineInt32KeyFrame ui)
        {
            if (instance == null) instance = new SplineInt32KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineInt32KeyFrame ui;

        public new Windows.Media.Animation.SplineInt32KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineInt32KeyFrame(SplineInt32KeyFrame view) => view?.UI;

        public static implicit operator SplineInt32KeyFrame(Windows.Media.Animation.SplineInt32KeyFrame ui) => SplineInt32KeyFrame.StartChain(ui);

        protected SplineInt32KeyFrame() { }
    }

    public static partial class SplineInt32KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineInt32KeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineInt32KeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineInt32KeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineInt32KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineInt32KeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineInt64KeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt64KeyFrame"/></summary>
        public static SplineInt64KeyFrame SplineInt64KeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineInt64KeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt64KeyFrame"/></summary>
        public static SplineInt64KeyFrame SplineInt64KeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineInt64KeyFrame();
            return global::CSharpMarkup.Wpf.SplineInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt64KeyFrame"/></summary>
        public static SplineInt64KeyFrame SplineInt64KeyFrame(long value)
        {
            var ui = new Windows.Media.Animation.SplineInt64KeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt64KeyFrame"/></summary>
        public static SplineInt64KeyFrame SplineInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineInt64KeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineInt64KeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineInt64KeyFrame"/></summary>
        public static SplineInt64KeyFrame SplineInt64KeyFrame(long value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineInt64KeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineInt64KeyFrame.StartChain(ui);
        }
    }

    public partial class SplineInt64KeyFrame : Int64KeyFrame, IUI<System.Windows.Media.Animation.SplineInt64KeyFrame>
    {
        static SplineInt64KeyFrame instance;

        internal static SplineInt64KeyFrame StartChain(Windows.Media.Animation.SplineInt64KeyFrame ui)
        {
            if (instance == null) instance = new SplineInt64KeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineInt64KeyFrame ui;

        public new Windows.Media.Animation.SplineInt64KeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineInt64KeyFrame(SplineInt64KeyFrame view) => view?.UI;

        public static implicit operator SplineInt64KeyFrame(Windows.Media.Animation.SplineInt64KeyFrame ui) => SplineInt64KeyFrame.StartChain(ui);

        protected SplineInt64KeyFrame() { }
    }

    public static partial class SplineInt64KeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineInt64KeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineInt64KeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineInt64KeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineInt64KeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineInt64KeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplinePoint3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame"/></summary>
        public static SplinePoint3DKeyFrame SplinePoint3DKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplinePoint3DKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplinePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame"/></summary>
        public static SplinePoint3DKeyFrame SplinePoint3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplinePoint3DKeyFrame();
            return global::CSharpMarkup.Wpf.SplinePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame"/></summary>
        public static SplinePoint3DKeyFrame SplinePoint3DKeyFrame(Windows.Media.Media3D.Point3D value)
        {
            var ui = new Windows.Media.Animation.SplinePoint3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplinePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame"/></summary>
        public static SplinePoint3DKeyFrame SplinePoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplinePoint3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplinePoint3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame"/></summary>
        public static SplinePoint3DKeyFrame SplinePoint3DKeyFrame(Windows.Media.Media3D.Point3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplinePoint3DKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplinePoint3DKeyFrame.StartChain(ui);
        }
    }

    public partial class SplinePoint3DKeyFrame : Point3DKeyFrame, IUI<System.Windows.Media.Animation.SplinePoint3DKeyFrame>
    {
        static SplinePoint3DKeyFrame instance;

        internal static SplinePoint3DKeyFrame StartChain(Windows.Media.Animation.SplinePoint3DKeyFrame ui)
        {
            if (instance == null) instance = new SplinePoint3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplinePoint3DKeyFrame ui;

        public new Windows.Media.Animation.SplinePoint3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplinePoint3DKeyFrame(SplinePoint3DKeyFrame view) => view?.UI;

        public static implicit operator SplinePoint3DKeyFrame(Windows.Media.Animation.SplinePoint3DKeyFrame ui) => SplinePoint3DKeyFrame.StartChain(ui);

        protected SplinePoint3DKeyFrame() { }
    }

    public static partial class SplinePoint3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplinePoint3DKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplinePoint3DKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplinePoint3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplinePoint3DKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplinePointKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePointKeyFrame"/></summary>
        public static SplinePointKeyFrame SplinePointKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplinePointKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplinePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePointKeyFrame"/></summary>
        public static SplinePointKeyFrame SplinePointKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplinePointKeyFrame();
            return global::CSharpMarkup.Wpf.SplinePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePointKeyFrame"/></summary>
        public static SplinePointKeyFrame SplinePointKeyFrame(Windows.Point value)
        {
            var ui = new Windows.Media.Animation.SplinePointKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplinePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePointKeyFrame"/></summary>
        public static SplinePointKeyFrame SplinePointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplinePointKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplinePointKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplinePointKeyFrame"/></summary>
        public static SplinePointKeyFrame SplinePointKeyFrame(Windows.Point value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplinePointKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplinePointKeyFrame.StartChain(ui);
        }
    }

    public partial class SplinePointKeyFrame : PointKeyFrame, IUI<System.Windows.Media.Animation.SplinePointKeyFrame>
    {
        static SplinePointKeyFrame instance;

        internal static SplinePointKeyFrame StartChain(Windows.Media.Animation.SplinePointKeyFrame ui)
        {
            if (instance == null) instance = new SplinePointKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplinePointKeyFrame ui;

        public new Windows.Media.Animation.SplinePointKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplinePointKeyFrame(SplinePointKeyFrame view) => view?.UI;

        public static implicit operator SplinePointKeyFrame(Windows.Media.Animation.SplinePointKeyFrame ui) => SplinePointKeyFrame.StartChain(ui);

        protected SplinePointKeyFrame() { }
    }

    public static partial class SplinePointKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplinePointKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplinePointKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplinePointKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplinePointKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplinePointKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineQuaternionKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame"/></summary>
        public static SplineQuaternionKeyFrame SplineQuaternionKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default, O<bool> UseShortestPath = default)
        {
            var ui = new Windows.Media.Animation.SplineQuaternionKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            if (UseShortestPath.HasValue) ui.UseShortestPath = UseShortestPath.Value;
            return global::CSharpMarkup.Wpf.SplineQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame"/></summary>
        public static SplineQuaternionKeyFrame SplineQuaternionKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineQuaternionKeyFrame();
            return global::CSharpMarkup.Wpf.SplineQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame"/></summary>
        public static SplineQuaternionKeyFrame SplineQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value)
        {
            var ui = new Windows.Media.Animation.SplineQuaternionKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame"/></summary>
        public static SplineQuaternionKeyFrame SplineQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineQuaternionKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineQuaternionKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame"/></summary>
        public static SplineQuaternionKeyFrame SplineQuaternionKeyFrame(Windows.Media.Media3D.Quaternion value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineQuaternionKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineQuaternionKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineQuaternionKeyFrame : QuaternionKeyFrame, IUI<System.Windows.Media.Animation.SplineQuaternionKeyFrame>
    {
        static SplineQuaternionKeyFrame instance;

        internal static SplineQuaternionKeyFrame StartChain(Windows.Media.Animation.SplineQuaternionKeyFrame ui)
        {
            if (instance == null) instance = new SplineQuaternionKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineQuaternionKeyFrame ui;

        public new Windows.Media.Animation.SplineQuaternionKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineQuaternionKeyFrame(SplineQuaternionKeyFrame view) => view?.UI;

        public static implicit operator SplineQuaternionKeyFrame(Windows.Media.Animation.SplineQuaternionKeyFrame ui) => SplineQuaternionKeyFrame.StartChain(ui);

        protected SplineQuaternionKeyFrame() { }
    }

    public static partial class SplineQuaternionKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineQuaternionKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame.UseShortestPath"/></summary>
        public static TView UseShortestPath<TView>(this TView view, bool value) where TView : SplineQuaternionKeyFrame { view.UI.UseShortestPath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineQuaternionKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineQuaternionKeyFrame.KeySplineProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineQuaternionKeyFrame.UseShortestPath"/></summary>
        public static DependencyProperty<TTarget, bool> UseShortestPath<TTarget>(this TTarget target) where TTarget : SplineQuaternionKeyFrame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.SplineQuaternionKeyFrame.UseShortestPathProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineRectKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRectKeyFrame"/></summary>
        public static SplineRectKeyFrame SplineRectKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineRectKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRectKeyFrame"/></summary>
        public static SplineRectKeyFrame SplineRectKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineRectKeyFrame();
            return global::CSharpMarkup.Wpf.SplineRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRectKeyFrame"/></summary>
        public static SplineRectKeyFrame SplineRectKeyFrame(Windows.Rect value)
        {
            var ui = new Windows.Media.Animation.SplineRectKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRectKeyFrame"/></summary>
        public static SplineRectKeyFrame SplineRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineRectKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineRectKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRectKeyFrame"/></summary>
        public static SplineRectKeyFrame SplineRectKeyFrame(Windows.Rect value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineRectKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineRectKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineRectKeyFrame : RectKeyFrame, IUI<System.Windows.Media.Animation.SplineRectKeyFrame>
    {
        static SplineRectKeyFrame instance;

        internal static SplineRectKeyFrame StartChain(Windows.Media.Animation.SplineRectKeyFrame ui)
        {
            if (instance == null) instance = new SplineRectKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineRectKeyFrame ui;

        public new Windows.Media.Animation.SplineRectKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineRectKeyFrame(SplineRectKeyFrame view) => view?.UI;

        public static implicit operator SplineRectKeyFrame(Windows.Media.Animation.SplineRectKeyFrame ui) => SplineRectKeyFrame.StartChain(ui);

        protected SplineRectKeyFrame() { }
    }

    public static partial class SplineRectKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineRectKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineRectKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineRectKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineRectKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineRectKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineRotation3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame"/></summary>
        public static SplineRotation3DKeyFrame SplineRotation3DKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineRotation3DKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame"/></summary>
        public static SplineRotation3DKeyFrame SplineRotation3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineRotation3DKeyFrame();
            return global::CSharpMarkup.Wpf.SplineRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame"/></summary>
        public static SplineRotation3DKeyFrame SplineRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value)
        {
            var ui = new Windows.Media.Animation.SplineRotation3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame"/></summary>
        public static SplineRotation3DKeyFrame SplineRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineRotation3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineRotation3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame"/></summary>
        public static SplineRotation3DKeyFrame SplineRotation3DKeyFrame(Windows.Media.Media3D.Rotation3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineRotation3DKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineRotation3DKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineRotation3DKeyFrame : Rotation3DKeyFrame, IUI<System.Windows.Media.Animation.SplineRotation3DKeyFrame>
    {
        static SplineRotation3DKeyFrame instance;

        internal static SplineRotation3DKeyFrame StartChain(Windows.Media.Animation.SplineRotation3DKeyFrame ui)
        {
            if (instance == null) instance = new SplineRotation3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineRotation3DKeyFrame ui;

        public new Windows.Media.Animation.SplineRotation3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineRotation3DKeyFrame(SplineRotation3DKeyFrame view) => view?.UI;

        public static implicit operator SplineRotation3DKeyFrame(Windows.Media.Animation.SplineRotation3DKeyFrame ui) => SplineRotation3DKeyFrame.StartChain(ui);

        protected SplineRotation3DKeyFrame() { }
    }

    public static partial class SplineRotation3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineRotation3DKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineRotation3DKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineRotation3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineRotation3DKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineSingleKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSingleKeyFrame"/></summary>
        public static SplineSingleKeyFrame SplineSingleKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineSingleKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSingleKeyFrame"/></summary>
        public static SplineSingleKeyFrame SplineSingleKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineSingleKeyFrame();
            return global::CSharpMarkup.Wpf.SplineSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSingleKeyFrame"/></summary>
        public static SplineSingleKeyFrame SplineSingleKeyFrame(float value)
        {
            var ui = new Windows.Media.Animation.SplineSingleKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSingleKeyFrame"/></summary>
        public static SplineSingleKeyFrame SplineSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineSingleKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineSingleKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSingleKeyFrame"/></summary>
        public static SplineSingleKeyFrame SplineSingleKeyFrame(float value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineSingleKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineSingleKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineSingleKeyFrame : SingleKeyFrame, IUI<System.Windows.Media.Animation.SplineSingleKeyFrame>
    {
        static SplineSingleKeyFrame instance;

        internal static SplineSingleKeyFrame StartChain(Windows.Media.Animation.SplineSingleKeyFrame ui)
        {
            if (instance == null) instance = new SplineSingleKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineSingleKeyFrame ui;

        public new Windows.Media.Animation.SplineSingleKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineSingleKeyFrame(SplineSingleKeyFrame view) => view?.UI;

        public static implicit operator SplineSingleKeyFrame(Windows.Media.Animation.SplineSingleKeyFrame ui) => SplineSingleKeyFrame.StartChain(ui);

        protected SplineSingleKeyFrame() { }
    }

    public static partial class SplineSingleKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineSingleKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineSingleKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineSingleKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineSingleKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineSingleKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineSizeKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSizeKeyFrame"/></summary>
        public static SplineSizeKeyFrame SplineSizeKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineSizeKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSizeKeyFrame"/></summary>
        public static SplineSizeKeyFrame SplineSizeKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineSizeKeyFrame();
            return global::CSharpMarkup.Wpf.SplineSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSizeKeyFrame"/></summary>
        public static SplineSizeKeyFrame SplineSizeKeyFrame(Windows.Size value)
        {
            var ui = new Windows.Media.Animation.SplineSizeKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSizeKeyFrame"/></summary>
        public static SplineSizeKeyFrame SplineSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineSizeKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineSizeKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineSizeKeyFrame"/></summary>
        public static SplineSizeKeyFrame SplineSizeKeyFrame(Windows.Size value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineSizeKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineSizeKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineSizeKeyFrame : SizeKeyFrame, IUI<System.Windows.Media.Animation.SplineSizeKeyFrame>
    {
        static SplineSizeKeyFrame instance;

        internal static SplineSizeKeyFrame StartChain(Windows.Media.Animation.SplineSizeKeyFrame ui)
        {
            if (instance == null) instance = new SplineSizeKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineSizeKeyFrame ui;

        public new Windows.Media.Animation.SplineSizeKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineSizeKeyFrame(SplineSizeKeyFrame view) => view?.UI;

        public static implicit operator SplineSizeKeyFrame(Windows.Media.Animation.SplineSizeKeyFrame ui) => SplineSizeKeyFrame.StartChain(ui);

        protected SplineSizeKeyFrame() { }
    }

    public static partial class SplineSizeKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineSizeKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineSizeKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineSizeKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineSizeKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineSizeKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineVector3DKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVector3DKeyFrame"/></summary>
        public static SplineVector3DKeyFrame SplineVector3DKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineVector3DKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVector3DKeyFrame"/></summary>
        public static SplineVector3DKeyFrame SplineVector3DKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineVector3DKeyFrame();
            return global::CSharpMarkup.Wpf.SplineVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVector3DKeyFrame"/></summary>
        public static SplineVector3DKeyFrame SplineVector3DKeyFrame(Windows.Media.Media3D.Vector3D value)
        {
            var ui = new Windows.Media.Animation.SplineVector3DKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVector3DKeyFrame"/></summary>
        public static SplineVector3DKeyFrame SplineVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineVector3DKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineVector3DKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVector3DKeyFrame"/></summary>
        public static SplineVector3DKeyFrame SplineVector3DKeyFrame(Windows.Media.Media3D.Vector3D value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineVector3DKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineVector3DKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineVector3DKeyFrame : Vector3DKeyFrame, IUI<System.Windows.Media.Animation.SplineVector3DKeyFrame>
    {
        static SplineVector3DKeyFrame instance;

        internal static SplineVector3DKeyFrame StartChain(Windows.Media.Animation.SplineVector3DKeyFrame ui)
        {
            if (instance == null) instance = new SplineVector3DKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineVector3DKeyFrame ui;

        public new Windows.Media.Animation.SplineVector3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineVector3DKeyFrame(SplineVector3DKeyFrame view) => view?.UI;

        public static implicit operator SplineVector3DKeyFrame(Windows.Media.Animation.SplineVector3DKeyFrame ui) => SplineVector3DKeyFrame.StartChain(ui);

        protected SplineVector3DKeyFrame() { }
    }

    public static partial class SplineVector3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineVector3DKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineVector3DKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineVector3DKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineVector3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineVector3DKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // SplineVectorKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVectorKeyFrame"/></summary>
        public static SplineVectorKeyFrame SplineVectorKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineVectorKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVectorKeyFrame"/></summary>
        public static SplineVectorKeyFrame SplineVectorKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineVectorKeyFrame();
            return global::CSharpMarkup.Wpf.SplineVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVectorKeyFrame"/></summary>
        public static SplineVectorKeyFrame SplineVectorKeyFrame(Windows.Vector value)
        {
            var ui = new Windows.Media.Animation.SplineVectorKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVectorKeyFrame"/></summary>
        public static SplineVectorKeyFrame SplineVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineVectorKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineVectorKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineVectorKeyFrame"/></summary>
        public static SplineVectorKeyFrame SplineVectorKeyFrame(Windows.Vector value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineVectorKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineVectorKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineVectorKeyFrame : VectorKeyFrame, IUI<System.Windows.Media.Animation.SplineVectorKeyFrame>
    {
        static SplineVectorKeyFrame instance;

        internal static SplineVectorKeyFrame StartChain(Windows.Media.Animation.SplineVectorKeyFrame ui)
        {
            if (instance == null) instance = new SplineVectorKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineVectorKeyFrame ui;

        public new Windows.Media.Animation.SplineVectorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineVectorKeyFrame(SplineVectorKeyFrame view) => view?.UI;

        public static implicit operator SplineVectorKeyFrame(Windows.Media.Animation.SplineVectorKeyFrame ui) => SplineVectorKeyFrame.StartChain(ui);

        protected SplineVectorKeyFrame() { }
    }

    public static partial class SplineVectorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineVectorKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineVectorKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineVectorKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineVectorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineVectorKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // StringAnimationBase
{
    public partial class StringAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.StringAnimationBase>
    {
        Windows.Media.Animation.StringAnimationBase ui;

        public new Windows.Media.Animation.StringAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected StringAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // StringAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.StringAnimationUsingKeyFrames"/></summary>
        public static StringAnimationUsingKeyFrames StringAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.StringKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.StringAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.StringAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.StringAnimationUsingKeyFrames"/></summary>
        public static StringAnimationUsingKeyFrames StringAnimationUsingKeyFrames(O<Windows.Media.Animation.StringKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.StringAnimationUsingKeyFrames();
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.StringAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.StringAnimationUsingKeyFrames"/></summary>
        public static StringAnimationUsingKeyFrames StringAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.StringAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.StringAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class StringAnimationUsingKeyFrames : StringAnimationBase, IUI<System.Windows.Media.Animation.StringAnimationUsingKeyFrames>
    {
        static StringAnimationUsingKeyFrames instance;

        internal static StringAnimationUsingKeyFrames StartChain(Windows.Media.Animation.StringAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new StringAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.StringAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.StringAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.StringAnimationUsingKeyFrames(StringAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator StringAnimationUsingKeyFrames(Windows.Media.Animation.StringAnimationUsingKeyFrames ui) => StringAnimationUsingKeyFrames.StartChain(ui);

        protected StringAnimationUsingKeyFrames() { }
    }

    public static partial class StringAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.StringAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.StringKeyFrameCollection value) where TView : StringAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // StringKeyFrame
{
    public partial class StringKeyFrame : Freezable, IUI<System.Windows.Media.Animation.StringKeyFrame>
    {
        Windows.Media.Animation.StringKeyFrame ui;

        public new Windows.Media.Animation.StringKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected StringKeyFrame() { }
    }

    public static partial class StringKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.StringKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : StringKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.StringKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, string value) where TView : StringKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.StringKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : StringKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.StringKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.StringKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, string> Value<TTarget>(this TTarget target) where TTarget : StringKeyFrame
        => DependencyProperty<TTarget, string>.Get(target, Windows.Media.Animation.StringKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // StringKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.StringKeyFrameCollection"/></summary>
        public static StringKeyFrameCollection StringKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.StringKeyFrameCollection();
            return global::CSharpMarkup.Wpf.StringKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class StringKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.StringKeyFrameCollection>
    {
        static StringKeyFrameCollection instance;

        internal static StringKeyFrameCollection StartChain(Windows.Media.Animation.StringKeyFrameCollection ui)
        {
            if (instance == null) instance = new StringKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.StringKeyFrameCollection ui;

        public new Windows.Media.Animation.StringKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.StringKeyFrameCollection(StringKeyFrameCollection view) => view?.UI;

        public static implicit operator StringKeyFrameCollection(Windows.Media.Animation.StringKeyFrameCollection ui) => StringKeyFrameCollection.StartChain(ui);

        protected StringKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Timeline
{
    public partial class Timeline : Animatable, IUI<System.Windows.Media.Animation.Timeline>
    {
        Windows.Media.Animation.Timeline ui;

        public new Windows.Media.Animation.Timeline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Timeline() { }
    }

    public static partial class TimelineExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.AccelerationRatio"/></summary>
        public static TView AccelerationRatio<TView>(this TView view, double value) where TView : Timeline { view.UI.AccelerationRatio = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.AutoReverse"/></summary>
        public static TView AutoReverse<TView>(this TView view, bool value) where TView : Timeline { view.UI.AutoReverse = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.BeginTime"/></summary>
        public static TView BeginTime<TView>(this TView view, TimeSpan? value) where TView : Timeline { view.UI.BeginTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.DecelerationRatio"/></summary>
        public static TView DecelerationRatio<TView>(this TView view, double value) where TView : Timeline { view.UI.DecelerationRatio = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.Duration"/></summary>
        public static TView Duration<TView>(this TView view, Windows.Duration value) where TView : Timeline { view.UI.Duration = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.FillBehavior"/></summary>
        public static TView FillBehavior<TView>(this TView view, Windows.Media.Animation.FillBehavior value) where TView : Timeline { view.UI.FillBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : Timeline { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.RepeatBehavior"/></summary>
        public static TView RepeatBehavior<TView>(this TView view, Windows.Media.Animation.RepeatBehavior value) where TView : Timeline { view.UI.RepeatBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.SpeedRatio"/></summary>
        public static TView SpeedRatio<TView>(this TView view, double value) where TView : Timeline { view.UI.SpeedRatio = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.AccelerationRatio"/></summary>
        public static DependencyProperty<TTarget, double> AccelerationRatio<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.Timeline.AccelerationRatioProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.AutoReverse"/></summary>
        public static DependencyProperty<TTarget, bool> AutoReverse<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Animation.Timeline.AutoReverseProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.BeginTime"/></summary>
        public static DependencyProperty<TTarget, TimeSpan?> BeginTime<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, TimeSpan?>.Get(target, Windows.Media.Animation.Timeline.BeginTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.DecelerationRatio"/></summary>
        public static DependencyProperty<TTarget, double> DecelerationRatio<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.Timeline.DecelerationRatioProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.Duration"/></summary>
        public static DependencyProperty<TTarget, Windows.Duration> Duration<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, Windows.Duration>.Get(target, Windows.Media.Animation.Timeline.DurationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.FillBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.FillBehavior> FillBehavior<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, Windows.Media.Animation.FillBehavior>.Get(target, Windows.Media.Animation.Timeline.FillBehaviorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.Name"/></summary>
        public static DependencyProperty<TTarget, string> Name<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, string>.Get(target, Windows.Media.Animation.Timeline.NameProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.RepeatBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.RepeatBehavior> RepeatBehavior<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, Windows.Media.Animation.RepeatBehavior>.Get(target, Windows.Media.Animation.Timeline.RepeatBehaviorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.SpeedRatio"/></summary>
        public static DependencyProperty<TTarget, double> SpeedRatio<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Animation.Timeline.SpeedRatioProperty);

        /// <summary>Set <see cref="Windows.Media.Animation.Timeline.DesiredFrameRate"/></summary>
        public static TTarget Timeline_DesiredFrameRate<TTarget>(this TTarget target, int? value) where TTarget : Timeline
        { Windows.Media.Animation.Timeline.SetDesiredFrameRate(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Timeline.DesiredFrameRate"/></summary>
        public static DependencyProperty<TTarget, int?> Timeline_DesiredFrameRate<TTarget>(this TTarget target) where TTarget : Timeline
        => DependencyProperty<TTarget, int?>.Get(target, Windows.Media.Animation.Timeline.DesiredFrameRateProperty);
    }
}

namespace CSharpMarkup.Wpf // TimelineCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.TimelineCollection"/></summary>
        public static TimelineCollection TimelineCollection()
        {
            var ui = new Windows.Media.Animation.TimelineCollection();
            return global::CSharpMarkup.Wpf.TimelineCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.TimelineCollection"/></summary>
        public static TimelineCollection TimelineCollection(IEnumerable<Windows.Media.Animation.Timeline> collection)
        {
            var ui = new Windows.Media.Animation.TimelineCollection(collection);
            return global::CSharpMarkup.Wpf.TimelineCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.TimelineCollection"/></summary>
        public static TimelineCollection TimelineCollection(int capacity)
        {
            var ui = new Windows.Media.Animation.TimelineCollection(capacity);
            return global::CSharpMarkup.Wpf.TimelineCollection.StartChain(ui);
        }
    }

    public partial class TimelineCollection : Animatable, IUI<System.Windows.Media.Animation.TimelineCollection>
    {
        static TimelineCollection instance;

        internal static TimelineCollection StartChain(Windows.Media.Animation.TimelineCollection ui)
        {
            if (instance == null) instance = new TimelineCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.TimelineCollection ui;

        public new Windows.Media.Animation.TimelineCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.TimelineCollection(TimelineCollection view) => view?.UI;

        public static implicit operator TimelineCollection(Windows.Media.Animation.TimelineCollection ui) => TimelineCollection.StartChain(ui);

        protected TimelineCollection() { }
    }
}

namespace CSharpMarkup.Wpf // TimelineGroup
{
    public partial class TimelineGroup : Timeline, IUI<System.Windows.Media.Animation.TimelineGroup>
    {
        Windows.Media.Animation.TimelineGroup ui;

        public new Windows.Media.Animation.TimelineGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TimelineGroup() { }
    }

    public static partial class TimelineGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.TimelineGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Animation.TimelineCollection value) where TView : TimelineGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.TimelineGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.TimelineCollection> Children<TTarget>(this TTarget target) where TTarget : TimelineGroup
        => DependencyProperty<TTarget, Windows.Media.Animation.TimelineCollection>.Get(target, Windows.Media.Animation.TimelineGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // Vector3DAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation(O<Windows.Media.Media3D.Vector3D?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Media.Media3D.Vector3D?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Media3D.Vector3D?> To = default)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation()
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation();
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation(Windows.Media.Media3D.Vector3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation(Windows.Media.Media3D.Vector3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation(Windows.Media.Media3D.Vector3D fromValue, Windows.Media.Media3D.Vector3D toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimation"/></summary>
        public static Vector3DAnimation Vector3DAnimation(Windows.Media.Media3D.Vector3D fromValue, Windows.Media.Media3D.Vector3D toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.Vector3DAnimation.StartChain(ui);
        }
    }

    public partial class Vector3DAnimation : Vector3DAnimationBase, IUI<System.Windows.Media.Animation.Vector3DAnimation>
    {
        static Vector3DAnimation instance;

        internal static Vector3DAnimation StartChain(Windows.Media.Animation.Vector3DAnimation ui)
        {
            if (instance == null) instance = new Vector3DAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Vector3DAnimation ui;

        public new Windows.Media.Animation.Vector3DAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Vector3DAnimation(Vector3DAnimation view) => view?.UI;

        public static implicit operator Vector3DAnimation(Windows.Media.Animation.Vector3DAnimation ui) => Vector3DAnimation.StartChain(ui);

        protected Vector3DAnimation() { }
    }

    public static partial class Vector3DAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Media.Media3D.Vector3D? value) where TView : Vector3DAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : Vector3DAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Media.Media3D.Vector3D? value) where TView : Vector3DAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Vector3DAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Vector3DAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Media.Media3D.Vector3D? value) where TView : Vector3DAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?> By<TTarget>(this TTarget target) where TTarget : Vector3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?>.Get(target, Windows.Media.Animation.Vector3DAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : Vector3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.Vector3DAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?> From<TTarget>(this TTarget target) where TTarget : Vector3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?>.Get(target, Windows.Media.Animation.Vector3DAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?> To<TTarget>(this TTarget target) where TTarget : Vector3DAnimation
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D?>.Get(target, Windows.Media.Animation.Vector3DAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // Vector3DAnimationBase
{
    public partial class Vector3DAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.Vector3DAnimationBase>
    {
        Windows.Media.Animation.Vector3DAnimationBase ui;

        public new Windows.Media.Animation.Vector3DAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Vector3DAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // Vector3DAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames"/></summary>
        public static Vector3DAnimationUsingKeyFrames Vector3DAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.Vector3DKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.Vector3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames"/></summary>
        public static Vector3DAnimationUsingKeyFrames Vector3DAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.Vector3DKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.Vector3DAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.Vector3DAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames"/></summary>
        public static Vector3DAnimationUsingKeyFrames Vector3DAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.Vector3DAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.Vector3DAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class Vector3DAnimationUsingKeyFrames : Vector3DAnimationBase, IUI<System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames>
    {
        static Vector3DAnimationUsingKeyFrames instance;

        internal static Vector3DAnimationUsingKeyFrames StartChain(Windows.Media.Animation.Vector3DAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new Vector3DAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Vector3DAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.Vector3DAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Vector3DAnimationUsingKeyFrames(Vector3DAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator Vector3DAnimationUsingKeyFrames(Windows.Media.Animation.Vector3DAnimationUsingKeyFrames ui) => Vector3DAnimationUsingKeyFrames.StartChain(ui);

        protected Vector3DAnimationUsingKeyFrames() { }
    }

    public static partial class Vector3DAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : Vector3DAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : Vector3DAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.Vector3DKeyFrameCollection value) where TView : Vector3DAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Vector3DKeyFrame
{
    public partial class Vector3DKeyFrame : Freezable, IUI<System.Windows.Media.Animation.Vector3DKeyFrame>
    {
        Windows.Media.Animation.Vector3DKeyFrame ui;

        public new Windows.Media.Animation.Vector3DKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Vector3DKeyFrame() { }
    }

    public static partial class Vector3DKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : Vector3DKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.Vector3DKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : Vector3DKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : Vector3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.Vector3DKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Vector3DKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> Value<TTarget>(this TTarget target) where TTarget : Vector3DKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Animation.Vector3DKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // Vector3DKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Vector3DKeyFrameCollection"/></summary>
        public static Vector3DKeyFrameCollection Vector3DKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.Vector3DKeyFrameCollection();
            return global::CSharpMarkup.Wpf.Vector3DKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class Vector3DKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.Vector3DKeyFrameCollection>
    {
        static Vector3DKeyFrameCollection instance;

        internal static Vector3DKeyFrameCollection StartChain(Windows.Media.Animation.Vector3DKeyFrameCollection ui)
        {
            if (instance == null) instance = new Vector3DKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Vector3DKeyFrameCollection ui;

        public new Windows.Media.Animation.Vector3DKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Vector3DKeyFrameCollection(Vector3DKeyFrameCollection view) => view?.UI;

        public static implicit operator Vector3DKeyFrameCollection(Windows.Media.Animation.Vector3DKeyFrameCollection ui) => Vector3DKeyFrameCollection.StartChain(ui);

        protected Vector3DKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // VectorAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation(O<Windows.Vector?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Vector?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Vector?> To = default)
        {
            var ui = new Windows.Media.Animation.VectorAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation()
        {
            var ui = new Windows.Media.Animation.VectorAnimation();
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation(Windows.Vector toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.VectorAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation(Windows.Vector toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.VectorAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation(Windows.Vector fromValue, Windows.Vector toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.VectorAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimation"/></summary>
        public static VectorAnimation VectorAnimation(Windows.Vector fromValue, Windows.Vector toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.VectorAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.VectorAnimation.StartChain(ui);
        }
    }

    public partial class VectorAnimation : VectorAnimationBase, IUI<System.Windows.Media.Animation.VectorAnimation>
    {
        static VectorAnimation instance;

        internal static VectorAnimation StartChain(Windows.Media.Animation.VectorAnimation ui)
        {
            if (instance == null) instance = new VectorAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.VectorAnimation ui;

        public new Windows.Media.Animation.VectorAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.VectorAnimation(VectorAnimation view) => view?.UI;

        public static implicit operator VectorAnimation(Windows.Media.Animation.VectorAnimation ui) => VectorAnimation.StartChain(ui);

        protected VectorAnimation() { }
    }

    public static partial class VectorAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Vector? value) where TView : VectorAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : VectorAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Vector? value) where TView : VectorAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : VectorAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : VectorAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Vector? value) where TView : VectorAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Vector?> By<TTarget>(this TTarget target) where TTarget : VectorAnimation
        => DependencyProperty<TTarget, Windows.Vector?>.Get(target, Windows.Media.Animation.VectorAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : VectorAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.VectorAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Vector?> From<TTarget>(this TTarget target) where TTarget : VectorAnimation
        => DependencyProperty<TTarget, Windows.Vector?>.Get(target, Windows.Media.Animation.VectorAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Vector?> To<TTarget>(this TTarget target) where TTarget : VectorAnimation
        => DependencyProperty<TTarget, Windows.Vector?>.Get(target, Windows.Media.Animation.VectorAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // VectorAnimationBase
{
    public partial class VectorAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.VectorAnimationBase>
    {
        Windows.Media.Animation.VectorAnimationBase ui;

        public new Windows.Media.Animation.VectorAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected VectorAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // VectorAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames"/></summary>
        public static VectorAnimationUsingKeyFrames VectorAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.VectorKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.VectorAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.VectorAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames"/></summary>
        public static VectorAnimationUsingKeyFrames VectorAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.VectorKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.VectorAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.VectorAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames"/></summary>
        public static VectorAnimationUsingKeyFrames VectorAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.VectorAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.VectorAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class VectorAnimationUsingKeyFrames : VectorAnimationBase, IUI<System.Windows.Media.Animation.VectorAnimationUsingKeyFrames>
    {
        static VectorAnimationUsingKeyFrames instance;

        internal static VectorAnimationUsingKeyFrames StartChain(Windows.Media.Animation.VectorAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new VectorAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.VectorAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.VectorAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.VectorAnimationUsingKeyFrames(VectorAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator VectorAnimationUsingKeyFrames(Windows.Media.Animation.VectorAnimationUsingKeyFrames ui) => VectorAnimationUsingKeyFrames.StartChain(ui);

        protected VectorAnimationUsingKeyFrames() { }
    }

    public static partial class VectorAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : VectorAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : VectorAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.VectorKeyFrameCollection value) where TView : VectorAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // VectorKeyFrame
{
    public partial class VectorKeyFrame : Freezable, IUI<System.Windows.Media.Animation.VectorKeyFrame>
    {
        Windows.Media.Animation.VectorKeyFrame ui;

        public new Windows.Media.Animation.VectorKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected VectorKeyFrame() { }
    }

    public static partial class VectorKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.VectorKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : VectorKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.VectorKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Vector value) where TView : VectorKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : VectorKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.VectorKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.VectorKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Vector> Value<TTarget>(this TTarget target) where TTarget : VectorKeyFrame
        => DependencyProperty<TTarget, Windows.Vector>.Get(target, Windows.Media.Animation.VectorKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // VectorKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.VectorKeyFrameCollection"/></summary>
        public static VectorKeyFrameCollection VectorKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.VectorKeyFrameCollection();
            return global::CSharpMarkup.Wpf.VectorKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class VectorKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.VectorKeyFrameCollection>
    {
        static VectorKeyFrameCollection instance;

        internal static VectorKeyFrameCollection StartChain(Windows.Media.Animation.VectorKeyFrameCollection ui)
        {
            if (instance == null) instance = new VectorKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.VectorKeyFrameCollection ui;

        public new Windows.Media.Animation.VectorKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.VectorKeyFrameCollection(VectorKeyFrameCollection view) => view?.UI;

        public static implicit operator VectorKeyFrameCollection(Windows.Media.Animation.VectorKeyFrameCollection ui) => VectorKeyFrameCollection.StartChain(ui);

        protected VectorKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // BevelBitmapEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BevelBitmapEffect"/></summary>
        public static BevelBitmapEffect BevelBitmapEffect(O<double> BevelWidth = default, O<Windows.Media.Effects.EdgeProfile> EdgeProfile = default, O<double> LightAngle = default, O<double> Relief = default, O<double> Smoothness = default)
        {
            var ui = new Windows.Media.Effects.BevelBitmapEffect();
            if (BevelWidth.HasValue) ui.BevelWidth = BevelWidth.Value;
            if (EdgeProfile.HasValue) ui.EdgeProfile = EdgeProfile.Value;
            if (LightAngle.HasValue) ui.LightAngle = LightAngle.Value;
            if (Relief.HasValue) ui.Relief = Relief.Value;
            if (Smoothness.HasValue) ui.Smoothness = Smoothness.Value;
            return global::CSharpMarkup.Wpf.BevelBitmapEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BevelBitmapEffect"/></summary>
        public static BevelBitmapEffect BevelBitmapEffect()
        {
            var ui = new Windows.Media.Effects.BevelBitmapEffect();
            return global::CSharpMarkup.Wpf.BevelBitmapEffect.StartChain(ui);
        }
    }

    public partial class BevelBitmapEffect : BitmapEffect, IUI<System.Windows.Media.Effects.BevelBitmapEffect>
    {
        static BevelBitmapEffect instance;

        internal static BevelBitmapEffect StartChain(Windows.Media.Effects.BevelBitmapEffect ui)
        {
            if (instance == null) instance = new BevelBitmapEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BevelBitmapEffect ui;

        public new Windows.Media.Effects.BevelBitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BevelBitmapEffect(BevelBitmapEffect view) => view?.UI;

        public static implicit operator BevelBitmapEffect(Windows.Media.Effects.BevelBitmapEffect ui) => BevelBitmapEffect.StartChain(ui);

        protected BevelBitmapEffect() { }
    }

    public static partial class BevelBitmapEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.BevelBitmapEffect.BevelWidth"/></summary>
        public static TView BevelWidth<TView>(this TView view, double value) where TView : BevelBitmapEffect { view.UI.BevelWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BevelBitmapEffect.EdgeProfile"/></summary>
        public static TView EdgeProfile<TView>(this TView view, Windows.Media.Effects.EdgeProfile value) where TView : BevelBitmapEffect { view.UI.EdgeProfile = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BevelBitmapEffect.LightAngle"/></summary>
        public static TView LightAngle<TView>(this TView view, double value) where TView : BevelBitmapEffect { view.UI.LightAngle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BevelBitmapEffect.Relief"/></summary>
        public static TView Relief<TView>(this TView view, double value) where TView : BevelBitmapEffect { view.UI.Relief = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BevelBitmapEffect.Smoothness"/></summary>
        public static TView Smoothness<TView>(this TView view, double value) where TView : BevelBitmapEffect { view.UI.Smoothness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BevelBitmapEffect.BevelWidth"/></summary>
        public static DependencyProperty<TTarget, double> BevelWidth<TTarget>(this TTarget target) where TTarget : BevelBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BevelBitmapEffect.BevelWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BevelBitmapEffect.EdgeProfile"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile> EdgeProfile<TTarget>(this TTarget target) where TTarget : BevelBitmapEffect
        => DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile>.Get(target, Windows.Media.Effects.BevelBitmapEffect.EdgeProfileProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BevelBitmapEffect.LightAngle"/></summary>
        public static DependencyProperty<TTarget, double> LightAngle<TTarget>(this TTarget target) where TTarget : BevelBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BevelBitmapEffect.LightAngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BevelBitmapEffect.Relief"/></summary>
        public static DependencyProperty<TTarget, double> Relief<TTarget>(this TTarget target) where TTarget : BevelBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BevelBitmapEffect.ReliefProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BevelBitmapEffect.Smoothness"/></summary>
        public static DependencyProperty<TTarget, double> Smoothness<TTarget>(this TTarget target) where TTarget : BevelBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BevelBitmapEffect.SmoothnessProperty);
    }
}

namespace CSharpMarkup.Wpf // BitmapEffect
{
    public partial class BitmapEffect : Animatable, IUI<System.Windows.Media.Effects.BitmapEffect>
    {
        Windows.Media.Effects.BitmapEffect ui;

        public new Windows.Media.Effects.BitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BitmapEffect() { }
    }
}

namespace CSharpMarkup.Wpf // BitmapEffectCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectCollection"/></summary>
        public static BitmapEffectCollection BitmapEffectCollection()
        {
            var ui = new Windows.Media.Effects.BitmapEffectCollection();
            return global::CSharpMarkup.Wpf.BitmapEffectCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectCollection"/></summary>
        public static BitmapEffectCollection BitmapEffectCollection(IEnumerable<Windows.Media.Effects.BitmapEffect> collection)
        {
            var ui = new Windows.Media.Effects.BitmapEffectCollection(collection);
            return global::CSharpMarkup.Wpf.BitmapEffectCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectCollection"/></summary>
        public static BitmapEffectCollection BitmapEffectCollection(int capacity)
        {
            var ui = new Windows.Media.Effects.BitmapEffectCollection(capacity);
            return global::CSharpMarkup.Wpf.BitmapEffectCollection.StartChain(ui);
        }
    }

    public partial class BitmapEffectCollection : Animatable, IUI<System.Windows.Media.Effects.BitmapEffectCollection>
    {
        static BitmapEffectCollection instance;

        internal static BitmapEffectCollection StartChain(Windows.Media.Effects.BitmapEffectCollection ui)
        {
            if (instance == null) instance = new BitmapEffectCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BitmapEffectCollection ui;

        public new Windows.Media.Effects.BitmapEffectCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BitmapEffectCollection(BitmapEffectCollection view) => view?.UI;

        public static implicit operator BitmapEffectCollection(Windows.Media.Effects.BitmapEffectCollection ui) => BitmapEffectCollection.StartChain(ui);

        protected BitmapEffectCollection() { }
    }
}

namespace CSharpMarkup.Wpf // BitmapEffectGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectGroup"/></summary>
        public static BitmapEffectGroup BitmapEffectGroup(
            params System.Windows.Media.Effects.BitmapEffect[] Children
)
        {
            var ui = new Windows.Media.Effects.BitmapEffectGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.BitmapEffectGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectGroup"/></summary>
        public static BitmapEffectGroup BitmapEffectGroup(O<Windows.Media.Effects.BitmapEffectCollection> Children = default)
        {
            var ui = new Windows.Media.Effects.BitmapEffectGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.BitmapEffectGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectGroup"/></summary>
        public static BitmapEffectGroup BitmapEffectGroup()
        {
            var ui = new Windows.Media.Effects.BitmapEffectGroup();
            return global::CSharpMarkup.Wpf.BitmapEffectGroup.StartChain(ui);
        }
    }

    public partial class BitmapEffectGroup : BitmapEffect, IUI<System.Windows.Media.Effects.BitmapEffectGroup>
    {
        static BitmapEffectGroup instance;

        internal static BitmapEffectGroup StartChain(Windows.Media.Effects.BitmapEffectGroup ui)
        {
            if (instance == null) instance = new BitmapEffectGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BitmapEffectGroup ui;

        public new Windows.Media.Effects.BitmapEffectGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BitmapEffectGroup(BitmapEffectGroup view) => view?.UI;

        public static implicit operator BitmapEffectGroup(Windows.Media.Effects.BitmapEffectGroup ui) => BitmapEffectGroup.StartChain(ui);

        protected BitmapEffectGroup() { }
    }

    public static partial class BitmapEffectGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.BitmapEffectGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Effects.BitmapEffectCollection value) where TView : BitmapEffectGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BitmapEffectGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectCollection> Children<TTarget>(this TTarget target) where TTarget : BitmapEffectGroup
        => DependencyProperty<TTarget, Windows.Media.Effects.BitmapEffectCollection>.Get(target, Windows.Media.Effects.BitmapEffectGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // BitmapEffectInput
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectInput"/></summary>
        public static BitmapEffectInput BitmapEffectInput(O<Windows.Rect> AreaToApplyEffect = default, O<Windows.Media.BrushMappingMode> AreaToApplyEffectUnits = default, O<Windows.Media.Imaging.BitmapSource> Input = default)
        {
            var ui = new Windows.Media.Effects.BitmapEffectInput();
            if (AreaToApplyEffect.HasValue) ui.AreaToApplyEffect = AreaToApplyEffect.Value;
            if (AreaToApplyEffectUnits.HasValue) ui.AreaToApplyEffectUnits = AreaToApplyEffectUnits.Value;
            if (Input.HasValue) ui.Input = Input.Value;
            return global::CSharpMarkup.Wpf.BitmapEffectInput.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectInput"/></summary>
        public static BitmapEffectInput BitmapEffectInput()
        {
            var ui = new Windows.Media.Effects.BitmapEffectInput();
            return global::CSharpMarkup.Wpf.BitmapEffectInput.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BitmapEffectInput"/></summary>
        public static BitmapEffectInput BitmapEffectInput(Windows.Media.Imaging.BitmapSource input)
        {
            var ui = new Windows.Media.Effects.BitmapEffectInput(input);
            return global::CSharpMarkup.Wpf.BitmapEffectInput.StartChain(ui);
        }
    }

    public partial class BitmapEffectInput : Animatable, IUI<System.Windows.Media.Effects.BitmapEffectInput>
    {
        static BitmapEffectInput instance;

        internal static BitmapEffectInput StartChain(Windows.Media.Effects.BitmapEffectInput ui)
        {
            if (instance == null) instance = new BitmapEffectInput();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BitmapEffectInput ui;

        public new Windows.Media.Effects.BitmapEffectInput UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BitmapEffectInput(BitmapEffectInput view) => view?.UI;

        public static implicit operator BitmapEffectInput(Windows.Media.Effects.BitmapEffectInput ui) => BitmapEffectInput.StartChain(ui);

        protected BitmapEffectInput() { }
    }

    public static partial class BitmapEffectInputExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffect"/></summary>
        public static TView AreaToApplyEffect<TView>(this TView view, Windows.Rect value) where TView : BitmapEffectInput { view.UI.AreaToApplyEffect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffectUnits"/></summary>
        public static TView AreaToApplyEffectUnits<TView>(this TView view, Windows.Media.BrushMappingMode value) where TView : BitmapEffectInput { view.UI.AreaToApplyEffectUnits = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BitmapEffectInput.Input"/></summary>
        public static TView Input<TView>(this TView view, Windows.Media.Imaging.BitmapSource value) where TView : BitmapEffectInput { view.UI.Input = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffect"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> AreaToApplyEffect<TTarget>(this TTarget target) where TTarget : BitmapEffectInput
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffectProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffectUnits"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.BrushMappingMode> AreaToApplyEffectUnits<TTarget>(this TTarget target) where TTarget : BitmapEffectInput
        => DependencyProperty<TTarget, Windows.Media.BrushMappingMode>.Get(target, Windows.Media.Effects.BitmapEffectInput.AreaToApplyEffectUnitsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BitmapEffectInput.Input"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource> Input<TTarget>(this TTarget target) where TTarget : BitmapEffectInput
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource>.Get(target, Windows.Media.Effects.BitmapEffectInput.InputProperty);
    }
}

namespace CSharpMarkup.Wpf // BlurBitmapEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BlurBitmapEffect"/></summary>
        public static BlurBitmapEffect BlurBitmapEffect(O<Windows.Media.Effects.KernelType> KernelType = default, O<double> Radius = default)
        {
            var ui = new Windows.Media.Effects.BlurBitmapEffect();
            if (KernelType.HasValue) ui.KernelType = KernelType.Value;
            if (Radius.HasValue) ui.Radius = Radius.Value;
            return global::CSharpMarkup.Wpf.BlurBitmapEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BlurBitmapEffect"/></summary>
        public static BlurBitmapEffect BlurBitmapEffect()
        {
            var ui = new Windows.Media.Effects.BlurBitmapEffect();
            return global::CSharpMarkup.Wpf.BlurBitmapEffect.StartChain(ui);
        }
    }

    public partial class BlurBitmapEffect : BitmapEffect, IUI<System.Windows.Media.Effects.BlurBitmapEffect>
    {
        static BlurBitmapEffect instance;

        internal static BlurBitmapEffect StartChain(Windows.Media.Effects.BlurBitmapEffect ui)
        {
            if (instance == null) instance = new BlurBitmapEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BlurBitmapEffect ui;

        public new Windows.Media.Effects.BlurBitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BlurBitmapEffect(BlurBitmapEffect view) => view?.UI;

        public static implicit operator BlurBitmapEffect(Windows.Media.Effects.BlurBitmapEffect ui) => BlurBitmapEffect.StartChain(ui);

        protected BlurBitmapEffect() { }
    }

    public static partial class BlurBitmapEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.BlurBitmapEffect.KernelType"/></summary>
        public static TView KernelType<TView>(this TView view, Windows.Media.Effects.KernelType value) where TView : BlurBitmapEffect { view.UI.KernelType = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BlurBitmapEffect.Radius"/></summary>
        public static TView Radius<TView>(this TView view, double value) where TView : BlurBitmapEffect { view.UI.Radius = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BlurBitmapEffect.KernelType"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.KernelType> KernelType<TTarget>(this TTarget target) where TTarget : BlurBitmapEffect
        => DependencyProperty<TTarget, Windows.Media.Effects.KernelType>.Get(target, Windows.Media.Effects.BlurBitmapEffect.KernelTypeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BlurBitmapEffect.Radius"/></summary>
        public static DependencyProperty<TTarget, double> Radius<TTarget>(this TTarget target) where TTarget : BlurBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BlurBitmapEffect.RadiusProperty);
    }
}

namespace CSharpMarkup.Wpf // BlurEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.BlurEffect"/></summary>
        public static BlurEffect BlurEffect(O<Windows.Media.Effects.KernelType> KernelType = default, O<double> Radius = default, O<Windows.Media.Effects.RenderingBias> RenderingBias = default)
        {
            var ui = new Windows.Media.Effects.BlurEffect();
            if (KernelType.HasValue) ui.KernelType = KernelType.Value;
            if (Radius.HasValue) ui.Radius = Radius.Value;
            if (RenderingBias.HasValue) ui.RenderingBias = RenderingBias.Value;
            return global::CSharpMarkup.Wpf.BlurEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.BlurEffect"/></summary>
        public static BlurEffect BlurEffect()
        {
            var ui = new Windows.Media.Effects.BlurEffect();
            return global::CSharpMarkup.Wpf.BlurEffect.StartChain(ui);
        }
    }

    public partial class BlurEffect : Effect, IUI<System.Windows.Media.Effects.BlurEffect>
    {
        static BlurEffect instance;

        internal static BlurEffect StartChain(Windows.Media.Effects.BlurEffect ui)
        {
            if (instance == null) instance = new BlurEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.BlurEffect ui;

        public new Windows.Media.Effects.BlurEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.BlurEffect(BlurEffect view) => view?.UI;

        public static implicit operator BlurEffect(Windows.Media.Effects.BlurEffect ui) => BlurEffect.StartChain(ui);

        protected BlurEffect() { }
    }

    public static partial class BlurEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.BlurEffect.KernelType"/></summary>
        public static TView KernelType<TView>(this TView view, Windows.Media.Effects.KernelType value) where TView : BlurEffect { view.UI.KernelType = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BlurEffect.Radius"/></summary>
        public static TView Radius<TView>(this TView view, double value) where TView : BlurEffect { view.UI.Radius = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.BlurEffect.RenderingBias"/></summary>
        public static TView RenderingBias<TView>(this TView view, Windows.Media.Effects.RenderingBias value) where TView : BlurEffect { view.UI.RenderingBias = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BlurEffect.KernelType"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.KernelType> KernelType<TTarget>(this TTarget target) where TTarget : BlurEffect
        => DependencyProperty<TTarget, Windows.Media.Effects.KernelType>.Get(target, Windows.Media.Effects.BlurEffect.KernelTypeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BlurEffect.Radius"/></summary>
        public static DependencyProperty<TTarget, double> Radius<TTarget>(this TTarget target) where TTarget : BlurEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.BlurEffect.RadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.BlurEffect.RenderingBias"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> RenderingBias<TTarget>(this TTarget target) where TTarget : BlurEffect
        => DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias>.Get(target, Windows.Media.Effects.BlurEffect.RenderingBiasProperty);
    }
}

namespace CSharpMarkup.Wpf // DropShadowBitmapEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.DropShadowBitmapEffect"/></summary>
        public static DropShadowBitmapEffect DropShadowBitmapEffect(O<Color> Color = default, O<double> Direction = default, O<double> Noise = default, O<double> Opacity = default, O<double> ShadowDepth = default, O<double> Softness = default)
        {
            var ui = new Windows.Media.Effects.DropShadowBitmapEffect();
            if (Color.HasValue) ui.Color = Color.Value;
            if (Direction.HasValue) ui.Direction = Direction.Value;
            if (Noise.HasValue) ui.Noise = Noise.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (ShadowDepth.HasValue) ui.ShadowDepth = ShadowDepth.Value;
            if (Softness.HasValue) ui.Softness = Softness.Value;
            return global::CSharpMarkup.Wpf.DropShadowBitmapEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.DropShadowBitmapEffect"/></summary>
        public static DropShadowBitmapEffect DropShadowBitmapEffect()
        {
            var ui = new Windows.Media.Effects.DropShadowBitmapEffect();
            return global::CSharpMarkup.Wpf.DropShadowBitmapEffect.StartChain(ui);
        }
    }

    public partial class DropShadowBitmapEffect : BitmapEffect, IUI<System.Windows.Media.Effects.DropShadowBitmapEffect>
    {
        static DropShadowBitmapEffect instance;

        internal static DropShadowBitmapEffect StartChain(Windows.Media.Effects.DropShadowBitmapEffect ui)
        {
            if (instance == null) instance = new DropShadowBitmapEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.DropShadowBitmapEffect ui;

        public new Windows.Media.Effects.DropShadowBitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.DropShadowBitmapEffect(DropShadowBitmapEffect view) => view?.UI;

        public static implicit operator DropShadowBitmapEffect(Windows.Media.Effects.DropShadowBitmapEffect ui) => DropShadowBitmapEffect.StartChain(ui);

        protected DropShadowBitmapEffect() { }
    }

    public static partial class DropShadowBitmapEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : DropShadowBitmapEffect { view.UI.Color = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Direction"/></summary>
        public static TView Direction<TView>(this TView view, double value) where TView : DropShadowBitmapEffect { view.UI.Direction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Noise"/></summary>
        public static TView Noise<TView>(this TView view, double value) where TView : DropShadowBitmapEffect { view.UI.Noise = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : DropShadowBitmapEffect { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.ShadowDepth"/></summary>
        public static TView ShadowDepth<TView>(this TView view, double value) where TView : DropShadowBitmapEffect { view.UI.ShadowDepth = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Softness"/></summary>
        public static TView Softness<TView>(this TView view, double value) where TView : DropShadowBitmapEffect { view.UI.Softness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.ColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Direction"/></summary>
        public static DependencyProperty<TTarget, double> Direction<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.DirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Noise"/></summary>
        public static DependencyProperty<TTarget, double> Noise<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.NoiseProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.OpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.ShadowDepth"/></summary>
        public static DependencyProperty<TTarget, double> ShadowDepth<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.ShadowDepthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowBitmapEffect.Softness"/></summary>
        public static DependencyProperty<TTarget, double> Softness<TTarget>(this TTarget target) where TTarget : DropShadowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowBitmapEffect.SoftnessProperty);
    }
}

namespace CSharpMarkup.Wpf // DropShadowEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.DropShadowEffect"/></summary>
        public static DropShadowEffect DropShadowEffect(O<double> BlurRadius = default, O<Color> Color = default, O<double> Direction = default, O<double> Opacity = default, O<Windows.Media.Effects.RenderingBias> RenderingBias = default, O<double> ShadowDepth = default)
        {
            var ui = new Windows.Media.Effects.DropShadowEffect();
            if (BlurRadius.HasValue) ui.BlurRadius = BlurRadius.Value;
            if (Color.HasValue) ui.Color = Color.Value;
            if (Direction.HasValue) ui.Direction = Direction.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (RenderingBias.HasValue) ui.RenderingBias = RenderingBias.Value;
            if (ShadowDepth.HasValue) ui.ShadowDepth = ShadowDepth.Value;
            return global::CSharpMarkup.Wpf.DropShadowEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.DropShadowEffect"/></summary>
        public static DropShadowEffect DropShadowEffect()
        {
            var ui = new Windows.Media.Effects.DropShadowEffect();
            return global::CSharpMarkup.Wpf.DropShadowEffect.StartChain(ui);
        }
    }

    public partial class DropShadowEffect : Effect, IUI<System.Windows.Media.Effects.DropShadowEffect>
    {
        static DropShadowEffect instance;

        internal static DropShadowEffect StartChain(Windows.Media.Effects.DropShadowEffect ui)
        {
            if (instance == null) instance = new DropShadowEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.DropShadowEffect ui;

        public new Windows.Media.Effects.DropShadowEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.DropShadowEffect(DropShadowEffect view) => view?.UI;

        public static implicit operator DropShadowEffect(Windows.Media.Effects.DropShadowEffect ui) => DropShadowEffect.StartChain(ui);

        protected DropShadowEffect() { }
    }

    public static partial class DropShadowEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.BlurRadius"/></summary>
        public static TView BlurRadius<TView>(this TView view, double value) where TView : DropShadowEffect { view.UI.BlurRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : DropShadowEffect { view.UI.Color = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.Direction"/></summary>
        public static TView Direction<TView>(this TView view, double value) where TView : DropShadowEffect { view.UI.Direction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : DropShadowEffect { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.RenderingBias"/></summary>
        public static TView RenderingBias<TView>(this TView view, Windows.Media.Effects.RenderingBias value) where TView : DropShadowEffect { view.UI.RenderingBias = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.DropShadowEffect.ShadowDepth"/></summary>
        public static TView ShadowDepth<TView>(this TView view, double value) where TView : DropShadowEffect { view.UI.ShadowDepth = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.BlurRadius"/></summary>
        public static DependencyProperty<TTarget, double> BlurRadius<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowEffect.BlurRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Effects.DropShadowEffect.ColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.Direction"/></summary>
        public static DependencyProperty<TTarget, double> Direction<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowEffect.DirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowEffect.OpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.RenderingBias"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> RenderingBias<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias>.Get(target, Windows.Media.Effects.DropShadowEffect.RenderingBiasProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.DropShadowEffect.ShadowDepth"/></summary>
        public static DependencyProperty<TTarget, double> ShadowDepth<TTarget>(this TTarget target) where TTarget : DropShadowEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.DropShadowEffect.ShadowDepthProperty);
    }
}

namespace CSharpMarkup.Wpf // Effect
{
    public partial class Effect : Animatable, IUI<System.Windows.Media.Effects.Effect>
    {
        Windows.Media.Effects.Effect ui;

        public new Windows.Media.Effects.Effect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Effect() { }
    }
}

namespace CSharpMarkup.Wpf // EmbossBitmapEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.EmbossBitmapEffect"/></summary>
        public static EmbossBitmapEffect EmbossBitmapEffect(O<double> LightAngle = default, O<double> Relief = default)
        {
            var ui = new Windows.Media.Effects.EmbossBitmapEffect();
            if (LightAngle.HasValue) ui.LightAngle = LightAngle.Value;
            if (Relief.HasValue) ui.Relief = Relief.Value;
            return global::CSharpMarkup.Wpf.EmbossBitmapEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.EmbossBitmapEffect"/></summary>
        public static EmbossBitmapEffect EmbossBitmapEffect()
        {
            var ui = new Windows.Media.Effects.EmbossBitmapEffect();
            return global::CSharpMarkup.Wpf.EmbossBitmapEffect.StartChain(ui);
        }
    }

    public partial class EmbossBitmapEffect : BitmapEffect, IUI<System.Windows.Media.Effects.EmbossBitmapEffect>
    {
        static EmbossBitmapEffect instance;

        internal static EmbossBitmapEffect StartChain(Windows.Media.Effects.EmbossBitmapEffect ui)
        {
            if (instance == null) instance = new EmbossBitmapEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.EmbossBitmapEffect ui;

        public new Windows.Media.Effects.EmbossBitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.EmbossBitmapEffect(EmbossBitmapEffect view) => view?.UI;

        public static implicit operator EmbossBitmapEffect(Windows.Media.Effects.EmbossBitmapEffect ui) => EmbossBitmapEffect.StartChain(ui);

        protected EmbossBitmapEffect() { }
    }

    public static partial class EmbossBitmapEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.EmbossBitmapEffect.LightAngle"/></summary>
        public static TView LightAngle<TView>(this TView view, double value) where TView : EmbossBitmapEffect { view.UI.LightAngle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.EmbossBitmapEffect.Relief"/></summary>
        public static TView Relief<TView>(this TView view, double value) where TView : EmbossBitmapEffect { view.UI.Relief = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.EmbossBitmapEffect.LightAngle"/></summary>
        public static DependencyProperty<TTarget, double> LightAngle<TTarget>(this TTarget target) where TTarget : EmbossBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.EmbossBitmapEffect.LightAngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.EmbossBitmapEffect.Relief"/></summary>
        public static DependencyProperty<TTarget, double> Relief<TTarget>(this TTarget target) where TTarget : EmbossBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.EmbossBitmapEffect.ReliefProperty);
    }
}

namespace CSharpMarkup.Wpf // OuterGlowBitmapEffect
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.OuterGlowBitmapEffect"/></summary>
        public static OuterGlowBitmapEffect OuterGlowBitmapEffect(O<Color> GlowColor = default, O<double> GlowSize = default, O<double> Noise = default, O<double> Opacity = default)
        {
            var ui = new Windows.Media.Effects.OuterGlowBitmapEffect();
            if (GlowColor.HasValue) ui.GlowColor = GlowColor.Value;
            if (GlowSize.HasValue) ui.GlowSize = GlowSize.Value;
            if (Noise.HasValue) ui.Noise = Noise.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            return global::CSharpMarkup.Wpf.OuterGlowBitmapEffect.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.OuterGlowBitmapEffect"/></summary>
        public static OuterGlowBitmapEffect OuterGlowBitmapEffect()
        {
            var ui = new Windows.Media.Effects.OuterGlowBitmapEffect();
            return global::CSharpMarkup.Wpf.OuterGlowBitmapEffect.StartChain(ui);
        }
    }

    public partial class OuterGlowBitmapEffect : BitmapEffect, IUI<System.Windows.Media.Effects.OuterGlowBitmapEffect>
    {
        static OuterGlowBitmapEffect instance;

        internal static OuterGlowBitmapEffect StartChain(Windows.Media.Effects.OuterGlowBitmapEffect ui)
        {
            if (instance == null) instance = new OuterGlowBitmapEffect();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.OuterGlowBitmapEffect ui;

        public new Windows.Media.Effects.OuterGlowBitmapEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.OuterGlowBitmapEffect(OuterGlowBitmapEffect view) => view?.UI;

        public static implicit operator OuterGlowBitmapEffect(Windows.Media.Effects.OuterGlowBitmapEffect ui) => OuterGlowBitmapEffect.StartChain(ui);

        protected OuterGlowBitmapEffect() { }
    }

    public static partial class OuterGlowBitmapEffectExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.GlowColor"/></summary>
        public static TView GlowColor<TView>(this TView view, Color value) where TView : OuterGlowBitmapEffect { view.UI.GlowColor = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.GlowSize"/></summary>
        public static TView GlowSize<TView>(this TView view, double value) where TView : OuterGlowBitmapEffect { view.UI.GlowSize = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.Noise"/></summary>
        public static TView Noise<TView>(this TView view, double value) where TView : OuterGlowBitmapEffect { view.UI.Noise = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : OuterGlowBitmapEffect { view.UI.Opacity = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.GlowColor"/></summary>
        public static DependencyProperty<TTarget, Color> GlowColor<TTarget>(this TTarget target) where TTarget : OuterGlowBitmapEffect
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Effects.OuterGlowBitmapEffect.GlowColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.GlowSize"/></summary>
        public static DependencyProperty<TTarget, double> GlowSize<TTarget>(this TTarget target) where TTarget : OuterGlowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.OuterGlowBitmapEffect.GlowSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.Noise"/></summary>
        public static DependencyProperty<TTarget, double> Noise<TTarget>(this TTarget target) where TTarget : OuterGlowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.OuterGlowBitmapEffect.NoiseProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.OuterGlowBitmapEffect.Opacity"/></summary>
        public static DependencyProperty<TTarget, double> Opacity<TTarget>(this TTarget target) where TTarget : OuterGlowBitmapEffect
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Effects.OuterGlowBitmapEffect.OpacityProperty);
    }
}

namespace CSharpMarkup.Wpf // PixelShader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Effects.PixelShader"/></summary>
        public static PixelShader PixelShader(O<Windows.Media.Effects.ShaderRenderMode> ShaderRenderMode = default, O<Uri> UriSource = default)
        {
            var ui = new Windows.Media.Effects.PixelShader();
            if (ShaderRenderMode.HasValue) ui.ShaderRenderMode = ShaderRenderMode.Value;
            if (UriSource.HasValue) ui.UriSource = UriSource.Value;
            return global::CSharpMarkup.Wpf.PixelShader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Effects.PixelShader"/></summary>
        public static PixelShader PixelShader()
        {
            var ui = new Windows.Media.Effects.PixelShader();
            return global::CSharpMarkup.Wpf.PixelShader.StartChain(ui);
        }
    }

    public partial class PixelShader : Animatable, IUI<System.Windows.Media.Effects.PixelShader>
    {
        static PixelShader instance;

        internal static PixelShader StartChain(Windows.Media.Effects.PixelShader ui)
        {
            if (instance == null) instance = new PixelShader();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Effects.PixelShader ui;

        public new Windows.Media.Effects.PixelShader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Effects.PixelShader(PixelShader view) => view?.UI;

        public static implicit operator PixelShader(Windows.Media.Effects.PixelShader ui) => PixelShader.StartChain(ui);

        protected PixelShader() { }
    }

    public static partial class PixelShaderExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Effects.PixelShader.ShaderRenderMode"/></summary>
        public static TView ShaderRenderMode<TView>(this TView view, Windows.Media.Effects.ShaderRenderMode value) where TView : PixelShader { view.UI.ShaderRenderMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Effects.PixelShader.UriSource"/></summary>
        public static TView UriSource<TView>(this TView view, Uri value) where TView : PixelShader { view.UI.UriSource = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.PixelShader.ShaderRenderMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Effects.ShaderRenderMode> ShaderRenderMode<TTarget>(this TTarget target) where TTarget : PixelShader
        => DependencyProperty<TTarget, Windows.Media.Effects.ShaderRenderMode>.Get(target, Windows.Media.Effects.PixelShader.ShaderRenderModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Effects.PixelShader.UriSource"/></summary>
        public static DependencyProperty<TTarget, Uri> UriSource<TTarget>(this TTarget target) where TTarget : PixelShader
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Media.Effects.PixelShader.UriSourceProperty);
    }
}

namespace CSharpMarkup.Wpf // ShaderEffect
{
    public partial class ShaderEffect : Effect, IUI<System.Windows.Media.Effects.ShaderEffect>
    {
        Windows.Media.Effects.ShaderEffect ui;

        public new Windows.Media.Effects.ShaderEffect UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ShaderEffect() { }
    }
}

namespace CSharpMarkup.Wpf // BitmapFrame
{
    public partial class BitmapFrame : BitmapSource, IUI<System.Windows.Media.Imaging.BitmapFrame>
    {
        Windows.Media.Imaging.BitmapFrame ui;

        public new Windows.Media.Imaging.BitmapFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BitmapFrame() { }
    }

    public static partial class BitmapFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapFrame.BaseUri"/></summary>
        public static TView BaseUri<TView>(this TView view, Uri value) where TView : BitmapFrame { view.UI.BaseUri = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // BitmapImage
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Imaging.BitmapImage"/></summary>
        public static BitmapImage BitmapImage(O<Uri> BaseUri = default, O<Windows.Media.Imaging.BitmapCacheOption> CacheOption = default, O<Windows.Media.Imaging.BitmapCreateOptions> CreateOptions = default, O<int> DecodePixelHeight = default, O<int> DecodePixelWidth = default, O<Windows.Media.Imaging.Rotation> Rotation = default, O<Windows.Int32Rect> SourceRect = default, O<Stream> StreamSource = default, O<RequestCachePolicy> UriCachePolicy = default, O<Uri> UriSource = default)
        {
            var ui = new Windows.Media.Imaging.BitmapImage();
            if (BaseUri.HasValue) ui.BaseUri = BaseUri.Value;
            if (CacheOption.HasValue) ui.CacheOption = CacheOption.Value;
            if (CreateOptions.HasValue) ui.CreateOptions = CreateOptions.Value;
            if (DecodePixelHeight.HasValue) ui.DecodePixelHeight = DecodePixelHeight.Value;
            if (DecodePixelWidth.HasValue) ui.DecodePixelWidth = DecodePixelWidth.Value;
            if (Rotation.HasValue) ui.Rotation = Rotation.Value;
            if (SourceRect.HasValue) ui.SourceRect = SourceRect.Value;
            if (StreamSource.HasValue) ui.StreamSource = StreamSource.Value;
            if (UriCachePolicy.HasValue) ui.UriCachePolicy = UriCachePolicy.Value;
            if (UriSource.HasValue) ui.UriSource = UriSource.Value;
            return global::CSharpMarkup.Wpf.BitmapImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.BitmapImage"/></summary>
        public static BitmapImage BitmapImage()
        {
            var ui = new Windows.Media.Imaging.BitmapImage();
            return global::CSharpMarkup.Wpf.BitmapImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.BitmapImage"/></summary>
        public static BitmapImage BitmapImage(Uri uriSource)
        {
            var ui = new Windows.Media.Imaging.BitmapImage(uriSource);
            return global::CSharpMarkup.Wpf.BitmapImage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.BitmapImage"/></summary>
        public static BitmapImage BitmapImage(Uri uriSource, RequestCachePolicy uriCachePolicy)
        {
            var ui = new Windows.Media.Imaging.BitmapImage(uriSource, uriCachePolicy);
            return global::CSharpMarkup.Wpf.BitmapImage.StartChain(ui);
        }
    }

    public partial class BitmapImage : BitmapSource, IUI<System.Windows.Media.Imaging.BitmapImage>
    {
        static BitmapImage instance;

        internal static BitmapImage StartChain(Windows.Media.Imaging.BitmapImage ui)
        {
            if (instance == null) instance = new BitmapImage();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Imaging.BitmapImage ui;

        public new Windows.Media.Imaging.BitmapImage UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Imaging.BitmapImage(BitmapImage view) => view?.UI;

        public static implicit operator BitmapImage(Windows.Media.Imaging.BitmapImage ui) => BitmapImage.StartChain(ui);

        protected BitmapImage() { }
    }

    public static partial class BitmapImageExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.BaseUri"/></summary>
        public static TView BaseUri<TView>(this TView view, Uri value) where TView : BitmapImage { view.UI.BaseUri = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.CacheOption"/></summary>
        public static TView CacheOption<TView>(this TView view, Windows.Media.Imaging.BitmapCacheOption value) where TView : BitmapImage { view.UI.CacheOption = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.CreateOptions"/></summary>
        public static TView CreateOptions<TView>(this TView view, Windows.Media.Imaging.BitmapCreateOptions value) where TView : BitmapImage { view.UI.CreateOptions = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.DecodePixelHeight"/></summary>
        public static TView DecodePixelHeight<TView>(this TView view, int value) where TView : BitmapImage { view.UI.DecodePixelHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.DecodePixelWidth"/></summary>
        public static TView DecodePixelWidth<TView>(this TView view, int value) where TView : BitmapImage { view.UI.DecodePixelWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.Rotation"/></summary>
        public static TView Rotation<TView>(this TView view, Windows.Media.Imaging.Rotation value) where TView : BitmapImage { view.UI.Rotation = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.SourceRect"/></summary>
        public static TView SourceRect<TView>(this TView view, Windows.Int32Rect value) where TView : BitmapImage { view.UI.SourceRect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.StreamSource"/></summary>
        public static TView StreamSource<TView>(this TView view, Stream value) where TView : BitmapImage { view.UI.StreamSource = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.UriCachePolicy"/></summary>
        public static TView UriCachePolicy<TView>(this TView view, RequestCachePolicy value) where TView : BitmapImage { view.UI.UriCachePolicy = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapImage.UriSource"/></summary>
        public static TView UriSource<TView>(this TView view, Uri value) where TView : BitmapImage { view.UI.UriSource = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.CacheOption"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption> CacheOption<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption>.Get(target, Windows.Media.Imaging.BitmapImage.CacheOptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.CreateOptions"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> CreateOptions<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions>.Get(target, Windows.Media.Imaging.BitmapImage.CreateOptionsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.DecodePixelHeight"/></summary>
        public static DependencyProperty<TTarget, int> DecodePixelHeight<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.Imaging.BitmapImage.DecodePixelHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.DecodePixelWidth"/></summary>
        public static DependencyProperty<TTarget, int> DecodePixelWidth<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, int>.Get(target, Windows.Media.Imaging.BitmapImage.DecodePixelWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.Rotation"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.Rotation> Rotation<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Windows.Media.Imaging.Rotation>.Get(target, Windows.Media.Imaging.BitmapImage.RotationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.SourceRect"/></summary>
        public static DependencyProperty<TTarget, Windows.Int32Rect> SourceRect<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Windows.Int32Rect>.Get(target, Windows.Media.Imaging.BitmapImage.SourceRectProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.StreamSource"/></summary>
        public static DependencyProperty<TTarget, Stream> StreamSource<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Stream>.Get(target, Windows.Media.Imaging.BitmapImage.StreamSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.UriCachePolicy"/></summary>
        public static DependencyProperty<TTarget, RequestCachePolicy> UriCachePolicy<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, RequestCachePolicy>.Get(target, Windows.Media.Imaging.BitmapImage.UriCachePolicyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.BitmapImage.UriSource"/></summary>
        public static DependencyProperty<TTarget, Uri> UriSource<TTarget>(this TTarget target) where TTarget : BitmapImage
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Media.Imaging.BitmapImage.UriSourceProperty);
    }
}

namespace CSharpMarkup.Wpf // BitmapMetadata
{
    public partial class BitmapMetadata : ImageMetadata, IUI<System.Windows.Media.Imaging.BitmapMetadata>
    {
        Windows.Media.Imaging.BitmapMetadata ui;

        public new Windows.Media.Imaging.BitmapMetadata UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BitmapMetadata() { }
    }

    public static partial class BitmapMetadataExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.ApplicationName"/></summary>
        public static TView ApplicationName<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.ApplicationName = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Author"/></summary>
        public static TView Author<TView>(this TView view, ReadOnlyCollection<string> value) where TView : BitmapMetadata { view.UI.Author = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.CameraManufacturer"/></summary>
        public static TView CameraManufacturer<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.CameraManufacturer = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.CameraModel"/></summary>
        public static TView CameraModel<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.CameraModel = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Comment"/></summary>
        public static TView Comment<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.Comment = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Copyright"/></summary>
        public static TView Copyright<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.Copyright = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.DateTaken"/></summary>
        public static TView DateTaken<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.DateTaken = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Keywords"/></summary>
        public static TView Keywords<TView>(this TView view, ReadOnlyCollection<string> value) where TView : BitmapMetadata { view.UI.Keywords = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Rating"/></summary>
        public static TView Rating<TView>(this TView view, int value) where TView : BitmapMetadata { view.UI.Rating = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Subject"/></summary>
        public static TView Subject<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.Subject = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.BitmapMetadata.Title"/></summary>
        public static TView Title<TView>(this TView view, string value) where TView : BitmapMetadata { view.UI.Title = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // BitmapSource
{
    public partial class BitmapSource : ImageSource, IUI<System.Windows.Media.Imaging.BitmapSource>
    {
        Windows.Media.Imaging.BitmapSource ui;

        public new Windows.Media.Imaging.BitmapSource UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected BitmapSource() { }
    }
}

namespace CSharpMarkup.Wpf // CachedBitmap
{
    public partial class CachedBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.CachedBitmap>
    {
        Windows.Media.Imaging.CachedBitmap ui;

        public new Windows.Media.Imaging.CachedBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected CachedBitmap() { }
    }
}

namespace CSharpMarkup.Wpf // ColorConvertedBitmap
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Imaging.ColorConvertedBitmap"/></summary>
        public static ColorConvertedBitmap ColorConvertedBitmap(O<Windows.Media.ColorContext> DestinationColorContext = default, O<Windows.Media.PixelFormat> DestinationFormat = default, O<Windows.Media.Imaging.BitmapSource> Source = default, O<Windows.Media.ColorContext> SourceColorContext = default)
        {
            var ui = new Windows.Media.Imaging.ColorConvertedBitmap();
            if (DestinationColorContext.HasValue) ui.DestinationColorContext = DestinationColorContext.Value;
            if (DestinationFormat.HasValue) ui.DestinationFormat = DestinationFormat.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            if (SourceColorContext.HasValue) ui.SourceColorContext = SourceColorContext.Value;
            return global::CSharpMarkup.Wpf.ColorConvertedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.ColorConvertedBitmap"/></summary>
        public static ColorConvertedBitmap ColorConvertedBitmap()
        {
            var ui = new Windows.Media.Imaging.ColorConvertedBitmap();
            return global::CSharpMarkup.Wpf.ColorConvertedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.ColorConvertedBitmap"/></summary>
        public static ColorConvertedBitmap ColorConvertedBitmap(Windows.Media.Imaging.BitmapSource source, Windows.Media.ColorContext sourceColorContext, Windows.Media.ColorContext destinationColorContext, Windows.Media.PixelFormat format)
        {
            var ui = new Windows.Media.Imaging.ColorConvertedBitmap(source, sourceColorContext, destinationColorContext, format);
            return global::CSharpMarkup.Wpf.ColorConvertedBitmap.StartChain(ui);
        }
    }

    public partial class ColorConvertedBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.ColorConvertedBitmap>
    {
        static ColorConvertedBitmap instance;

        internal static ColorConvertedBitmap StartChain(Windows.Media.Imaging.ColorConvertedBitmap ui)
        {
            if (instance == null) instance = new ColorConvertedBitmap();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Imaging.ColorConvertedBitmap ui;

        public new Windows.Media.Imaging.ColorConvertedBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Imaging.ColorConvertedBitmap(ColorConvertedBitmap view) => view?.UI;

        public static implicit operator ColorConvertedBitmap(Windows.Media.Imaging.ColorConvertedBitmap ui) => ColorConvertedBitmap.StartChain(ui);

        protected ColorConvertedBitmap() { }
    }

    public static partial class ColorConvertedBitmapExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.ColorConvertedBitmap.DestinationColorContext"/></summary>
        public static TView DestinationColorContext<TView>(this TView view, Windows.Media.ColorContext value) where TView : ColorConvertedBitmap { view.UI.DestinationColorContext = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.ColorConvertedBitmap.DestinationFormat"/></summary>
        public static TView DestinationFormat<TView>(this TView view, Windows.Media.PixelFormat value) where TView : ColorConvertedBitmap { view.UI.DestinationFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.ColorConvertedBitmap.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.Imaging.BitmapSource value) where TView : ColorConvertedBitmap { view.UI.Source = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.ColorConvertedBitmap.SourceColorContext"/></summary>
        public static TView SourceColorContext<TView>(this TView view, Windows.Media.ColorContext value) where TView : ColorConvertedBitmap { view.UI.SourceColorContext = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.ColorConvertedBitmap.DestinationColorContext"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ColorContext> DestinationColorContext<TTarget>(this TTarget target) where TTarget : ColorConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.ColorContext>.Get(target, Windows.Media.Imaging.ColorConvertedBitmap.DestinationColorContextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.ColorConvertedBitmap.DestinationFormat"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PixelFormat> DestinationFormat<TTarget>(this TTarget target) where TTarget : ColorConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.PixelFormat>.Get(target, Windows.Media.Imaging.ColorConvertedBitmap.DestinationFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.ColorConvertedBitmap.SourceColorContext"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ColorContext> SourceColorContext<TTarget>(this TTarget target) where TTarget : ColorConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.ColorContext>.Get(target, Windows.Media.Imaging.ColorConvertedBitmap.SourceColorContextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.ColorConvertedBitmap.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource> Source<TTarget>(this TTarget target) where TTarget : ColorConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource>.Get(target, Windows.Media.Imaging.ColorConvertedBitmap.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // CroppedBitmap
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Imaging.CroppedBitmap"/></summary>
        public static CroppedBitmap CroppedBitmap(O<Windows.Media.Imaging.BitmapSource> Source = default, O<Windows.Int32Rect> SourceRect = default)
        {
            var ui = new Windows.Media.Imaging.CroppedBitmap();
            if (Source.HasValue) ui.Source = Source.Value;
            if (SourceRect.HasValue) ui.SourceRect = SourceRect.Value;
            return global::CSharpMarkup.Wpf.CroppedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.CroppedBitmap"/></summary>
        public static CroppedBitmap CroppedBitmap()
        {
            var ui = new Windows.Media.Imaging.CroppedBitmap();
            return global::CSharpMarkup.Wpf.CroppedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.CroppedBitmap"/></summary>
        public static CroppedBitmap CroppedBitmap(Windows.Media.Imaging.BitmapSource source, Windows.Int32Rect sourceRect)
        {
            var ui = new Windows.Media.Imaging.CroppedBitmap(source, sourceRect);
            return global::CSharpMarkup.Wpf.CroppedBitmap.StartChain(ui);
        }
    }

    public partial class CroppedBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.CroppedBitmap>
    {
        static CroppedBitmap instance;

        internal static CroppedBitmap StartChain(Windows.Media.Imaging.CroppedBitmap ui)
        {
            if (instance == null) instance = new CroppedBitmap();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Imaging.CroppedBitmap ui;

        public new Windows.Media.Imaging.CroppedBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Imaging.CroppedBitmap(CroppedBitmap view) => view?.UI;

        public static implicit operator CroppedBitmap(Windows.Media.Imaging.CroppedBitmap ui) => CroppedBitmap.StartChain(ui);

        protected CroppedBitmap() { }
    }

    public static partial class CroppedBitmapExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.CroppedBitmap.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.Imaging.BitmapSource value) where TView : CroppedBitmap { view.UI.Source = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.CroppedBitmap.SourceRect"/></summary>
        public static TView SourceRect<TView>(this TView view, Windows.Int32Rect value) where TView : CroppedBitmap { view.UI.SourceRect = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.CroppedBitmap.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource> Source<TTarget>(this TTarget target) where TTarget : CroppedBitmap
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource>.Get(target, Windows.Media.Imaging.CroppedBitmap.SourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.CroppedBitmap.SourceRect"/></summary>
        public static DependencyProperty<TTarget, Windows.Int32Rect> SourceRect<TTarget>(this TTarget target) where TTarget : CroppedBitmap
        => DependencyProperty<TTarget, Windows.Int32Rect>.Get(target, Windows.Media.Imaging.CroppedBitmap.SourceRectProperty);
    }
}

namespace CSharpMarkup.Wpf // FormatConvertedBitmap
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Imaging.FormatConvertedBitmap"/></summary>
        public static FormatConvertedBitmap FormatConvertedBitmap(O<double> AlphaThreshold = default, O<Windows.Media.PixelFormat> DestinationFormat = default, O<Windows.Media.Imaging.BitmapPalette> DestinationPalette = default, O<Windows.Media.Imaging.BitmapSource> Source = default)
        {
            var ui = new Windows.Media.Imaging.FormatConvertedBitmap();
            if (AlphaThreshold.HasValue) ui.AlphaThreshold = AlphaThreshold.Value;
            if (DestinationFormat.HasValue) ui.DestinationFormat = DestinationFormat.Value;
            if (DestinationPalette.HasValue) ui.DestinationPalette = DestinationPalette.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.FormatConvertedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.FormatConvertedBitmap"/></summary>
        public static FormatConvertedBitmap FormatConvertedBitmap()
        {
            var ui = new Windows.Media.Imaging.FormatConvertedBitmap();
            return global::CSharpMarkup.Wpf.FormatConvertedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.FormatConvertedBitmap"/></summary>
        public static FormatConvertedBitmap FormatConvertedBitmap(Windows.Media.Imaging.BitmapSource source, Windows.Media.PixelFormat destinationFormat, Windows.Media.Imaging.BitmapPalette destinationPalette, double alphaThreshold)
        {
            var ui = new Windows.Media.Imaging.FormatConvertedBitmap(source, destinationFormat, destinationPalette, alphaThreshold);
            return global::CSharpMarkup.Wpf.FormatConvertedBitmap.StartChain(ui);
        }
    }

    public partial class FormatConvertedBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.FormatConvertedBitmap>
    {
        static FormatConvertedBitmap instance;

        internal static FormatConvertedBitmap StartChain(Windows.Media.Imaging.FormatConvertedBitmap ui)
        {
            if (instance == null) instance = new FormatConvertedBitmap();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Imaging.FormatConvertedBitmap ui;

        public new Windows.Media.Imaging.FormatConvertedBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Imaging.FormatConvertedBitmap(FormatConvertedBitmap view) => view?.UI;

        public static implicit operator FormatConvertedBitmap(Windows.Media.Imaging.FormatConvertedBitmap ui) => FormatConvertedBitmap.StartChain(ui);

        protected FormatConvertedBitmap() { }
    }

    public static partial class FormatConvertedBitmapExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.FormatConvertedBitmap.AlphaThreshold"/></summary>
        public static TView AlphaThreshold<TView>(this TView view, double value) where TView : FormatConvertedBitmap { view.UI.AlphaThreshold = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.FormatConvertedBitmap.DestinationFormat"/></summary>
        public static TView DestinationFormat<TView>(this TView view, Windows.Media.PixelFormat value) where TView : FormatConvertedBitmap { view.UI.DestinationFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.FormatConvertedBitmap.DestinationPalette"/></summary>
        public static TView DestinationPalette<TView>(this TView view, Windows.Media.Imaging.BitmapPalette value) where TView : FormatConvertedBitmap { view.UI.DestinationPalette = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.FormatConvertedBitmap.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.Imaging.BitmapSource value) where TView : FormatConvertedBitmap { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.FormatConvertedBitmap.AlphaThreshold"/></summary>
        public static DependencyProperty<TTarget, double> AlphaThreshold<TTarget>(this TTarget target) where TTarget : FormatConvertedBitmap
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Imaging.FormatConvertedBitmap.AlphaThresholdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.FormatConvertedBitmap.DestinationFormat"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PixelFormat> DestinationFormat<TTarget>(this TTarget target) where TTarget : FormatConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.PixelFormat>.Get(target, Windows.Media.Imaging.FormatConvertedBitmap.DestinationFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.FormatConvertedBitmap.DestinationPalette"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapPalette> DestinationPalette<TTarget>(this TTarget target) where TTarget : FormatConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapPalette>.Get(target, Windows.Media.Imaging.FormatConvertedBitmap.DestinationPaletteProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.FormatConvertedBitmap.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource> Source<TTarget>(this TTarget target) where TTarget : FormatConvertedBitmap
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource>.Get(target, Windows.Media.Imaging.FormatConvertedBitmap.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // InPlaceBitmapMetadataWriter
{
    public partial class InPlaceBitmapMetadataWriter : BitmapMetadata, IUI<System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter>
    {
        Windows.Media.Imaging.InPlaceBitmapMetadataWriter ui;

        public new Windows.Media.Imaging.InPlaceBitmapMetadataWriter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected InPlaceBitmapMetadataWriter() { }
    }
}

namespace CSharpMarkup.Wpf // RenderTargetBitmap
{
    public partial class RenderTargetBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.RenderTargetBitmap>
    {
        Windows.Media.Imaging.RenderTargetBitmap ui;

        public new Windows.Media.Imaging.RenderTargetBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected RenderTargetBitmap() { }
    }
}

namespace CSharpMarkup.Wpf // TransformedBitmap
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Imaging.TransformedBitmap"/></summary>
        public static TransformedBitmap TransformedBitmap(O<Windows.Media.Imaging.BitmapSource> Source = default, O<Windows.Media.Transform> Transform = default)
        {
            var ui = new Windows.Media.Imaging.TransformedBitmap();
            if (Source.HasValue) ui.Source = Source.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            return global::CSharpMarkup.Wpf.TransformedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.TransformedBitmap"/></summary>
        public static TransformedBitmap TransformedBitmap()
        {
            var ui = new Windows.Media.Imaging.TransformedBitmap();
            return global::CSharpMarkup.Wpf.TransformedBitmap.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Imaging.TransformedBitmap"/></summary>
        public static TransformedBitmap TransformedBitmap(Windows.Media.Imaging.BitmapSource source, Windows.Media.Transform newTransform)
        {
            var ui = new Windows.Media.Imaging.TransformedBitmap(source, newTransform);
            return global::CSharpMarkup.Wpf.TransformedBitmap.StartChain(ui);
        }
    }

    public partial class TransformedBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.TransformedBitmap>
    {
        static TransformedBitmap instance;

        internal static TransformedBitmap StartChain(Windows.Media.Imaging.TransformedBitmap ui)
        {
            if (instance == null) instance = new TransformedBitmap();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Imaging.TransformedBitmap ui;

        public new Windows.Media.Imaging.TransformedBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Imaging.TransformedBitmap(TransformedBitmap view) => view?.UI;

        public static implicit operator TransformedBitmap(Windows.Media.Imaging.TransformedBitmap ui) => TransformedBitmap.StartChain(ui);

        protected TransformedBitmap() { }
    }

    public static partial class TransformedBitmapExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Imaging.TransformedBitmap.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.Imaging.BitmapSource value) where TView : TransformedBitmap { view.UI.Source = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Imaging.TransformedBitmap.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : TransformedBitmap { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.TransformedBitmap.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource> Source<TTarget>(this TTarget target) where TTarget : TransformedBitmap
        => DependencyProperty<TTarget, Windows.Media.Imaging.BitmapSource>.Get(target, Windows.Media.Imaging.TransformedBitmap.SourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Imaging.TransformedBitmap.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> Transform<TTarget>(this TTarget target) where TTarget : TransformedBitmap
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.Media.Imaging.TransformedBitmap.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // WriteableBitmap
{
    public partial class WriteableBitmap : BitmapSource, IUI<System.Windows.Media.Imaging.WriteableBitmap>
    {
        Windows.Media.Imaging.WriteableBitmap ui;

        public new Windows.Media.Imaging.WriteableBitmap UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected WriteableBitmap() { }
    }
}

namespace CSharpMarkup.Wpf // AffineTransform3D
{
    public partial class AffineTransform3D : Transform3D, IUI<System.Windows.Media.Media3D.AffineTransform3D>
    {
        Windows.Media.Media3D.AffineTransform3D ui;

        public new Windows.Media.Media3D.AffineTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected AffineTransform3D() { }
    }
}

namespace CSharpMarkup.Wpf // AmbientLight
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.AmbientLight"/></summary>
        public static AmbientLight AmbientLight()
        {
            var ui = new Windows.Media.Media3D.AmbientLight();
            return global::CSharpMarkup.Wpf.AmbientLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.AmbientLight"/></summary>
        public static AmbientLight AmbientLight(Color ambientColor)
        {
            var ui = new Windows.Media.Media3D.AmbientLight(ambientColor);
            return global::CSharpMarkup.Wpf.AmbientLight.StartChain(ui);
        }
    }

    public partial class AmbientLight : Light, IUI<System.Windows.Media.Media3D.AmbientLight>
    {
        static AmbientLight instance;

        internal static AmbientLight StartChain(Windows.Media.Media3D.AmbientLight ui)
        {
            if (instance == null) instance = new AmbientLight();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.AmbientLight ui;

        public new Windows.Media.Media3D.AmbientLight UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.AmbientLight(AmbientLight view) => view?.UI;

        public static implicit operator AmbientLight(Windows.Media.Media3D.AmbientLight ui) => AmbientLight.StartChain(ui);

        protected AmbientLight() { }
    }
}

namespace CSharpMarkup.Wpf // AxisAngleRotation3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.AxisAngleRotation3D"/></summary>
        public static AxisAngleRotation3D AxisAngleRotation3D(O<double> Angle = default, O<Windows.Media.Media3D.Vector3D> Axis = default)
        {
            var ui = new Windows.Media.Media3D.AxisAngleRotation3D();
            if (Angle.HasValue) ui.Angle = Angle.Value;
            if (Axis.HasValue) ui.Axis = Axis.Value;
            return global::CSharpMarkup.Wpf.AxisAngleRotation3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.AxisAngleRotation3D"/></summary>
        public static AxisAngleRotation3D AxisAngleRotation3D()
        {
            var ui = new Windows.Media.Media3D.AxisAngleRotation3D();
            return global::CSharpMarkup.Wpf.AxisAngleRotation3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.AxisAngleRotation3D"/></summary>
        public static AxisAngleRotation3D AxisAngleRotation3D(Windows.Media.Media3D.Vector3D axis, double angle)
        {
            var ui = new Windows.Media.Media3D.AxisAngleRotation3D(axis, angle);
            return global::CSharpMarkup.Wpf.AxisAngleRotation3D.StartChain(ui);
        }
    }

    public partial class AxisAngleRotation3D : Rotation3D, IUI<System.Windows.Media.Media3D.AxisAngleRotation3D>
    {
        static AxisAngleRotation3D instance;

        internal static AxisAngleRotation3D StartChain(Windows.Media.Media3D.AxisAngleRotation3D ui)
        {
            if (instance == null) instance = new AxisAngleRotation3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.AxisAngleRotation3D ui;

        public new Windows.Media.Media3D.AxisAngleRotation3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.AxisAngleRotation3D(AxisAngleRotation3D view) => view?.UI;

        public static implicit operator AxisAngleRotation3D(Windows.Media.Media3D.AxisAngleRotation3D ui) => AxisAngleRotation3D.StartChain(ui);

        protected AxisAngleRotation3D() { }
    }

    public static partial class AxisAngleRotation3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.AxisAngleRotation3D.Angle"/></summary>
        public static TView Angle<TView>(this TView view, double value) where TView : AxisAngleRotation3D { view.UI.Angle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.AxisAngleRotation3D.Axis"/></summary>
        public static TView Axis<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : AxisAngleRotation3D { view.UI.Axis = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.AxisAngleRotation3D.Angle"/></summary>
        public static DependencyProperty<TTarget, double> Angle<TTarget>(this TTarget target) where TTarget : AxisAngleRotation3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.AxisAngleRotation3D.AngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.AxisAngleRotation3D.Axis"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> Axis<TTarget>(this TTarget target) where TTarget : AxisAngleRotation3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Media3D.AxisAngleRotation3D.AxisProperty);
    }
}

namespace CSharpMarkup.Wpf // Camera
{
    public partial class Camera : Animatable, IUI<System.Windows.Media.Media3D.Camera>
    {
        Windows.Media.Media3D.Camera ui;

        public new Windows.Media.Media3D.Camera UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Camera() { }
    }

    public static partial class CameraExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Camera.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Media3D.Transform3D value) where TView : Camera { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Camera.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D> Transform<TTarget>(this TTarget target) where TTarget : Camera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D>.Get(target, Windows.Media.Media3D.Camera.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // ContainerUIElement3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.ContainerUIElement3D"/></summary>
        public static ContainerUIElement3D ContainerUIElement3D(
            params System.Windows.Media.Media3D.Visual3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.ContainerUIElement3D();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.ContainerUIElement3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ContainerUIElement3D"/></summary>
        public static ContainerUIElement3D ContainerUIElement3D()
        {
            var ui = new Windows.Media.Media3D.ContainerUIElement3D();
            return global::CSharpMarkup.Wpf.ContainerUIElement3D.StartChain(ui);
        }
    }

    public partial class ContainerUIElement3D : UIElement3D, IUI<System.Windows.Media.Media3D.ContainerUIElement3D>
    {
        static ContainerUIElement3D instance;

        internal static ContainerUIElement3D StartChain(Windows.Media.Media3D.ContainerUIElement3D ui)
        {
            if (instance == null) instance = new ContainerUIElement3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.ContainerUIElement3D ui;

        public new Windows.Media.Media3D.ContainerUIElement3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.ContainerUIElement3D(ContainerUIElement3D view) => view?.UI;

        public static implicit operator ContainerUIElement3D(Windows.Media.Media3D.ContainerUIElement3D ui) => ContainerUIElement3D.StartChain(ui);

        protected ContainerUIElement3D() { }
    }
}

namespace CSharpMarkup.Wpf // DiffuseMaterial
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.DiffuseMaterial"/></summary>
        public static DiffuseMaterial DiffuseMaterial(O<Color> AmbientColor = default, O<Windows.Media.Brush> Brush = default, O<Color> Color = default)
        {
            var ui = new Windows.Media.Media3D.DiffuseMaterial();
            if (AmbientColor.HasValue) ui.AmbientColor = AmbientColor.Value;
            if (Brush.HasValue) ui.Brush = Brush.Value;
            if (Color.HasValue) ui.Color = Color.Value;
            return global::CSharpMarkup.Wpf.DiffuseMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.DiffuseMaterial"/></summary>
        public static DiffuseMaterial DiffuseMaterial()
        {
            var ui = new Windows.Media.Media3D.DiffuseMaterial();
            return global::CSharpMarkup.Wpf.DiffuseMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.DiffuseMaterial"/></summary>
        public static DiffuseMaterial DiffuseMaterial(Windows.Media.Brush brush)
        {
            var ui = new Windows.Media.Media3D.DiffuseMaterial(brush);
            return global::CSharpMarkup.Wpf.DiffuseMaterial.StartChain(ui);
        }
    }

    public partial class DiffuseMaterial : Material, IUI<System.Windows.Media.Media3D.DiffuseMaterial>
    {
        static DiffuseMaterial instance;

        internal static DiffuseMaterial StartChain(Windows.Media.Media3D.DiffuseMaterial ui)
        {
            if (instance == null) instance = new DiffuseMaterial();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.DiffuseMaterial ui;

        public new Windows.Media.Media3D.DiffuseMaterial UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.DiffuseMaterial(DiffuseMaterial view) => view?.UI;

        public static implicit operator DiffuseMaterial(Windows.Media.Media3D.DiffuseMaterial ui) => DiffuseMaterial.StartChain(ui);

        protected DiffuseMaterial() { }
    }

    public static partial class DiffuseMaterialExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.DiffuseMaterial.AmbientColor"/></summary>
        public static TView AmbientColor<TView>(this TView view, Color value) where TView : DiffuseMaterial { view.UI.AmbientColor = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.DiffuseMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Windows.Media.Brush value) where TView : DiffuseMaterial { view.UI.Brush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.DiffuseMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Color value) where TView : DiffuseMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.DiffuseMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, string color) where TView : DiffuseMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.DiffuseMaterial.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : DiffuseMaterial { view.UI.Color = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.DiffuseMaterial.AmbientColor"/></summary>
        public static DependencyProperty<TTarget, Color> AmbientColor<TTarget>(this TTarget target) where TTarget : DiffuseMaterial
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Media3D.DiffuseMaterial.AmbientColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.DiffuseMaterial.Brush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Brush<TTarget>(this TTarget target) where TTarget : DiffuseMaterial
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.Media3D.DiffuseMaterial.BrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.DiffuseMaterial.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : DiffuseMaterial
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Media3D.DiffuseMaterial.ColorProperty);
    }
}

namespace CSharpMarkup.Wpf // DirectionalLight
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.DirectionalLight"/></summary>
        public static DirectionalLight DirectionalLight(O<Windows.Media.Media3D.Vector3D> Direction = default)
        {
            var ui = new Windows.Media.Media3D.DirectionalLight();
            if (Direction.HasValue) ui.Direction = Direction.Value;
            return global::CSharpMarkup.Wpf.DirectionalLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.DirectionalLight"/></summary>
        public static DirectionalLight DirectionalLight()
        {
            var ui = new Windows.Media.Media3D.DirectionalLight();
            return global::CSharpMarkup.Wpf.DirectionalLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.DirectionalLight"/></summary>
        public static DirectionalLight DirectionalLight(Color diffuseColor, Windows.Media.Media3D.Vector3D direction)
        {
            var ui = new Windows.Media.Media3D.DirectionalLight(diffuseColor, direction);
            return global::CSharpMarkup.Wpf.DirectionalLight.StartChain(ui);
        }
    }

    public partial class DirectionalLight : Light, IUI<System.Windows.Media.Media3D.DirectionalLight>
    {
        static DirectionalLight instance;

        internal static DirectionalLight StartChain(Windows.Media.Media3D.DirectionalLight ui)
        {
            if (instance == null) instance = new DirectionalLight();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.DirectionalLight ui;

        public new Windows.Media.Media3D.DirectionalLight UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.DirectionalLight(DirectionalLight view) => view?.UI;

        public static implicit operator DirectionalLight(Windows.Media.Media3D.DirectionalLight ui) => DirectionalLight.StartChain(ui);

        protected DirectionalLight() { }
    }

    public static partial class DirectionalLightExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.DirectionalLight.Direction"/></summary>
        public static TView Direction<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : DirectionalLight { view.UI.Direction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.DirectionalLight.Direction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> Direction<TTarget>(this TTarget target) where TTarget : DirectionalLight
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Media3D.DirectionalLight.DirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // EmissiveMaterial
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.EmissiveMaterial"/></summary>
        public static EmissiveMaterial EmissiveMaterial(O<Windows.Media.Brush> Brush = default, O<Color> Color = default)
        {
            var ui = new Windows.Media.Media3D.EmissiveMaterial();
            if (Brush.HasValue) ui.Brush = Brush.Value;
            if (Color.HasValue) ui.Color = Color.Value;
            return global::CSharpMarkup.Wpf.EmissiveMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.EmissiveMaterial"/></summary>
        public static EmissiveMaterial EmissiveMaterial()
        {
            var ui = new Windows.Media.Media3D.EmissiveMaterial();
            return global::CSharpMarkup.Wpf.EmissiveMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.EmissiveMaterial"/></summary>
        public static EmissiveMaterial EmissiveMaterial(Windows.Media.Brush brush)
        {
            var ui = new Windows.Media.Media3D.EmissiveMaterial(brush);
            return global::CSharpMarkup.Wpf.EmissiveMaterial.StartChain(ui);
        }
    }

    public partial class EmissiveMaterial : Material, IUI<System.Windows.Media.Media3D.EmissiveMaterial>
    {
        static EmissiveMaterial instance;

        internal static EmissiveMaterial StartChain(Windows.Media.Media3D.EmissiveMaterial ui)
        {
            if (instance == null) instance = new EmissiveMaterial();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.EmissiveMaterial ui;

        public new Windows.Media.Media3D.EmissiveMaterial UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.EmissiveMaterial(EmissiveMaterial view) => view?.UI;

        public static implicit operator EmissiveMaterial(Windows.Media.Media3D.EmissiveMaterial ui) => EmissiveMaterial.StartChain(ui);

        protected EmissiveMaterial() { }
    }

    public static partial class EmissiveMaterialExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.EmissiveMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Windows.Media.Brush value) where TView : EmissiveMaterial { view.UI.Brush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.EmissiveMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Color value) where TView : EmissiveMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.EmissiveMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, string color) where TView : EmissiveMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.EmissiveMaterial.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : EmissiveMaterial { view.UI.Color = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.EmissiveMaterial.Brush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Brush<TTarget>(this TTarget target) where TTarget : EmissiveMaterial
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.Media3D.EmissiveMaterial.BrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.EmissiveMaterial.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : EmissiveMaterial
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Media3D.EmissiveMaterial.ColorProperty);
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform2DTo3D
{
    public partial class GeneralTransform2DTo3D : Freezable, IUI<System.Windows.Media.Media3D.GeneralTransform2DTo3D>
    {
        Windows.Media.Media3D.GeneralTransform2DTo3D ui;

        public new Windows.Media.Media3D.GeneralTransform2DTo3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected GeneralTransform2DTo3D() { }
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform3D
{
    public partial class GeneralTransform3D : Animatable, IUI<System.Windows.Media.Media3D.GeneralTransform3D>
    {
        Windows.Media.Media3D.GeneralTransform3D ui;

        public new Windows.Media.Media3D.GeneralTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected GeneralTransform3D() { }
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform3DCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DCollection"/></summary>
        public static GeneralTransform3DCollection GeneralTransform3DCollection()
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DCollection();
            return global::CSharpMarkup.Wpf.GeneralTransform3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DCollection"/></summary>
        public static GeneralTransform3DCollection GeneralTransform3DCollection(IEnumerable<Windows.Media.Media3D.GeneralTransform3D> collection)
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DCollection(collection);
            return global::CSharpMarkup.Wpf.GeneralTransform3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DCollection"/></summary>
        public static GeneralTransform3DCollection GeneralTransform3DCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DCollection(capacity);
            return global::CSharpMarkup.Wpf.GeneralTransform3DCollection.StartChain(ui);
        }
    }

    public partial class GeneralTransform3DCollection : Animatable, IUI<System.Windows.Media.Media3D.GeneralTransform3DCollection>
    {
        static GeneralTransform3DCollection instance;

        internal static GeneralTransform3DCollection StartChain(Windows.Media.Media3D.GeneralTransform3DCollection ui)
        {
            if (instance == null) instance = new GeneralTransform3DCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.GeneralTransform3DCollection ui;

        public new Windows.Media.Media3D.GeneralTransform3DCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.GeneralTransform3DCollection(GeneralTransform3DCollection view) => view?.UI;

        public static implicit operator GeneralTransform3DCollection(Windows.Media.Media3D.GeneralTransform3DCollection ui) => GeneralTransform3DCollection.StartChain(ui);

        protected GeneralTransform3DCollection() { }
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform3DGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DGroup"/></summary>
        public static GeneralTransform3DGroup GeneralTransform3DGroup(
            params System.Windows.Media.Media3D.GeneralTransform3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.GeneralTransform3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DGroup"/></summary>
        public static GeneralTransform3DGroup GeneralTransform3DGroup(O<Windows.Media.Media3D.GeneralTransform3DCollection> Children = default)
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.GeneralTransform3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeneralTransform3DGroup"/></summary>
        public static GeneralTransform3DGroup GeneralTransform3DGroup()
        {
            var ui = new Windows.Media.Media3D.GeneralTransform3DGroup();
            return global::CSharpMarkup.Wpf.GeneralTransform3DGroup.StartChain(ui);
        }
    }

    public partial class GeneralTransform3DGroup : GeneralTransform3D, IUI<System.Windows.Media.Media3D.GeneralTransform3DGroup>
    {
        static GeneralTransform3DGroup instance;

        internal static GeneralTransform3DGroup StartChain(Windows.Media.Media3D.GeneralTransform3DGroup ui)
        {
            if (instance == null) instance = new GeneralTransform3DGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.GeneralTransform3DGroup ui;

        public new Windows.Media.Media3D.GeneralTransform3DGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.GeneralTransform3DGroup(GeneralTransform3DGroup view) => view?.UI;

        public static implicit operator GeneralTransform3DGroup(Windows.Media.Media3D.GeneralTransform3DGroup ui) => GeneralTransform3DGroup.StartChain(ui);

        protected GeneralTransform3DGroup() { }
    }

    public static partial class GeneralTransform3DGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.GeneralTransform3DGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Media3D.GeneralTransform3DCollection value) where TView : GeneralTransform3DGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.GeneralTransform3DGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.GeneralTransform3DCollection> Children<TTarget>(this TTarget target) where TTarget : GeneralTransform3DGroup
        => DependencyProperty<TTarget, Windows.Media.Media3D.GeneralTransform3DCollection>.Get(target, Windows.Media.Media3D.GeneralTransform3DGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // GeneralTransform3DTo2D
{
    public partial class GeneralTransform3DTo2D : Freezable, IUI<System.Windows.Media.Media3D.GeneralTransform3DTo2D>
    {
        Windows.Media.Media3D.GeneralTransform3DTo2D ui;

        public new Windows.Media.Media3D.GeneralTransform3DTo2D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected GeneralTransform3DTo2D() { }
    }
}

namespace CSharpMarkup.Wpf // Geometry3D
{
    public partial class Geometry3D : Animatable, IUI<System.Windows.Media.Media3D.Geometry3D>
    {
        Windows.Media.Media3D.Geometry3D ui;

        public new Windows.Media.Media3D.Geometry3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Geometry3D() { }
    }
}

namespace CSharpMarkup.Wpf // GeometryModel3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.GeometryModel3D"/></summary>
        public static GeometryModel3D GeometryModel3D(O<Windows.Media.Media3D.Material> BackMaterial = default, O<Windows.Media.Media3D.Geometry3D> Geometry = default, O<Windows.Media.Media3D.Material> Material = default)
        {
            var ui = new Windows.Media.Media3D.GeometryModel3D();
            if (BackMaterial.HasValue) ui.BackMaterial = BackMaterial.Value;
            if (Geometry.HasValue) ui.Geometry = Geometry.Value;
            if (Material.HasValue) ui.Material = Material.Value;
            return global::CSharpMarkup.Wpf.GeometryModel3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeometryModel3D"/></summary>
        public static GeometryModel3D GeometryModel3D()
        {
            var ui = new Windows.Media.Media3D.GeometryModel3D();
            return global::CSharpMarkup.Wpf.GeometryModel3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.GeometryModel3D"/></summary>
        public static GeometryModel3D GeometryModel3D(Windows.Media.Media3D.Geometry3D geometry, Windows.Media.Media3D.Material material)
        {
            var ui = new Windows.Media.Media3D.GeometryModel3D(geometry, material);
            return global::CSharpMarkup.Wpf.GeometryModel3D.StartChain(ui);
        }
    }

    public partial class GeometryModel3D : Model3D, IUI<System.Windows.Media.Media3D.GeometryModel3D>
    {
        static GeometryModel3D instance;

        internal static GeometryModel3D StartChain(Windows.Media.Media3D.GeometryModel3D ui)
        {
            if (instance == null) instance = new GeometryModel3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.GeometryModel3D ui;

        public new Windows.Media.Media3D.GeometryModel3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.GeometryModel3D(GeometryModel3D view) => view?.UI;

        public static implicit operator GeometryModel3D(Windows.Media.Media3D.GeometryModel3D ui) => GeometryModel3D.StartChain(ui);

        protected GeometryModel3D() { }
    }

    public static partial class GeometryModel3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.GeometryModel3D.BackMaterial"/></summary>
        public static TView BackMaterial<TView>(this TView view, Windows.Media.Media3D.Material value) where TView : GeometryModel3D { view.UI.BackMaterial = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.GeometryModel3D.Geometry"/></summary>
        public static TView Geometry<TView>(this TView view, Windows.Media.Media3D.Geometry3D value) where TView : GeometryModel3D { view.UI.Geometry = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.GeometryModel3D.Material"/></summary>
        public static TView Material<TView>(this TView view, Windows.Media.Media3D.Material value) where TView : GeometryModel3D { view.UI.Material = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.GeometryModel3D.BackMaterial"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Material> BackMaterial<TTarget>(this TTarget target) where TTarget : GeometryModel3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Material>.Get(target, Windows.Media.Media3D.GeometryModel3D.BackMaterialProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.GeometryModel3D.Geometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Geometry3D> Geometry<TTarget>(this TTarget target) where TTarget : GeometryModel3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Geometry3D>.Get(target, Windows.Media.Media3D.GeometryModel3D.GeometryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.GeometryModel3D.Material"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Material> Material<TTarget>(this TTarget target) where TTarget : GeometryModel3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Material>.Get(target, Windows.Media.Media3D.GeometryModel3D.MaterialProperty);
    }
}

namespace CSharpMarkup.Wpf // Light
{
    public partial class Light : Model3D, IUI<System.Windows.Media.Media3D.Light>
    {
        Windows.Media.Media3D.Light ui;

        public new Windows.Media.Media3D.Light UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Light() { }
    }

    public static partial class LightExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Light.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : Light { view.UI.Color = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Light.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : Light
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Media3D.Light.ColorProperty);
    }
}

namespace CSharpMarkup.Wpf // Material
{
    public partial class Material : Animatable, IUI<System.Windows.Media.Media3D.Material>
    {
        Windows.Media.Media3D.Material ui;

        public new Windows.Media.Media3D.Material UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Material() { }
    }
}

namespace CSharpMarkup.Wpf // MaterialCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialCollection"/></summary>
        public static MaterialCollection MaterialCollection()
        {
            var ui = new Windows.Media.Media3D.MaterialCollection();
            return global::CSharpMarkup.Wpf.MaterialCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialCollection"/></summary>
        public static MaterialCollection MaterialCollection(IEnumerable<Windows.Media.Media3D.Material> collection)
        {
            var ui = new Windows.Media.Media3D.MaterialCollection(collection);
            return global::CSharpMarkup.Wpf.MaterialCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialCollection"/></summary>
        public static MaterialCollection MaterialCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.MaterialCollection(capacity);
            return global::CSharpMarkup.Wpf.MaterialCollection.StartChain(ui);
        }
    }

    public partial class MaterialCollection : Animatable, IUI<System.Windows.Media.Media3D.MaterialCollection>
    {
        static MaterialCollection instance;

        internal static MaterialCollection StartChain(Windows.Media.Media3D.MaterialCollection ui)
        {
            if (instance == null) instance = new MaterialCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.MaterialCollection ui;

        public new Windows.Media.Media3D.MaterialCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.MaterialCollection(MaterialCollection view) => view?.UI;

        public static implicit operator MaterialCollection(Windows.Media.Media3D.MaterialCollection ui) => MaterialCollection.StartChain(ui);

        protected MaterialCollection() { }
    }
}

namespace CSharpMarkup.Wpf // MaterialGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialGroup"/></summary>
        public static MaterialGroup MaterialGroup(
            params System.Windows.Media.Media3D.Material[] Children
)
        {
            var ui = new Windows.Media.Media3D.MaterialGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.MaterialGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialGroup"/></summary>
        public static MaterialGroup MaterialGroup(O<Windows.Media.Media3D.MaterialCollection> Children = default)
        {
            var ui = new Windows.Media.Media3D.MaterialGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.MaterialGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MaterialGroup"/></summary>
        public static MaterialGroup MaterialGroup()
        {
            var ui = new Windows.Media.Media3D.MaterialGroup();
            return global::CSharpMarkup.Wpf.MaterialGroup.StartChain(ui);
        }
    }

    public partial class MaterialGroup : Material, IUI<System.Windows.Media.Media3D.MaterialGroup>
    {
        static MaterialGroup instance;

        internal static MaterialGroup StartChain(Windows.Media.Media3D.MaterialGroup ui)
        {
            if (instance == null) instance = new MaterialGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.MaterialGroup ui;

        public new Windows.Media.Media3D.MaterialGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.MaterialGroup(MaterialGroup view) => view?.UI;

        public static implicit operator MaterialGroup(Windows.Media.Media3D.MaterialGroup ui) => MaterialGroup.StartChain(ui);

        protected MaterialGroup() { }
    }

    public static partial class MaterialGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.MaterialGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Media3D.MaterialCollection value) where TView : MaterialGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MaterialGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.MaterialCollection> Children<TTarget>(this TTarget target) where TTarget : MaterialGroup
        => DependencyProperty<TTarget, Windows.Media.Media3D.MaterialCollection>.Get(target, Windows.Media.Media3D.MaterialGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // MatrixCamera
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixCamera"/></summary>
        public static MatrixCamera MatrixCamera(O<Windows.Media.Media3D.Matrix3D> ProjectionMatrix = default, O<Windows.Media.Media3D.Matrix3D> ViewMatrix = default)
        {
            var ui = new Windows.Media.Media3D.MatrixCamera();
            if (ProjectionMatrix.HasValue) ui.ProjectionMatrix = ProjectionMatrix.Value;
            if (ViewMatrix.HasValue) ui.ViewMatrix = ViewMatrix.Value;
            return global::CSharpMarkup.Wpf.MatrixCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixCamera"/></summary>
        public static MatrixCamera MatrixCamera()
        {
            var ui = new Windows.Media.Media3D.MatrixCamera();
            return global::CSharpMarkup.Wpf.MatrixCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixCamera"/></summary>
        public static MatrixCamera MatrixCamera(Windows.Media.Media3D.Matrix3D viewMatrix, Windows.Media.Media3D.Matrix3D projectionMatrix)
        {
            var ui = new Windows.Media.Media3D.MatrixCamera(viewMatrix, projectionMatrix);
            return global::CSharpMarkup.Wpf.MatrixCamera.StartChain(ui);
        }
    }

    public partial class MatrixCamera : Camera, IUI<System.Windows.Media.Media3D.MatrixCamera>
    {
        static MatrixCamera instance;

        internal static MatrixCamera StartChain(Windows.Media.Media3D.MatrixCamera ui)
        {
            if (instance == null) instance = new MatrixCamera();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.MatrixCamera ui;

        public new Windows.Media.Media3D.MatrixCamera UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.MatrixCamera(MatrixCamera view) => view?.UI;

        public static implicit operator MatrixCamera(Windows.Media.Media3D.MatrixCamera ui) => MatrixCamera.StartChain(ui);

        protected MatrixCamera() { }
    }

    public static partial class MatrixCameraExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.MatrixCamera.ProjectionMatrix"/></summary>
        public static TView ProjectionMatrix<TView>(this TView view, Windows.Media.Media3D.Matrix3D value) where TView : MatrixCamera { view.UI.ProjectionMatrix = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.MatrixCamera.ViewMatrix"/></summary>
        public static TView ViewMatrix<TView>(this TView view, Windows.Media.Media3D.Matrix3D value) where TView : MatrixCamera { view.UI.ViewMatrix = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MatrixCamera.ProjectionMatrix"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D> ProjectionMatrix<TTarget>(this TTarget target) where TTarget : MatrixCamera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D>.Get(target, Windows.Media.Media3D.MatrixCamera.ProjectionMatrixProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MatrixCamera.ViewMatrix"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D> ViewMatrix<TTarget>(this TTarget target) where TTarget : MatrixCamera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D>.Get(target, Windows.Media.Media3D.MatrixCamera.ViewMatrixProperty);
    }
}

namespace CSharpMarkup.Wpf // MatrixTransform3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixTransform3D"/></summary>
        public static MatrixTransform3D MatrixTransform3D(O<Windows.Media.Media3D.Matrix3D> Matrix = default)
        {
            var ui = new Windows.Media.Media3D.MatrixTransform3D();
            if (Matrix.HasValue) ui.Matrix = Matrix.Value;
            return global::CSharpMarkup.Wpf.MatrixTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixTransform3D"/></summary>
        public static MatrixTransform3D MatrixTransform3D()
        {
            var ui = new Windows.Media.Media3D.MatrixTransform3D();
            return global::CSharpMarkup.Wpf.MatrixTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MatrixTransform3D"/></summary>
        public static MatrixTransform3D MatrixTransform3D(Windows.Media.Media3D.Matrix3D matrix)
        {
            var ui = new Windows.Media.Media3D.MatrixTransform3D(matrix);
            return global::CSharpMarkup.Wpf.MatrixTransform3D.StartChain(ui);
        }
    }

    public partial class MatrixTransform3D : Transform3D, IUI<System.Windows.Media.Media3D.MatrixTransform3D>
    {
        static MatrixTransform3D instance;

        internal static MatrixTransform3D StartChain(Windows.Media.Media3D.MatrixTransform3D ui)
        {
            if (instance == null) instance = new MatrixTransform3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.MatrixTransform3D ui;

        public new Windows.Media.Media3D.MatrixTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.MatrixTransform3D(MatrixTransform3D view) => view?.UI;

        public static implicit operator MatrixTransform3D(Windows.Media.Media3D.MatrixTransform3D ui) => MatrixTransform3D.StartChain(ui);

        protected MatrixTransform3D() { }
    }

    public static partial class MatrixTransform3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.MatrixTransform3D.Matrix"/></summary>
        public static TView Matrix<TView>(this TView view, Windows.Media.Media3D.Matrix3D value) where TView : MatrixTransform3D { view.UI.Matrix = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MatrixTransform3D.Matrix"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D> Matrix<TTarget>(this TTarget target) where TTarget : MatrixTransform3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Matrix3D>.Get(target, Windows.Media.Media3D.MatrixTransform3D.MatrixProperty);
    }
}

namespace CSharpMarkup.Wpf // MeshGeometry3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.MeshGeometry3D"/></summary>
        public static MeshGeometry3D MeshGeometry3D(O<Windows.Media.Media3D.Vector3DCollection> Normals = default, O<Windows.Media.Media3D.Point3DCollection> Positions = default, O<Windows.Media.PointCollection> TextureCoordinates = default, O<Windows.Media.Int32Collection> TriangleIndices = default)
        {
            var ui = new Windows.Media.Media3D.MeshGeometry3D();
            if (Normals.HasValue) ui.Normals = Normals.Value;
            if (Positions.HasValue) ui.Positions = Positions.Value;
            if (TextureCoordinates.HasValue) ui.TextureCoordinates = TextureCoordinates.Value;
            if (TriangleIndices.HasValue) ui.TriangleIndices = TriangleIndices.Value;
            return global::CSharpMarkup.Wpf.MeshGeometry3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.MeshGeometry3D"/></summary>
        public static MeshGeometry3D MeshGeometry3D()
        {
            var ui = new Windows.Media.Media3D.MeshGeometry3D();
            return global::CSharpMarkup.Wpf.MeshGeometry3D.StartChain(ui);
        }
    }

    public partial class MeshGeometry3D : Geometry3D, IUI<System.Windows.Media.Media3D.MeshGeometry3D>
    {
        static MeshGeometry3D instance;

        internal static MeshGeometry3D StartChain(Windows.Media.Media3D.MeshGeometry3D ui)
        {
            if (instance == null) instance = new MeshGeometry3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.MeshGeometry3D ui;

        public new Windows.Media.Media3D.MeshGeometry3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.MeshGeometry3D(MeshGeometry3D view) => view?.UI;

        public static implicit operator MeshGeometry3D(Windows.Media.Media3D.MeshGeometry3D ui) => MeshGeometry3D.StartChain(ui);

        protected MeshGeometry3D() { }
    }

    public static partial class MeshGeometry3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.MeshGeometry3D.Normals"/></summary>
        public static TView Normals<TView>(this TView view, Windows.Media.Media3D.Vector3DCollection value) where TView : MeshGeometry3D { view.UI.Normals = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.MeshGeometry3D.Positions"/></summary>
        public static TView Positions<TView>(this TView view, Windows.Media.Media3D.Point3DCollection value) where TView : MeshGeometry3D { view.UI.Positions = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.MeshGeometry3D.TextureCoordinates"/></summary>
        public static TView TextureCoordinates<TView>(this TView view, Windows.Media.PointCollection value) where TView : MeshGeometry3D { view.UI.TextureCoordinates = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.MeshGeometry3D.TriangleIndices"/></summary>
        public static TView TriangleIndices<TView>(this TView view, Windows.Media.Int32Collection value) where TView : MeshGeometry3D { view.UI.TriangleIndices = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MeshGeometry3D.Normals"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3DCollection> Normals<TTarget>(this TTarget target) where TTarget : MeshGeometry3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3DCollection>.Get(target, Windows.Media.Media3D.MeshGeometry3D.NormalsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MeshGeometry3D.Positions"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3DCollection> Positions<TTarget>(this TTarget target) where TTarget : MeshGeometry3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3DCollection>.Get(target, Windows.Media.Media3D.MeshGeometry3D.PositionsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MeshGeometry3D.TextureCoordinates"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> TextureCoordinates<TTarget>(this TTarget target) where TTarget : MeshGeometry3D
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Media.Media3D.MeshGeometry3D.TextureCoordinatesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.MeshGeometry3D.TriangleIndices"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Int32Collection> TriangleIndices<TTarget>(this TTarget target) where TTarget : MeshGeometry3D
        => DependencyProperty<TTarget, Windows.Media.Int32Collection>.Get(target, Windows.Media.Media3D.MeshGeometry3D.TriangleIndicesProperty);
    }
}

namespace CSharpMarkup.Wpf // Model3D
{
    public partial class Model3D : Animatable, IUI<System.Windows.Media.Media3D.Model3D>
    {
        Windows.Media.Media3D.Model3D ui;

        public new Windows.Media.Media3D.Model3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Model3D() { }
    }

    public static partial class Model3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Model3D.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Media3D.Transform3D value) where TView : Model3D { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Model3D.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D> Transform<TTarget>(this TTarget target) where TTarget : Model3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D>.Get(target, Windows.Media.Media3D.Model3D.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // Model3DCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DCollection"/></summary>
        public static Model3DCollection Model3DCollection()
        {
            var ui = new Windows.Media.Media3D.Model3DCollection();
            return global::CSharpMarkup.Wpf.Model3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DCollection"/></summary>
        public static Model3DCollection Model3DCollection(IEnumerable<Windows.Media.Media3D.Model3D> collection)
        {
            var ui = new Windows.Media.Media3D.Model3DCollection(collection);
            return global::CSharpMarkup.Wpf.Model3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DCollection"/></summary>
        public static Model3DCollection Model3DCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.Model3DCollection(capacity);
            return global::CSharpMarkup.Wpf.Model3DCollection.StartChain(ui);
        }
    }

    public partial class Model3DCollection : Animatable, IUI<System.Windows.Media.Media3D.Model3DCollection>
    {
        static Model3DCollection instance;

        internal static Model3DCollection StartChain(Windows.Media.Media3D.Model3DCollection ui)
        {
            if (instance == null) instance = new Model3DCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Model3DCollection ui;

        public new Windows.Media.Media3D.Model3DCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Model3DCollection(Model3DCollection view) => view?.UI;

        public static implicit operator Model3DCollection(Windows.Media.Media3D.Model3DCollection ui) => Model3DCollection.StartChain(ui);

        protected Model3DCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Model3DGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DGroup"/></summary>
        public static Model3DGroup Model3DGroup(
            params System.Windows.Media.Media3D.Model3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.Model3DGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Model3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DGroup"/></summary>
        public static Model3DGroup Model3DGroup(O<Windows.Media.Media3D.Model3DCollection> Children = default)
        {
            var ui = new Windows.Media.Media3D.Model3DGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.Model3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Model3DGroup"/></summary>
        public static Model3DGroup Model3DGroup()
        {
            var ui = new Windows.Media.Media3D.Model3DGroup();
            return global::CSharpMarkup.Wpf.Model3DGroup.StartChain(ui);
        }
    }

    public partial class Model3DGroup : Model3D, IUI<System.Windows.Media.Media3D.Model3DGroup>
    {
        static Model3DGroup instance;

        internal static Model3DGroup StartChain(Windows.Media.Media3D.Model3DGroup ui)
        {
            if (instance == null) instance = new Model3DGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Model3DGroup ui;

        public new Windows.Media.Media3D.Model3DGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Model3DGroup(Model3DGroup view) => view?.UI;

        public static implicit operator Model3DGroup(Windows.Media.Media3D.Model3DGroup ui) => Model3DGroup.StartChain(ui);

        protected Model3DGroup() { }
    }

    public static partial class Model3DGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Model3DGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Media3D.Model3DCollection value) where TView : Model3DGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Model3DGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Model3DCollection> Children<TTarget>(this TTarget target) where TTarget : Model3DGroup
        => DependencyProperty<TTarget, Windows.Media.Media3D.Model3DCollection>.Get(target, Windows.Media.Media3D.Model3DGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // ModelUIElement3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelUIElement3D"/></summary>
        public static ModelUIElement3D ModelUIElement3D(
            System.Windows.Media.Media3D.Model3D Model
)
        {
            var ui = new Windows.Media.Media3D.ModelUIElement3D();
            if (Model is not null) ui.Model = Model;
            return global::CSharpMarkup.Wpf.ModelUIElement3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelUIElement3D"/></summary>
        public static ModelUIElement3D ModelUIElement3D(O<Windows.Media.Media3D.Model3D> Model = default)
        {
            var ui = new Windows.Media.Media3D.ModelUIElement3D();
            if (Model.HasValue) ui.Model = Model.Value;
            return global::CSharpMarkup.Wpf.ModelUIElement3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelUIElement3D"/></summary>
        public static ModelUIElement3D ModelUIElement3D()
        {
            var ui = new Windows.Media.Media3D.ModelUIElement3D();
            return global::CSharpMarkup.Wpf.ModelUIElement3D.StartChain(ui);
        }
    }

    public partial class ModelUIElement3D : UIElement3D, IUI<System.Windows.Media.Media3D.ModelUIElement3D>
    {
        static ModelUIElement3D instance;

        internal static ModelUIElement3D StartChain(Windows.Media.Media3D.ModelUIElement3D ui)
        {
            if (instance == null) instance = new ModelUIElement3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.ModelUIElement3D ui;

        public new Windows.Media.Media3D.ModelUIElement3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.ModelUIElement3D(ModelUIElement3D view) => view?.UI;

        public static implicit operator ModelUIElement3D(Windows.Media.Media3D.ModelUIElement3D ui) => ModelUIElement3D.StartChain(ui);

        protected ModelUIElement3D() { }
    }

    public static partial class ModelUIElement3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.ModelUIElement3D.Model"/></summary>
        public static TView Model<TView>(this TView view, Windows.Media.Media3D.Model3D value) where TView : ModelUIElement3D { view.UI.Model = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ModelUIElement3D.Model"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Model3D> Model<TTarget>(this TTarget target) where TTarget : ModelUIElement3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Model3D>.Get(target, Windows.Media.Media3D.ModelUIElement3D.ModelProperty);
    }
}

namespace CSharpMarkup.Wpf // ModelVisual3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelVisual3D"/></summary>
        public static ModelVisual3D ModelVisual3D(
            params System.Windows.Media.Media3D.Visual3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.ModelVisual3D();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.ModelVisual3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelVisual3D"/></summary>
        public static ModelVisual3D ModelVisual3D(O<Windows.Media.Media3D.Model3D> Content = default, O<Windows.Media.Media3D.Transform3D> Transform = default)
        {
            var ui = new Windows.Media.Media3D.ModelVisual3D();
            if (Content.HasValue) ui.Content = Content.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            return global::CSharpMarkup.Wpf.ModelVisual3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ModelVisual3D"/></summary>
        public static ModelVisual3D ModelVisual3D()
        {
            var ui = new Windows.Media.Media3D.ModelVisual3D();
            return global::CSharpMarkup.Wpf.ModelVisual3D.StartChain(ui);
        }
    }

    public partial class ModelVisual3D : Visual3D, IUI<System.Windows.Media.Media3D.ModelVisual3D>
    {
        static ModelVisual3D instance;

        internal static ModelVisual3D StartChain(Windows.Media.Media3D.ModelVisual3D ui)
        {
            if (instance == null) instance = new ModelVisual3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.ModelVisual3D ui;

        public new Windows.Media.Media3D.ModelVisual3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.ModelVisual3D(ModelVisual3D view) => view?.UI;

        public static implicit operator ModelVisual3D(Windows.Media.Media3D.ModelVisual3D ui) => ModelVisual3D.StartChain(ui);

        protected ModelVisual3D() { }
    }

    public static partial class ModelVisual3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.ModelVisual3D.Content"/></summary>
        public static TView Content<TView>(this TView view, Windows.Media.Media3D.Model3D value) where TView : ModelVisual3D { view.UI.Content = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ModelVisual3D.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Media3D.Transform3D value) where TView : ModelVisual3D { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ModelVisual3D.Content"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Model3D> Content<TTarget>(this TTarget target) where TTarget : ModelVisual3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Model3D>.Get(target, Windows.Media.Media3D.ModelVisual3D.ContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ModelVisual3D.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D> Transform<TTarget>(this TTarget target) where TTarget : ModelVisual3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D>.Get(target, Windows.Media.Media3D.ModelVisual3D.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // OrthographicCamera
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.OrthographicCamera"/></summary>
        public static OrthographicCamera OrthographicCamera(O<double> Width = default)
        {
            var ui = new Windows.Media.Media3D.OrthographicCamera();
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.OrthographicCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.OrthographicCamera"/></summary>
        public static OrthographicCamera OrthographicCamera()
        {
            var ui = new Windows.Media.Media3D.OrthographicCamera();
            return global::CSharpMarkup.Wpf.OrthographicCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.OrthographicCamera"/></summary>
        public static OrthographicCamera OrthographicCamera(Windows.Media.Media3D.Point3D position, Windows.Media.Media3D.Vector3D lookDirection, Windows.Media.Media3D.Vector3D upDirection, double width)
        {
            var ui = new Windows.Media.Media3D.OrthographicCamera(position, lookDirection, upDirection, width);
            return global::CSharpMarkup.Wpf.OrthographicCamera.StartChain(ui);
        }
    }

    public partial class OrthographicCamera : ProjectionCamera, IUI<System.Windows.Media.Media3D.OrthographicCamera>
    {
        static OrthographicCamera instance;

        internal static OrthographicCamera StartChain(Windows.Media.Media3D.OrthographicCamera ui)
        {
            if (instance == null) instance = new OrthographicCamera();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.OrthographicCamera ui;

        public new Windows.Media.Media3D.OrthographicCamera UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.OrthographicCamera(OrthographicCamera view) => view?.UI;

        public static implicit operator OrthographicCamera(Windows.Media.Media3D.OrthographicCamera ui) => OrthographicCamera.StartChain(ui);

        protected OrthographicCamera() { }
    }

    public static partial class OrthographicCameraExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.OrthographicCamera.Width"/></summary>
        public static TView Width<TView>(this TView view, double value) where TView : OrthographicCamera { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.OrthographicCamera.Width"/></summary>
        public static DependencyProperty<TTarget, double> Width<TTarget>(this TTarget target) where TTarget : OrthographicCamera
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.OrthographicCamera.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // PerspectiveCamera
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.PerspectiveCamera"/></summary>
        public static PerspectiveCamera PerspectiveCamera(O<double> FieldOfView = default)
        {
            var ui = new Windows.Media.Media3D.PerspectiveCamera();
            if (FieldOfView.HasValue) ui.FieldOfView = FieldOfView.Value;
            return global::CSharpMarkup.Wpf.PerspectiveCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.PerspectiveCamera"/></summary>
        public static PerspectiveCamera PerspectiveCamera()
        {
            var ui = new Windows.Media.Media3D.PerspectiveCamera();
            return global::CSharpMarkup.Wpf.PerspectiveCamera.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.PerspectiveCamera"/></summary>
        public static PerspectiveCamera PerspectiveCamera(Windows.Media.Media3D.Point3D position, Windows.Media.Media3D.Vector3D lookDirection, Windows.Media.Media3D.Vector3D upDirection, double fieldOfView)
        {
            var ui = new Windows.Media.Media3D.PerspectiveCamera(position, lookDirection, upDirection, fieldOfView);
            return global::CSharpMarkup.Wpf.PerspectiveCamera.StartChain(ui);
        }
    }

    public partial class PerspectiveCamera : ProjectionCamera, IUI<System.Windows.Media.Media3D.PerspectiveCamera>
    {
        static PerspectiveCamera instance;

        internal static PerspectiveCamera StartChain(Windows.Media.Media3D.PerspectiveCamera ui)
        {
            if (instance == null) instance = new PerspectiveCamera();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.PerspectiveCamera ui;

        public new Windows.Media.Media3D.PerspectiveCamera UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.PerspectiveCamera(PerspectiveCamera view) => view?.UI;

        public static implicit operator PerspectiveCamera(Windows.Media.Media3D.PerspectiveCamera ui) => PerspectiveCamera.StartChain(ui);

        protected PerspectiveCamera() { }
    }

    public static partial class PerspectiveCameraExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.PerspectiveCamera.FieldOfView"/></summary>
        public static TView FieldOfView<TView>(this TView view, double value) where TView : PerspectiveCamera { view.UI.FieldOfView = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PerspectiveCamera.FieldOfView"/></summary>
        public static DependencyProperty<TTarget, double> FieldOfView<TTarget>(this TTarget target) where TTarget : PerspectiveCamera
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.PerspectiveCamera.FieldOfViewProperty);
    }
}

namespace CSharpMarkup.Wpf // Point3DCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Point3DCollection"/></summary>
        public static Point3DCollection Point3DCollection()
        {
            var ui = new Windows.Media.Media3D.Point3DCollection();
            return global::CSharpMarkup.Wpf.Point3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Point3DCollection"/></summary>
        public static Point3DCollection Point3DCollection(IEnumerable<Windows.Media.Media3D.Point3D> collection)
        {
            var ui = new Windows.Media.Media3D.Point3DCollection(collection);
            return global::CSharpMarkup.Wpf.Point3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Point3DCollection"/></summary>
        public static Point3DCollection Point3DCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.Point3DCollection(capacity);
            return global::CSharpMarkup.Wpf.Point3DCollection.StartChain(ui);
        }
    }

    public partial class Point3DCollection : Freezable, IUI<System.Windows.Media.Media3D.Point3DCollection>
    {
        static Point3DCollection instance;

        internal static Point3DCollection StartChain(Windows.Media.Media3D.Point3DCollection ui)
        {
            if (instance == null) instance = new Point3DCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Point3DCollection ui;

        public new Windows.Media.Media3D.Point3DCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Point3DCollection(Point3DCollection view) => view?.UI;

        public static implicit operator Point3DCollection(Windows.Media.Media3D.Point3DCollection ui) => Point3DCollection.StartChain(ui);

        protected Point3DCollection() { }
    }
}

namespace CSharpMarkup.Wpf // PointLight
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.PointLight"/></summary>
        public static PointLight PointLight()
        {
            var ui = new Windows.Media.Media3D.PointLight();
            return global::CSharpMarkup.Wpf.PointLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.PointLight"/></summary>
        public static PointLight PointLight(Color diffuseColor, Windows.Media.Media3D.Point3D position)
        {
            var ui = new Windows.Media.Media3D.PointLight(diffuseColor, position);
            return global::CSharpMarkup.Wpf.PointLight.StartChain(ui);
        }
    }

    public partial class PointLight : PointLightBase, IUI<System.Windows.Media.Media3D.PointLight>
    {
        static PointLight instance;

        internal static PointLight StartChain(Windows.Media.Media3D.PointLight ui)
        {
            if (instance == null) instance = new PointLight();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.PointLight ui;

        public new Windows.Media.Media3D.PointLight UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.PointLight(PointLight view) => view?.UI;

        public static implicit operator PointLight(Windows.Media.Media3D.PointLight ui) => PointLight.StartChain(ui);

        protected PointLight() { }
    }
}

namespace CSharpMarkup.Wpf // PointLightBase
{
    public partial class PointLightBase : Light, IUI<System.Windows.Media.Media3D.PointLightBase>
    {
        Windows.Media.Media3D.PointLightBase ui;

        public new Windows.Media.Media3D.PointLightBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected PointLightBase() { }
    }

    public static partial class PointLightBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.PointLightBase.ConstantAttenuation"/></summary>
        public static TView ConstantAttenuation<TView>(this TView view, double value) where TView : PointLightBase { view.UI.ConstantAttenuation = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.PointLightBase.LinearAttenuation"/></summary>
        public static TView LinearAttenuation<TView>(this TView view, double value) where TView : PointLightBase { view.UI.LinearAttenuation = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.PointLightBase.Position"/></summary>
        public static TView Position<TView>(this TView view, Windows.Media.Media3D.Point3D value) where TView : PointLightBase { view.UI.Position = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.PointLightBase.QuadraticAttenuation"/></summary>
        public static TView QuadraticAttenuation<TView>(this TView view, double value) where TView : PointLightBase { view.UI.QuadraticAttenuation = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.PointLightBase.Range"/></summary>
        public static TView Range<TView>(this TView view, double value) where TView : PointLightBase { view.UI.Range = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PointLightBase.ConstantAttenuation"/></summary>
        public static DependencyProperty<TTarget, double> ConstantAttenuation<TTarget>(this TTarget target) where TTarget : PointLightBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.PointLightBase.ConstantAttenuationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PointLightBase.LinearAttenuation"/></summary>
        public static DependencyProperty<TTarget, double> LinearAttenuation<TTarget>(this TTarget target) where TTarget : PointLightBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.PointLightBase.LinearAttenuationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PointLightBase.Position"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D> Position<TTarget>(this TTarget target) where TTarget : PointLightBase
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D>.Get(target, Windows.Media.Media3D.PointLightBase.PositionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PointLightBase.QuadraticAttenuation"/></summary>
        public static DependencyProperty<TTarget, double> QuadraticAttenuation<TTarget>(this TTarget target) where TTarget : PointLightBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.PointLightBase.QuadraticAttenuationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.PointLightBase.Range"/></summary>
        public static DependencyProperty<TTarget, double> Range<TTarget>(this TTarget target) where TTarget : PointLightBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.PointLightBase.RangeProperty);
    }
}

namespace CSharpMarkup.Wpf // ProjectionCamera
{
    public partial class ProjectionCamera : Camera, IUI<System.Windows.Media.Media3D.ProjectionCamera>
    {
        Windows.Media.Media3D.ProjectionCamera ui;

        public new Windows.Media.Media3D.ProjectionCamera UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ProjectionCamera() { }
    }

    public static partial class ProjectionCameraExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.ProjectionCamera.FarPlaneDistance"/></summary>
        public static TView FarPlaneDistance<TView>(this TView view, double value) where TView : ProjectionCamera { view.UI.FarPlaneDistance = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ProjectionCamera.LookDirection"/></summary>
        public static TView LookDirection<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : ProjectionCamera { view.UI.LookDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ProjectionCamera.NearPlaneDistance"/></summary>
        public static TView NearPlaneDistance<TView>(this TView view, double value) where TView : ProjectionCamera { view.UI.NearPlaneDistance = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ProjectionCamera.Position"/></summary>
        public static TView Position<TView>(this TView view, Windows.Media.Media3D.Point3D value) where TView : ProjectionCamera { view.UI.Position = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ProjectionCamera.UpDirection"/></summary>
        public static TView UpDirection<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : ProjectionCamera { view.UI.UpDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ProjectionCamera.FarPlaneDistance"/></summary>
        public static DependencyProperty<TTarget, double> FarPlaneDistance<TTarget>(this TTarget target) where TTarget : ProjectionCamera
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ProjectionCamera.FarPlaneDistanceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ProjectionCamera.LookDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> LookDirection<TTarget>(this TTarget target) where TTarget : ProjectionCamera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Media3D.ProjectionCamera.LookDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ProjectionCamera.NearPlaneDistance"/></summary>
        public static DependencyProperty<TTarget, double> NearPlaneDistance<TTarget>(this TTarget target) where TTarget : ProjectionCamera
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ProjectionCamera.NearPlaneDistanceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ProjectionCamera.Position"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Point3D> Position<TTarget>(this TTarget target) where TTarget : ProjectionCamera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Point3D>.Get(target, Windows.Media.Media3D.ProjectionCamera.PositionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ProjectionCamera.UpDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> UpDirection<TTarget>(this TTarget target) where TTarget : ProjectionCamera
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Media3D.ProjectionCamera.UpDirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // QuaternionRotation3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.QuaternionRotation3D"/></summary>
        public static QuaternionRotation3D QuaternionRotation3D(O<Windows.Media.Media3D.Quaternion> Quaternion = default)
        {
            var ui = new Windows.Media.Media3D.QuaternionRotation3D();
            if (Quaternion.HasValue) ui.Quaternion = Quaternion.Value;
            return global::CSharpMarkup.Wpf.QuaternionRotation3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.QuaternionRotation3D"/></summary>
        public static QuaternionRotation3D QuaternionRotation3D()
        {
            var ui = new Windows.Media.Media3D.QuaternionRotation3D();
            return global::CSharpMarkup.Wpf.QuaternionRotation3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.QuaternionRotation3D"/></summary>
        public static QuaternionRotation3D QuaternionRotation3D(Windows.Media.Media3D.Quaternion quaternion)
        {
            var ui = new Windows.Media.Media3D.QuaternionRotation3D(quaternion);
            return global::CSharpMarkup.Wpf.QuaternionRotation3D.StartChain(ui);
        }
    }

    public partial class QuaternionRotation3D : Rotation3D, IUI<System.Windows.Media.Media3D.QuaternionRotation3D>
    {
        static QuaternionRotation3D instance;

        internal static QuaternionRotation3D StartChain(Windows.Media.Media3D.QuaternionRotation3D ui)
        {
            if (instance == null) instance = new QuaternionRotation3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.QuaternionRotation3D ui;

        public new Windows.Media.Media3D.QuaternionRotation3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.QuaternionRotation3D(QuaternionRotation3D view) => view?.UI;

        public static implicit operator QuaternionRotation3D(Windows.Media.Media3D.QuaternionRotation3D ui) => QuaternionRotation3D.StartChain(ui);

        protected QuaternionRotation3D() { }
    }

    public static partial class QuaternionRotation3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.QuaternionRotation3D.Quaternion"/></summary>
        public static TView Quaternion<TView>(this TView view, Windows.Media.Media3D.Quaternion value) where TView : QuaternionRotation3D { view.UI.Quaternion = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.QuaternionRotation3D.Quaternion"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion> Quaternion<TTarget>(this TTarget target) where TTarget : QuaternionRotation3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Quaternion>.Get(target, Windows.Media.Media3D.QuaternionRotation3D.QuaternionProperty);
    }
}

namespace CSharpMarkup.Wpf // RotateTransform3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.RotateTransform3D"/></summary>
        public static RotateTransform3D RotateTransform3D(O<double> CenterX = default, O<double> CenterY = default, O<double> CenterZ = default, O<Windows.Media.Media3D.Rotation3D> Rotation = default)
        {
            var ui = new Windows.Media.Media3D.RotateTransform3D();
            if (CenterX.HasValue) ui.CenterX = CenterX.Value;
            if (CenterY.HasValue) ui.CenterY = CenterY.Value;
            if (CenterZ.HasValue) ui.CenterZ = CenterZ.Value;
            if (Rotation.HasValue) ui.Rotation = Rotation.Value;
            return global::CSharpMarkup.Wpf.RotateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.RotateTransform3D"/></summary>
        public static RotateTransform3D RotateTransform3D()
        {
            var ui = new Windows.Media.Media3D.RotateTransform3D();
            return global::CSharpMarkup.Wpf.RotateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.RotateTransform3D"/></summary>
        public static RotateTransform3D RotateTransform3D(Windows.Media.Media3D.Rotation3D rotation)
        {
            var ui = new Windows.Media.Media3D.RotateTransform3D(rotation);
            return global::CSharpMarkup.Wpf.RotateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.RotateTransform3D"/></summary>
        public static RotateTransform3D RotateTransform3D(Windows.Media.Media3D.Rotation3D rotation, double centerX, double centerY, double centerZ)
        {
            var ui = new Windows.Media.Media3D.RotateTransform3D(rotation, centerX, centerY, centerZ);
            return global::CSharpMarkup.Wpf.RotateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.RotateTransform3D"/></summary>
        public static RotateTransform3D RotateTransform3D(Windows.Media.Media3D.Rotation3D rotation, Windows.Media.Media3D.Point3D center)
        {
            var ui = new Windows.Media.Media3D.RotateTransform3D(rotation, center);
            return global::CSharpMarkup.Wpf.RotateTransform3D.StartChain(ui);
        }
    }

    public partial class RotateTransform3D : AffineTransform3D, IUI<System.Windows.Media.Media3D.RotateTransform3D>
    {
        static RotateTransform3D instance;

        internal static RotateTransform3D StartChain(Windows.Media.Media3D.RotateTransform3D ui)
        {
            if (instance == null) instance = new RotateTransform3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.RotateTransform3D ui;

        public new Windows.Media.Media3D.RotateTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.RotateTransform3D(RotateTransform3D view) => view?.UI;

        public static implicit operator RotateTransform3D(Windows.Media.Media3D.RotateTransform3D ui) => RotateTransform3D.StartChain(ui);

        protected RotateTransform3D() { }
    }

    public static partial class RotateTransform3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.RotateTransform3D.CenterX"/></summary>
        public static TView CenterX<TView>(this TView view, double value) where TView : RotateTransform3D { view.UI.CenterX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.RotateTransform3D.CenterY"/></summary>
        public static TView CenterY<TView>(this TView view, double value) where TView : RotateTransform3D { view.UI.CenterY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.RotateTransform3D.CenterZ"/></summary>
        public static TView CenterZ<TView>(this TView view, double value) where TView : RotateTransform3D { view.UI.CenterZ = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.RotateTransform3D.Rotation"/></summary>
        public static TView Rotation<TView>(this TView view, Windows.Media.Media3D.Rotation3D value) where TView : RotateTransform3D { view.UI.Rotation = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.RotateTransform3D.CenterX"/></summary>
        public static DependencyProperty<TTarget, double> CenterX<TTarget>(this TTarget target) where TTarget : RotateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.RotateTransform3D.CenterXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.RotateTransform3D.CenterY"/></summary>
        public static DependencyProperty<TTarget, double> CenterY<TTarget>(this TTarget target) where TTarget : RotateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.RotateTransform3D.CenterYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.RotateTransform3D.CenterZ"/></summary>
        public static DependencyProperty<TTarget, double> CenterZ<TTarget>(this TTarget target) where TTarget : RotateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.RotateTransform3D.CenterZProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.RotateTransform3D.Rotation"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D> Rotation<TTarget>(this TTarget target) where TTarget : RotateTransform3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Rotation3D>.Get(target, Windows.Media.Media3D.RotateTransform3D.RotationProperty);
    }
}

namespace CSharpMarkup.Wpf // Rotation3D
{
    public partial class Rotation3D : Animatable, IUI<System.Windows.Media.Media3D.Rotation3D>
    {
        Windows.Media.Media3D.Rotation3D ui;

        public new Windows.Media.Media3D.Rotation3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Rotation3D() { }
    }
}

namespace CSharpMarkup.Wpf // ScaleTransform3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D(O<double> CenterX = default, O<double> CenterY = default, O<double> CenterZ = default, O<double> ScaleX = default, O<double> ScaleY = default, O<double> ScaleZ = default)
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D();
            if (CenterX.HasValue) ui.CenterX = CenterX.Value;
            if (CenterY.HasValue) ui.CenterY = CenterY.Value;
            if (CenterZ.HasValue) ui.CenterZ = CenterZ.Value;
            if (ScaleX.HasValue) ui.ScaleX = ScaleX.Value;
            if (ScaleY.HasValue) ui.ScaleY = ScaleY.Value;
            if (ScaleZ.HasValue) ui.ScaleZ = ScaleZ.Value;
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D()
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D();
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D(double scaleX, double scaleY, double scaleZ)
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D(scaleX, scaleY, scaleZ);
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D(double scaleX, double scaleY, double scaleZ, double centerX, double centerY, double centerZ)
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D(scaleX, scaleY, scaleZ, centerX, centerY, centerZ);
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D(Windows.Media.Media3D.Vector3D scale)
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D(scale);
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.ScaleTransform3D"/></summary>
        public static ScaleTransform3D ScaleTransform3D(Windows.Media.Media3D.Vector3D scale, Windows.Media.Media3D.Point3D center)
        {
            var ui = new Windows.Media.Media3D.ScaleTransform3D(scale, center);
            return global::CSharpMarkup.Wpf.ScaleTransform3D.StartChain(ui);
        }
    }

    public partial class ScaleTransform3D : AffineTransform3D, IUI<System.Windows.Media.Media3D.ScaleTransform3D>
    {
        static ScaleTransform3D instance;

        internal static ScaleTransform3D StartChain(Windows.Media.Media3D.ScaleTransform3D ui)
        {
            if (instance == null) instance = new ScaleTransform3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.ScaleTransform3D ui;

        public new Windows.Media.Media3D.ScaleTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.ScaleTransform3D(ScaleTransform3D view) => view?.UI;

        public static implicit operator ScaleTransform3D(Windows.Media.Media3D.ScaleTransform3D ui) => ScaleTransform3D.StartChain(ui);

        protected ScaleTransform3D() { }
    }

    public static partial class ScaleTransform3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterX"/></summary>
        public static TView CenterX<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.CenterX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterY"/></summary>
        public static TView CenterY<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.CenterY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterZ"/></summary>
        public static TView CenterZ<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.CenterZ = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleX"/></summary>
        public static TView ScaleX<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.ScaleX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleY"/></summary>
        public static TView ScaleY<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.ScaleY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleZ"/></summary>
        public static TView ScaleZ<TView>(this TView view, double value) where TView : ScaleTransform3D { view.UI.ScaleZ = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterX"/></summary>
        public static DependencyProperty<TTarget, double> CenterX<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.CenterXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterY"/></summary>
        public static DependencyProperty<TTarget, double> CenterY<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.CenterYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.CenterZ"/></summary>
        public static DependencyProperty<TTarget, double> CenterZ<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.CenterZProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleX"/></summary>
        public static DependencyProperty<TTarget, double> ScaleX<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.ScaleXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleY"/></summary>
        public static DependencyProperty<TTarget, double> ScaleY<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.ScaleYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.ScaleTransform3D.ScaleZ"/></summary>
        public static DependencyProperty<TTarget, double> ScaleZ<TTarget>(this TTarget target) where TTarget : ScaleTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.ScaleTransform3D.ScaleZProperty);
    }
}

namespace CSharpMarkup.Wpf // SpecularMaterial
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.SpecularMaterial"/></summary>
        public static SpecularMaterial SpecularMaterial(O<Windows.Media.Brush> Brush = default, O<Color> Color = default, O<double> SpecularPower = default)
        {
            var ui = new Windows.Media.Media3D.SpecularMaterial();
            if (Brush.HasValue) ui.Brush = Brush.Value;
            if (Color.HasValue) ui.Color = Color.Value;
            if (SpecularPower.HasValue) ui.SpecularPower = SpecularPower.Value;
            return global::CSharpMarkup.Wpf.SpecularMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.SpecularMaterial"/></summary>
        public static SpecularMaterial SpecularMaterial()
        {
            var ui = new Windows.Media.Media3D.SpecularMaterial();
            return global::CSharpMarkup.Wpf.SpecularMaterial.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.SpecularMaterial"/></summary>
        public static SpecularMaterial SpecularMaterial(Windows.Media.Brush brush, double specularPower)
        {
            var ui = new Windows.Media.Media3D.SpecularMaterial(brush, specularPower);
            return global::CSharpMarkup.Wpf.SpecularMaterial.StartChain(ui);
        }
    }

    public partial class SpecularMaterial : Material, IUI<System.Windows.Media.Media3D.SpecularMaterial>
    {
        static SpecularMaterial instance;

        internal static SpecularMaterial StartChain(Windows.Media.Media3D.SpecularMaterial ui)
        {
            if (instance == null) instance = new SpecularMaterial();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.SpecularMaterial ui;

        public new Windows.Media.Media3D.SpecularMaterial UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.SpecularMaterial(SpecularMaterial view) => view?.UI;

        public static implicit operator SpecularMaterial(Windows.Media.Media3D.SpecularMaterial ui) => SpecularMaterial.StartChain(ui);

        protected SpecularMaterial() { }
    }

    public static partial class SpecularMaterialExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.SpecularMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Windows.Media.Brush value) where TView : SpecularMaterial { view.UI.Brush = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpecularMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, Color value) where TView : SpecularMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpecularMaterial.Brush"/></summary>
        public static TView Brush<TView>(this TView view, string color) where TView : SpecularMaterial { view.UI.Brush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpecularMaterial.Color"/></summary>
        public static TView Color<TView>(this TView view, Color value) where TView : SpecularMaterial { view.UI.Color = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpecularMaterial.SpecularPower"/></summary>
        public static TView SpecularPower<TView>(this TView view, double value) where TView : SpecularMaterial { view.UI.SpecularPower = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpecularMaterial.Brush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Brush<TTarget>(this TTarget target) where TTarget : SpecularMaterial
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Media.Media3D.SpecularMaterial.BrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpecularMaterial.Color"/></summary>
        public static DependencyProperty<TTarget, Color> Color<TTarget>(this TTarget target) where TTarget : SpecularMaterial
        => DependencyProperty<TTarget, Color>.Get(target, Windows.Media.Media3D.SpecularMaterial.ColorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpecularMaterial.SpecularPower"/></summary>
        public static DependencyProperty<TTarget, double> SpecularPower<TTarget>(this TTarget target) where TTarget : SpecularMaterial
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.SpecularMaterial.SpecularPowerProperty);
    }
}

namespace CSharpMarkup.Wpf // SpotLight
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.SpotLight"/></summary>
        public static SpotLight SpotLight(O<Windows.Media.Media3D.Vector3D> Direction = default, O<double> InnerConeAngle = default, O<double> OuterConeAngle = default)
        {
            var ui = new Windows.Media.Media3D.SpotLight();
            if (Direction.HasValue) ui.Direction = Direction.Value;
            if (InnerConeAngle.HasValue) ui.InnerConeAngle = InnerConeAngle.Value;
            if (OuterConeAngle.HasValue) ui.OuterConeAngle = OuterConeAngle.Value;
            return global::CSharpMarkup.Wpf.SpotLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.SpotLight"/></summary>
        public static SpotLight SpotLight()
        {
            var ui = new Windows.Media.Media3D.SpotLight();
            return global::CSharpMarkup.Wpf.SpotLight.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.SpotLight"/></summary>
        public static SpotLight SpotLight(Color diffuseColor, Windows.Media.Media3D.Point3D position, Windows.Media.Media3D.Vector3D direction, double outerConeAngle, double innerConeAngle)
        {
            var ui = new Windows.Media.Media3D.SpotLight(diffuseColor, position, direction, outerConeAngle, innerConeAngle);
            return global::CSharpMarkup.Wpf.SpotLight.StartChain(ui);
        }
    }

    public partial class SpotLight : PointLightBase, IUI<System.Windows.Media.Media3D.SpotLight>
    {
        static SpotLight instance;

        internal static SpotLight StartChain(Windows.Media.Media3D.SpotLight ui)
        {
            if (instance == null) instance = new SpotLight();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.SpotLight ui;

        public new Windows.Media.Media3D.SpotLight UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.SpotLight(SpotLight view) => view?.UI;

        public static implicit operator SpotLight(Windows.Media.Media3D.SpotLight ui) => SpotLight.StartChain(ui);

        protected SpotLight() { }
    }

    public static partial class SpotLightExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.SpotLight.Direction"/></summary>
        public static TView Direction<TView>(this TView view, Windows.Media.Media3D.Vector3D value) where TView : SpotLight { view.UI.Direction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpotLight.InnerConeAngle"/></summary>
        public static TView InnerConeAngle<TView>(this TView view, double value) where TView : SpotLight { view.UI.InnerConeAngle = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.SpotLight.OuterConeAngle"/></summary>
        public static TView OuterConeAngle<TView>(this TView view, double value) where TView : SpotLight { view.UI.OuterConeAngle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpotLight.Direction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D> Direction<TTarget>(this TTarget target) where TTarget : SpotLight
        => DependencyProperty<TTarget, Windows.Media.Media3D.Vector3D>.Get(target, Windows.Media.Media3D.SpotLight.DirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpotLight.InnerConeAngle"/></summary>
        public static DependencyProperty<TTarget, double> InnerConeAngle<TTarget>(this TTarget target) where TTarget : SpotLight
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.SpotLight.InnerConeAngleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.SpotLight.OuterConeAngle"/></summary>
        public static DependencyProperty<TTarget, double> OuterConeAngle<TTarget>(this TTarget target) where TTarget : SpotLight
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.SpotLight.OuterConeAngleProperty);
    }
}

namespace CSharpMarkup.Wpf // Transform3D
{
    public partial class Transform3D : GeneralTransform3D, IUI<System.Windows.Media.Media3D.Transform3D>
    {
        Windows.Media.Media3D.Transform3D ui;

        public new Windows.Media.Media3D.Transform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Transform3D() { }
    }
}

namespace CSharpMarkup.Wpf // Transform3DCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DCollection"/></summary>
        public static Transform3DCollection Transform3DCollection()
        {
            var ui = new Windows.Media.Media3D.Transform3DCollection();
            return global::CSharpMarkup.Wpf.Transform3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DCollection"/></summary>
        public static Transform3DCollection Transform3DCollection(IEnumerable<Windows.Media.Media3D.Transform3D> collection)
        {
            var ui = new Windows.Media.Media3D.Transform3DCollection(collection);
            return global::CSharpMarkup.Wpf.Transform3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DCollection"/></summary>
        public static Transform3DCollection Transform3DCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.Transform3DCollection(capacity);
            return global::CSharpMarkup.Wpf.Transform3DCollection.StartChain(ui);
        }
    }

    public partial class Transform3DCollection : Animatable, IUI<System.Windows.Media.Media3D.Transform3DCollection>
    {
        static Transform3DCollection instance;

        internal static Transform3DCollection StartChain(Windows.Media.Media3D.Transform3DCollection ui)
        {
            if (instance == null) instance = new Transform3DCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Transform3DCollection ui;

        public new Windows.Media.Media3D.Transform3DCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Transform3DCollection(Transform3DCollection view) => view?.UI;

        public static implicit operator Transform3DCollection(Windows.Media.Media3D.Transform3DCollection ui) => Transform3DCollection.StartChain(ui);

        protected Transform3DCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Transform3DGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DGroup"/></summary>
        public static Transform3DGroup Transform3DGroup(
            params System.Windows.Media.Media3D.Transform3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.Transform3DGroup();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Transform3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DGroup"/></summary>
        public static Transform3DGroup Transform3DGroup(O<Windows.Media.Media3D.Transform3DCollection> Children = default)
        {
            var ui = new Windows.Media.Media3D.Transform3DGroup();
            if (Children.HasValue) ui.Children = Children.Value;
            return global::CSharpMarkup.Wpf.Transform3DGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Transform3DGroup"/></summary>
        public static Transform3DGroup Transform3DGroup()
        {
            var ui = new Windows.Media.Media3D.Transform3DGroup();
            return global::CSharpMarkup.Wpf.Transform3DGroup.StartChain(ui);
        }
    }

    public partial class Transform3DGroup : Transform3D, IUI<System.Windows.Media.Media3D.Transform3DGroup>
    {
        static Transform3DGroup instance;

        internal static Transform3DGroup StartChain(Windows.Media.Media3D.Transform3DGroup ui)
        {
            if (instance == null) instance = new Transform3DGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Transform3DGroup ui;

        public new Windows.Media.Media3D.Transform3DGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Transform3DGroup(Transform3DGroup view) => view?.UI;

        public static implicit operator Transform3DGroup(Windows.Media.Media3D.Transform3DGroup ui) => Transform3DGroup.StartChain(ui);

        protected Transform3DGroup() { }
    }

    public static partial class Transform3DGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Transform3DGroup.Children"/></summary>
        public static TView Children<TView>(this TView view, Windows.Media.Media3D.Transform3DCollection value) where TView : Transform3DGroup { view.UI.Children = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Transform3DGroup.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Transform3DCollection> Children<TTarget>(this TTarget target) where TTarget : Transform3DGroup
        => DependencyProperty<TTarget, Windows.Media.Media3D.Transform3DCollection>.Get(target, Windows.Media.Media3D.Transform3DGroup.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // TranslateTransform3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.TranslateTransform3D"/></summary>
        public static TranslateTransform3D TranslateTransform3D(O<double> OffsetX = default, O<double> OffsetY = default, O<double> OffsetZ = default)
        {
            var ui = new Windows.Media.Media3D.TranslateTransform3D();
            if (OffsetX.HasValue) ui.OffsetX = OffsetX.Value;
            if (OffsetY.HasValue) ui.OffsetY = OffsetY.Value;
            if (OffsetZ.HasValue) ui.OffsetZ = OffsetZ.Value;
            return global::CSharpMarkup.Wpf.TranslateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.TranslateTransform3D"/></summary>
        public static TranslateTransform3D TranslateTransform3D()
        {
            var ui = new Windows.Media.Media3D.TranslateTransform3D();
            return global::CSharpMarkup.Wpf.TranslateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.TranslateTransform3D"/></summary>
        public static TranslateTransform3D TranslateTransform3D(double offsetX, double offsetY, double offsetZ)
        {
            var ui = new Windows.Media.Media3D.TranslateTransform3D(offsetX, offsetY, offsetZ);
            return global::CSharpMarkup.Wpf.TranslateTransform3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.TranslateTransform3D"/></summary>
        public static TranslateTransform3D TranslateTransform3D(Windows.Media.Media3D.Vector3D offset)
        {
            var ui = new Windows.Media.Media3D.TranslateTransform3D(offset);
            return global::CSharpMarkup.Wpf.TranslateTransform3D.StartChain(ui);
        }
    }

    public partial class TranslateTransform3D : AffineTransform3D, IUI<System.Windows.Media.Media3D.TranslateTransform3D>
    {
        static TranslateTransform3D instance;

        internal static TranslateTransform3D StartChain(Windows.Media.Media3D.TranslateTransform3D ui)
        {
            if (instance == null) instance = new TranslateTransform3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.TranslateTransform3D ui;

        public new Windows.Media.Media3D.TranslateTransform3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.TranslateTransform3D(TranslateTransform3D view) => view?.UI;

        public static implicit operator TranslateTransform3D(Windows.Media.Media3D.TranslateTransform3D ui) => TranslateTransform3D.StartChain(ui);

        protected TranslateTransform3D() { }
    }

    public static partial class TranslateTransform3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetX"/></summary>
        public static TView OffsetX<TView>(this TView view, double value) where TView : TranslateTransform3D { view.UI.OffsetX = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetY"/></summary>
        public static TView OffsetY<TView>(this TView view, double value) where TView : TranslateTransform3D { view.UI.OffsetY = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetZ"/></summary>
        public static TView OffsetZ<TView>(this TView view, double value) where TView : TranslateTransform3D { view.UI.OffsetZ = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetX"/></summary>
        public static DependencyProperty<TTarget, double> OffsetX<TTarget>(this TTarget target) where TTarget : TranslateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.TranslateTransform3D.OffsetXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetY"/></summary>
        public static DependencyProperty<TTarget, double> OffsetY<TTarget>(this TTarget target) where TTarget : TranslateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.TranslateTransform3D.OffsetYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.TranslateTransform3D.OffsetZ"/></summary>
        public static DependencyProperty<TTarget, double> OffsetZ<TTarget>(this TTarget target) where TTarget : TranslateTransform3D
        => DependencyProperty<TTarget, double>.Get(target, Windows.Media.Media3D.TranslateTransform3D.OffsetZProperty);
    }
}

namespace CSharpMarkup.Wpf // Vector3DCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Vector3DCollection"/></summary>
        public static Vector3DCollection Vector3DCollection()
        {
            var ui = new Windows.Media.Media3D.Vector3DCollection();
            return global::CSharpMarkup.Wpf.Vector3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Vector3DCollection"/></summary>
        public static Vector3DCollection Vector3DCollection(IEnumerable<Windows.Media.Media3D.Vector3D> collection)
        {
            var ui = new Windows.Media.Media3D.Vector3DCollection(collection);
            return global::CSharpMarkup.Wpf.Vector3DCollection.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Vector3DCollection"/></summary>
        public static Vector3DCollection Vector3DCollection(int capacity)
        {
            var ui = new Windows.Media.Media3D.Vector3DCollection(capacity);
            return global::CSharpMarkup.Wpf.Vector3DCollection.StartChain(ui);
        }
    }

    public partial class Vector3DCollection : Freezable, IUI<System.Windows.Media.Media3D.Vector3DCollection>
    {
        static Vector3DCollection instance;

        internal static Vector3DCollection StartChain(Windows.Media.Media3D.Vector3DCollection ui)
        {
            if (instance == null) instance = new Vector3DCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Vector3DCollection ui;

        public new Windows.Media.Media3D.Vector3DCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Vector3DCollection(Vector3DCollection view) => view?.UI;

        public static implicit operator Vector3DCollection(Windows.Media.Media3D.Vector3DCollection ui) => Vector3DCollection.StartChain(ui);

        protected Vector3DCollection() { }
    }
}

namespace CSharpMarkup.Wpf // Viewport2DVisual3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport2DVisual3D"/></summary>
        public static Viewport2DVisual3D Viewport2DVisual3D(
            System.Windows.Media.Visual Visual
)
        {
            var ui = new Windows.Media.Media3D.Viewport2DVisual3D();
            if (Visual is not null) ui.Visual = Visual;
            return global::CSharpMarkup.Wpf.Viewport2DVisual3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport2DVisual3D"/></summary>
        public static Viewport2DVisual3D Viewport2DVisual3D(O<Windows.Media.CacheMode> CacheMode = default, O<Windows.Media.Media3D.Geometry3D> Geometry = default, O<Windows.Media.Media3D.Material> Material = default, O<Windows.Media.Visual> Visual = default)
        {
            var ui = new Windows.Media.Media3D.Viewport2DVisual3D();
            if (CacheMode.HasValue) ui.CacheMode = CacheMode.Value;
            if (Geometry.HasValue) ui.Geometry = Geometry.Value;
            if (Material.HasValue) ui.Material = Material.Value;
            if (Visual.HasValue) ui.Visual = Visual.Value;
            return global::CSharpMarkup.Wpf.Viewport2DVisual3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport2DVisual3D"/></summary>
        public static Viewport2DVisual3D Viewport2DVisual3D()
        {
            var ui = new Windows.Media.Media3D.Viewport2DVisual3D();
            return global::CSharpMarkup.Wpf.Viewport2DVisual3D.StartChain(ui);
        }
    }

    public partial class Viewport2DVisual3D : Visual3D, IUI<System.Windows.Media.Media3D.Viewport2DVisual3D>
    {
        static Viewport2DVisual3D instance;

        internal static Viewport2DVisual3D StartChain(Windows.Media.Media3D.Viewport2DVisual3D ui)
        {
            if (instance == null) instance = new Viewport2DVisual3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Viewport2DVisual3D ui;

        public new Windows.Media.Media3D.Viewport2DVisual3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Viewport2DVisual3D(Viewport2DVisual3D view) => view?.UI;

        public static implicit operator Viewport2DVisual3D(Windows.Media.Media3D.Viewport2DVisual3D ui) => Viewport2DVisual3D.StartChain(ui);

        protected Viewport2DVisual3D() { }
    }

    public static partial class Viewport2DVisual3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport2DVisual3D.CacheMode"/></summary>
        public static TView CacheMode<TView>(this TView view, Windows.Media.CacheMode value) where TView : Viewport2DVisual3D { view.UI.CacheMode = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Geometry"/></summary>
        public static TView Geometry<TView>(this TView view, Windows.Media.Media3D.Geometry3D value) where TView : Viewport2DVisual3D { view.UI.Geometry = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Material"/></summary>
        public static TView Material<TView>(this TView view, Windows.Media.Media3D.Material value) where TView : Viewport2DVisual3D { view.UI.Material = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Visual"/></summary>
        public static TView Visual<TView>(this TView view, Windows.Media.Visual value) where TView : Viewport2DVisual3D { view.UI.Visual = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport2DVisual3D.CacheMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.CacheMode> CacheMode<TTarget>(this TTarget target) where TTarget : Viewport2DVisual3D
        => DependencyProperty<TTarget, Windows.Media.CacheMode>.Get(target, Windows.Media.Media3D.Viewport2DVisual3D.CacheModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Geometry"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Geometry3D> Geometry<TTarget>(this TTarget target) where TTarget : Viewport2DVisual3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Geometry3D>.Get(target, Windows.Media.Media3D.Viewport2DVisual3D.GeometryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Material"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Material> Material<TTarget>(this TTarget target) where TTarget : Viewport2DVisual3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Material>.Get(target, Windows.Media.Media3D.Viewport2DVisual3D.MaterialProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport2DVisual3D.Visual"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Visual> Visual<TTarget>(this TTarget target) where TTarget : Viewport2DVisual3D
        => DependencyProperty<TTarget, Windows.Media.Visual>.Get(target, Windows.Media.Media3D.Viewport2DVisual3D.VisualProperty);

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport2DVisual3D.IsVisualHostMaterial"/></summary>
        public static TTarget Viewport2DVisual3D_IsVisualHostMaterial<TTarget>(this TTarget target, bool value) where TTarget : Material
        { Windows.Media.Media3D.Viewport2DVisual3D.SetIsVisualHostMaterial(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport2DVisual3D.IsVisualHostMaterial"/></summary>
        public static DependencyProperty<TTarget, bool> Viewport2DVisual3D_IsVisualHostMaterial<TTarget>(this TTarget target) where TTarget : Material
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Media.Media3D.Viewport2DVisual3D.IsVisualHostMaterialProperty);
    }
}

namespace CSharpMarkup.Wpf // Viewport3DVisual
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport3DVisual"/></summary>
        public static Viewport3DVisual Viewport3DVisual(
            params System.Windows.Media.Media3D.Visual3D[] Children
)
        {
            var ui = new Windows.Media.Media3D.Viewport3DVisual();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Viewport3DVisual.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport3DVisual"/></summary>
        public static Viewport3DVisual Viewport3DVisual(O<Windows.Media.Effects.BitmapEffect> BitmapEffect = default, O<Windows.Media.Effects.BitmapEffectInput> BitmapEffectInput = default, O<Windows.Media.Media3D.Camera> Camera = default, O<Windows.Media.Geometry> Clip = default, O<Windows.Vector> Offset = default, O<double> Opacity = default, O<Windows.Media.Brush> OpacityMask = default, O<Windows.Media.Transform> Transform = default, O<Windows.Rect> Viewport = default)
        {
            var ui = new Windows.Media.Media3D.Viewport3DVisual();
            if (BitmapEffect.HasValue) ui.BitmapEffect = BitmapEffect.Value;
            if (BitmapEffectInput.HasValue) ui.BitmapEffectInput = BitmapEffectInput.Value;
            if (Camera.HasValue) ui.Camera = Camera.Value;
            if (Clip.HasValue) ui.Clip = Clip.Value;
            if (Offset.HasValue) ui.Offset = Offset.Value;
            if (Opacity.HasValue) ui.Opacity = Opacity.Value;
            if (OpacityMask.HasValue) ui.OpacityMask = OpacityMask.Value;
            if (Transform.HasValue) ui.Transform = Transform.Value;
            if (Viewport.HasValue) ui.Viewport = Viewport.Value;
            return global::CSharpMarkup.Wpf.Viewport3DVisual.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Media3D.Viewport3DVisual"/></summary>
        public static Viewport3DVisual Viewport3DVisual()
        {
            var ui = new Windows.Media.Media3D.Viewport3DVisual();
            return global::CSharpMarkup.Wpf.Viewport3DVisual.StartChain(ui);
        }
    }

    public partial class Viewport3DVisual : Visual, IUI<System.Windows.Media.Media3D.Viewport3DVisual>
    {
        static Viewport3DVisual instance;

        internal static Viewport3DVisual StartChain(Windows.Media.Media3D.Viewport3DVisual ui)
        {
            if (instance == null) instance = new Viewport3DVisual();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Media3D.Viewport3DVisual ui;

        public new Windows.Media.Media3D.Viewport3DVisual UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Media3D.Viewport3DVisual(Viewport3DVisual view) => view?.UI;

        public static implicit operator Viewport3DVisual(Windows.Media.Media3D.Viewport3DVisual ui) => Viewport3DVisual.StartChain(ui);

        protected Viewport3DVisual() { }
    }

    public static partial class Viewport3DVisualExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.BitmapEffect"/></summary>
        public static TView BitmapEffect<TView>(this TView view, Windows.Media.Effects.BitmapEffect value) where TView : Viewport3DVisual { view.UI.BitmapEffect = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.BitmapEffectInput"/></summary>
        public static TView BitmapEffectInput<TView>(this TView view, Windows.Media.Effects.BitmapEffectInput value) where TView : Viewport3DVisual { view.UI.BitmapEffectInput = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Camera"/></summary>
        public static TView Camera<TView>(this TView view, Windows.Media.Media3D.Camera value) where TView : Viewport3DVisual { view.UI.Camera = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Clip"/></summary>
        public static TView Clip<TView>(this TView view, Windows.Media.Geometry value) where TView : Viewport3DVisual { view.UI.Clip = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Offset"/></summary>
        public static TView Offset<TView>(this TView view, Windows.Vector value) where TView : Viewport3DVisual { view.UI.Offset = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Opacity"/></summary>
        public static TView Opacity<TView>(this TView view, double value) where TView : Viewport3DVisual { view.UI.Opacity = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Windows.Media.Brush value) where TView : Viewport3DVisual { view.UI.OpacityMask = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, Color value) where TView : Viewport3DVisual { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.OpacityMask"/></summary>
        public static TView OpacityMask<TView>(this TView view, string color) where TView : Viewport3DVisual { view.UI.OpacityMask = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Transform value) where TView : Viewport3DVisual { view.UI.Transform = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Media3D.Viewport3DVisual.Viewport"/></summary>
        public static TView Viewport<TView>(this TView view, Windows.Rect value) where TView : Viewport3DVisual { view.UI.Viewport = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport3DVisual.Camera"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Camera> Camera<TTarget>(this TTarget target) where TTarget : Viewport3DVisual
        => DependencyProperty<TTarget, Windows.Media.Media3D.Camera>.Get(target, Windows.Media.Media3D.Viewport3DVisual.CameraProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Viewport3DVisual.Viewport"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> Viewport<TTarget>(this TTarget target) where TTarget : Viewport3DVisual
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Media.Media3D.Viewport3DVisual.ViewportProperty);
    }
}

namespace CSharpMarkup.Wpf // Visual3D
{
    public partial class Visual3D : DependencyObject, IUI<System.Windows.Media.Media3D.Visual3D>
    {
        Windows.Media.Media3D.Visual3D ui;

        public new Windows.Media.Media3D.Visual3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Visual3D() { }
    }

    public static partial class Visual3DExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Media3D.Visual3D.Transform"/></summary>
        public static TView Transform<TView>(this TView view, Windows.Media.Media3D.Transform3D value) where TView : Visual3D { view.UI.Transform = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Media3D.Visual3D.Transform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D> Transform<TTarget>(this TTarget target) where TTarget : Visual3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Transform3D>.Get(target, Windows.Media.Media3D.Visual3D.TransformProperty);
    }
}

namespace CSharpMarkup.Wpf // DataTrigger
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.DataTrigger"/></summary>
        public static DataTrigger DataTrigger(
            params System.Windows.SetterBase[] Setters
)
        {
            var ui = new Windows.DataTrigger();
            foreach (var child in Setters) if (child is not null) ui.Setters.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Setters);
            return global::CSharpMarkup.Wpf.DataTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.DataTrigger"/></summary>
        public static DataTrigger DataTrigger(O<Windows.Data.BindingBase> Binding = default, O<object> Value = default)
        {
            var ui = new Windows.DataTrigger();
            if (Binding.HasValue) ui.Binding = Binding.Value;
            if (Value.HasValue) ui.Value = Value.Value;
            return global::CSharpMarkup.Wpf.DataTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.DataTrigger"/></summary>
        public static DataTrigger DataTrigger()
        {
            var ui = new Windows.DataTrigger();
            return global::CSharpMarkup.Wpf.DataTrigger.StartChain(ui);
        }
    }

    public partial class DataTrigger : TriggerBase, IUI<System.Windows.DataTrigger>
    {
        static DataTrigger instance;

        internal static DataTrigger StartChain(Windows.DataTrigger ui)
        {
            if (instance == null) instance = new DataTrigger();
            instance.UI = ui;
            return instance;
        }

        Windows.DataTrigger ui;

        public new Windows.DataTrigger UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.DataTrigger(DataTrigger view) => view?.UI;

        public static implicit operator DataTrigger(Windows.DataTrigger ui) => DataTrigger.StartChain(ui);

        protected DataTrigger() { }
    }

    public static partial class DataTriggerExtensions
    {
        /// <summary>Set <see cref="Windows.DataTrigger.Binding"/></summary>
        public static TView Binding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataTrigger { view.UI.Binding = value; return view; }

        /// <summary>Set <see cref="Windows.DataTrigger.Value"/></summary>
        public static TView Value<TView>(this TView view, object value) where TView : DataTrigger { view.UI.Value = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // EventTrigger
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.EventTrigger"/></summary>
        public static EventTrigger EventTrigger(
            params System.Windows.TriggerAction[] Actions
)
        {
            var ui = new Windows.EventTrigger();
            foreach (var child in Actions) if (child is not null) ui.Actions.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Actions);
            return global::CSharpMarkup.Wpf.EventTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.EventTrigger"/></summary>
        public static EventTrigger EventTrigger(O<Windows.RoutedEvent> RoutedEvent = default, O<string> SourceName = default)
        {
            var ui = new Windows.EventTrigger();
            if (RoutedEvent.HasValue) ui.RoutedEvent = RoutedEvent.Value;
            if (SourceName.HasValue) ui.SourceName = SourceName.Value;
            return global::CSharpMarkup.Wpf.EventTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.EventTrigger"/></summary>
        public static EventTrigger EventTrigger()
        {
            var ui = new Windows.EventTrigger();
            return global::CSharpMarkup.Wpf.EventTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.EventTrigger"/></summary>
        public static EventTrigger EventTrigger(Windows.RoutedEvent routedEvent)
        {
            var ui = new Windows.EventTrigger(routedEvent);
            return global::CSharpMarkup.Wpf.EventTrigger.StartChain(ui);
        }
    }

    public partial class EventTrigger : TriggerBase, IUI<System.Windows.EventTrigger>
    {
        static EventTrigger instance;

        internal static EventTrigger StartChain(Windows.EventTrigger ui)
        {
            if (instance == null) instance = new EventTrigger();
            instance.UI = ui;
            return instance;
        }

        Windows.EventTrigger ui;

        public new Windows.EventTrigger UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.EventTrigger(EventTrigger view) => view?.UI;

        public static implicit operator EventTrigger(Windows.EventTrigger ui) => EventTrigger.StartChain(ui);

        protected EventTrigger() { }
    }

    public static partial class EventTriggerExtensions
    {
        /// <summary>Set <see cref="Windows.EventTrigger.RoutedEvent"/></summary>
        public static TView RoutedEvent<TView>(this TView view, Windows.RoutedEvent value) where TView : EventTrigger { view.UI.RoutedEvent = value; return view; }

        /// <summary>Set <see cref="Windows.EventTrigger.SourceName"/></summary>
        public static TView SourceName<TView>(this TView view, string value) where TView : EventTrigger { view.UI.SourceName = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // FrameworkContentElement
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.FrameworkContentElement"/></summary>
        public static FrameworkContentElement FrameworkContentElement(O<Windows.Data.BindingGroup> BindingGroup = default, O<Windows.Controls.ContextMenu> ContextMenu = default, O<Windows.Input.Cursor> Cursor = default, O<object> DataContext = default, O<Windows.Style> FocusVisualStyle = default, O<bool> ForceCursor = default, O<Windows.Input.InputScope> InputScope = default, O<Windows.Markup.XmlLanguage> Language = default, O<string> Name = default, O<bool> OverridesDefaultStyle = default, O<Windows.ResourceDictionary> Resources = default, O<Windows.Style> Style = default, O<object> Tag = default, O<object> ToolTip = default)
        {
            var ui = new Windows.FrameworkContentElement();
            if (BindingGroup.HasValue) ui.BindingGroup = BindingGroup.Value;
            if (ContextMenu.HasValue) ui.ContextMenu = ContextMenu.Value;
            if (Cursor.HasValue) ui.Cursor = Cursor.Value;
            if (DataContext.HasValue) ui.DataContext = DataContext.Value;
            if (FocusVisualStyle.HasValue) ui.FocusVisualStyle = FocusVisualStyle.Value;
            if (ForceCursor.HasValue) ui.ForceCursor = ForceCursor.Value;
            if (InputScope.HasValue) ui.InputScope = InputScope.Value;
            if (Language.HasValue) ui.Language = Language.Value;
            if (Name.HasValue) ui.Name = Name.Value;
            if (OverridesDefaultStyle.HasValue) ui.OverridesDefaultStyle = OverridesDefaultStyle.Value;
            if (Resources.HasValue) ui.Resources = Resources.Value;
            if (Style.HasValue) ui.Style = Style.Value;
            if (Tag.HasValue) ui.Tag = Tag.Value;
            if (ToolTip.HasValue) ui.ToolTip = ToolTip.Value;
            return global::CSharpMarkup.Wpf.FrameworkContentElement.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.FrameworkContentElement"/></summary>
        public static FrameworkContentElement FrameworkContentElement()
        {
            var ui = new Windows.FrameworkContentElement();
            return global::CSharpMarkup.Wpf.FrameworkContentElement.StartChain(ui);
        }
    }

    public partial class FrameworkContentElement : ContentElement, IUI<System.Windows.FrameworkContentElement>
    {
        static FrameworkContentElement instance;

        internal static FrameworkContentElement StartChain(Windows.FrameworkContentElement ui)
        {
            if (instance == null) instance = new FrameworkContentElement();
            instance.UI = ui;
            return instance;
        }

        Windows.FrameworkContentElement ui;

        public new Windows.FrameworkContentElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.FrameworkContentElement(FrameworkContentElement view) => view?.UI;

        public static implicit operator FrameworkContentElement(Windows.FrameworkContentElement ui) => FrameworkContentElement.StartChain(ui);

        protected FrameworkContentElement() { }
    }

    public static partial class FrameworkContentElementExtensions
    {
        /// <summary>Set <see cref="Windows.FrameworkContentElement.BindingGroup"/></summary>
        public static TView BindingGroup<TView>(this TView view, Windows.Data.BindingGroup value) where TView : FrameworkContentElement { view.UI.BindingGroup = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.ContextMenu"/></summary>
        public static TView ContextMenu<TView>(this TView view, Windows.Controls.ContextMenu value) where TView : FrameworkContentElement { view.UI.ContextMenu = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Cursor"/></summary>
        public static TView Cursor<TView>(this TView view, Windows.Input.Cursor value) where TView : FrameworkContentElement { view.UI.Cursor = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.DataContext"/></summary>
        public static TView DataContext<TView>(this TView view, object value) where TView : FrameworkContentElement { view.UI.DataContext = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.FocusVisualStyle"/></summary>
        public static TView FocusVisualStyle<TView>(this TView view, Windows.Style value) where TView : FrameworkContentElement { view.UI.FocusVisualStyle = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.ForceCursor"/></summary>
        public static TView ForceCursor<TView>(this TView view, bool value) where TView : FrameworkContentElement { view.UI.ForceCursor = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.InputScope"/></summary>
        public static TView InputScope<TView>(this TView view, Windows.Input.InputScope value) where TView : FrameworkContentElement { view.UI.InputScope = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Language"/></summary>
        public static TView Language<TView>(this TView view, Windows.Markup.XmlLanguage value) where TView : FrameworkContentElement { view.UI.Language = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : FrameworkContentElement { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.OverridesDefaultStyle"/></summary>
        public static TView OverridesDefaultStyle<TView>(this TView view, bool value) where TView : FrameworkContentElement { view.UI.OverridesDefaultStyle = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Resources"/></summary>
        public static TView Resources<TView>(this TView view, Windows.ResourceDictionary value) where TView : FrameworkContentElement { view.UI.Resources = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Style"/></summary>
        public static TView Style<TView>(this TView view, Windows.Style value) where TView : FrameworkContentElement { view.UI.Style = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.Tag"/></summary>
        public static TView Tag<TView>(this TView view, object value) where TView : FrameworkContentElement { view.UI.Tag = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkContentElement.ToolTip"/></summary>
        public static TView ToolTip<TView>(this TView view, object value) where TView : FrameworkContentElement { view.UI.ToolTip = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.BindingGroup"/></summary>
        public static DependencyProperty<TTarget, Windows.Data.BindingGroup> BindingGroup<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Data.BindingGroup>.Get(target, Windows.FrameworkContentElement.BindingGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.ContextMenu"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ContextMenu> ContextMenu<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Controls.ContextMenu>.Get(target, Windows.FrameworkContentElement.ContextMenuProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.Cursor"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.Cursor> Cursor<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Input.Cursor>.Get(target, Windows.FrameworkContentElement.CursorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.DataContext"/></summary>
        public static DependencyProperty<TTarget, object> DataContext<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkContentElement.DataContextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.FocusVisualStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> FocusVisualStyle<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.FrameworkContentElement.FocusVisualStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.ForceCursor"/></summary>
        public static DependencyProperty<TTarget, bool> ForceCursor<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.FrameworkContentElement.ForceCursorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.InputScope"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.InputScope> InputScope<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Input.InputScope>.Get(target, Windows.FrameworkContentElement.InputScopeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.Language"/></summary>
        public static DependencyProperty<TTarget, Windows.Markup.XmlLanguage> Language<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Markup.XmlLanguage>.Get(target, Windows.FrameworkContentElement.LanguageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.Name"/></summary>
        public static DependencyProperty<TTarget, string> Name<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, string>.Get(target, Windows.FrameworkContentElement.NameProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.OverridesDefaultStyle"/></summary>
        public static DependencyProperty<TTarget, bool> OverridesDefaultStyle<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.FrameworkContentElement.OverridesDefaultStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.Style"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> Style<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.FrameworkContentElement.StyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.Tag"/></summary>
        public static DependencyProperty<TTarget, object> Tag<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkContentElement.TagProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkContentElement.ToolTip"/></summary>
        public static DependencyProperty<TTarget, object> ToolTip<TTarget>(this TTarget target) where TTarget : FrameworkContentElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkContentElement.ToolTipProperty);
    }
}

namespace CSharpMarkup.Wpf // FrameworkElement
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.FrameworkElement"/></summary>
        public static FrameworkElement FrameworkElement(O<Windows.Data.BindingGroup> BindingGroup = default, O<Windows.Controls.ContextMenu> ContextMenu = default, O<Windows.Input.Cursor> Cursor = default, O<object> DataContext = default, O<Windows.FlowDirection> FlowDirection = default, O<Windows.Style> FocusVisualStyle = default, O<bool> ForceCursor = default, O<double> Height = default, O<Windows.HorizontalAlignment> HorizontalAlignment = default, O<Windows.Input.InputScope> InputScope = default, O<Windows.Markup.XmlLanguage> Language = default, O<Windows.Media.Transform> LayoutTransform = default, O<Windows.Thickness> Margin = default, O<double> MaxHeight = default, O<double> MaxWidth = default, O<double> MinHeight = default, O<double> MinWidth = default, O<string> Name = default, O<bool> OverridesDefaultStyle = default, O<Windows.ResourceDictionary> Resources = default, O<Windows.Style> Style = default, O<object> Tag = default, O<object> ToolTip = default, O<bool> UseLayoutRounding = default, O<Windows.VerticalAlignment> VerticalAlignment = default, O<double> Width = default)
        {
            var ui = new Windows.FrameworkElement();
            if (BindingGroup.HasValue) ui.BindingGroup = BindingGroup.Value;
            if (ContextMenu.HasValue) ui.ContextMenu = ContextMenu.Value;
            if (Cursor.HasValue) ui.Cursor = Cursor.Value;
            if (DataContext.HasValue) ui.DataContext = DataContext.Value;
            if (FlowDirection.HasValue) ui.FlowDirection = FlowDirection.Value;
            if (FocusVisualStyle.HasValue) ui.FocusVisualStyle = FocusVisualStyle.Value;
            if (ForceCursor.HasValue) ui.ForceCursor = ForceCursor.Value;
            if (Height.HasValue) ui.Height = Height.Value;
            if (HorizontalAlignment.HasValue) ui.HorizontalAlignment = HorizontalAlignment.Value;
            if (InputScope.HasValue) ui.InputScope = InputScope.Value;
            if (Language.HasValue) ui.Language = Language.Value;
            if (LayoutTransform.HasValue) ui.LayoutTransform = LayoutTransform.Value;
            if (Margin.HasValue) ui.Margin = Margin.Value;
            if (MaxHeight.HasValue) ui.MaxHeight = MaxHeight.Value;
            if (MaxWidth.HasValue) ui.MaxWidth = MaxWidth.Value;
            if (MinHeight.HasValue) ui.MinHeight = MinHeight.Value;
            if (MinWidth.HasValue) ui.MinWidth = MinWidth.Value;
            if (Name.HasValue) ui.Name = Name.Value;
            if (OverridesDefaultStyle.HasValue) ui.OverridesDefaultStyle = OverridesDefaultStyle.Value;
            if (Resources.HasValue) ui.Resources = Resources.Value;
            if (Style.HasValue) ui.Style = Style.Value;
            if (Tag.HasValue) ui.Tag = Tag.Value;
            if (ToolTip.HasValue) ui.ToolTip = ToolTip.Value;
            if (UseLayoutRounding.HasValue) ui.UseLayoutRounding = UseLayoutRounding.Value;
            if (VerticalAlignment.HasValue) ui.VerticalAlignment = VerticalAlignment.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.FrameworkElement.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.FrameworkElement"/></summary>
        public static FrameworkElement FrameworkElement()
        {
            var ui = new Windows.FrameworkElement();
            return global::CSharpMarkup.Wpf.FrameworkElement.StartChain(ui);
        }
    }

    public partial class FrameworkElement : UIElement, IUI<System.Windows.FrameworkElement>
    {
        static FrameworkElement instance;

        internal static FrameworkElement StartChain(Windows.FrameworkElement ui)
        {
            if (instance == null) instance = new FrameworkElement();
            instance.UI = ui;
            return instance;
        }

        Windows.FrameworkElement ui;

        public new Windows.FrameworkElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(FrameworkElement view) => view?.UI;

        public static implicit operator Windows.FrameworkElement(FrameworkElement view) => view?.UI;

        public static implicit operator FrameworkElement(Windows.FrameworkElement ui) => FrameworkElement.StartChain(ui);

        protected FrameworkElement() { }
    }

    public static partial class FrameworkElementExtensions
    {
        /// <summary>Set <see cref="Windows.FrameworkElement.BindingGroup"/></summary>
        public static TView BindingGroup<TView>(this TView view, Windows.Data.BindingGroup value) where TView : FrameworkElement { view.UI.BindingGroup = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.ContextMenu"/></summary>
        public static TView ContextMenu<TView>(this TView view, Windows.Controls.ContextMenu value) where TView : FrameworkElement { view.UI.ContextMenu = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Cursor"/></summary>
        public static TView Cursor<TView>(this TView view, Windows.Input.Cursor value) where TView : FrameworkElement { view.UI.Cursor = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.DataContext"/></summary>
        public static TView DataContext<TView>(this TView view, object value) where TView : FrameworkElement { view.UI.DataContext = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : FrameworkElement { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.FocusVisualStyle"/></summary>
        public static TView FocusVisualStyle<TView>(this TView view, Windows.Style value) where TView : FrameworkElement { view.UI.FocusVisualStyle = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.ForceCursor"/></summary>
        public static TView ForceCursor<TView>(this TView view, bool value) where TView : FrameworkElement { view.UI.ForceCursor = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Height"/></summary>
        public static TView Height<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.Height = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.HorizontalAlignment"/></summary>
        public static TView HorizontalAlignment<TView>(this TView view, Windows.HorizontalAlignment value) where TView : FrameworkElement { view.UI.HorizontalAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.InputScope"/></summary>
        public static TView InputScope<TView>(this TView view, Windows.Input.InputScope value) where TView : FrameworkElement { view.UI.InputScope = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Language"/></summary>
        public static TView Language<TView>(this TView view, Windows.Markup.XmlLanguage value) where TView : FrameworkElement { view.UI.Language = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.LayoutTransform"/></summary>
        public static TView LayoutTransform<TView>(this TView view, Windows.Media.Transform value) where TView : FrameworkElement { view.UI.LayoutTransform = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static TView Margin<TView>(this TView view, Windows.Thickness value) where TView : FrameworkElement { view.UI.Margin = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double uniform) where TView : FrameworkElement { view.UI.Margin = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double horizontal, double vertical) where TView : FrameworkElement { view.UI.Margin = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double left, double top, double right, double bottom) where TView : FrameworkElement { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static TView Margins<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : FrameworkElement { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.MaxHeight"/></summary>
        public static TView MaxHeight<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.MaxHeight = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.MaxWidth"/></summary>
        public static TView MaxWidth<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.MaxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.MinHeight"/></summary>
        public static TView MinHeight<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.MinHeight = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.MinWidth"/></summary>
        public static TView MinWidth<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.MinWidth = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : FrameworkElement { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.OverridesDefaultStyle"/></summary>
        public static TView OverridesDefaultStyle<TView>(this TView view, bool value) where TView : FrameworkElement { view.UI.OverridesDefaultStyle = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Resources"/></summary>
        public static TView Resources<TView>(this TView view, Windows.ResourceDictionary value) where TView : FrameworkElement { view.UI.Resources = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Style"/></summary>
        public static TView Style<TView>(this TView view, Windows.Style value) where TView : FrameworkElement { view.UI.Style = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Tag"/></summary>
        public static TView Tag<TView>(this TView view, object value) where TView : FrameworkElement { view.UI.Tag = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.ToolTip"/></summary>
        public static TView ToolTip<TView>(this TView view, object value) where TView : FrameworkElement { view.UI.ToolTip = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.UseLayoutRounding"/></summary>
        public static TView UseLayoutRounding<TView>(this TView view, bool value) where TView : FrameworkElement { view.UI.UseLayoutRounding = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.VerticalAlignment"/></summary>
        public static TView VerticalAlignment<TView>(this TView view, Windows.VerticalAlignment value) where TView : FrameworkElement { view.UI.VerticalAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.FrameworkElement.Width"/></summary>
        public static TView Width<TView>(this TView view, double value) where TView : FrameworkElement { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.ActualHeight"/></summary>
        public static DependencyProperty<TTarget, double> ActualHeight<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.ActualHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.ActualWidth"/></summary>
        public static DependencyProperty<TTarget, double> ActualWidth<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.ActualWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.BindingGroup"/></summary>
        public static DependencyProperty<TTarget, Windows.Data.BindingGroup> BindingGroup<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Data.BindingGroup>.Get(target, Windows.FrameworkElement.BindingGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.ContextMenu"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ContextMenu> ContextMenu<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Controls.ContextMenu>.Get(target, Windows.FrameworkElement.ContextMenuProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Cursor"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.Cursor> Cursor<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Input.Cursor>.Get(target, Windows.FrameworkElement.CursorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.DataContext"/></summary>
        public static DependencyProperty<TTarget, object> DataContext<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkElement.DataContextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.FrameworkElement.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.FocusVisualStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> FocusVisualStyle<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.FrameworkElement.FocusVisualStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.ForceCursor"/></summary>
        public static DependencyProperty<TTarget, bool> ForceCursor<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.FrameworkElement.ForceCursorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Height"/></summary>
        public static DependencyProperty<TTarget, double> Height<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.HeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.HorizontalAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.HorizontalAlignment> HorizontalAlignment<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.HorizontalAlignment>.Get(target, Windows.FrameworkElement.HorizontalAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.InputScope"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.InputScope> InputScope<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Input.InputScope>.Get(target, Windows.FrameworkElement.InputScopeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Language"/></summary>
        public static DependencyProperty<TTarget, Windows.Markup.XmlLanguage> Language<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Markup.XmlLanguage>.Get(target, Windows.FrameworkElement.LanguageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.LayoutTransform"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Transform> LayoutTransform<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Media.Transform>.Get(target, Windows.FrameworkElement.LayoutTransformProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Margin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Margin<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.FrameworkElement.MarginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.MaxHeight"/></summary>
        public static DependencyProperty<TTarget, double> MaxHeight<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.MaxHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.MaxWidth"/></summary>
        public static DependencyProperty<TTarget, double> MaxWidth<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.MaxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.MinHeight"/></summary>
        public static DependencyProperty<TTarget, double> MinHeight<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.MinHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.MinWidth"/></summary>
        public static DependencyProperty<TTarget, double> MinWidth<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.MinWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Name"/></summary>
        public static DependencyProperty<TTarget, string> Name<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, string>.Get(target, Windows.FrameworkElement.NameProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.OverridesDefaultStyle"/></summary>
        public static DependencyProperty<TTarget, bool> OverridesDefaultStyle<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.FrameworkElement.OverridesDefaultStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Style"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> Style<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.FrameworkElement.StyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Tag"/></summary>
        public static DependencyProperty<TTarget, object> Tag<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkElement.TagProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.ToolTip"/></summary>
        public static DependencyProperty<TTarget, object> ToolTip<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, object>.Get(target, Windows.FrameworkElement.ToolTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.UseLayoutRounding"/></summary>
        public static DependencyProperty<TTarget, bool> UseLayoutRounding<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.FrameworkElement.UseLayoutRoundingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.VerticalAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.VerticalAlignment> VerticalAlignment<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.VerticalAlignment>.Get(target, Windows.FrameworkElement.VerticalAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.Width"/></summary>
        public static DependencyProperty<TTarget, double> Width<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.FrameworkElement.WidthProperty);

        /// <summary>Set <see cref="Windows.FrameworkElement.FlowDirection"/></summary>
        public static TTarget FrameworkElement_FlowDirection<TTarget>(this TTarget target, Windows.FlowDirection value) where TTarget : DependencyObject
        { Windows.FrameworkElement.SetFlowDirection(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.FrameworkElement.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FrameworkElement_FlowDirection<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.FrameworkElement.FlowDirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // MultiDataTrigger
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.MultiDataTrigger"/></summary>
        public static MultiDataTrigger MultiDataTrigger(
            params System.Windows.SetterBase[] Setters
)
        {
            var ui = new Windows.MultiDataTrigger();
            foreach (var child in Setters) if (child is not null) ui.Setters.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Setters);
            return global::CSharpMarkup.Wpf.MultiDataTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.MultiDataTrigger"/></summary>
        public static MultiDataTrigger MultiDataTrigger()
        {
            var ui = new Windows.MultiDataTrigger();
            return global::CSharpMarkup.Wpf.MultiDataTrigger.StartChain(ui);
        }
    }

    public partial class MultiDataTrigger : TriggerBase, IUI<System.Windows.MultiDataTrigger>
    {
        static MultiDataTrigger instance;

        internal static MultiDataTrigger StartChain(Windows.MultiDataTrigger ui)
        {
            if (instance == null) instance = new MultiDataTrigger();
            instance.UI = ui;
            return instance;
        }

        Windows.MultiDataTrigger ui;

        public new Windows.MultiDataTrigger UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.MultiDataTrigger(MultiDataTrigger view) => view?.UI;

        public static implicit operator MultiDataTrigger(Windows.MultiDataTrigger ui) => MultiDataTrigger.StartChain(ui);

        protected MultiDataTrigger() { }
    }
}

namespace CSharpMarkup.Wpf // MultiTrigger
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.MultiTrigger"/></summary>
        public static MultiTrigger MultiTrigger(
            params System.Windows.SetterBase[] Setters
)
        {
            var ui = new Windows.MultiTrigger();
            foreach (var child in Setters) if (child is not null) ui.Setters.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Setters);
            return global::CSharpMarkup.Wpf.MultiTrigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.MultiTrigger"/></summary>
        public static MultiTrigger MultiTrigger()
        {
            var ui = new Windows.MultiTrigger();
            return global::CSharpMarkup.Wpf.MultiTrigger.StartChain(ui);
        }
    }

    public partial class MultiTrigger : TriggerBase, IUI<System.Windows.MultiTrigger>
    {
        static MultiTrigger instance;

        internal static MultiTrigger StartChain(Windows.MultiTrigger ui)
        {
            if (instance == null) instance = new MultiTrigger();
            instance.UI = ui;
            return instance;
        }

        Windows.MultiTrigger ui;

        public new Windows.MultiTrigger UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.MultiTrigger(MultiTrigger view) => view?.UI;

        public static implicit operator MultiTrigger(Windows.MultiTrigger ui) => MultiTrigger.StartChain(ui);

        protected MultiTrigger() { }
    }
}

namespace CSharpMarkup.Wpf // Trigger
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Trigger"/></summary>
        public static Trigger Trigger(
            params System.Windows.SetterBase[] Setters
)
        {
            var ui = new Windows.Trigger();
            foreach (var child in Setters) if (child is not null) ui.Setters.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Setters);
            return global::CSharpMarkup.Wpf.Trigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Trigger"/></summary>
        public static Trigger Trigger(O<Windows.DependencyProperty> Property = default, O<string> SourceName = default, O<object> Value = default)
        {
            var ui = new Windows.Trigger();
            if (Property.HasValue) ui.Property = Property.Value;
            if (SourceName.HasValue) ui.SourceName = SourceName.Value;
            if (Value.HasValue) ui.Value = Value.Value;
            return global::CSharpMarkup.Wpf.Trigger.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Trigger"/></summary>
        public static Trigger Trigger()
        {
            var ui = new Windows.Trigger();
            return global::CSharpMarkup.Wpf.Trigger.StartChain(ui);
        }
    }

    public partial class Trigger : TriggerBase, IUI<System.Windows.Trigger>
    {
        static Trigger instance;

        internal static Trigger StartChain(Windows.Trigger ui)
        {
            if (instance == null) instance = new Trigger();
            instance.UI = ui;
            return instance;
        }

        Windows.Trigger ui;

        public new Windows.Trigger UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Trigger(Trigger view) => view?.UI;

        public static implicit operator Trigger(Windows.Trigger ui) => Trigger.StartChain(ui);

        protected Trigger() { }
    }

    public static partial class TriggerExtensions
    {
        /// <summary>Set <see cref="Windows.Trigger.Property"/></summary>
        public static TView Property<TView>(this TView view, Windows.DependencyProperty value) where TView : Trigger { view.UI.Property = value; return view; }

        /// <summary>Set <see cref="Windows.Trigger.SourceName"/></summary>
        public static TView SourceName<TView>(this TView view, string value) where TView : Trigger { view.UI.SourceName = value; return view; }

        /// <summary>Set <see cref="Windows.Trigger.Value"/></summary>
        public static TView Value<TView>(this TView view, object value) where TView : Trigger { view.UI.Value = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // TriggerAction
{
    public partial class TriggerAction : DependencyObject, IUI<System.Windows.TriggerAction>
    {
        Windows.TriggerAction ui;

        public new Windows.TriggerAction UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TriggerAction() { }
    }
}

namespace CSharpMarkup.Wpf // TriggerBase
{
    public partial class TriggerBase : DependencyObject, IUI<System.Windows.TriggerBase>
    {
        Windows.TriggerBase ui;

        public new Windows.TriggerBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TriggerBase() { }
    }
}

namespace CSharpMarkup.Wpf // VisualState
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.VisualState"/></summary>
        public static VisualState VisualState(
            System.Windows.Media.Animation.Storyboard Storyboard
)
        {
            var ui = new Windows.VisualState();
            if (Storyboard is not null) ui.Storyboard = Storyboard;
            return global::CSharpMarkup.Wpf.VisualState.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualState"/></summary>
        public static VisualState VisualState(O<string> Name = default, O<Windows.Media.Animation.Storyboard> Storyboard = default)
        {
            var ui = new Windows.VisualState();
            if (Name.HasValue) ui.Name = Name.Value;
            if (Storyboard.HasValue) ui.Storyboard = Storyboard.Value;
            return global::CSharpMarkup.Wpf.VisualState.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualState"/></summary>
        public static VisualState VisualState()
        {
            var ui = new Windows.VisualState();
            return global::CSharpMarkup.Wpf.VisualState.StartChain(ui);
        }
    }

    public partial class VisualState : DependencyObject, IUI<System.Windows.VisualState>
    {
        static VisualState instance;

        internal static VisualState StartChain(Windows.VisualState ui)
        {
            if (instance == null) instance = new VisualState();
            instance.UI = ui;
            return instance;
        }

        Windows.VisualState ui;

        public new Windows.VisualState UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.VisualState(VisualState view) => view?.UI;

        public static implicit operator VisualState(Windows.VisualState ui) => VisualState.StartChain(ui);

        protected VisualState() { }
    }

    public static partial class VisualStateExtensions
    {
        /// <summary>Set <see cref="Windows.VisualState.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : VisualState { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.VisualState.Storyboard"/></summary>
        public static TView Storyboard<TView>(this TView view, Windows.Media.Animation.Storyboard value) where TView : VisualState { view.UI.Storyboard = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // VisualStateGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.VisualStateGroup"/></summary>
        public static VisualStateGroup VisualStateGroup(
            params object?[] States
)
        {
            var ui = new Windows.VisualStateGroup();
            foreach (var child in States) if (child is not null) ui.States.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.States);
            return global::CSharpMarkup.Wpf.VisualStateGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualStateGroup"/></summary>
        public static VisualStateGroup VisualStateGroup(O<string> Name = default)
        {
            var ui = new Windows.VisualStateGroup();
            if (Name.HasValue) ui.Name = Name.Value;
            return global::CSharpMarkup.Wpf.VisualStateGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualStateGroup"/></summary>
        public static VisualStateGroup VisualStateGroup()
        {
            var ui = new Windows.VisualStateGroup();
            return global::CSharpMarkup.Wpf.VisualStateGroup.StartChain(ui);
        }
    }

    public partial class VisualStateGroup : DependencyObject, IUI<System.Windows.VisualStateGroup>
    {
        static VisualStateGroup instance;

        internal static VisualStateGroup StartChain(Windows.VisualStateGroup ui)
        {
            if (instance == null) instance = new VisualStateGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.VisualStateGroup ui;

        public new Windows.VisualStateGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.VisualStateGroup(VisualStateGroup view) => view?.UI;

        public static implicit operator VisualStateGroup(Windows.VisualStateGroup ui) => VisualStateGroup.StartChain(ui);

        protected VisualStateGroup() { }
    }

    public static partial class VisualStateGroupExtensions
    {
        /// <summary>Set <see cref="Windows.VisualStateGroup.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : VisualStateGroup { view.UI.Name = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // VisualStateManager
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.VisualStateManager"/></summary>
        public static VisualStateManager VisualStateManager()
        {
            var ui = new Windows.VisualStateManager();
            return global::CSharpMarkup.Wpf.VisualStateManager.StartChain(ui);
        }
    }

    public partial class VisualStateManager : DependencyObject, IUI<System.Windows.VisualStateManager>
    {
        static VisualStateManager instance;

        internal static VisualStateManager StartChain(Windows.VisualStateManager ui)
        {
            if (instance == null) instance = new VisualStateManager();
            instance.UI = ui;
            return instance;
        }

        Windows.VisualStateManager ui;

        public new Windows.VisualStateManager UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.VisualStateManager(VisualStateManager view) => view?.UI;

        public static implicit operator VisualStateManager(Windows.VisualStateManager ui) => VisualStateManager.StartChain(ui);

        protected VisualStateManager() { }
    }

    public static partial class VisualStateManagerExtensions
    {
        /// <summary>Set <see cref="Windows.VisualStateManager.CustomVisualStateManager"/></summary>
        public static TTarget VisualStateManager_CustomVisualStateManager<TTarget>(this TTarget target, Windows.VisualStateManager value) where TTarget : FrameworkElement
        { Windows.VisualStateManager.SetCustomVisualStateManager(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.VisualStateManager.CustomVisualStateManager"/></summary>
        public static DependencyProperty<TTarget, Windows.VisualStateManager> VisualStateManager_CustomVisualStateManager<TTarget>(this TTarget target) where TTarget : FrameworkElement
        => DependencyProperty<TTarget, Windows.VisualStateManager>.Get(target, Windows.VisualStateManager.CustomVisualStateManagerProperty);
    }
}

namespace CSharpMarkup.Wpf // VisualTransition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.VisualTransition"/></summary>
        public static VisualTransition VisualTransition(
            System.Windows.Media.Animation.Storyboard Storyboard
)
        {
            var ui = new Windows.VisualTransition();
            if (Storyboard is not null) ui.Storyboard = Storyboard;
            return global::CSharpMarkup.Wpf.VisualTransition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualTransition"/></summary>
        public static VisualTransition VisualTransition(O<string> From = default, O<Windows.Duration> GeneratedDuration = default, O<Windows.Media.Animation.IEasingFunction> GeneratedEasingFunction = default, O<Windows.Media.Animation.Storyboard> Storyboard = default, O<string> To = default)
        {
            var ui = new Windows.VisualTransition();
            if (From.HasValue) ui.From = From.Value;
            if (GeneratedDuration.HasValue) ui.GeneratedDuration = GeneratedDuration.Value;
            if (GeneratedEasingFunction.HasValue) ui.GeneratedEasingFunction = GeneratedEasingFunction.Value;
            if (Storyboard.HasValue) ui.Storyboard = Storyboard.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.VisualTransition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.VisualTransition"/></summary>
        public static VisualTransition VisualTransition()
        {
            var ui = new Windows.VisualTransition();
            return global::CSharpMarkup.Wpf.VisualTransition.StartChain(ui);
        }
    }

    public partial class VisualTransition : DependencyObject, IUI<System.Windows.VisualTransition>
    {
        static VisualTransition instance;

        internal static VisualTransition StartChain(Windows.VisualTransition ui)
        {
            if (instance == null) instance = new VisualTransition();
            instance.UI = ui;
            return instance;
        }

        Windows.VisualTransition ui;

        public new Windows.VisualTransition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.VisualTransition(VisualTransition view) => view?.UI;

        public static implicit operator VisualTransition(Windows.VisualTransition ui) => VisualTransition.StartChain(ui);

        protected VisualTransition() { }
    }

    public static partial class VisualTransitionExtensions
    {
        /// <summary>Set <see cref="Windows.VisualTransition.From"/></summary>
        public static TView From<TView>(this TView view, string value) where TView : VisualTransition { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.VisualTransition.GeneratedDuration"/></summary>
        public static TView GeneratedDuration<TView>(this TView view, Windows.Duration value) where TView : VisualTransition { view.UI.GeneratedDuration = value; return view; }

        /// <summary>Set <see cref="Windows.VisualTransition.GeneratedEasingFunction"/></summary>
        public static TView GeneratedEasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : VisualTransition { view.UI.GeneratedEasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.VisualTransition.Storyboard"/></summary>
        public static TView Storyboard<TView>(this TView view, Windows.Media.Animation.Storyboard value) where TView : VisualTransition { view.UI.Storyboard = value; return view; }

        /// <summary>Set <see cref="Windows.VisualTransition.To"/></summary>
        public static TView To<TView>(this TView view, string value) where TView : VisualTransition { view.UI.To = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Window
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Window"/></summary>
        public static Window Window(
            object Content
)
        {
            var ui = new Windows.Window();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.Window.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Window"/></summary>
        public static Window Window(O<bool> AllowsTransparency = default, O<bool?> DialogResult = default, O<Windows.Media.ImageSource> Icon = default, O<double> Left = default, O<Windows.Window> Owner = default, O<Windows.ResizeMode> ResizeMode = default, O<bool> ShowActivated = default, O<bool> ShowInTaskbar = default, O<Windows.SizeToContent> SizeToContent = default, O<Windows.Shell.TaskbarItemInfo> TaskbarItemInfo = default, O<string> Title = default, O<double> Top = default, O<bool> Topmost = default, O<Windows.WindowStartupLocation> WindowStartupLocation = default, O<Windows.WindowState> WindowState = default, O<Windows.WindowStyle> WindowStyle = default)
        {
            var ui = new Windows.Window();
            if (AllowsTransparency.HasValue) ui.AllowsTransparency = AllowsTransparency.Value;
            if (DialogResult.HasValue) ui.DialogResult = DialogResult.Value;
            if (Icon.HasValue) ui.Icon = Icon.Value;
            if (Left.HasValue) ui.Left = Left.Value;
            if (Owner.HasValue) ui.Owner = Owner.Value;
            if (ResizeMode.HasValue) ui.ResizeMode = ResizeMode.Value;
            if (ShowActivated.HasValue) ui.ShowActivated = ShowActivated.Value;
            if (ShowInTaskbar.HasValue) ui.ShowInTaskbar = ShowInTaskbar.Value;
            if (SizeToContent.HasValue) ui.SizeToContent = SizeToContent.Value;
            if (TaskbarItemInfo.HasValue) ui.TaskbarItemInfo = TaskbarItemInfo.Value;
            if (Title.HasValue) ui.Title = Title.Value;
            if (Top.HasValue) ui.Top = Top.Value;
            if (Topmost.HasValue) ui.Topmost = Topmost.Value;
            if (WindowStartupLocation.HasValue) ui.WindowStartupLocation = WindowStartupLocation.Value;
            if (WindowState.HasValue) ui.WindowState = WindowState.Value;
            if (WindowStyle.HasValue) ui.WindowStyle = WindowStyle.Value;
            return global::CSharpMarkup.Wpf.Window.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Window"/></summary>
        public static Window Window()
        {
            var ui = new Windows.Window();
            return global::CSharpMarkup.Wpf.Window.StartChain(ui);
        }
    }

    public partial class Window : ContentControl, IUI<System.Windows.Window>
    {
        static Window instance;

        internal static Window StartChain(Windows.Window ui)
        {
            if (instance == null) instance = new Window();
            instance.UI = ui;
            return instance;
        }

        Windows.Window ui;

        public new Windows.Window UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Window view) => view?.UI;

        public static implicit operator Windows.Window(Window view) => view?.UI;

        public static implicit operator Window(Windows.Window ui) => Window.StartChain(ui);

        protected Window() { }
    }

    public static partial class WindowExtensions
    {
        /// <summary>Set <see cref="Windows.Window.AllowsTransparency"/></summary>
        public static TView AllowsTransparency<TView>(this TView view, bool value) where TView : Window { view.UI.AllowsTransparency = value; return view; }

        /// <summary>Set <see cref="Windows.Window.DialogResult"/></summary>
        public static TView DialogResult<TView>(this TView view, bool? value) where TView : Window { view.UI.DialogResult = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Icon"/></summary>
        public static TView Icon<TView>(this TView view, Windows.Media.ImageSource value) where TView : Window { view.UI.Icon = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Left"/></summary>
        public static TView Left<TView>(this TView view, double value) where TView : Window { view.UI.Left = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Owner"/></summary>
        public static TView Owner<TView>(this TView view, Windows.Window value) where TView : Window { view.UI.Owner = value; return view; }

        /// <summary>Set <see cref="Windows.Window.ResizeMode"/></summary>
        public static TView ResizeMode<TView>(this TView view, Windows.ResizeMode value) where TView : Window { view.UI.ResizeMode = value; return view; }

        /// <summary>Set <see cref="Windows.Window.ShowActivated"/></summary>
        public static TView ShowActivated<TView>(this TView view, bool value) where TView : Window { view.UI.ShowActivated = value; return view; }

        /// <summary>Set <see cref="Windows.Window.ShowInTaskbar"/></summary>
        public static TView ShowInTaskbar<TView>(this TView view, bool value) where TView : Window { view.UI.ShowInTaskbar = value; return view; }

        /// <summary>Set <see cref="Windows.Window.SizeToContent"/></summary>
        public static TView SizeToContent<TView>(this TView view, Windows.SizeToContent value) where TView : Window { view.UI.SizeToContent = value; return view; }

        /// <summary>Set <see cref="Windows.Window.TaskbarItemInfo"/></summary>
        public static TView TaskbarItemInfo<TView>(this TView view, Windows.Shell.TaskbarItemInfo value) where TView : Window { view.UI.TaskbarItemInfo = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Title"/></summary>
        public static TView Title<TView>(this TView view, string value) where TView : Window { view.UI.Title = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Top"/></summary>
        public static TView Top<TView>(this TView view, double value) where TView : Window { view.UI.Top = value; return view; }

        /// <summary>Set <see cref="Windows.Window.Topmost"/></summary>
        public static TView Topmost<TView>(this TView view, bool value) where TView : Window { view.UI.Topmost = value; return view; }

        /// <summary>Set <see cref="Windows.Window.WindowStartupLocation"/></summary>
        public static TView WindowStartupLocation<TView>(this TView view, Windows.WindowStartupLocation value) where TView : Window { view.UI.WindowStartupLocation = value; return view; }

        /// <summary>Set <see cref="Windows.Window.WindowState"/></summary>
        public static TView WindowState<TView>(this TView view, Windows.WindowState value) where TView : Window { view.UI.WindowState = value; return view; }

        /// <summary>Set <see cref="Windows.Window.WindowStyle"/></summary>
        public static TView WindowStyle<TView>(this TView view, Windows.WindowStyle value) where TView : Window { view.UI.WindowStyle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.AllowsTransparency"/></summary>
        public static DependencyProperty<TTarget, bool> AllowsTransparency<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Window.AllowsTransparencyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.Icon"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> Icon<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Window.IconProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.IsActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsActive<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Window.IsActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.Left"/></summary>
        public static DependencyProperty<TTarget, double> Left<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, double>.Get(target, Windows.Window.LeftProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.ResizeMode"/></summary>
        public static DependencyProperty<TTarget, Windows.ResizeMode> ResizeMode<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.ResizeMode>.Get(target, Windows.Window.ResizeModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.ShowActivated"/></summary>
        public static DependencyProperty<TTarget, bool> ShowActivated<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Window.ShowActivatedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.ShowInTaskbar"/></summary>
        public static DependencyProperty<TTarget, bool> ShowInTaskbar<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Window.ShowInTaskbarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.SizeToContent"/></summary>
        public static DependencyProperty<TTarget, Windows.SizeToContent> SizeToContent<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.SizeToContent>.Get(target, Windows.Window.SizeToContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.TaskbarItemInfo"/></summary>
        public static DependencyProperty<TTarget, Windows.Shell.TaskbarItemInfo> TaskbarItemInfo<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.Shell.TaskbarItemInfo>.Get(target, Windows.Window.TaskbarItemInfoProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.Title"/></summary>
        public static DependencyProperty<TTarget, string> Title<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, string>.Get(target, Windows.Window.TitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.Topmost"/></summary>
        public static DependencyProperty<TTarget, bool> Topmost<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Window.TopmostProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.Top"/></summary>
        public static DependencyProperty<TTarget, double> Top<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, double>.Get(target, Windows.Window.TopProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.WindowState"/></summary>
        public static DependencyProperty<TTarget, Windows.WindowState> WindowState<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.WindowState>.Get(target, Windows.Window.WindowStateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Window.WindowStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.WindowStyle> WindowStyle<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.WindowStyle>.Get(target, Windows.Window.WindowStyleProperty);
    }
}

namespace CSharpMarkup.Wpf // AccessText
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.AccessText"/></summary>
        public static AccessText AccessText(
            string Text
)
        {
            var ui = new Windows.Controls.AccessText();
            if (Text is not null) ui.Text = Text;
            return global::CSharpMarkup.Wpf.AccessText.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.AccessText"/></summary>
        public static AccessText AccessText(O<Windows.Media.Brush> Background = default, O<double> BaselineOffset = default, O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.FontStretch> FontStretch = default, O<Windows.FontStyle> FontStyle = default, O<Windows.FontWeight> FontWeight = default, O<Windows.Media.Brush> Foreground = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<string> Text = default, O<Windows.TextAlignment> TextAlignment = default, O<Windows.TextDecorationCollection> TextDecorations = default, O<Windows.Media.TextEffectCollection> TextEffects = default, O<Windows.TextTrimming> TextTrimming = default, O<Windows.TextWrapping> TextWrapping = default)
        {
            var ui = new Windows.Controls.AccessText();
            if (Background.HasValue) ui.Background = Background.Value;
            if (BaselineOffset.HasValue) ui.BaselineOffset = BaselineOffset.Value;
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (FontStretch.HasValue) ui.FontStretch = FontStretch.Value;
            if (FontStyle.HasValue) ui.FontStyle = FontStyle.Value;
            if (FontWeight.HasValue) ui.FontWeight = FontWeight.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            if (TextDecorations.HasValue) ui.TextDecorations = TextDecorations.Value;
            if (TextEffects.HasValue) ui.TextEffects = TextEffects.Value;
            if (TextTrimming.HasValue) ui.TextTrimming = TextTrimming.Value;
            if (TextWrapping.HasValue) ui.TextWrapping = TextWrapping.Value;
            return global::CSharpMarkup.Wpf.AccessText.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.AccessText"/></summary>
        public static AccessText AccessText()
        {
            var ui = new Windows.Controls.AccessText();
            return global::CSharpMarkup.Wpf.AccessText.StartChain(ui);
        }
    }

    public partial class AccessText : FrameworkElement, IUI<System.Windows.Controls.AccessText>
    {
        static AccessText instance;

        internal static AccessText StartChain(Windows.Controls.AccessText ui)
        {
            if (instance == null) instance = new AccessText();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.AccessText ui;

        public new Windows.Controls.AccessText UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(AccessText view) => view?.UI;

        public static implicit operator Windows.Controls.AccessText(AccessText view) => view?.UI;

        public static implicit operator AccessText(Windows.Controls.AccessText ui) => AccessText.StartChain(ui);

        protected AccessText() { }
    }

    public static partial class AccessTextExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.AccessText.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : AccessText { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : AccessText { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : AccessText { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.BaselineOffset"/></summary>
        public static TView BaselineOffset<TView>(this TView view, double value) where TView : AccessText { view.UI.BaselineOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : AccessText { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : AccessText { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.FontStretch"/></summary>
        public static TView FontStretch<TView>(this TView view, Windows.FontStretch value) where TView : AccessText { view.UI.FontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : AccessText { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : AccessText { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : AccessText { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : AccessText { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : AccessText { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : AccessText { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : AccessText { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : AccessText { view.UI.Text = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : AccessText { view.UI.TextAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : AccessText { view.UI.TextDecorations = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.TextEffects"/></summary>
        public static TView TextEffects<TView>(this TView view, Windows.Media.TextEffectCollection value) where TView : AccessText { view.UI.TextEffects = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.TextTrimming"/></summary>
        public static TView TextTrimming<TView>(this TView view, Windows.TextTrimming value) where TView : AccessText { view.UI.TextTrimming = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.AccessText.TextWrapping"/></summary>
        public static TView TextWrapping<TView>(this TView view, Windows.TextWrapping value) where TView : AccessText { view.UI.TextWrapping = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.AccessText.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.BaselineOffset"/></summary>
        public static DependencyProperty<TTarget, double> BaselineOffset<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.AccessText.BaselineOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.AccessText.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.AccessText.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> FontStretch<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Controls.AccessText.FontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.AccessText.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.AccessText.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.AccessText.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.AccessText.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Controls.AccessText.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Controls.AccessText.TextAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Controls.AccessText.TextDecorationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.TextEffects"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TextEffectCollection> TextEffects<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.Media.TextEffectCollection>.Get(target, Windows.Controls.AccessText.TextEffectsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.AccessText.TextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.TextTrimming"/></summary>
        public static DependencyProperty<TTarget, Windows.TextTrimming> TextTrimming<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.TextTrimming>.Get(target, Windows.Controls.AccessText.TextTrimmingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.AccessText.TextWrapping"/></summary>
        public static DependencyProperty<TTarget, Windows.TextWrapping> TextWrapping<TTarget>(this TTarget target) where TTarget : AccessText
        => DependencyProperty<TTarget, Windows.TextWrapping>.Get(target, Windows.Controls.AccessText.TextWrappingProperty);
    }
}

namespace CSharpMarkup.Wpf // AdornedElementPlaceholder
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.AdornedElementPlaceholder"/></summary>
        public static AdornedElementPlaceholder AdornedElementPlaceholder(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.AdornedElementPlaceholder();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.AdornedElementPlaceholder.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.AdornedElementPlaceholder"/></summary>
        public static AdornedElementPlaceholder AdornedElementPlaceholder()
        {
            var ui = new Windows.Controls.AdornedElementPlaceholder();
            return global::CSharpMarkup.Wpf.AdornedElementPlaceholder.StartChain(ui);
        }
    }

    public partial class AdornedElementPlaceholder : FrameworkElement, IUI<System.Windows.Controls.AdornedElementPlaceholder>
    {
        static AdornedElementPlaceholder instance;

        internal static AdornedElementPlaceholder StartChain(Windows.Controls.AdornedElementPlaceholder ui)
        {
            if (instance == null) instance = new AdornedElementPlaceholder();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.AdornedElementPlaceholder ui;

        public new Windows.Controls.AdornedElementPlaceholder UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(AdornedElementPlaceholder view) => view?.UI;

        public static implicit operator Windows.Controls.AdornedElementPlaceholder(AdornedElementPlaceholder view) => view?.UI;

        public static implicit operator AdornedElementPlaceholder(Windows.Controls.AdornedElementPlaceholder ui) => AdornedElementPlaceholder.StartChain(ui);

        protected AdornedElementPlaceholder() { }
    }
}

namespace CSharpMarkup.Wpf // Border
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Border"/></summary>
        public static Border Border(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.Border();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.Border.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Border"/></summary>
        public static Border Border(O<Windows.Media.Brush> Background = default, O<Windows.Media.Brush> BorderBrush = default, O<Windows.Thickness> BorderThickness = default, O<Windows.CornerRadius> CornerRadius = default, O<Windows.Thickness> Padding = default)
        {
            var ui = new Windows.Controls.Border();
            if (Background.HasValue) ui.Background = Background.Value;
            if (BorderBrush.HasValue) ui.BorderBrush = BorderBrush.Value;
            if (BorderThickness.HasValue) ui.BorderThickness = BorderThickness.Value;
            if (CornerRadius.HasValue) ui.CornerRadius = CornerRadius.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            return global::CSharpMarkup.Wpf.Border.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Border"/></summary>
        public static Border Border()
        {
            var ui = new Windows.Controls.Border();
            return global::CSharpMarkup.Wpf.Border.StartChain(ui);
        }
    }

    public partial class Border : Decorator, IUI<System.Windows.Controls.Border>
    {
        static Border instance;

        internal static Border StartChain(Windows.Controls.Border ui)
        {
            if (instance == null) instance = new Border();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Border ui;

        public new Windows.Controls.Border UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Border view) => view?.UI;

        public static implicit operator Windows.Controls.Border(Border view) => view?.UI;

        public static implicit operator Border(Windows.Controls.Border ui) => Border.StartChain(ui);

        protected Border() { }
    }

    public static partial class BorderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Border.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : Border { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : Border { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : Border { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Border { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : Border { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : Border { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : Border { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : Border { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : Border { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : Border { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Border { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.CornerRadius"/></summary>
        public static TView CornerRadius<TView>(this TView view, Windows.CornerRadius value) where TView : Border { view.UI.CornerRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : Border { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : Border { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : Border { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : Border { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Border.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Border { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Border.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : Border
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Border.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Border.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : Border
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Border.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Border.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : Border
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.Border.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Border.CornerRadius"/></summary>
        public static DependencyProperty<TTarget, Windows.CornerRadius> CornerRadius<TTarget>(this TTarget target) where TTarget : Border
        => DependencyProperty<TTarget, Windows.CornerRadius>.Get(target, Windows.Controls.Border.CornerRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Border.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : Border
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.Border.PaddingProperty);
    }
}

namespace CSharpMarkup.Wpf // Button
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Button"/></summary>
        public static Button Button(
            object Content
)
        {
            var ui = new Windows.Controls.Button();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.Button.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Button"/></summary>
        public static Button Button(O<bool> IsCancel = default, O<bool> IsDefault = default)
        {
            var ui = new Windows.Controls.Button();
            if (IsCancel.HasValue) ui.IsCancel = IsCancel.Value;
            if (IsDefault.HasValue) ui.IsDefault = IsDefault.Value;
            return global::CSharpMarkup.Wpf.Button.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Button"/></summary>
        public static Button Button()
        {
            var ui = new Windows.Controls.Button();
            return global::CSharpMarkup.Wpf.Button.StartChain(ui);
        }
    }

    public partial class Button : ButtonBase, IUI<System.Windows.Controls.Button>
    {
        static Button instance;

        internal static Button StartChain(Windows.Controls.Button ui)
        {
            if (instance == null) instance = new Button();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Button ui;

        public new Windows.Controls.Button UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Button view) => view?.UI;

        public static implicit operator Windows.Controls.Button(Button view) => view?.UI;

        public static implicit operator Button(Windows.Controls.Button ui) => Button.StartChain(ui);

        protected Button() { }
    }

    public static partial class ButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Button.IsCancel"/></summary>
        public static TView IsCancel<TView>(this TView view, bool value) where TView : Button { view.UI.IsCancel = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Button.IsDefault"/></summary>
        public static TView IsDefault<TView>(this TView view, bool value) where TView : Button { view.UI.IsDefault = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Button.IsCancel"/></summary>
        public static DependencyProperty<TTarget, bool> IsCancel<TTarget>(this TTarget target) where TTarget : Button
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Button.IsCancelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Button.IsDefaulted"/></summary>
        public static DependencyProperty<TTarget, bool> IsDefaulted<TTarget>(this TTarget target) where TTarget : Button
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Button.IsDefaultedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Button.IsDefault"/></summary>
        public static DependencyProperty<TTarget, bool> IsDefault<TTarget>(this TTarget target) where TTarget : Button
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Button.IsDefaultProperty);
    }
}

namespace CSharpMarkup.Wpf // Calendar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Calendar"/></summary>
        /// <remarks>Remark: Calendar().Bind() binds to <see cref="Windows.Controls.Calendar.SelectedDateProperty"/></remarks>
        public static Calendar Calendar(O<Windows.Style> CalendarButtonStyle = default, O<Windows.Style> CalendarDayButtonStyle = default, O<Windows.Style> CalendarItemStyle = default, O<DateTime> DisplayDate = default, O<DateTime?> DisplayDateEnd = default, O<DateTime?> DisplayDateStart = default, O<Windows.Controls.CalendarMode> DisplayMode = default, O<DayOfWeek> FirstDayOfWeek = default, O<bool> IsTodayHighlighted = default, O<DateTime?> SelectedDate = default, O<Windows.Controls.CalendarSelectionMode> SelectionMode = default)
        {
            var ui = new Windows.Controls.Calendar();
            if (CalendarButtonStyle.HasValue) ui.CalendarButtonStyle = CalendarButtonStyle.Value;
            if (CalendarDayButtonStyle.HasValue) ui.CalendarDayButtonStyle = CalendarDayButtonStyle.Value;
            if (CalendarItemStyle.HasValue) ui.CalendarItemStyle = CalendarItemStyle.Value;
            if (DisplayDate.HasValue) ui.DisplayDate = DisplayDate.Value;
            if (DisplayDateEnd.HasValue) ui.DisplayDateEnd = DisplayDateEnd.Value;
            if (DisplayDateStart.HasValue) ui.DisplayDateStart = DisplayDateStart.Value;
            if (DisplayMode.HasValue) ui.DisplayMode = DisplayMode.Value;
            if (FirstDayOfWeek.HasValue) ui.FirstDayOfWeek = FirstDayOfWeek.Value;
            if (IsTodayHighlighted.HasValue) ui.IsTodayHighlighted = IsTodayHighlighted.Value;
            if (SelectedDate.HasValue) ui.SelectedDate = SelectedDate.Value;
            if (SelectionMode.HasValue) ui.SelectionMode = SelectionMode.Value;
            return global::CSharpMarkup.Wpf.Calendar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Calendar"/></summary>
        /// <remarks>Remark: Calendar().Bind() binds to <see cref="Windows.Controls.Calendar.SelectedDateProperty"/></remarks>
        public static Calendar Calendar()
        {
            var ui = new Windows.Controls.Calendar();
            return global::CSharpMarkup.Wpf.Calendar.StartChain(ui);
        }
    }

    public partial class Calendar : Control, IUI<System.Windows.Controls.Calendar>, IDefaultBindProperty
    {
        static Calendar instance;

        internal static Calendar StartChain(Windows.Controls.Calendar ui)
        {
            if (instance == null) instance = new Calendar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Calendar ui;

        public new Windows.Controls.Calendar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Calendar.SelectedDateProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Calendar.SelectedDateProperty;

        public static implicit operator Windows.UIElement(Calendar view) => view?.UI;

        public static implicit operator Windows.Controls.Calendar(Calendar view) => view?.UI;

        public static implicit operator Calendar(Windows.Controls.Calendar ui) => Calendar.StartChain(ui);

        protected Calendar() { }
    }

    public static partial class CalendarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Calendar.CalendarButtonStyle"/></summary>
        public static TView CalendarButtonStyle<TView>(this TView view, Windows.Style value) where TView : Calendar { view.UI.CalendarButtonStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.CalendarDayButtonStyle"/></summary>
        public static TView CalendarDayButtonStyle<TView>(this TView view, Windows.Style value) where TView : Calendar { view.UI.CalendarDayButtonStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.CalendarItemStyle"/></summary>
        public static TView CalendarItemStyle<TView>(this TView view, Windows.Style value) where TView : Calendar { view.UI.CalendarItemStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.DisplayDate"/></summary>
        public static TView DisplayDate<TView>(this TView view, DateTime value) where TView : Calendar { view.UI.DisplayDate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.DisplayDateEnd"/></summary>
        public static TView DisplayDateEnd<TView>(this TView view, DateTime? value) where TView : Calendar { view.UI.DisplayDateEnd = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.DisplayDateStart"/></summary>
        public static TView DisplayDateStart<TView>(this TView view, DateTime? value) where TView : Calendar { view.UI.DisplayDateStart = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.DisplayMode"/></summary>
        public static TView DisplayMode<TView>(this TView view, Windows.Controls.CalendarMode value) where TView : Calendar { view.UI.DisplayMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.FirstDayOfWeek"/></summary>
        public static TView FirstDayOfWeek<TView>(this TView view, DayOfWeek value) where TView : Calendar { view.UI.FirstDayOfWeek = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.IsTodayHighlighted"/></summary>
        public static TView IsTodayHighlighted<TView>(this TView view, bool value) where TView : Calendar { view.UI.IsTodayHighlighted = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.SelectedDate"/></summary>
        public static TView SelectedDate<TView>(this TView view, DateTime? value) where TView : Calendar { view.UI.SelectedDate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Calendar.SelectionMode"/></summary>
        public static TView SelectionMode<TView>(this TView view, Windows.Controls.CalendarSelectionMode value) where TView : Calendar { view.UI.SelectionMode = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.CalendarButtonStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CalendarButtonStyle<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Calendar.CalendarButtonStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.CalendarDayButtonStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CalendarDayButtonStyle<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Calendar.CalendarDayButtonStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.CalendarItemStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CalendarItemStyle<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Calendar.CalendarItemStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.DisplayDateEnd"/></summary>
        public static DependencyProperty<TTarget, DateTime?> DisplayDateEnd<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.Calendar.DisplayDateEndProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.DisplayDate"/></summary>
        public static DependencyProperty<TTarget, DateTime> DisplayDate<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, DateTime>.Get(target, Windows.Controls.Calendar.DisplayDateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.DisplayDateStart"/></summary>
        public static DependencyProperty<TTarget, DateTime?> DisplayDateStart<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.Calendar.DisplayDateStartProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.DisplayMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.CalendarMode> DisplayMode<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, Windows.Controls.CalendarMode>.Get(target, Windows.Controls.Calendar.DisplayModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.FirstDayOfWeek"/></summary>
        public static DependencyProperty<TTarget, DayOfWeek> FirstDayOfWeek<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, DayOfWeek>.Get(target, Windows.Controls.Calendar.FirstDayOfWeekProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.IsTodayHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsTodayHighlighted<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Calendar.IsTodayHighlightedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.SelectedDate"/></summary>
        public static DependencyProperty<TTarget, DateTime?> SelectedDate<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.Calendar.SelectedDateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Calendar.SelectionMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode> SelectionMode<TTarget>(this TTarget target) where TTarget : Calendar
        => DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode>.Get(target, Windows.Controls.Calendar.SelectionModeProperty);
    }
}

namespace CSharpMarkup.Wpf // Canvas
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Canvas"/></summary>
        public static Canvas Canvas(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Canvas();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Canvas.StartChain(ui);
        }
    }

    public partial class Canvas : Panel, IUI<System.Windows.Controls.Canvas>
    {
        static Canvas instance;

        internal static Canvas StartChain(Windows.Controls.Canvas ui)
        {
            if (instance == null) instance = new Canvas();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Canvas ui;

        public new Windows.Controls.Canvas UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Canvas view) => view?.UI;

        public static implicit operator Windows.Controls.Canvas(Canvas view) => view?.UI;

        public static implicit operator Canvas(Windows.Controls.Canvas ui) => Canvas.StartChain(ui);

        protected Canvas() { }
    }

    public static partial class CanvasExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Canvas.Bottom"/></summary>
        public static TTarget Canvas_Bottom<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.Canvas.SetBottom(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Canvas.Bottom"/></summary>
        public static DependencyProperty<TTarget, double> Canvas_Bottom<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Canvas.BottomProperty);

        /// <summary>Set <see cref="Windows.Controls.Canvas.Left"/></summary>
        public static TTarget Canvas_Left<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.Canvas.SetLeft(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Canvas.Left"/></summary>
        public static DependencyProperty<TTarget, double> Canvas_Left<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Canvas.LeftProperty);

        /// <summary>Set <see cref="Windows.Controls.Canvas.Right"/></summary>
        public static TTarget Canvas_Right<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.Canvas.SetRight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Canvas.Right"/></summary>
        public static DependencyProperty<TTarget, double> Canvas_Right<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Canvas.RightProperty);

        /// <summary>Set <see cref="Windows.Controls.Canvas.Top"/></summary>
        public static TTarget Canvas_Top<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.Canvas.SetTop(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Canvas.Top"/></summary>
        public static DependencyProperty<TTarget, double> Canvas_Top<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Canvas.TopProperty);

        /// <summary>Set <see cref="Windows.Controls.Canvas"/> attached properties</summary>
        public static TTarget Canvas<TTarget>(this TTarget target

            , O<double> Bottom = default

            , O<double> Left = default

            , O<double> Right = default

            , O<double> Top = default

        ) where TTarget : UIElement
        {
            if (Bottom.HasValue) Windows.Controls.Canvas.SetBottom(target.UI, Bottom.Value);

            if (Left.HasValue) Windows.Controls.Canvas.SetLeft(target.UI, Left.Value);

            if (Right.HasValue) Windows.Controls.Canvas.SetRight(target.UI, Right.Value);

            if (Top.HasValue) Windows.Controls.Canvas.SetTop(target.UI, Top.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // CheckBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.CheckBox"/></summary>
        public static CheckBox CheckBox(
            object Content
)
        {
            var ui = new Windows.Controls.CheckBox();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.CheckBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.CheckBox"/></summary>
        public static CheckBox CheckBox()
        {
            var ui = new Windows.Controls.CheckBox();
            return global::CSharpMarkup.Wpf.CheckBox.StartChain(ui);
        }
    }

    public partial class CheckBox : ToggleButton, IUI<System.Windows.Controls.CheckBox>
    {
        static CheckBox instance;

        internal static CheckBox StartChain(Windows.Controls.CheckBox ui)
        {
            if (instance == null) instance = new CheckBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.CheckBox ui;

        public new Windows.Controls.CheckBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(CheckBox view) => view?.UI;

        public static implicit operator Windows.Controls.CheckBox(CheckBox view) => view?.UI;

        public static implicit operator CheckBox(Windows.Controls.CheckBox ui) => CheckBox.StartChain(ui);

        protected CheckBox() { }
    }
}

namespace CSharpMarkup.Wpf // ColumnDefinition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ColumnDefinition"/></summary>
        /// <remarks>Remark: ColumnDefinition().Bind() binds to <see cref="Windows.Controls.ColumnDefinition.WidthProperty"/></remarks>
        public static ColumnDefinition ColumnDefinition(O<double> MaxWidth = default, O<double> MinWidth = default, O<Windows.GridLength> Width = default)
        {
            var ui = new Windows.Controls.ColumnDefinition();
            if (MaxWidth.HasValue) ui.MaxWidth = MaxWidth.Value;
            if (MinWidth.HasValue) ui.MinWidth = MinWidth.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.ColumnDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ColumnDefinition"/></summary>
        /// <remarks>Remark: ColumnDefinition().Bind() binds to <see cref="Windows.Controls.ColumnDefinition.WidthProperty"/></remarks>
        public static ColumnDefinition ColumnDefinition()
        {
            var ui = new Windows.Controls.ColumnDefinition();
            return global::CSharpMarkup.Wpf.ColumnDefinition.StartChain(ui);
        }
    }

    public partial class ColumnDefinition : DefinitionBase, IUI<System.Windows.Controls.ColumnDefinition>, IDefaultBindProperty
    {
        static ColumnDefinition instance;

        internal static ColumnDefinition StartChain(Windows.Controls.ColumnDefinition ui)
        {
            if (instance == null) instance = new ColumnDefinition();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ColumnDefinition ui;

        public new Windows.Controls.ColumnDefinition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.ColumnDefinition.WidthProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.ColumnDefinition.WidthProperty;

        public static implicit operator Windows.Controls.ColumnDefinition(ColumnDefinition view) => view?.UI;

        public static implicit operator ColumnDefinition(Windows.Controls.ColumnDefinition ui) => ColumnDefinition.StartChain(ui);

        protected ColumnDefinition() { }
    }

    public static partial class ColumnDefinitionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ColumnDefinition.MaxWidth"/></summary>
        public static TView MaxWidth<TView>(this TView view, double value) where TView : ColumnDefinition { view.UI.MaxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ColumnDefinition.MinWidth"/></summary>
        public static TView MinWidth<TView>(this TView view, double value) where TView : ColumnDefinition { view.UI.MinWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ColumnDefinition.Width"/></summary>
        public static TView Width<TView>(this TView view, Windows.GridLength value) where TView : ColumnDefinition { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ColumnDefinition.MaxWidth"/></summary>
        public static DependencyProperty<TTarget, double> MaxWidth<TTarget>(this TTarget target) where TTarget : ColumnDefinition
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ColumnDefinition.MaxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ColumnDefinition.MinWidth"/></summary>
        public static DependencyProperty<TTarget, double> MinWidth<TTarget>(this TTarget target) where TTarget : ColumnDefinition
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ColumnDefinition.MinWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ColumnDefinition.Width"/></summary>
        public static DependencyProperty<TTarget, Windows.GridLength> Width<TTarget>(this TTarget target) where TTarget : ColumnDefinition
        => DependencyProperty<TTarget, Windows.GridLength>.Get(target, Windows.Controls.ColumnDefinition.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // ComboBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ComboBox"/></summary>
        public static ComboBox ComboBox(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ComboBox();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ComboBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ComboBox"/></summary>
        public static ComboBox ComboBox(O<bool> IsDropDownOpen = default, O<bool> IsEditable = default, O<bool> IsReadOnly = default, O<double> MaxDropDownHeight = default, O<bool> ShouldPreserveUserEnteredPrefix = default, O<bool> StaysOpenOnEdit = default, O<string> Text = default)
        {
            var ui = new Windows.Controls.ComboBox();
            if (IsDropDownOpen.HasValue) ui.IsDropDownOpen = IsDropDownOpen.Value;
            if (IsEditable.HasValue) ui.IsEditable = IsEditable.Value;
            if (IsReadOnly.HasValue) ui.IsReadOnly = IsReadOnly.Value;
            if (MaxDropDownHeight.HasValue) ui.MaxDropDownHeight = MaxDropDownHeight.Value;
            if (ShouldPreserveUserEnteredPrefix.HasValue) ui.ShouldPreserveUserEnteredPrefix = ShouldPreserveUserEnteredPrefix.Value;
            if (StaysOpenOnEdit.HasValue) ui.StaysOpenOnEdit = StaysOpenOnEdit.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            return global::CSharpMarkup.Wpf.ComboBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ComboBox"/></summary>
        public static ComboBox ComboBox()
        {
            var ui = new Windows.Controls.ComboBox();
            return global::CSharpMarkup.Wpf.ComboBox.StartChain(ui);
        }
    }

    public partial class ComboBox : Selector, IUI<System.Windows.Controls.ComboBox>
    {
        static ComboBox instance;

        internal static ComboBox StartChain(Windows.Controls.ComboBox ui)
        {
            if (instance == null) instance = new ComboBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ComboBox ui;

        public new Windows.Controls.ComboBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ComboBox view) => view?.UI;

        public static implicit operator Windows.Controls.ComboBox(ComboBox view) => view?.UI;

        public static implicit operator ComboBox(Windows.Controls.ComboBox ui) => ComboBox.StartChain(ui);

        protected ComboBox() { }
    }

    public static partial class ComboBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ComboBox.IsDropDownOpen"/></summary>
        public static TView IsDropDownOpen<TView>(this TView view, bool value) where TView : ComboBox { view.UI.IsDropDownOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.IsEditable"/></summary>
        public static TView IsEditable<TView>(this TView view, bool value) where TView : ComboBox { view.UI.IsEditable = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.IsReadOnly"/></summary>
        public static TView IsReadOnly<TView>(this TView view, bool value) where TView : ComboBox { view.UI.IsReadOnly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.MaxDropDownHeight"/></summary>
        public static TView MaxDropDownHeight<TView>(this TView view, double value) where TView : ComboBox { view.UI.MaxDropDownHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix"/></summary>
        public static TView ShouldPreserveUserEnteredPrefix<TView>(this TView view, bool value) where TView : ComboBox { view.UI.ShouldPreserveUserEnteredPrefix = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.StaysOpenOnEdit"/></summary>
        public static TView StaysOpenOnEdit<TView>(this TView view, bool value) where TView : ComboBox { view.UI.StaysOpenOnEdit = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ComboBox.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : ComboBox { view.UI.Text = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.IsDropDownOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownOpen<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBox.IsDropDownOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.IsEditable"/></summary>
        public static DependencyProperty<TTarget, bool> IsEditable<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBox.IsEditableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBox.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.MaxDropDownHeight"/></summary>
        public static DependencyProperty<TTarget, double> MaxDropDownHeight<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ComboBox.MaxDropDownHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.SelectionBoxItem"/></summary>
        public static DependencyProperty<TTarget, object> SelectionBoxItem<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.ComboBox.SelectionBoxItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.SelectionBoxItemStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> SelectionBoxItemStringFormat<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ComboBox.SelectionBoxItemStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.SelectionBoxItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> SelectionBoxItemTemplate<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.ComboBox.SelectionBoxItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix"/></summary>
        public static DependencyProperty<TTarget, bool> ShouldPreserveUserEnteredPrefix<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefixProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.StaysOpenOnEdit"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpenOnEdit<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBox.StaysOpenOnEditProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBox.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : ComboBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ComboBox.TextProperty);
    }
}

namespace CSharpMarkup.Wpf // ComboBoxItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ComboBoxItem"/></summary>
        public static ComboBoxItem ComboBoxItem(
            object Content
)
        {
            var ui = new Windows.Controls.ComboBoxItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ComboBoxItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ComboBoxItem"/></summary>
        public static ComboBoxItem ComboBoxItem()
        {
            var ui = new Windows.Controls.ComboBoxItem();
            return global::CSharpMarkup.Wpf.ComboBoxItem.StartChain(ui);
        }
    }

    public partial class ComboBoxItem : ListBoxItem, IUI<System.Windows.Controls.ComboBoxItem>
    {
        static ComboBoxItem instance;

        internal static ComboBoxItem StartChain(Windows.Controls.ComboBoxItem ui)
        {
            if (instance == null) instance = new ComboBoxItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ComboBoxItem ui;

        public new Windows.Controls.ComboBoxItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ComboBoxItem view) => view?.UI;

        public static implicit operator Windows.Controls.ComboBoxItem(ComboBoxItem view) => view?.UI;

        public static implicit operator ComboBoxItem(Windows.Controls.ComboBoxItem ui) => ComboBoxItem.StartChain(ui);

        protected ComboBoxItem() { }
    }

    public static partial class ComboBoxItemExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ComboBoxItem.IsHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsHighlighted<TTarget>(this TTarget target) where TTarget : ComboBoxItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ComboBoxItem.IsHighlightedProperty);
    }
}

namespace CSharpMarkup.Wpf // ContentControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ContentControl"/></summary>
        /// <remarks>Remark: ContentControl().Bind() binds to <see cref="Windows.Controls.ContentControl.ContentProperty"/></remarks>
        public static ContentControl ContentControl(
            object Content
)
        {
            var ui = new Windows.Controls.ContentControl();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ContentControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ContentControl"/></summary>
        /// <remarks>Remark: ContentControl().Bind() binds to <see cref="Windows.Controls.ContentControl.ContentProperty"/></remarks>
        public static ContentControl ContentControl(O<string> ContentStringFormat = default, O<Windows.DataTemplate> ContentTemplate = default, O<Windows.Controls.DataTemplateSelector> ContentTemplateSelector = default)
        {
            var ui = new Windows.Controls.ContentControl();
            if (ContentStringFormat.HasValue) ui.ContentStringFormat = ContentStringFormat.Value;
            if (ContentTemplate.HasValue) ui.ContentTemplate = ContentTemplate.Value;
            if (ContentTemplateSelector.HasValue) ui.ContentTemplateSelector = ContentTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.ContentControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ContentControl"/></summary>
        /// <remarks>Remark: ContentControl().Bind() binds to <see cref="Windows.Controls.ContentControl.ContentProperty"/></remarks>
        public static ContentControl ContentControl()
        {
            var ui = new Windows.Controls.ContentControl();
            return global::CSharpMarkup.Wpf.ContentControl.StartChain(ui);
        }
    }

    public partial class ContentControl : Control, IUI<System.Windows.Controls.ContentControl>, IDefaultBindProperty
    {
        static ContentControl instance;

        internal static ContentControl StartChain(Windows.Controls.ContentControl ui)
        {
            if (instance == null) instance = new ContentControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ContentControl ui;

        public new Windows.Controls.ContentControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.ContentControl.ContentProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.ContentControl.ContentProperty;

        public static implicit operator Windows.UIElement(ContentControl view) => view?.UI;

        public static implicit operator Windows.Controls.ContentControl(ContentControl view) => view?.UI;

        public static implicit operator ContentControl(Windows.Controls.ContentControl ui) => ContentControl.StartChain(ui);

        protected ContentControl() { }
    }

    public static partial class ContentControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ContentControl.ContentStringFormat"/></summary>
        public static TView ContentStringFormat<TView>(this TView view, string value) where TView : ContentControl { view.UI.ContentStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentControl.ContentTemplate"/></summary>
        public static TView ContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : ContentControl { view.UI.ContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentControl.ContentTemplateSelector"/></summary>
        public static TView ContentTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : ContentControl { view.UI.ContentTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentControl.Content"/></summary>
        public static DependencyProperty<TTarget, object> Content<TTarget>(this TTarget target) where TTarget : ContentControl
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.ContentControl.ContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentControl.ContentStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ContentStringFormat<TTarget>(this TTarget target) where TTarget : ContentControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ContentControl.ContentStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentControl.ContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ContentTemplate<TTarget>(this TTarget target) where TTarget : ContentControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.ContentControl.ContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentControl.ContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ContentTemplateSelector<TTarget>(this TTarget target) where TTarget : ContentControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.ContentControl.ContentTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentControl.HasContent"/></summary>
        public static DependencyProperty<TTarget, bool> HasContent<TTarget>(this TTarget target) where TTarget : ContentControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ContentControl.HasContentProperty);
    }
}

namespace CSharpMarkup.Wpf // ContentPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ContentPresenter"/></summary>
        /// <remarks>Remark: ContentPresenter().Bind() binds to <see cref="Windows.Controls.ContentPresenter.ContentProperty"/></remarks>
        public static ContentPresenter ContentPresenter(O<object> Content = default, O<string> ContentSource = default, O<string> ContentStringFormat = default, O<Windows.DataTemplate> ContentTemplate = default, O<Windows.Controls.DataTemplateSelector> ContentTemplateSelector = default, O<bool> RecognizesAccessKey = default)
        {
            var ui = new Windows.Controls.ContentPresenter();
            if (Content.HasValue) ui.Content = Content.Value;
            if (ContentSource.HasValue) ui.ContentSource = ContentSource.Value;
            if (ContentStringFormat.HasValue) ui.ContentStringFormat = ContentStringFormat.Value;
            if (ContentTemplate.HasValue) ui.ContentTemplate = ContentTemplate.Value;
            if (ContentTemplateSelector.HasValue) ui.ContentTemplateSelector = ContentTemplateSelector.Value;
            if (RecognizesAccessKey.HasValue) ui.RecognizesAccessKey = RecognizesAccessKey.Value;
            return global::CSharpMarkup.Wpf.ContentPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ContentPresenter"/></summary>
        /// <remarks>Remark: ContentPresenter().Bind() binds to <see cref="Windows.Controls.ContentPresenter.ContentProperty"/></remarks>
        public static ContentPresenter ContentPresenter()
        {
            var ui = new Windows.Controls.ContentPresenter();
            return global::CSharpMarkup.Wpf.ContentPresenter.StartChain(ui);
        }
    }

    public partial class ContentPresenter : FrameworkElement, IUI<System.Windows.Controls.ContentPresenter>, IDefaultBindProperty
    {
        static ContentPresenter instance;

        internal static ContentPresenter StartChain(Windows.Controls.ContentPresenter ui)
        {
            if (instance == null) instance = new ContentPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ContentPresenter ui;

        public new Windows.Controls.ContentPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.ContentPresenter.ContentProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.ContentPresenter.ContentProperty;

        public static implicit operator Windows.UIElement(ContentPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.ContentPresenter(ContentPresenter view) => view?.UI;

        public static implicit operator ContentPresenter(Windows.Controls.ContentPresenter ui) => ContentPresenter.StartChain(ui);

        protected ContentPresenter() { }
    }

    public static partial class ContentPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.Content"/></summary>
        public static TView Content<TView>(this TView view, object value) where TView : ContentPresenter { view.UI.Content = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.ContentSource"/></summary>
        public static TView ContentSource<TView>(this TView view, string value) where TView : ContentPresenter { view.UI.ContentSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.ContentStringFormat"/></summary>
        public static TView ContentStringFormat<TView>(this TView view, string value) where TView : ContentPresenter { view.UI.ContentStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.ContentTemplate"/></summary>
        public static TView ContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : ContentPresenter { view.UI.ContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.ContentTemplateSelector"/></summary>
        public static TView ContentTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : ContentPresenter { view.UI.ContentTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContentPresenter.RecognizesAccessKey"/></summary>
        public static TView RecognizesAccessKey<TView>(this TView view, bool value) where TView : ContentPresenter { view.UI.RecognizesAccessKey = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.Content"/></summary>
        public static DependencyProperty<TTarget, object> Content<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.ContentPresenter.ContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.ContentSource"/></summary>
        public static DependencyProperty<TTarget, string> ContentSource<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ContentPresenter.ContentSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.ContentStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ContentStringFormat<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ContentPresenter.ContentStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.ContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ContentTemplate<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.ContentPresenter.ContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.ContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ContentTemplateSelector<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.ContentPresenter.ContentTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContentPresenter.RecognizesAccessKey"/></summary>
        public static DependencyProperty<TTarget, bool> RecognizesAccessKey<TTarget>(this TTarget target) where TTarget : ContentPresenter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ContentPresenter.RecognizesAccessKeyProperty);
    }
}

namespace CSharpMarkup.Wpf // ContextMenu
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ContextMenu"/></summary>
        public static ContextMenu ContextMenu(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ContextMenu();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ContextMenu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ContextMenu"/></summary>
        public static ContextMenu ContextMenu(O<Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback = default, O<bool> HasDropShadow = default, O<double> HorizontalOffset = default, O<bool> IsOpen = default, O<Windows.Controls.Primitives.PlacementMode> Placement = default, O<Windows.Rect> PlacementRectangle = default, O<Windows.UIElement> PlacementTarget = default, O<bool> StaysOpen = default, O<double> VerticalOffset = default)
        {
            var ui = new Windows.Controls.ContextMenu();
            if (CustomPopupPlacementCallback.HasValue) ui.CustomPopupPlacementCallback = CustomPopupPlacementCallback.Value;
            if (HasDropShadow.HasValue) ui.HasDropShadow = HasDropShadow.Value;
            if (HorizontalOffset.HasValue) ui.HorizontalOffset = HorizontalOffset.Value;
            if (IsOpen.HasValue) ui.IsOpen = IsOpen.Value;
            if (Placement.HasValue) ui.Placement = Placement.Value;
            if (PlacementRectangle.HasValue) ui.PlacementRectangle = PlacementRectangle.Value;
            if (PlacementTarget.HasValue) ui.PlacementTarget = PlacementTarget.Value;
            if (StaysOpen.HasValue) ui.StaysOpen = StaysOpen.Value;
            if (VerticalOffset.HasValue) ui.VerticalOffset = VerticalOffset.Value;
            return global::CSharpMarkup.Wpf.ContextMenu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ContextMenu"/></summary>
        public static ContextMenu ContextMenu()
        {
            var ui = new Windows.Controls.ContextMenu();
            return global::CSharpMarkup.Wpf.ContextMenu.StartChain(ui);
        }
    }

    public partial class ContextMenu : MenuBase, IUI<System.Windows.Controls.ContextMenu>
    {
        static ContextMenu instance;

        internal static ContextMenu StartChain(Windows.Controls.ContextMenu ui)
        {
            if (instance == null) instance = new ContextMenu();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ContextMenu ui;

        public new Windows.Controls.ContextMenu UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ContextMenu view) => view?.UI;

        public static implicit operator Windows.Controls.ContextMenu(ContextMenu view) => view?.UI;

        public static implicit operator ContextMenu(Windows.Controls.ContextMenu ui) => ContextMenu.StartChain(ui);

        protected ContextMenu() { }
    }

    public static partial class ContextMenuExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ContextMenu.CustomPopupPlacementCallback"/></summary>
        public static TView CustomPopupPlacementCallback<TView>(this TView view, Windows.Controls.Primitives.CustomPopupPlacementCallback value) where TView : ContextMenu { view.UI.CustomPopupPlacementCallback = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.HasDropShadow"/></summary>
        public static TView HasDropShadow<TView>(this TView view, bool value) where TView : ContextMenu { view.UI.HasDropShadow = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.HorizontalOffset"/></summary>
        public static TView HorizontalOffset<TView>(this TView view, double value) where TView : ContextMenu { view.UI.HorizontalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.IsOpen"/></summary>
        public static TView IsOpen<TView>(this TView view, bool value) where TView : ContextMenu { view.UI.IsOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.Placement"/></summary>
        public static TView Placement<TView>(this TView view, Windows.Controls.Primitives.PlacementMode value) where TView : ContextMenu { view.UI.Placement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.PlacementRectangle"/></summary>
        public static TView PlacementRectangle<TView>(this TView view, Windows.Rect value) where TView : ContextMenu { view.UI.PlacementRectangle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.PlacementTarget"/></summary>
        public static TView PlacementTarget<TView>(this TView view, Windows.UIElement value) where TView : ContextMenu { view.UI.PlacementTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.StaysOpen"/></summary>
        public static TView StaysOpen<TView>(this TView view, bool value) where TView : ContextMenu { view.UI.StaysOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ContextMenu.VerticalOffset"/></summary>
        public static TView VerticalOffset<TView>(this TView view, double value) where TView : ContextMenu { view.UI.VerticalOffset = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.CustomPopupPlacementCallback"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback>.Get(target, Windows.Controls.ContextMenu.CustomPopupPlacementCallbackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.HasDropShadow"/></summary>
        public static DependencyProperty<TTarget, bool> HasDropShadow<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ContextMenu.HasDropShadowProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ContextMenu.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.IsOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsOpen<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ContextMenu.IsOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.Placement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> Placement<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode>.Get(target, Windows.Controls.ContextMenu.PlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.PlacementRectangle"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> PlacementRectangle<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Controls.ContextMenu.PlacementRectangleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.PlacementTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.UIElement> PlacementTarget<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, Windows.UIElement>.Get(target, Windows.Controls.ContextMenu.PlacementTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.StaysOpen"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpen<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ContextMenu.StaysOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ContextMenu.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : ContextMenu
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ContextMenu.VerticalOffsetProperty);
    }
}

namespace CSharpMarkup.Wpf // Control
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Control"/></summary>
        public static Control Control(O<Windows.Media.Brush> Background = default, O<Windows.Media.Brush> BorderBrush = default, O<Windows.Thickness> BorderThickness = default, O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.FontStretch> FontStretch = default, O<Windows.FontStyle> FontStyle = default, O<Windows.FontWeight> FontWeight = default, O<Windows.Media.Brush> Foreground = default, O<Windows.HorizontalAlignment> HorizontalContentAlignment = default, O<bool> IsTabStop = default, O<Windows.Thickness> Padding = default, O<int> TabIndex = default, O<Windows.Controls.ControlTemplate> Template = default, O<Windows.VerticalAlignment> VerticalContentAlignment = default)
        {
            var ui = new Windows.Controls.Control();
            if (Background.HasValue) ui.Background = Background.Value;
            if (BorderBrush.HasValue) ui.BorderBrush = BorderBrush.Value;
            if (BorderThickness.HasValue) ui.BorderThickness = BorderThickness.Value;
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (FontStretch.HasValue) ui.FontStretch = FontStretch.Value;
            if (FontStyle.HasValue) ui.FontStyle = FontStyle.Value;
            if (FontWeight.HasValue) ui.FontWeight = FontWeight.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (HorizontalContentAlignment.HasValue) ui.HorizontalContentAlignment = HorizontalContentAlignment.Value;
            if (IsTabStop.HasValue) ui.IsTabStop = IsTabStop.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            if (TabIndex.HasValue) ui.TabIndex = TabIndex.Value;
            if (Template.HasValue) ui.Template = Template.Value;
            if (VerticalContentAlignment.HasValue) ui.VerticalContentAlignment = VerticalContentAlignment.Value;
            return global::CSharpMarkup.Wpf.Control.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Control"/></summary>
        public static Control Control()
        {
            var ui = new Windows.Controls.Control();
            return global::CSharpMarkup.Wpf.Control.StartChain(ui);
        }
    }

    public partial class Control : FrameworkElement, IUI<System.Windows.Controls.Control>
    {
        static Control instance;

        internal static Control StartChain(Windows.Controls.Control ui)
        {
            if (instance == null) instance = new Control();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Control ui;

        public new Windows.Controls.Control UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Control view) => view?.UI;

        public static implicit operator Windows.Controls.Control(Control view) => view?.UI;

        public static implicit operator Control(Windows.Controls.Control ui) => Control.StartChain(ui);

        protected Control() { }
    }

    public static partial class ControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Control.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : Control { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : Control { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : Control { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Control { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : Control { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : Control { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : Control { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : Control { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : Control { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : Control { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Control { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : Control { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : Control { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.FontStretch"/></summary>
        public static TView FontStretch<TView>(this TView view, Windows.FontStretch value) where TView : Control { view.UI.FontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : Control { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : Control { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : Control { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : Control { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : Control { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.HorizontalContentAlignment"/></summary>
        public static TView HorizontalContentAlignment<TView>(this TView view, Windows.HorizontalAlignment value) where TView : Control { view.UI.HorizontalContentAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.IsTabStop"/></summary>
        public static TView IsTabStop<TView>(this TView view, bool value) where TView : Control { view.UI.IsTabStop = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : Control { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : Control { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : Control { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : Control { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Control { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.TabIndex"/></summary>
        public static TView TabIndex<TView>(this TView view, int value) where TView : Control { view.UI.TabIndex = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.Template"/></summary>
        public static TView Template<TView>(this TView view, Windows.Controls.ControlTemplate value) where TView : Control { view.UI.Template = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Control.VerticalContentAlignment"/></summary>
        public static TView VerticalContentAlignment<TView>(this TView view, Windows.VerticalAlignment value) where TView : Control { view.UI.VerticalContentAlignment = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Control.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Control.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.Control.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.Control.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Control.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> FontStretch<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Controls.Control.FontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.Control.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.Control.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Control.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.HorizontalContentAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.HorizontalAlignment> HorizontalContentAlignment<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.HorizontalAlignment>.Get(target, Windows.Controls.Control.HorizontalContentAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.IsTabStop"/></summary>
        public static DependencyProperty<TTarget, bool> IsTabStop<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Control.IsTabStopProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.Control.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.TabIndex"/></summary>
        public static DependencyProperty<TTarget, int> TabIndex<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Control.TabIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.Template"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ControlTemplate> Template<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.Controls.ControlTemplate>.Get(target, Windows.Controls.Control.TemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Control.VerticalContentAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.VerticalAlignment> VerticalContentAlignment<TTarget>(this TTarget target) where TTarget : Control
        => DependencyProperty<TTarget, Windows.VerticalAlignment>.Get(target, Windows.Controls.Control.VerticalContentAlignmentProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGrid
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGrid"/></summary>
        public static DataGrid DataGrid(
            params object[] Items
)
        {
            var ui = new Windows.Controls.DataGrid();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.DataGrid.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGrid"/></summary>
        public static DataGrid DataGrid(O<Windows.Media.Brush> AlternatingRowBackground = default, O<bool> AreRowDetailsFrozen = default, O<bool> AutoGenerateColumns = default, O<bool> CanUserAddRows = default, O<bool> CanUserDeleteRows = default, O<bool> CanUserReorderColumns = default, O<bool> CanUserResizeColumns = default, O<bool> CanUserResizeRows = default, O<bool> CanUserSortColumns = default, O<Windows.Style> CellStyle = default, O<Windows.Controls.DataGridClipboardCopyMode> ClipboardCopyMode = default, O<double> ColumnHeaderHeight = default, O<Windows.Style> ColumnHeaderStyle = default, O<Windows.Controls.DataGridLength> ColumnWidth = default, O<Windows.Controls.DataGridCellInfo> CurrentCell = default, O<Windows.Controls.DataGridColumn> CurrentColumn = default, O<object> CurrentItem = default, O<Windows.Style> DragIndicatorStyle = default, O<Windows.Style> DropLocationIndicatorStyle = default, O<bool> EnableColumnVirtualization = default, O<bool> EnableRowVirtualization = default, O<int> FrozenColumnCount = default, O<Windows.Controls.DataGridGridLinesVisibility> GridLinesVisibility = default, O<Windows.Controls.DataGridHeadersVisibility> HeadersVisibility = default, O<Windows.Media.Brush> HorizontalGridLinesBrush = default, O<Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility = default, O<bool> IsReadOnly = default, O<double> MaxColumnWidth = default, O<double> MinColumnWidth = default, O<double> MinRowHeight = default, O<Windows.Media.Brush> RowBackground = default, O<Windows.DataTemplate> RowDetailsTemplate = default, O<Windows.Controls.DataTemplateSelector> RowDetailsTemplateSelector = default, O<Windows.Controls.DataGridRowDetailsVisibilityMode> RowDetailsVisibilityMode = default, O<Windows.Style> RowHeaderStyle = default, O<Windows.DataTemplate> RowHeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> RowHeaderTemplateSelector = default, O<double> RowHeaderWidth = default, O<double> RowHeight = default, O<Windows.Style> RowStyle = default, O<Windows.Controls.StyleSelector> RowStyleSelector = default, O<Windows.Controls.ControlTemplate> RowValidationErrorTemplate = default, O<Windows.Controls.DataGridSelectionMode> SelectionMode = default, O<Windows.Controls.DataGridSelectionUnit> SelectionUnit = default, O<Windows.Media.Brush> VerticalGridLinesBrush = default, O<Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility = default)
        {
            var ui = new Windows.Controls.DataGrid();
            if (AlternatingRowBackground.HasValue) ui.AlternatingRowBackground = AlternatingRowBackground.Value;
            if (AreRowDetailsFrozen.HasValue) ui.AreRowDetailsFrozen = AreRowDetailsFrozen.Value;
            if (AutoGenerateColumns.HasValue) ui.AutoGenerateColumns = AutoGenerateColumns.Value;
            if (CanUserAddRows.HasValue) ui.CanUserAddRows = CanUserAddRows.Value;
            if (CanUserDeleteRows.HasValue) ui.CanUserDeleteRows = CanUserDeleteRows.Value;
            if (CanUserReorderColumns.HasValue) ui.CanUserReorderColumns = CanUserReorderColumns.Value;
            if (CanUserResizeColumns.HasValue) ui.CanUserResizeColumns = CanUserResizeColumns.Value;
            if (CanUserResizeRows.HasValue) ui.CanUserResizeRows = CanUserResizeRows.Value;
            if (CanUserSortColumns.HasValue) ui.CanUserSortColumns = CanUserSortColumns.Value;
            if (CellStyle.HasValue) ui.CellStyle = CellStyle.Value;
            if (ClipboardCopyMode.HasValue) ui.ClipboardCopyMode = ClipboardCopyMode.Value;
            if (ColumnHeaderHeight.HasValue) ui.ColumnHeaderHeight = ColumnHeaderHeight.Value;
            if (ColumnHeaderStyle.HasValue) ui.ColumnHeaderStyle = ColumnHeaderStyle.Value;
            if (ColumnWidth.HasValue) ui.ColumnWidth = ColumnWidth.Value;
            if (CurrentCell.HasValue) ui.CurrentCell = CurrentCell.Value;
            if (CurrentColumn.HasValue) ui.CurrentColumn = CurrentColumn.Value;
            if (CurrentItem.HasValue) ui.CurrentItem = CurrentItem.Value;
            if (DragIndicatorStyle.HasValue) ui.DragIndicatorStyle = DragIndicatorStyle.Value;
            if (DropLocationIndicatorStyle.HasValue) ui.DropLocationIndicatorStyle = DropLocationIndicatorStyle.Value;
            if (EnableColumnVirtualization.HasValue) ui.EnableColumnVirtualization = EnableColumnVirtualization.Value;
            if (EnableRowVirtualization.HasValue) ui.EnableRowVirtualization = EnableRowVirtualization.Value;
            if (FrozenColumnCount.HasValue) ui.FrozenColumnCount = FrozenColumnCount.Value;
            if (GridLinesVisibility.HasValue) ui.GridLinesVisibility = GridLinesVisibility.Value;
            if (HeadersVisibility.HasValue) ui.HeadersVisibility = HeadersVisibility.Value;
            if (HorizontalGridLinesBrush.HasValue) ui.HorizontalGridLinesBrush = HorizontalGridLinesBrush.Value;
            if (HorizontalScrollBarVisibility.HasValue) ui.HorizontalScrollBarVisibility = HorizontalScrollBarVisibility.Value;
            if (IsReadOnly.HasValue) ui.IsReadOnly = IsReadOnly.Value;
            if (MaxColumnWidth.HasValue) ui.MaxColumnWidth = MaxColumnWidth.Value;
            if (MinColumnWidth.HasValue) ui.MinColumnWidth = MinColumnWidth.Value;
            if (MinRowHeight.HasValue) ui.MinRowHeight = MinRowHeight.Value;
            if (RowBackground.HasValue) ui.RowBackground = RowBackground.Value;
            if (RowDetailsTemplate.HasValue) ui.RowDetailsTemplate = RowDetailsTemplate.Value;
            if (RowDetailsTemplateSelector.HasValue) ui.RowDetailsTemplateSelector = RowDetailsTemplateSelector.Value;
            if (RowDetailsVisibilityMode.HasValue) ui.RowDetailsVisibilityMode = RowDetailsVisibilityMode.Value;
            if (RowHeaderStyle.HasValue) ui.RowHeaderStyle = RowHeaderStyle.Value;
            if (RowHeaderTemplate.HasValue) ui.RowHeaderTemplate = RowHeaderTemplate.Value;
            if (RowHeaderTemplateSelector.HasValue) ui.RowHeaderTemplateSelector = RowHeaderTemplateSelector.Value;
            if (RowHeaderWidth.HasValue) ui.RowHeaderWidth = RowHeaderWidth.Value;
            if (RowHeight.HasValue) ui.RowHeight = RowHeight.Value;
            if (RowStyle.HasValue) ui.RowStyle = RowStyle.Value;
            if (RowStyleSelector.HasValue) ui.RowStyleSelector = RowStyleSelector.Value;
            if (RowValidationErrorTemplate.HasValue) ui.RowValidationErrorTemplate = RowValidationErrorTemplate.Value;
            if (SelectionMode.HasValue) ui.SelectionMode = SelectionMode.Value;
            if (SelectionUnit.HasValue) ui.SelectionUnit = SelectionUnit.Value;
            if (VerticalGridLinesBrush.HasValue) ui.VerticalGridLinesBrush = VerticalGridLinesBrush.Value;
            if (VerticalScrollBarVisibility.HasValue) ui.VerticalScrollBarVisibility = VerticalScrollBarVisibility.Value;
            return global::CSharpMarkup.Wpf.DataGrid.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGrid"/></summary>
        public static DataGrid DataGrid()
        {
            var ui = new Windows.Controls.DataGrid();
            return global::CSharpMarkup.Wpf.DataGrid.StartChain(ui);
        }
    }

    public partial class DataGrid : MultiSelector, IUI<System.Windows.Controls.DataGrid>
    {
        static DataGrid instance;

        internal static DataGrid StartChain(Windows.Controls.DataGrid ui)
        {
            if (instance == null) instance = new DataGrid();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGrid ui;

        public new Windows.Controls.DataGrid UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGrid view) => view?.UI;

        public static implicit operator Windows.Controls.DataGrid(DataGrid view) => view?.UI;

        public static implicit operator DataGrid(Windows.Controls.DataGrid ui) => DataGrid.StartChain(ui);

        protected DataGrid() { }
    }

    public static partial class DataGridExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGrid.AlternatingRowBackground"/></summary>
        public static TView AlternatingRowBackground<TView>(this TView view, Windows.Media.Brush value) where TView : DataGrid { view.UI.AlternatingRowBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.AlternatingRowBackground"/></summary>
        public static TView AlternatingRowBackground<TView>(this TView view, Color value) where TView : DataGrid { view.UI.AlternatingRowBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.AlternatingRowBackground"/></summary>
        public static TView AlternatingRowBackground<TView>(this TView view, string color) where TView : DataGrid { view.UI.AlternatingRowBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.AreRowDetailsFrozen"/></summary>
        public static TView AreRowDetailsFrozen<TView>(this TView view, bool value) where TView : DataGrid { view.UI.AreRowDetailsFrozen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.AutoGenerateColumns"/></summary>
        public static TView AutoGenerateColumns<TView>(this TView view, bool value) where TView : DataGrid { view.UI.AutoGenerateColumns = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserAddRows"/></summary>
        public static TView CanUserAddRows<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserAddRows = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserDeleteRows"/></summary>
        public static TView CanUserDeleteRows<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserDeleteRows = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserReorderColumns"/></summary>
        public static TView CanUserReorderColumns<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserReorderColumns = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserResizeColumns"/></summary>
        public static TView CanUserResizeColumns<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserResizeColumns = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserResizeRows"/></summary>
        public static TView CanUserResizeRows<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserResizeRows = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CanUserSortColumns"/></summary>
        public static TView CanUserSortColumns<TView>(this TView view, bool value) where TView : DataGrid { view.UI.CanUserSortColumns = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CellStyle"/></summary>
        public static TView CellStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.CellStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.ClipboardCopyMode"/></summary>
        public static TView ClipboardCopyMode<TView>(this TView view, Windows.Controls.DataGridClipboardCopyMode value) where TView : DataGrid { view.UI.ClipboardCopyMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.ColumnHeaderHeight"/></summary>
        public static TView ColumnHeaderHeight<TView>(this TView view, double value) where TView : DataGrid { view.UI.ColumnHeaderHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.ColumnHeaderStyle"/></summary>
        public static TView ColumnHeaderStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.ColumnHeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.ColumnWidth"/></summary>
        public static TView ColumnWidth<TView>(this TView view, Windows.Controls.DataGridLength value) where TView : DataGrid { view.UI.ColumnWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CurrentCell"/></summary>
        public static TView CurrentCell<TView>(this TView view, Windows.Controls.DataGridCellInfo value) where TView : DataGrid { view.UI.CurrentCell = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CurrentColumn"/></summary>
        public static TView CurrentColumn<TView>(this TView view, Windows.Controls.DataGridColumn value) where TView : DataGrid { view.UI.CurrentColumn = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.CurrentItem"/></summary>
        public static TView CurrentItem<TView>(this TView view, object value) where TView : DataGrid { view.UI.CurrentItem = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.DragIndicatorStyle"/></summary>
        public static TView DragIndicatorStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.DragIndicatorStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.DropLocationIndicatorStyle"/></summary>
        public static TView DropLocationIndicatorStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.DropLocationIndicatorStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.EnableColumnVirtualization"/></summary>
        public static TView EnableColumnVirtualization<TView>(this TView view, bool value) where TView : DataGrid { view.UI.EnableColumnVirtualization = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.EnableRowVirtualization"/></summary>
        public static TView EnableRowVirtualization<TView>(this TView view, bool value) where TView : DataGrid { view.UI.EnableRowVirtualization = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.FrozenColumnCount"/></summary>
        public static TView FrozenColumnCount<TView>(this TView view, int value) where TView : DataGrid { view.UI.FrozenColumnCount = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.GridLinesVisibility"/></summary>
        public static TView GridLinesVisibility<TView>(this TView view, Windows.Controls.DataGridGridLinesVisibility value) where TView : DataGrid { view.UI.GridLinesVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.HeadersVisibility"/></summary>
        public static TView HeadersVisibility<TView>(this TView view, Windows.Controls.DataGridHeadersVisibility value) where TView : DataGrid { view.UI.HeadersVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.HorizontalGridLinesBrush"/></summary>
        public static TView HorizontalGridLinesBrush<TView>(this TView view, Windows.Media.Brush value) where TView : DataGrid { view.UI.HorizontalGridLinesBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.HorizontalGridLinesBrush"/></summary>
        public static TView HorizontalGridLinesBrush<TView>(this TView view, Color value) where TView : DataGrid { view.UI.HorizontalGridLinesBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.HorizontalGridLinesBrush"/></summary>
        public static TView HorizontalGridLinesBrush<TView>(this TView view, string color) where TView : DataGrid { view.UI.HorizontalGridLinesBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.HorizontalScrollBarVisibility"/></summary>
        public static TView HorizontalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : DataGrid { view.UI.HorizontalScrollBarVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.IsReadOnly"/></summary>
        public static TView IsReadOnly<TView>(this TView view, bool value) where TView : DataGrid { view.UI.IsReadOnly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.MaxColumnWidth"/></summary>
        public static TView MaxColumnWidth<TView>(this TView view, double value) where TView : DataGrid { view.UI.MaxColumnWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.MinColumnWidth"/></summary>
        public static TView MinColumnWidth<TView>(this TView view, double value) where TView : DataGrid { view.UI.MinColumnWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.MinRowHeight"/></summary>
        public static TView MinRowHeight<TView>(this TView view, double value) where TView : DataGrid { view.UI.MinRowHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowBackground"/></summary>
        public static TView RowBackground<TView>(this TView view, Windows.Media.Brush value) where TView : DataGrid { view.UI.RowBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowBackground"/></summary>
        public static TView RowBackground<TView>(this TView view, Color value) where TView : DataGrid { view.UI.RowBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowBackground"/></summary>
        public static TView RowBackground<TView>(this TView view, string color) where TView : DataGrid { view.UI.RowBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowDetailsTemplate"/></summary>
        public static TView RowDetailsTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGrid { view.UI.RowDetailsTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowDetailsTemplateSelector"/></summary>
        public static TView RowDetailsTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGrid { view.UI.RowDetailsTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowDetailsVisibilityMode"/></summary>
        public static TView RowDetailsVisibilityMode<TView>(this TView view, Windows.Controls.DataGridRowDetailsVisibilityMode value) where TView : DataGrid { view.UI.RowDetailsVisibilityMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowHeaderStyle"/></summary>
        public static TView RowHeaderStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.RowHeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowHeaderTemplate"/></summary>
        public static TView RowHeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGrid { view.UI.RowHeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowHeaderTemplateSelector"/></summary>
        public static TView RowHeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGrid { view.UI.RowHeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowHeaderWidth"/></summary>
        public static TView RowHeaderWidth<TView>(this TView view, double value) where TView : DataGrid { view.UI.RowHeaderWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowHeight"/></summary>
        public static TView RowHeight<TView>(this TView view, double value) where TView : DataGrid { view.UI.RowHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowStyle"/></summary>
        public static TView RowStyle<TView>(this TView view, Windows.Style value) where TView : DataGrid { view.UI.RowStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowStyleSelector"/></summary>
        public static TView RowStyleSelector<TView>(this TView view, Windows.Controls.StyleSelector value) where TView : DataGrid { view.UI.RowStyleSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.RowValidationErrorTemplate"/></summary>
        public static TView RowValidationErrorTemplate<TView>(this TView view, Windows.Controls.ControlTemplate value) where TView : DataGrid { view.UI.RowValidationErrorTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.SelectionMode"/></summary>
        public static TView SelectionMode<TView>(this TView view, Windows.Controls.DataGridSelectionMode value) where TView : DataGrid { view.UI.SelectionMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.SelectionUnit"/></summary>
        public static TView SelectionUnit<TView>(this TView view, Windows.Controls.DataGridSelectionUnit value) where TView : DataGrid { view.UI.SelectionUnit = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.VerticalGridLinesBrush"/></summary>
        public static TView VerticalGridLinesBrush<TView>(this TView view, Windows.Media.Brush value) where TView : DataGrid { view.UI.VerticalGridLinesBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.VerticalGridLinesBrush"/></summary>
        public static TView VerticalGridLinesBrush<TView>(this TView view, Color value) where TView : DataGrid { view.UI.VerticalGridLinesBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.VerticalGridLinesBrush"/></summary>
        public static TView VerticalGridLinesBrush<TView>(this TView view, string color) where TView : DataGrid { view.UI.VerticalGridLinesBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGrid.VerticalScrollBarVisibility"/></summary>
        public static TView VerticalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : DataGrid { view.UI.VerticalScrollBarVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.AlternatingRowBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> AlternatingRowBackground<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.DataGrid.AlternatingRowBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.AreRowDetailsFrozen"/></summary>
        public static DependencyProperty<TTarget, bool> AreRowDetailsFrozen<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.AreRowDetailsFrozenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.AutoGenerateColumns"/></summary>
        public static DependencyProperty<TTarget, bool> AutoGenerateColumns<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.AutoGenerateColumnsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserAddRows"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserAddRows<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserAddRowsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserDeleteRows"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserDeleteRows<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserDeleteRowsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserReorderColumns"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserReorderColumns<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserReorderColumnsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserResizeColumns"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeColumns<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserResizeColumnsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserResizeRows"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeRows<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserResizeRowsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CanUserSortColumns"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserSortColumns<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.CanUserSortColumnsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CellsPanelHorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> CellsPanelHorizontalOffset<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.CellsPanelHorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CellStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CellStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.CellStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.ClipboardCopyMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridClipboardCopyMode> ClipboardCopyMode<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridClipboardCopyMode>.Get(target, Windows.Controls.DataGrid.ClipboardCopyModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.ColumnHeaderHeight"/></summary>
        public static DependencyProperty<TTarget, double> ColumnHeaderHeight<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.ColumnHeaderHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.ColumnHeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ColumnHeaderStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.ColumnHeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.ColumnWidth"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridLength> ColumnWidth<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridLength>.Get(target, Windows.Controls.DataGrid.ColumnWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CurrentCell"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridCellInfo> CurrentCell<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridCellInfo>.Get(target, Windows.Controls.DataGrid.CurrentCellProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CurrentColumn"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridColumn> CurrentColumn<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridColumn>.Get(target, Windows.Controls.DataGrid.CurrentColumnProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.CurrentItem"/></summary>
        public static DependencyProperty<TTarget, object> CurrentItem<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.DataGrid.CurrentItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.DragIndicatorStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> DragIndicatorStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.DragIndicatorStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.DropLocationIndicatorStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> DropLocationIndicatorStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.DropLocationIndicatorStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.EnableColumnVirtualization"/></summary>
        public static DependencyProperty<TTarget, bool> EnableColumnVirtualization<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.EnableColumnVirtualizationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.EnableRowVirtualization"/></summary>
        public static DependencyProperty<TTarget, bool> EnableRowVirtualization<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.EnableRowVirtualizationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.FrozenColumnCount"/></summary>
        public static DependencyProperty<TTarget, int> FrozenColumnCount<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.DataGrid.FrozenColumnCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.GridLinesVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility> GridLinesVisibility<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility>.Get(target, Windows.Controls.DataGrid.GridLinesVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.HeadersVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility> HeadersVisibility<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility>.Get(target, Windows.Controls.DataGrid.HeadersVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.HorizontalGridLinesBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> HorizontalGridLinesBrush<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.DataGrid.HorizontalGridLinesBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.HorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.DataGrid.HorizontalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGrid.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.MaxColumnWidth"/></summary>
        public static DependencyProperty<TTarget, double> MaxColumnWidth<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.MaxColumnWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.MinColumnWidth"/></summary>
        public static DependencyProperty<TTarget, double> MinColumnWidth<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.MinColumnWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.MinRowHeight"/></summary>
        public static DependencyProperty<TTarget, double> MinRowHeight<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.MinRowHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.NewItemMargin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> NewItemMargin<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.DataGrid.NewItemMarginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.NonFrozenColumnsViewportHorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> NonFrozenColumnsViewportHorizontalOffset<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.NonFrozenColumnsViewportHorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> RowBackground<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.DataGrid.RowBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowDetailsTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> RowDetailsTemplate<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGrid.RowDetailsTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowDetailsTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> RowDetailsTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGrid.RowDetailsTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowDetailsVisibilityMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridRowDetailsVisibilityMode> RowDetailsVisibilityMode<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridRowDetailsVisibilityMode>.Get(target, Windows.Controls.DataGrid.RowDetailsVisibilityModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeaderActualWidth"/></summary>
        public static DependencyProperty<TTarget, double> RowHeaderActualWidth<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.RowHeaderActualWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> RowHeaderStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.RowHeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> RowHeaderTemplate<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGrid.RowHeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> RowHeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGrid.RowHeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeaderWidth"/></summary>
        public static DependencyProperty<TTarget, double> RowHeaderWidth<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.RowHeaderWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowHeight"/></summary>
        public static DependencyProperty<TTarget, double> RowHeight<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGrid.RowHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> RowStyle<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGrid.RowStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowStyleSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StyleSelector> RowStyleSelector<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.StyleSelector>.Get(target, Windows.Controls.DataGrid.RowStyleSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.RowValidationErrorTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ControlTemplate> RowValidationErrorTemplate<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.ControlTemplate>.Get(target, Windows.Controls.DataGrid.RowValidationErrorTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.SelectionMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridSelectionMode> SelectionMode<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridSelectionMode>.Get(target, Windows.Controls.DataGrid.SelectionModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.SelectionUnit"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridSelectionUnit> SelectionUnit<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.DataGridSelectionUnit>.Get(target, Windows.Controls.DataGrid.SelectionUnitProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.VerticalGridLinesBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> VerticalGridLinesBrush<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.DataGrid.VerticalGridLinesBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGrid.VerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : DataGrid
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.DataGrid.VerticalScrollBarVisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridBoundColumn
{
    public partial class DataGridBoundColumn : DataGridColumn, IUI<System.Windows.Controls.DataGridBoundColumn>
    {
        Windows.Controls.DataGridBoundColumn ui;

        public new Windows.Controls.DataGridBoundColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DataGridBoundColumn() { }
    }

    public static partial class DataGridBoundColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridBoundColumn.Binding"/></summary>
        public static TView Binding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridBoundColumn { view.UI.Binding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridBoundColumn.ClipboardContentBinding"/></summary>
        public static TView ClipboardContentBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridBoundColumn { view.UI.ClipboardContentBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridBoundColumn.EditingElementStyle"/></summary>
        public static TView EditingElementStyle<TView>(this TView view, Windows.Style value) where TView : DataGridBoundColumn { view.UI.EditingElementStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridBoundColumn.ElementStyle"/></summary>
        public static TView ElementStyle<TView>(this TView view, Windows.Style value) where TView : DataGridBoundColumn { view.UI.ElementStyle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridBoundColumn.EditingElementStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> EditingElementStyle<TTarget>(this TTarget target) where TTarget : DataGridBoundColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridBoundColumn.EditingElementStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridBoundColumn.ElementStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ElementStyle<TTarget>(this TTarget target) where TTarget : DataGridBoundColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridBoundColumn.ElementStyleProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridCell
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridCell"/></summary>
        public static DataGridCell DataGridCell(
            object Content
)
        {
            var ui = new Windows.Controls.DataGridCell();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.DataGridCell.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridCell"/></summary>
        public static DataGridCell DataGridCell(O<bool> IsEditing = default, O<bool> IsSelected = default)
        {
            var ui = new Windows.Controls.DataGridCell();
            if (IsEditing.HasValue) ui.IsEditing = IsEditing.Value;
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            return global::CSharpMarkup.Wpf.DataGridCell.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridCell"/></summary>
        public static DataGridCell DataGridCell()
        {
            var ui = new Windows.Controls.DataGridCell();
            return global::CSharpMarkup.Wpf.DataGridCell.StartChain(ui);
        }
    }

    public partial class DataGridCell : ContentControl, IUI<System.Windows.Controls.DataGridCell>
    {
        static DataGridCell instance;

        internal static DataGridCell StartChain(Windows.Controls.DataGridCell ui)
        {
            if (instance == null) instance = new DataGridCell();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridCell ui;

        public new Windows.Controls.DataGridCell UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridCell view) => view?.UI;

        public static implicit operator Windows.Controls.DataGridCell(DataGridCell view) => view?.UI;

        public static implicit operator DataGridCell(Windows.Controls.DataGridCell ui) => DataGridCell.StartChain(ui);

        protected DataGridCell() { }
    }

    public static partial class DataGridCellExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridCell.IsEditing"/></summary>
        public static TView IsEditing<TView>(this TView view, bool value) where TView : DataGridCell { view.UI.IsEditing = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridCell.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : DataGridCell { view.UI.IsSelected = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridCell.Column"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridColumn> Column<TTarget>(this TTarget target) where TTarget : DataGridCell
        => DependencyProperty<TTarget, Windows.Controls.DataGridColumn>.Get(target, Windows.Controls.DataGridCell.ColumnProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridCell.IsEditing"/></summary>
        public static DependencyProperty<TTarget, bool> IsEditing<TTarget>(this TTarget target) where TTarget : DataGridCell
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridCell.IsEditingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridCell.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : DataGridCell
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridCell.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridCell.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : DataGridCell
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridCell.IsSelectedProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridCellsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridCellsPanel"/></summary>
        public static DataGridCellsPanel DataGridCellsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.DataGridCellsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.DataGridCellsPanel.StartChain(ui);
        }
    }

    public partial class DataGridCellsPanel : VirtualizingPanel, IUI<System.Windows.Controls.DataGridCellsPanel>
    {
        static DataGridCellsPanel instance;

        internal static DataGridCellsPanel StartChain(Windows.Controls.DataGridCellsPanel ui)
        {
            if (instance == null) instance = new DataGridCellsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridCellsPanel ui;

        public new Windows.Controls.DataGridCellsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridCellsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.DataGridCellsPanel(DataGridCellsPanel view) => view?.UI;

        public static implicit operator DataGridCellsPanel(Windows.Controls.DataGridCellsPanel ui) => DataGridCellsPanel.StartChain(ui);

        protected DataGridCellsPanel() { }
    }
}

namespace CSharpMarkup.Wpf // DataGridCheckBoxColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridCheckBoxColumn"/></summary>
        public static DataGridCheckBoxColumn DataGridCheckBoxColumn(O<bool> IsThreeState = default)
        {
            var ui = new Windows.Controls.DataGridCheckBoxColumn();
            if (IsThreeState.HasValue) ui.IsThreeState = IsThreeState.Value;
            return global::CSharpMarkup.Wpf.DataGridCheckBoxColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridCheckBoxColumn"/></summary>
        public static DataGridCheckBoxColumn DataGridCheckBoxColumn()
        {
            var ui = new Windows.Controls.DataGridCheckBoxColumn();
            return global::CSharpMarkup.Wpf.DataGridCheckBoxColumn.StartChain(ui);
        }
    }

    public partial class DataGridCheckBoxColumn : DataGridBoundColumn, IUI<System.Windows.Controls.DataGridCheckBoxColumn>
    {
        static DataGridCheckBoxColumn instance;

        internal static DataGridCheckBoxColumn StartChain(Windows.Controls.DataGridCheckBoxColumn ui)
        {
            if (instance == null) instance = new DataGridCheckBoxColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridCheckBoxColumn ui;

        public new Windows.Controls.DataGridCheckBoxColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.DataGridCheckBoxColumn(DataGridCheckBoxColumn view) => view?.UI;

        public static implicit operator DataGridCheckBoxColumn(Windows.Controls.DataGridCheckBoxColumn ui) => DataGridCheckBoxColumn.StartChain(ui);

        protected DataGridCheckBoxColumn() { }
    }

    public static partial class DataGridCheckBoxColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridCheckBoxColumn.IsThreeState"/></summary>
        public static TView IsThreeState<TView>(this TView view, bool value) where TView : DataGridCheckBoxColumn { view.UI.IsThreeState = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridCheckBoxColumn.IsThreeState"/></summary>
        public static DependencyProperty<TTarget, bool> IsThreeState<TTarget>(this TTarget target) where TTarget : DataGridCheckBoxColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridCheckBoxColumn.IsThreeStateProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridColumn
{
    public partial class DataGridColumn : DependencyObject, IUI<System.Windows.Controls.DataGridColumn>
    {
        Windows.Controls.DataGridColumn ui;

        public new Windows.Controls.DataGridColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DataGridColumn() { }
    }

    public static partial class DataGridColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.CanUserReorder"/></summary>
        public static TView CanUserReorder<TView>(this TView view, bool value) where TView : DataGridColumn { view.UI.CanUserReorder = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.CanUserResize"/></summary>
        public static TView CanUserResize<TView>(this TView view, bool value) where TView : DataGridColumn { view.UI.CanUserResize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.CanUserSort"/></summary>
        public static TView CanUserSort<TView>(this TView view, bool value) where TView : DataGridColumn { view.UI.CanUserSort = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.CellStyle"/></summary>
        public static TView CellStyle<TView>(this TView view, Windows.Style value) where TView : DataGridColumn { view.UI.CellStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.ClipboardContentBinding"/></summary>
        public static TView ClipboardContentBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridColumn { view.UI.ClipboardContentBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.DisplayIndex"/></summary>
        public static TView DisplayIndex<TView>(this TView view, int value) where TView : DataGridColumn { view.UI.DisplayIndex = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.DragIndicatorStyle"/></summary>
        public static TView DragIndicatorStyle<TView>(this TView view, Windows.Style value) where TView : DataGridColumn { view.UI.DragIndicatorStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : DataGridColumn { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.HeaderStringFormat"/></summary>
        public static TView HeaderStringFormat<TView>(this TView view, string value) where TView : DataGridColumn { view.UI.HeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.HeaderStyle"/></summary>
        public static TView HeaderStyle<TView>(this TView view, Windows.Style value) where TView : DataGridColumn { view.UI.HeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGridColumn { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGridColumn { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.IsReadOnly"/></summary>
        public static TView IsReadOnly<TView>(this TView view, bool value) where TView : DataGridColumn { view.UI.IsReadOnly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.MaxWidth"/></summary>
        public static TView MaxWidth<TView>(this TView view, double value) where TView : DataGridColumn { view.UI.MaxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.MinWidth"/></summary>
        public static TView MinWidth<TView>(this TView view, double value) where TView : DataGridColumn { view.UI.MinWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.SortDirection"/></summary>
        public static TView SortDirection<TView>(this TView view, ListSortDirection? value) where TView : DataGridColumn { view.UI.SortDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.SortMemberPath"/></summary>
        public static TView SortMemberPath<TView>(this TView view, string value) where TView : DataGridColumn { view.UI.SortMemberPath = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.Visibility"/></summary>
        public static TView Visibility<TView>(this TView view, Windows.Visibility value) where TView : DataGridColumn { view.UI.Visibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridColumn.Width"/></summary>
        public static TView Width<TView>(this TView view, Windows.Controls.DataGridLength value) where TView : DataGridColumn { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.ActualWidth"/></summary>
        public static DependencyProperty<TTarget, double> ActualWidth<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGridColumn.ActualWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.CanUserReorder"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserReorder<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.CanUserReorderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.CanUserResize"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResize<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.CanUserResizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.CanUserSort"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserSort<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.CanUserSortProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.CellStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CellStyle<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridColumn.CellStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.DisplayIndex"/></summary>
        public static DependencyProperty<TTarget, int> DisplayIndex<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.DataGridColumn.DisplayIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.DragIndicatorStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> DragIndicatorStyle<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridColumn.DragIndicatorStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.DataGridColumn.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.HeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> HeaderStringFormat<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DataGridColumn.HeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.HeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> HeaderStyle<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridColumn.HeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGridColumn.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGridColumn.HeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.IsAutoGenerated"/></summary>
        public static DependencyProperty<TTarget, bool> IsAutoGenerated<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.IsAutoGeneratedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.IsFrozen"/></summary>
        public static DependencyProperty<TTarget, bool> IsFrozen<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.IsFrozenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridColumn.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.MaxWidth"/></summary>
        public static DependencyProperty<TTarget, double> MaxWidth<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGridColumn.MaxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.MinWidth"/></summary>
        public static DependencyProperty<TTarget, double> MinWidth<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGridColumn.MinWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.SortDirection"/></summary>
        public static DependencyProperty<TTarget, ListSortDirection?> SortDirection<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, ListSortDirection?>.Get(target, Windows.Controls.DataGridColumn.SortDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.SortMemberPath"/></summary>
        public static DependencyProperty<TTarget, string> SortMemberPath<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DataGridColumn.SortMemberPathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.Visibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> Visibility<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.DataGridColumn.VisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridColumn.Width"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataGridLength> Width<TTarget>(this TTarget target) where TTarget : DataGridColumn
        => DependencyProperty<TTarget, Windows.Controls.DataGridLength>.Get(target, Windows.Controls.DataGridColumn.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridComboBoxColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridComboBoxColumn"/></summary>
        public static DataGridComboBoxColumn DataGridComboBoxColumn(O<Windows.Data.BindingBase> ClipboardContentBinding = default, O<string> DisplayMemberPath = default, O<Windows.Style> EditingElementStyle = default, O<Windows.Style> ElementStyle = default, O<IEnumerable> ItemsSource = default, O<Windows.Data.BindingBase> SelectedItemBinding = default, O<Windows.Data.BindingBase> SelectedValueBinding = default, O<string> SelectedValuePath = default, O<Windows.Data.BindingBase> TextBinding = default)
        {
            var ui = new Windows.Controls.DataGridComboBoxColumn();
            if (ClipboardContentBinding.HasValue) ui.ClipboardContentBinding = ClipboardContentBinding.Value;
            if (DisplayMemberPath.HasValue) ui.DisplayMemberPath = DisplayMemberPath.Value;
            if (EditingElementStyle.HasValue) ui.EditingElementStyle = EditingElementStyle.Value;
            if (ElementStyle.HasValue) ui.ElementStyle = ElementStyle.Value;
            if (ItemsSource.HasValue) ui.ItemsSource = ItemsSource.Value;
            if (SelectedItemBinding.HasValue) ui.SelectedItemBinding = SelectedItemBinding.Value;
            if (SelectedValueBinding.HasValue) ui.SelectedValueBinding = SelectedValueBinding.Value;
            if (SelectedValuePath.HasValue) ui.SelectedValuePath = SelectedValuePath.Value;
            if (TextBinding.HasValue) ui.TextBinding = TextBinding.Value;
            return global::CSharpMarkup.Wpf.DataGridComboBoxColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridComboBoxColumn"/></summary>
        public static DataGridComboBoxColumn DataGridComboBoxColumn()
        {
            var ui = new Windows.Controls.DataGridComboBoxColumn();
            return global::CSharpMarkup.Wpf.DataGridComboBoxColumn.StartChain(ui);
        }
    }

    public partial class DataGridComboBoxColumn : DataGridColumn, IUI<System.Windows.Controls.DataGridComboBoxColumn>
    {
        static DataGridComboBoxColumn instance;

        internal static DataGridComboBoxColumn StartChain(Windows.Controls.DataGridComboBoxColumn ui)
        {
            if (instance == null) instance = new DataGridComboBoxColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridComboBoxColumn ui;

        public new Windows.Controls.DataGridComboBoxColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.DataGridComboBoxColumn(DataGridComboBoxColumn view) => view?.UI;

        public static implicit operator DataGridComboBoxColumn(Windows.Controls.DataGridComboBoxColumn ui) => DataGridComboBoxColumn.StartChain(ui);

        protected DataGridComboBoxColumn() { }
    }

    public static partial class DataGridComboBoxColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.ClipboardContentBinding"/></summary>
        public static TView ClipboardContentBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridComboBoxColumn { view.UI.ClipboardContentBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.DisplayMemberPath"/></summary>
        public static TView DisplayMemberPath<TView>(this TView view, string value) where TView : DataGridComboBoxColumn { view.UI.DisplayMemberPath = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.EditingElementStyle"/></summary>
        public static TView EditingElementStyle<TView>(this TView view, Windows.Style value) where TView : DataGridComboBoxColumn { view.UI.EditingElementStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.ElementStyle"/></summary>
        public static TView ElementStyle<TView>(this TView view, Windows.Style value) where TView : DataGridComboBoxColumn { view.UI.ElementStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.ItemsSource"/></summary>
        public static TView ItemsSource<TView>(this TView view, IEnumerable value) where TView : DataGridComboBoxColumn { view.UI.ItemsSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.SelectedItemBinding"/></summary>
        public static TView SelectedItemBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridComboBoxColumn { view.UI.SelectedItemBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.SelectedValueBinding"/></summary>
        public static TView SelectedValueBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridComboBoxColumn { view.UI.SelectedValueBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.SelectedValuePath"/></summary>
        public static TView SelectedValuePath<TView>(this TView view, string value) where TView : DataGridComboBoxColumn { view.UI.SelectedValuePath = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridComboBoxColumn.TextBinding"/></summary>
        public static TView TextBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridComboBoxColumn { view.UI.TextBinding = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridComboBoxColumn.DisplayMemberPath"/></summary>
        public static DependencyProperty<TTarget, string> DisplayMemberPath<TTarget>(this TTarget target) where TTarget : DataGridComboBoxColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DataGridComboBoxColumn.DisplayMemberPathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridComboBoxColumn.EditingElementStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> EditingElementStyle<TTarget>(this TTarget target) where TTarget : DataGridComboBoxColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridComboBoxColumn.EditingElementStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridComboBoxColumn.ElementStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ElementStyle<TTarget>(this TTarget target) where TTarget : DataGridComboBoxColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridComboBoxColumn.ElementStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridComboBoxColumn.ItemsSource"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> ItemsSource<TTarget>(this TTarget target) where TTarget : DataGridComboBoxColumn
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Controls.DataGridComboBoxColumn.ItemsSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridComboBoxColumn.SelectedValuePath"/></summary>
        public static DependencyProperty<TTarget, string> SelectedValuePath<TTarget>(this TTarget target) where TTarget : DataGridComboBoxColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DataGridComboBoxColumn.SelectedValuePathProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridHyperlinkColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridHyperlinkColumn"/></summary>
        public static DataGridHyperlinkColumn DataGridHyperlinkColumn(O<Windows.Data.BindingBase> ContentBinding = default, O<string> TargetName = default)
        {
            var ui = new Windows.Controls.DataGridHyperlinkColumn();
            if (ContentBinding.HasValue) ui.ContentBinding = ContentBinding.Value;
            if (TargetName.HasValue) ui.TargetName = TargetName.Value;
            return global::CSharpMarkup.Wpf.DataGridHyperlinkColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridHyperlinkColumn"/></summary>
        public static DataGridHyperlinkColumn DataGridHyperlinkColumn()
        {
            var ui = new Windows.Controls.DataGridHyperlinkColumn();
            return global::CSharpMarkup.Wpf.DataGridHyperlinkColumn.StartChain(ui);
        }
    }

    public partial class DataGridHyperlinkColumn : DataGridBoundColumn, IUI<System.Windows.Controls.DataGridHyperlinkColumn>
    {
        static DataGridHyperlinkColumn instance;

        internal static DataGridHyperlinkColumn StartChain(Windows.Controls.DataGridHyperlinkColumn ui)
        {
            if (instance == null) instance = new DataGridHyperlinkColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridHyperlinkColumn ui;

        public new Windows.Controls.DataGridHyperlinkColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.DataGridHyperlinkColumn(DataGridHyperlinkColumn view) => view?.UI;

        public static implicit operator DataGridHyperlinkColumn(Windows.Controls.DataGridHyperlinkColumn ui) => DataGridHyperlinkColumn.StartChain(ui);

        protected DataGridHyperlinkColumn() { }
    }

    public static partial class DataGridHyperlinkColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridHyperlinkColumn.ContentBinding"/></summary>
        public static TView ContentBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : DataGridHyperlinkColumn { view.UI.ContentBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridHyperlinkColumn.TargetName"/></summary>
        public static TView TargetName<TView>(this TView view, string value) where TView : DataGridHyperlinkColumn { view.UI.TargetName = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridHyperlinkColumn.TargetName"/></summary>
        public static DependencyProperty<TTarget, string> TargetName<TTarget>(this TTarget target) where TTarget : DataGridHyperlinkColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DataGridHyperlinkColumn.TargetNameProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridRow
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridRow"/></summary>
        public static DataGridRow DataGridRow(O<Windows.DataTemplate> DetailsTemplate = default, O<Windows.Controls.DataTemplateSelector> DetailsTemplateSelector = default, O<Windows.Visibility> DetailsVisibility = default, O<object> Header = default, O<Windows.Style> HeaderStyle = default, O<Windows.DataTemplate> HeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> HeaderTemplateSelector = default, O<bool> IsSelected = default, O<object> Item = default, O<Windows.Controls.ItemsPanelTemplate> ItemsPanel = default, O<Windows.Controls.ControlTemplate> ValidationErrorTemplate = default)
        {
            var ui = new Windows.Controls.DataGridRow();
            if (DetailsTemplate.HasValue) ui.DetailsTemplate = DetailsTemplate.Value;
            if (DetailsTemplateSelector.HasValue) ui.DetailsTemplateSelector = DetailsTemplateSelector.Value;
            if (DetailsVisibility.HasValue) ui.DetailsVisibility = DetailsVisibility.Value;
            if (Header.HasValue) ui.Header = Header.Value;
            if (HeaderStyle.HasValue) ui.HeaderStyle = HeaderStyle.Value;
            if (HeaderTemplate.HasValue) ui.HeaderTemplate = HeaderTemplate.Value;
            if (HeaderTemplateSelector.HasValue) ui.HeaderTemplateSelector = HeaderTemplateSelector.Value;
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            if (Item.HasValue) ui.Item = Item.Value;
            if (ItemsPanel.HasValue) ui.ItemsPanel = ItemsPanel.Value;
            if (ValidationErrorTemplate.HasValue) ui.ValidationErrorTemplate = ValidationErrorTemplate.Value;
            return global::CSharpMarkup.Wpf.DataGridRow.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridRow"/></summary>
        public static DataGridRow DataGridRow()
        {
            var ui = new Windows.Controls.DataGridRow();
            return global::CSharpMarkup.Wpf.DataGridRow.StartChain(ui);
        }
    }

    public partial class DataGridRow : Control, IUI<System.Windows.Controls.DataGridRow>
    {
        static DataGridRow instance;

        internal static DataGridRow StartChain(Windows.Controls.DataGridRow ui)
        {
            if (instance == null) instance = new DataGridRow();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridRow ui;

        public new Windows.Controls.DataGridRow UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridRow view) => view?.UI;

        public static implicit operator Windows.Controls.DataGridRow(DataGridRow view) => view?.UI;

        public static implicit operator DataGridRow(Windows.Controls.DataGridRow ui) => DataGridRow.StartChain(ui);

        protected DataGridRow() { }
    }

    public static partial class DataGridRowExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridRow.DetailsTemplate"/></summary>
        public static TView DetailsTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGridRow { view.UI.DetailsTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.DetailsTemplateSelector"/></summary>
        public static TView DetailsTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGridRow { view.UI.DetailsTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.DetailsVisibility"/></summary>
        public static TView DetailsVisibility<TView>(this TView view, Windows.Visibility value) where TView : DataGridRow { view.UI.DetailsVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : DataGridRow { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.HeaderStyle"/></summary>
        public static TView HeaderStyle<TView>(this TView view, Windows.Style value) where TView : DataGridRow { view.UI.HeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGridRow { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGridRow { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : DataGridRow { view.UI.IsSelected = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.Item"/></summary>
        public static TView Item<TView>(this TView view, object value) where TView : DataGridRow { view.UI.Item = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.ItemsPanel"/></summary>
        public static TView ItemsPanel<TView>(this TView view, Windows.Controls.ItemsPanelTemplate value) where TView : DataGridRow { view.UI.ItemsPanel = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridRow.ValidationErrorTemplate"/></summary>
        public static TView ValidationErrorTemplate<TView>(this TView view, Windows.Controls.ControlTemplate value) where TView : DataGridRow { view.UI.ValidationErrorTemplate = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.AlternationIndex"/></summary>
        public static DependencyProperty<TTarget, int> AlternationIndex<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.DataGridRow.AlternationIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.DetailsTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> DetailsTemplate<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGridRow.DetailsTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.DetailsTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> DetailsTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGridRow.DetailsTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.DetailsVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> DetailsVisibility<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.DataGridRow.DetailsVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.DataGridRow.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.HeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> HeaderStyle<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DataGridRow.HeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGridRow.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGridRow.HeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.IsEditing"/></summary>
        public static DependencyProperty<TTarget, bool> IsEditing<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridRow.IsEditingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.IsNewItem"/></summary>
        public static DependencyProperty<TTarget, bool> IsNewItem<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridRow.IsNewItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DataGridRow.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.Item"/></summary>
        public static DependencyProperty<TTarget, object> Item<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.DataGridRow.ItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.ItemsPanel"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ItemsPanelTemplate> ItemsPanel<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Controls.ItemsPanelTemplate>.Get(target, Windows.Controls.DataGridRow.ItemsPanelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridRow.ValidationErrorTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ControlTemplate> ValidationErrorTemplate<TTarget>(this TTarget target) where TTarget : DataGridRow
        => DependencyProperty<TTarget, Windows.Controls.ControlTemplate>.Get(target, Windows.Controls.DataGridRow.ValidationErrorTemplateProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridTemplateColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridTemplateColumn"/></summary>
        public static DataGridTemplateColumn DataGridTemplateColumn(O<Windows.DataTemplate> CellEditingTemplate = default, O<Windows.Controls.DataTemplateSelector> CellEditingTemplateSelector = default, O<Windows.DataTemplate> CellTemplate = default, O<Windows.Controls.DataTemplateSelector> CellTemplateSelector = default)
        {
            var ui = new Windows.Controls.DataGridTemplateColumn();
            if (CellEditingTemplate.HasValue) ui.CellEditingTemplate = CellEditingTemplate.Value;
            if (CellEditingTemplateSelector.HasValue) ui.CellEditingTemplateSelector = CellEditingTemplateSelector.Value;
            if (CellTemplate.HasValue) ui.CellTemplate = CellTemplate.Value;
            if (CellTemplateSelector.HasValue) ui.CellTemplateSelector = CellTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.DataGridTemplateColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridTemplateColumn"/></summary>
        public static DataGridTemplateColumn DataGridTemplateColumn()
        {
            var ui = new Windows.Controls.DataGridTemplateColumn();
            return global::CSharpMarkup.Wpf.DataGridTemplateColumn.StartChain(ui);
        }
    }

    public partial class DataGridTemplateColumn : DataGridColumn, IUI<System.Windows.Controls.DataGridTemplateColumn>
    {
        static DataGridTemplateColumn instance;

        internal static DataGridTemplateColumn StartChain(Windows.Controls.DataGridTemplateColumn ui)
        {
            if (instance == null) instance = new DataGridTemplateColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridTemplateColumn ui;

        public new Windows.Controls.DataGridTemplateColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.DataGridTemplateColumn(DataGridTemplateColumn view) => view?.UI;

        public static implicit operator DataGridTemplateColumn(Windows.Controls.DataGridTemplateColumn ui) => DataGridTemplateColumn.StartChain(ui);

        protected DataGridTemplateColumn() { }
    }

    public static partial class DataGridTemplateColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridTemplateColumn.CellEditingTemplate"/></summary>
        public static TView CellEditingTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGridTemplateColumn { view.UI.CellEditingTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTemplateColumn.CellEditingTemplateSelector"/></summary>
        public static TView CellEditingTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGridTemplateColumn { view.UI.CellEditingTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTemplateColumn.CellTemplate"/></summary>
        public static TView CellTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : DataGridTemplateColumn { view.UI.CellTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTemplateColumn.CellTemplateSelector"/></summary>
        public static TView CellTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : DataGridTemplateColumn { view.UI.CellTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTemplateColumn.CellEditingTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> CellEditingTemplate<TTarget>(this TTarget target) where TTarget : DataGridTemplateColumn
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGridTemplateColumn.CellEditingTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTemplateColumn.CellEditingTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> CellEditingTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGridTemplateColumn
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGridTemplateColumn.CellEditingTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTemplateColumn.CellTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> CellTemplate<TTarget>(this TTarget target) where TTarget : DataGridTemplateColumn
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.DataGridTemplateColumn.CellTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTemplateColumn.CellTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> CellTemplateSelector<TTarget>(this TTarget target) where TTarget : DataGridTemplateColumn
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.DataGridTemplateColumn.CellTemplateSelectorProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridTextColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DataGridTextColumn"/></summary>
        public static DataGridTextColumn DataGridTextColumn(O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.FontStyle> FontStyle = default, O<Windows.FontWeight> FontWeight = default, O<Windows.Media.Brush> Foreground = default)
        {
            var ui = new Windows.Controls.DataGridTextColumn();
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (FontStyle.HasValue) ui.FontStyle = FontStyle.Value;
            if (FontWeight.HasValue) ui.FontWeight = FontWeight.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            return global::CSharpMarkup.Wpf.DataGridTextColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DataGridTextColumn"/></summary>
        public static DataGridTextColumn DataGridTextColumn()
        {
            var ui = new Windows.Controls.DataGridTextColumn();
            return global::CSharpMarkup.Wpf.DataGridTextColumn.StartChain(ui);
        }
    }

    public partial class DataGridTextColumn : DataGridBoundColumn, IUI<System.Windows.Controls.DataGridTextColumn>
    {
        static DataGridTextColumn instance;

        internal static DataGridTextColumn StartChain(Windows.Controls.DataGridTextColumn ui)
        {
            if (instance == null) instance = new DataGridTextColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DataGridTextColumn ui;

        public new Windows.Controls.DataGridTextColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.DataGridTextColumn(DataGridTextColumn view) => view?.UI;

        public static implicit operator DataGridTextColumn(Windows.Controls.DataGridTextColumn ui) => DataGridTextColumn.StartChain(ui);

        protected DataGridTextColumn() { }
    }

    public static partial class DataGridTextColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : DataGridTextColumn { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : DataGridTextColumn { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : DataGridTextColumn { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : DataGridTextColumn { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : DataGridTextColumn { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : DataGridTextColumn { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.DataGridTextColumn.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : DataGridTextColumn { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTextColumn.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : DataGridTextColumn
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.DataGridTextColumn.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTextColumn.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : DataGridTextColumn
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DataGridTextColumn.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTextColumn.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : DataGridTextColumn
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.DataGridTextColumn.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTextColumn.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : DataGridTextColumn
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.DataGridTextColumn.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DataGridTextColumn.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : DataGridTextColumn
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.DataGridTextColumn.ForegroundProperty);
    }
}

namespace CSharpMarkup.Wpf // DatePicker
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DatePicker"/></summary>
        /// <remarks>Remark: DatePicker().Bind() binds to <see cref="Windows.Controls.DatePicker.SelectedDateProperty"/></remarks>
        public static DatePicker DatePicker(O<Windows.Style> CalendarStyle = default, O<DateTime> DisplayDate = default, O<DateTime?> DisplayDateEnd = default, O<DateTime?> DisplayDateStart = default, O<DayOfWeek> FirstDayOfWeek = default, O<bool> IsDropDownOpen = default, O<bool> IsTodayHighlighted = default, O<DateTime?> SelectedDate = default, O<Windows.Controls.DatePickerFormat> SelectedDateFormat = default, O<string> Text = default)
        {
            var ui = new Windows.Controls.DatePicker();
            if (CalendarStyle.HasValue) ui.CalendarStyle = CalendarStyle.Value;
            if (DisplayDate.HasValue) ui.DisplayDate = DisplayDate.Value;
            if (DisplayDateEnd.HasValue) ui.DisplayDateEnd = DisplayDateEnd.Value;
            if (DisplayDateStart.HasValue) ui.DisplayDateStart = DisplayDateStart.Value;
            if (FirstDayOfWeek.HasValue) ui.FirstDayOfWeek = FirstDayOfWeek.Value;
            if (IsDropDownOpen.HasValue) ui.IsDropDownOpen = IsDropDownOpen.Value;
            if (IsTodayHighlighted.HasValue) ui.IsTodayHighlighted = IsTodayHighlighted.Value;
            if (SelectedDate.HasValue) ui.SelectedDate = SelectedDate.Value;
            if (SelectedDateFormat.HasValue) ui.SelectedDateFormat = SelectedDateFormat.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            return global::CSharpMarkup.Wpf.DatePicker.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DatePicker"/></summary>
        /// <remarks>Remark: DatePicker().Bind() binds to <see cref="Windows.Controls.DatePicker.SelectedDateProperty"/></remarks>
        public static DatePicker DatePicker()
        {
            var ui = new Windows.Controls.DatePicker();
            return global::CSharpMarkup.Wpf.DatePicker.StartChain(ui);
        }
    }

    public partial class DatePicker : Control, IUI<System.Windows.Controls.DatePicker>, IDefaultBindProperty
    {
        static DatePicker instance;

        internal static DatePicker StartChain(Windows.Controls.DatePicker ui)
        {
            if (instance == null) instance = new DatePicker();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DatePicker ui;

        public new Windows.Controls.DatePicker UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.DatePicker.SelectedDateProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.DatePicker.SelectedDateProperty;

        public static implicit operator Windows.UIElement(DatePicker view) => view?.UI;

        public static implicit operator Windows.Controls.DatePicker(DatePicker view) => view?.UI;

        public static implicit operator DatePicker(Windows.Controls.DatePicker ui) => DatePicker.StartChain(ui);

        protected DatePicker() { }
    }

    public static partial class DatePickerExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DatePicker.CalendarStyle"/></summary>
        public static TView CalendarStyle<TView>(this TView view, Windows.Style value) where TView : DatePicker { view.UI.CalendarStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.DisplayDate"/></summary>
        public static TView DisplayDate<TView>(this TView view, DateTime value) where TView : DatePicker { view.UI.DisplayDate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.DisplayDateEnd"/></summary>
        public static TView DisplayDateEnd<TView>(this TView view, DateTime? value) where TView : DatePicker { view.UI.DisplayDateEnd = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.DisplayDateStart"/></summary>
        public static TView DisplayDateStart<TView>(this TView view, DateTime? value) where TView : DatePicker { view.UI.DisplayDateStart = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.FirstDayOfWeek"/></summary>
        public static TView FirstDayOfWeek<TView>(this TView view, DayOfWeek value) where TView : DatePicker { view.UI.FirstDayOfWeek = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.IsDropDownOpen"/></summary>
        public static TView IsDropDownOpen<TView>(this TView view, bool value) where TView : DatePicker { view.UI.IsDropDownOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.IsTodayHighlighted"/></summary>
        public static TView IsTodayHighlighted<TView>(this TView view, bool value) where TView : DatePicker { view.UI.IsTodayHighlighted = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.SelectedDate"/></summary>
        public static TView SelectedDate<TView>(this TView view, DateTime? value) where TView : DatePicker { view.UI.SelectedDate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.SelectedDateFormat"/></summary>
        public static TView SelectedDateFormat<TView>(this TView view, Windows.Controls.DatePickerFormat value) where TView : DatePicker { view.UI.SelectedDateFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DatePicker.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : DatePicker { view.UI.Text = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.CalendarStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CalendarStyle<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.DatePicker.CalendarStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.DisplayDateEnd"/></summary>
        public static DependencyProperty<TTarget, DateTime?> DisplayDateEnd<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.DatePicker.DisplayDateEndProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.DisplayDate"/></summary>
        public static DependencyProperty<TTarget, DateTime> DisplayDate<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, DateTime>.Get(target, Windows.Controls.DatePicker.DisplayDateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.DisplayDateStart"/></summary>
        public static DependencyProperty<TTarget, DateTime?> DisplayDateStart<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.DatePicker.DisplayDateStartProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.FirstDayOfWeek"/></summary>
        public static DependencyProperty<TTarget, DayOfWeek> FirstDayOfWeek<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, DayOfWeek>.Get(target, Windows.Controls.DatePicker.FirstDayOfWeekProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.IsDropDownOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownOpen<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DatePicker.IsDropDownOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.IsTodayHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsTodayHighlighted<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DatePicker.IsTodayHighlightedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.SelectedDateFormat"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DatePickerFormat> SelectedDateFormat<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, Windows.Controls.DatePickerFormat>.Get(target, Windows.Controls.DatePicker.SelectedDateFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.SelectedDate"/></summary>
        public static DependencyProperty<TTarget, DateTime?> SelectedDate<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, DateTime?>.Get(target, Windows.Controls.DatePicker.SelectedDateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DatePicker.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : DatePicker
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DatePicker.TextProperty);
    }
}

namespace CSharpMarkup.Wpf // Decorator
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Decorator"/></summary>
        public static Decorator Decorator(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.Decorator();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.Decorator.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Decorator"/></summary>
        public static Decorator Decorator()
        {
            var ui = new Windows.Controls.Decorator();
            return global::CSharpMarkup.Wpf.Decorator.StartChain(ui);
        }
    }

    public partial class Decorator : FrameworkElement, IUI<System.Windows.Controls.Decorator>
    {
        static Decorator instance;

        internal static Decorator StartChain(Windows.Controls.Decorator ui)
        {
            if (instance == null) instance = new Decorator();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Decorator ui;

        public new Windows.Controls.Decorator UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Decorator view) => view?.UI;

        public static implicit operator Windows.Controls.Decorator(Decorator view) => view?.UI;

        public static implicit operator Decorator(Windows.Controls.Decorator ui) => Decorator.StartChain(ui);

        protected Decorator() { }
    }
}

namespace CSharpMarkup.Wpf // DefinitionBase
{
    public partial class DefinitionBase : FrameworkContentElement, IUI<System.Windows.Controls.DefinitionBase>
    {
        Windows.Controls.DefinitionBase ui;

        public new Windows.Controls.DefinitionBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected DefinitionBase() { }
    }

    public static partial class DefinitionBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DefinitionBase.SharedSizeGroup"/></summary>
        public static TView SharedSizeGroup<TView>(this TView view, string value) where TView : DefinitionBase { view.UI.SharedSizeGroup = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DefinitionBase.SharedSizeGroup"/></summary>
        public static DependencyProperty<TTarget, string> SharedSizeGroup<TTarget>(this TTarget target) where TTarget : DefinitionBase
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.DefinitionBase.SharedSizeGroupProperty);
    }
}

namespace CSharpMarkup.Wpf // DockPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DockPanel"/></summary>
        public static DockPanel DockPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.DockPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.DockPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DockPanel"/></summary>
        public static DockPanel DockPanel(O<bool> LastChildFill = default)
        {
            var ui = new Windows.Controls.DockPanel();
            if (LastChildFill.HasValue) ui.LastChildFill = LastChildFill.Value;
            return global::CSharpMarkup.Wpf.DockPanel.StartChain(ui);
        }
    }

    public partial class DockPanel : Panel, IUI<System.Windows.Controls.DockPanel>
    {
        static DockPanel instance;

        internal static DockPanel StartChain(Windows.Controls.DockPanel ui)
        {
            if (instance == null) instance = new DockPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DockPanel ui;

        public new Windows.Controls.DockPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DockPanel view) => view?.UI;

        public static implicit operator Windows.Controls.DockPanel(DockPanel view) => view?.UI;

        public static implicit operator DockPanel(Windows.Controls.DockPanel ui) => DockPanel.StartChain(ui);

        protected DockPanel() { }
    }

    public static partial class DockPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DockPanel.LastChildFill"/></summary>
        public static TView LastChildFill<TView>(this TView view, bool value) where TView : DockPanel { view.UI.LastChildFill = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DockPanel.LastChildFill"/></summary>
        public static DependencyProperty<TTarget, bool> LastChildFill<TTarget>(this TTarget target) where TTarget : DockPanel
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DockPanel.LastChildFillProperty);

        /// <summary>Set <see cref="Windows.Controls.DockPanel.Dock"/></summary>
        public static TTarget DockPanel_Dock<TTarget>(this TTarget target, Windows.Controls.Dock value) where TTarget : UIElement
        { Windows.Controls.DockPanel.SetDock(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DockPanel.Dock"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Dock> DockPanel_Dock<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Windows.Controls.Dock>.Get(target, Windows.Controls.DockPanel.DockProperty);
    }
}

namespace CSharpMarkup.Wpf // DocumentViewer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.DocumentViewer"/></summary>
        public static DocumentViewer DocumentViewer(
            System.Windows.Documents.IDocumentPaginatorSource Document
)
        {
            var ui = new Windows.Controls.DocumentViewer();
            if (Document is not null) ui.Document = Document;
            return global::CSharpMarkup.Wpf.DocumentViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DocumentViewer"/></summary>
        public static DocumentViewer DocumentViewer(O<double> HorizontalOffset = default, O<double> HorizontalPageSpacing = default, O<int> MaxPagesAcross = default, O<bool> ShowPageBorders = default, O<double> VerticalOffset = default, O<double> VerticalPageSpacing = default, O<double> Zoom = default)
        {
            var ui = new Windows.Controls.DocumentViewer();
            if (HorizontalOffset.HasValue) ui.HorizontalOffset = HorizontalOffset.Value;
            if (HorizontalPageSpacing.HasValue) ui.HorizontalPageSpacing = HorizontalPageSpacing.Value;
            if (MaxPagesAcross.HasValue) ui.MaxPagesAcross = MaxPagesAcross.Value;
            if (ShowPageBorders.HasValue) ui.ShowPageBorders = ShowPageBorders.Value;
            if (VerticalOffset.HasValue) ui.VerticalOffset = VerticalOffset.Value;
            if (VerticalPageSpacing.HasValue) ui.VerticalPageSpacing = VerticalPageSpacing.Value;
            if (Zoom.HasValue) ui.Zoom = Zoom.Value;
            return global::CSharpMarkup.Wpf.DocumentViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.DocumentViewer"/></summary>
        public static DocumentViewer DocumentViewer()
        {
            var ui = new Windows.Controls.DocumentViewer();
            return global::CSharpMarkup.Wpf.DocumentViewer.StartChain(ui);
        }
    }

    public partial class DocumentViewer : DocumentViewerBase, IUI<System.Windows.Controls.DocumentViewer>
    {
        static DocumentViewer instance;

        internal static DocumentViewer StartChain(Windows.Controls.DocumentViewer ui)
        {
            if (instance == null) instance = new DocumentViewer();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.DocumentViewer ui;

        public new Windows.Controls.DocumentViewer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DocumentViewer view) => view?.UI;

        public static implicit operator Windows.Controls.DocumentViewer(DocumentViewer view) => view?.UI;

        public static implicit operator DocumentViewer(Windows.Controls.DocumentViewer ui) => DocumentViewer.StartChain(ui);

        protected DocumentViewer() { }
    }

    public static partial class DocumentViewerExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.HorizontalOffset"/></summary>
        public static TView HorizontalOffset<TView>(this TView view, double value) where TView : DocumentViewer { view.UI.HorizontalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.HorizontalPageSpacing"/></summary>
        public static TView HorizontalPageSpacing<TView>(this TView view, double value) where TView : DocumentViewer { view.UI.HorizontalPageSpacing = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.MaxPagesAcross"/></summary>
        public static TView MaxPagesAcross<TView>(this TView view, int value) where TView : DocumentViewer { view.UI.MaxPagesAcross = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.ShowPageBorders"/></summary>
        public static TView ShowPageBorders<TView>(this TView view, bool value) where TView : DocumentViewer { view.UI.ShowPageBorders = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.VerticalOffset"/></summary>
        public static TView VerticalOffset<TView>(this TView view, double value) where TView : DocumentViewer { view.UI.VerticalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.VerticalPageSpacing"/></summary>
        public static TView VerticalPageSpacing<TView>(this TView view, double value) where TView : DocumentViewer { view.UI.VerticalPageSpacing = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.DocumentViewer.Zoom"/></summary>
        public static TView Zoom<TView>(this TView view, double value) where TView : DocumentViewer { view.UI.Zoom = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanDecreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanDecreaseZoom<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanDecreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanIncreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanIncreaseZoom<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanIncreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanMoveDown"/></summary>
        public static DependencyProperty<TTarget, bool> CanMoveDown<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanMoveDownProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanMoveLeft"/></summary>
        public static DependencyProperty<TTarget, bool> CanMoveLeft<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanMoveLeftProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanMoveRight"/></summary>
        public static DependencyProperty<TTarget, bool> CanMoveRight<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanMoveRightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.CanMoveUp"/></summary>
        public static DependencyProperty<TTarget, bool> CanMoveUp<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.CanMoveUpProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.ExtentHeight"/></summary>
        public static DependencyProperty<TTarget, double> ExtentHeight<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.ExtentHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.ExtentWidth"/></summary>
        public static DependencyProperty<TTarget, double> ExtentWidth<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.ExtentWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.HorizontalPageSpacing"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalPageSpacing<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.HorizontalPageSpacingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.MaxPagesAcross"/></summary>
        public static DependencyProperty<TTarget, int> MaxPagesAcross<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.DocumentViewer.MaxPagesAcrossProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.ShowPageBorders"/></summary>
        public static DependencyProperty<TTarget, bool> ShowPageBorders<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.DocumentViewer.ShowPageBordersProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.VerticalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.VerticalPageSpacing"/></summary>
        public static DependencyProperty<TTarget, double> VerticalPageSpacing<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.VerticalPageSpacingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.ViewportHeight"/></summary>
        public static DependencyProperty<TTarget, double> ViewportHeight<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.ViewportHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.ViewportWidth"/></summary>
        public static DependencyProperty<TTarget, double> ViewportWidth<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.ViewportWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.DocumentViewer.Zoom"/></summary>
        public static DependencyProperty<TTarget, double> Zoom<TTarget>(this TTarget target) where TTarget : DocumentViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.DocumentViewer.ZoomProperty);
    }
}

namespace CSharpMarkup.Wpf // Expander
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Expander"/></summary>
        /// <remarks>Remark: Expander().Bind() binds to <see cref="Windows.Controls.Expander.IsExpandedProperty"/></remarks>
        public static Expander Expander(
            object Content
)
        {
            var ui = new Windows.Controls.Expander();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.Expander.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Expander"/></summary>
        /// <remarks>Remark: Expander().Bind() binds to <see cref="Windows.Controls.Expander.IsExpandedProperty"/></remarks>
        public static Expander Expander(O<Windows.Controls.ExpandDirection> ExpandDirection = default, O<bool> IsExpanded = default)
        {
            var ui = new Windows.Controls.Expander();
            if (ExpandDirection.HasValue) ui.ExpandDirection = ExpandDirection.Value;
            if (IsExpanded.HasValue) ui.IsExpanded = IsExpanded.Value;
            return global::CSharpMarkup.Wpf.Expander.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Expander"/></summary>
        /// <remarks>Remark: Expander().Bind() binds to <see cref="Windows.Controls.Expander.IsExpandedProperty"/></remarks>
        public static Expander Expander()
        {
            var ui = new Windows.Controls.Expander();
            return global::CSharpMarkup.Wpf.Expander.StartChain(ui);
        }
    }

    public partial class Expander : HeaderedContentControl, IUI<System.Windows.Controls.Expander>, IDefaultBindProperty
    {
        static Expander instance;

        internal static Expander StartChain(Windows.Controls.Expander ui)
        {
            if (instance == null) instance = new Expander();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Expander ui;

        public new Windows.Controls.Expander UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Expander.IsExpandedProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Expander.IsExpandedProperty;

        public static implicit operator Windows.UIElement(Expander view) => view?.UI;

        public static implicit operator Windows.Controls.Expander(Expander view) => view?.UI;

        public static implicit operator Expander(Windows.Controls.Expander ui) => Expander.StartChain(ui);

        protected Expander() { }
    }

    public static partial class ExpanderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Expander.ExpandDirection"/></summary>
        public static TView ExpandDirection<TView>(this TView view, Windows.Controls.ExpandDirection value) where TView : Expander { view.UI.ExpandDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Expander.IsExpanded"/></summary>
        public static TView IsExpanded<TView>(this TView view, bool value) where TView : Expander { view.UI.IsExpanded = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Expander.ExpandDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ExpandDirection> ExpandDirection<TTarget>(this TTarget target) where TTarget : Expander
        => DependencyProperty<TTarget, Windows.Controls.ExpandDirection>.Get(target, Windows.Controls.Expander.ExpandDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Expander.IsExpanded"/></summary>
        public static DependencyProperty<TTarget, bool> IsExpanded<TTarget>(this TTarget target) where TTarget : Expander
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Expander.IsExpandedProperty);
    }
}

namespace CSharpMarkup.Wpf // FlowDocumentPageViewer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentPageViewer"/></summary>
        public static FlowDocumentPageViewer FlowDocumentPageViewer(
            System.Windows.Documents.IDocumentPaginatorSource Document
)
        {
            var ui = new Windows.Controls.FlowDocumentPageViewer();
            if (Document is not null) ui.Document = Document;
            return global::CSharpMarkup.Wpf.FlowDocumentPageViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentPageViewer"/></summary>
        public static FlowDocumentPageViewer FlowDocumentPageViewer(O<bool> IsInactiveSelectionHighlightEnabled = default, O<double> MaxZoom = default, O<double> MinZoom = default, O<Windows.Media.Brush> SelectionBrush = default, O<double> SelectionOpacity = default, O<double> Zoom = default, O<double> ZoomIncrement = default)
        {
            var ui = new Windows.Controls.FlowDocumentPageViewer();
            if (IsInactiveSelectionHighlightEnabled.HasValue) ui.IsInactiveSelectionHighlightEnabled = IsInactiveSelectionHighlightEnabled.Value;
            if (MaxZoom.HasValue) ui.MaxZoom = MaxZoom.Value;
            if (MinZoom.HasValue) ui.MinZoom = MinZoom.Value;
            if (SelectionBrush.HasValue) ui.SelectionBrush = SelectionBrush.Value;
            if (SelectionOpacity.HasValue) ui.SelectionOpacity = SelectionOpacity.Value;
            if (Zoom.HasValue) ui.Zoom = Zoom.Value;
            if (ZoomIncrement.HasValue) ui.ZoomIncrement = ZoomIncrement.Value;
            return global::CSharpMarkup.Wpf.FlowDocumentPageViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentPageViewer"/></summary>
        public static FlowDocumentPageViewer FlowDocumentPageViewer()
        {
            var ui = new Windows.Controls.FlowDocumentPageViewer();
            return global::CSharpMarkup.Wpf.FlowDocumentPageViewer.StartChain(ui);
        }
    }

    public partial class FlowDocumentPageViewer : DocumentViewerBase, IUI<System.Windows.Controls.FlowDocumentPageViewer>
    {
        static FlowDocumentPageViewer instance;

        internal static FlowDocumentPageViewer StartChain(Windows.Controls.FlowDocumentPageViewer ui)
        {
            if (instance == null) instance = new FlowDocumentPageViewer();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.FlowDocumentPageViewer ui;

        public new Windows.Controls.FlowDocumentPageViewer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(FlowDocumentPageViewer view) => view?.UI;

        public static implicit operator Windows.Controls.FlowDocumentPageViewer(FlowDocumentPageViewer view) => view?.UI;

        public static implicit operator FlowDocumentPageViewer(Windows.Controls.FlowDocumentPageViewer ui) => FlowDocumentPageViewer.StartChain(ui);

        protected FlowDocumentPageViewer() { }
    }

    public static partial class FlowDocumentPageViewerExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.IsInactiveSelectionHighlightEnabled"/></summary>
        public static TView IsInactiveSelectionHighlightEnabled<TView>(this TView view, bool value) where TView : FlowDocumentPageViewer { view.UI.IsInactiveSelectionHighlightEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.MaxZoom"/></summary>
        public static TView MaxZoom<TView>(this TView view, double value) where TView : FlowDocumentPageViewer { view.UI.MaxZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.MinZoom"/></summary>
        public static TView MinZoom<TView>(this TView view, double value) where TView : FlowDocumentPageViewer { view.UI.MinZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocumentPageViewer { view.UI.SelectionBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Color value) where TView : FlowDocumentPageViewer { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, string color) where TView : FlowDocumentPageViewer { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionOpacity"/></summary>
        public static TView SelectionOpacity<TView>(this TView view, double value) where TView : FlowDocumentPageViewer { view.UI.SelectionOpacity = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.Zoom"/></summary>
        public static TView Zoom<TView>(this TView view, double value) where TView : FlowDocumentPageViewer { view.UI.Zoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentPageViewer.ZoomIncrement"/></summary>
        public static TView ZoomIncrement<TView>(this TView view, double value) where TView : FlowDocumentPageViewer { view.UI.ZoomIncrement = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.CanDecreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanDecreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentPageViewer.CanDecreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.CanIncreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanIncreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentPageViewer.CanIncreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.IsInactiveSelectionHighlightEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactiveSelectionHighlightEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentPageViewer.IsInactiveSelectionHighlightEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentPageViewer.IsSelectionActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.MaxZoom"/></summary>
        public static DependencyProperty<TTarget, double> MaxZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentPageViewer.MaxZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.MinZoom"/></summary>
        public static DependencyProperty<TTarget, double> MinZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentPageViewer.MinZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionBrush<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.FlowDocumentPageViewer.SelectionBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.SelectionOpacity"/></summary>
        public static DependencyProperty<TTarget, double> SelectionOpacity<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentPageViewer.SelectionOpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.ZoomIncrement"/></summary>
        public static DependencyProperty<TTarget, double> ZoomIncrement<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentPageViewer.ZoomIncrementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentPageViewer.Zoom"/></summary>
        public static DependencyProperty<TTarget, double> Zoom<TTarget>(this TTarget target) where TTarget : FlowDocumentPageViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentPageViewer.ZoomProperty);
    }
}

namespace CSharpMarkup.Wpf // FlowDocumentReader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentReader"/></summary>
        /// <remarks>Remark: FlowDocumentReader().Bind() binds to <see cref="Windows.Controls.FlowDocumentReader.DocumentProperty"/></remarks>
        public static FlowDocumentReader FlowDocumentReader(
            System.Windows.Documents.FlowDocument Document
)
        {
            var ui = new Windows.Controls.FlowDocumentReader();
            if (Document is not null) ui.Document = Document;
            return global::CSharpMarkup.Wpf.FlowDocumentReader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentReader"/></summary>
        /// <remarks>Remark: FlowDocumentReader().Bind() binds to <see cref="Windows.Controls.FlowDocumentReader.DocumentProperty"/></remarks>
        public static FlowDocumentReader FlowDocumentReader(O<Windows.Documents.FlowDocument> Document = default, O<bool> IsFindEnabled = default, O<bool> IsInactiveSelectionHighlightEnabled = default, O<bool> IsPageViewEnabled = default, O<bool> IsPrintEnabled = default, O<bool> IsScrollViewEnabled = default, O<bool> IsTwoPageViewEnabled = default, O<double> MaxZoom = default, O<double> MinZoom = default, O<Windows.Media.Brush> SelectionBrush = default, O<double> SelectionOpacity = default, O<Windows.Controls.FlowDocumentReaderViewingMode> ViewingMode = default, O<double> Zoom = default, O<double> ZoomIncrement = default)
        {
            var ui = new Windows.Controls.FlowDocumentReader();
            if (Document.HasValue) ui.Document = Document.Value;
            if (IsFindEnabled.HasValue) ui.IsFindEnabled = IsFindEnabled.Value;
            if (IsInactiveSelectionHighlightEnabled.HasValue) ui.IsInactiveSelectionHighlightEnabled = IsInactiveSelectionHighlightEnabled.Value;
            if (IsPageViewEnabled.HasValue) ui.IsPageViewEnabled = IsPageViewEnabled.Value;
            if (IsPrintEnabled.HasValue) ui.IsPrintEnabled = IsPrintEnabled.Value;
            if (IsScrollViewEnabled.HasValue) ui.IsScrollViewEnabled = IsScrollViewEnabled.Value;
            if (IsTwoPageViewEnabled.HasValue) ui.IsTwoPageViewEnabled = IsTwoPageViewEnabled.Value;
            if (MaxZoom.HasValue) ui.MaxZoom = MaxZoom.Value;
            if (MinZoom.HasValue) ui.MinZoom = MinZoom.Value;
            if (SelectionBrush.HasValue) ui.SelectionBrush = SelectionBrush.Value;
            if (SelectionOpacity.HasValue) ui.SelectionOpacity = SelectionOpacity.Value;
            if (ViewingMode.HasValue) ui.ViewingMode = ViewingMode.Value;
            if (Zoom.HasValue) ui.Zoom = Zoom.Value;
            if (ZoomIncrement.HasValue) ui.ZoomIncrement = ZoomIncrement.Value;
            return global::CSharpMarkup.Wpf.FlowDocumentReader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentReader"/></summary>
        /// <remarks>Remark: FlowDocumentReader().Bind() binds to <see cref="Windows.Controls.FlowDocumentReader.DocumentProperty"/></remarks>
        public static FlowDocumentReader FlowDocumentReader()
        {
            var ui = new Windows.Controls.FlowDocumentReader();
            return global::CSharpMarkup.Wpf.FlowDocumentReader.StartChain(ui);
        }
    }

    public partial class FlowDocumentReader : Control, IUI<System.Windows.Controls.FlowDocumentReader>, IDefaultBindProperty
    {
        static FlowDocumentReader instance;

        internal static FlowDocumentReader StartChain(Windows.Controls.FlowDocumentReader ui)
        {
            if (instance == null) instance = new FlowDocumentReader();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.FlowDocumentReader ui;

        public new Windows.Controls.FlowDocumentReader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.FlowDocumentReader.DocumentProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.FlowDocumentReader.DocumentProperty;

        public static implicit operator Windows.UIElement(FlowDocumentReader view) => view?.UI;

        public static implicit operator Windows.Controls.FlowDocumentReader(FlowDocumentReader view) => view?.UI;

        public static implicit operator FlowDocumentReader(Windows.Controls.FlowDocumentReader ui) => FlowDocumentReader.StartChain(ui);

        protected FlowDocumentReader() { }
    }

    public static partial class FlowDocumentReaderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.Document"/></summary>
        public static TView Document<TView>(this TView view, Windows.Documents.FlowDocument value) where TView : FlowDocumentReader { view.UI.Document = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsFindEnabled"/></summary>
        public static TView IsFindEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsFindEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsInactiveSelectionHighlightEnabled"/></summary>
        public static TView IsInactiveSelectionHighlightEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsInactiveSelectionHighlightEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsPageViewEnabled"/></summary>
        public static TView IsPageViewEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsPageViewEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsPrintEnabled"/></summary>
        public static TView IsPrintEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsPrintEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsScrollViewEnabled"/></summary>
        public static TView IsScrollViewEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsScrollViewEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.IsTwoPageViewEnabled"/></summary>
        public static TView IsTwoPageViewEnabled<TView>(this TView view, bool value) where TView : FlowDocumentReader { view.UI.IsTwoPageViewEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.MaxZoom"/></summary>
        public static TView MaxZoom<TView>(this TView view, double value) where TView : FlowDocumentReader { view.UI.MaxZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.MinZoom"/></summary>
        public static TView MinZoom<TView>(this TView view, double value) where TView : FlowDocumentReader { view.UI.MinZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocumentReader { view.UI.SelectionBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Color value) where TView : FlowDocumentReader { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, string color) where TView : FlowDocumentReader { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.SelectionOpacity"/></summary>
        public static TView SelectionOpacity<TView>(this TView view, double value) where TView : FlowDocumentReader { view.UI.SelectionOpacity = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.ViewingMode"/></summary>
        public static TView ViewingMode<TView>(this TView view, Windows.Controls.FlowDocumentReaderViewingMode value) where TView : FlowDocumentReader { view.UI.ViewingMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.Zoom"/></summary>
        public static TView Zoom<TView>(this TView view, double value) where TView : FlowDocumentReader { view.UI.Zoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentReader.ZoomIncrement"/></summary>
        public static TView ZoomIncrement<TView>(this TView view, double value) where TView : FlowDocumentReader { view.UI.ZoomIncrement = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.CanDecreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanDecreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.CanDecreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.CanGoToNextPage"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoToNextPage<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.CanGoToNextPageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.CanGoToPreviousPage"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoToPreviousPage<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.CanGoToPreviousPageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.CanIncreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanIncreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.CanIncreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.Document"/></summary>
        public static DependencyProperty<TTarget, Windows.Documents.FlowDocument> Document<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, Windows.Documents.FlowDocument>.Get(target, Windows.Controls.FlowDocumentReader.DocumentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsFindEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsFindEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsFindEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsInactiveSelectionHighlightEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactiveSelectionHighlightEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsInactiveSelectionHighlightEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsPageViewEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsPageViewEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsPageViewEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsPrintEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsPrintEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsPrintEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsScrollViewEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsScrollViewEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsScrollViewEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsSelectionActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.IsTwoPageViewEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsTwoPageViewEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentReader.IsTwoPageViewEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.MaxZoom"/></summary>
        public static DependencyProperty<TTarget, double> MaxZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentReader.MaxZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.MinZoom"/></summary>
        public static DependencyProperty<TTarget, double> MinZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentReader.MinZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.PageCount"/></summary>
        public static DependencyProperty<TTarget, int> PageCount<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.FlowDocumentReader.PageCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.PageNumber"/></summary>
        public static DependencyProperty<TTarget, int> PageNumber<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.FlowDocumentReader.PageNumberProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.SelectionBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionBrush<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.FlowDocumentReader.SelectionBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.SelectionOpacity"/></summary>
        public static DependencyProperty<TTarget, double> SelectionOpacity<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentReader.SelectionOpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.ViewingMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.FlowDocumentReaderViewingMode> ViewingMode<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, Windows.Controls.FlowDocumentReaderViewingMode>.Get(target, Windows.Controls.FlowDocumentReader.ViewingModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.ZoomIncrement"/></summary>
        public static DependencyProperty<TTarget, double> ZoomIncrement<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentReader.ZoomIncrementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentReader.Zoom"/></summary>
        public static DependencyProperty<TTarget, double> Zoom<TTarget>(this TTarget target) where TTarget : FlowDocumentReader
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentReader.ZoomProperty);
    }
}

namespace CSharpMarkup.Wpf // FlowDocumentScrollViewer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentScrollViewer"/></summary>
        /// <remarks>Remark: FlowDocumentScrollViewer().Bind() binds to <see cref="Windows.Controls.FlowDocumentScrollViewer.DocumentProperty"/></remarks>
        public static FlowDocumentScrollViewer FlowDocumentScrollViewer(
            System.Windows.Documents.FlowDocument Document
)
        {
            var ui = new Windows.Controls.FlowDocumentScrollViewer();
            if (Document is not null) ui.Document = Document;
            return global::CSharpMarkup.Wpf.FlowDocumentScrollViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentScrollViewer"/></summary>
        /// <remarks>Remark: FlowDocumentScrollViewer().Bind() binds to <see cref="Windows.Controls.FlowDocumentScrollViewer.DocumentProperty"/></remarks>
        public static FlowDocumentScrollViewer FlowDocumentScrollViewer(O<Windows.Documents.FlowDocument> Document = default, O<Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility = default, O<bool> IsInactiveSelectionHighlightEnabled = default, O<bool> IsSelectionEnabled = default, O<bool> IsToolBarVisible = default, O<double> MaxZoom = default, O<double> MinZoom = default, O<Windows.Media.Brush> SelectionBrush = default, O<double> SelectionOpacity = default, O<Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility = default, O<double> Zoom = default, O<double> ZoomIncrement = default)
        {
            var ui = new Windows.Controls.FlowDocumentScrollViewer();
            if (Document.HasValue) ui.Document = Document.Value;
            if (HorizontalScrollBarVisibility.HasValue) ui.HorizontalScrollBarVisibility = HorizontalScrollBarVisibility.Value;
            if (IsInactiveSelectionHighlightEnabled.HasValue) ui.IsInactiveSelectionHighlightEnabled = IsInactiveSelectionHighlightEnabled.Value;
            if (IsSelectionEnabled.HasValue) ui.IsSelectionEnabled = IsSelectionEnabled.Value;
            if (IsToolBarVisible.HasValue) ui.IsToolBarVisible = IsToolBarVisible.Value;
            if (MaxZoom.HasValue) ui.MaxZoom = MaxZoom.Value;
            if (MinZoom.HasValue) ui.MinZoom = MinZoom.Value;
            if (SelectionBrush.HasValue) ui.SelectionBrush = SelectionBrush.Value;
            if (SelectionOpacity.HasValue) ui.SelectionOpacity = SelectionOpacity.Value;
            if (VerticalScrollBarVisibility.HasValue) ui.VerticalScrollBarVisibility = VerticalScrollBarVisibility.Value;
            if (Zoom.HasValue) ui.Zoom = Zoom.Value;
            if (ZoomIncrement.HasValue) ui.ZoomIncrement = ZoomIncrement.Value;
            return global::CSharpMarkup.Wpf.FlowDocumentScrollViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.FlowDocumentScrollViewer"/></summary>
        /// <remarks>Remark: FlowDocumentScrollViewer().Bind() binds to <see cref="Windows.Controls.FlowDocumentScrollViewer.DocumentProperty"/></remarks>
        public static FlowDocumentScrollViewer FlowDocumentScrollViewer()
        {
            var ui = new Windows.Controls.FlowDocumentScrollViewer();
            return global::CSharpMarkup.Wpf.FlowDocumentScrollViewer.StartChain(ui);
        }
    }

    public partial class FlowDocumentScrollViewer : Control, IUI<System.Windows.Controls.FlowDocumentScrollViewer>, IDefaultBindProperty
    {
        static FlowDocumentScrollViewer instance;

        internal static FlowDocumentScrollViewer StartChain(Windows.Controls.FlowDocumentScrollViewer ui)
        {
            if (instance == null) instance = new FlowDocumentScrollViewer();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.FlowDocumentScrollViewer ui;

        public new Windows.Controls.FlowDocumentScrollViewer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.FlowDocumentScrollViewer.DocumentProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.FlowDocumentScrollViewer.DocumentProperty;

        public static implicit operator Windows.UIElement(FlowDocumentScrollViewer view) => view?.UI;

        public static implicit operator Windows.Controls.FlowDocumentScrollViewer(FlowDocumentScrollViewer view) => view?.UI;

        public static implicit operator FlowDocumentScrollViewer(Windows.Controls.FlowDocumentScrollViewer ui) => FlowDocumentScrollViewer.StartChain(ui);

        protected FlowDocumentScrollViewer() { }
    }

    public static partial class FlowDocumentScrollViewerExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.Document"/></summary>
        public static TView Document<TView>(this TView view, Windows.Documents.FlowDocument value) where TView : FlowDocumentScrollViewer { view.UI.Document = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static TView HorizontalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : FlowDocumentScrollViewer { view.UI.HorizontalScrollBarVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.IsInactiveSelectionHighlightEnabled"/></summary>
        public static TView IsInactiveSelectionHighlightEnabled<TView>(this TView view, bool value) where TView : FlowDocumentScrollViewer { view.UI.IsInactiveSelectionHighlightEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.IsSelectionEnabled"/></summary>
        public static TView IsSelectionEnabled<TView>(this TView view, bool value) where TView : FlowDocumentScrollViewer { view.UI.IsSelectionEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.IsToolBarVisible"/></summary>
        public static TView IsToolBarVisible<TView>(this TView view, bool value) where TView : FlowDocumentScrollViewer { view.UI.IsToolBarVisible = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.MaxZoom"/></summary>
        public static TView MaxZoom<TView>(this TView view, double value) where TView : FlowDocumentScrollViewer { view.UI.MaxZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.MinZoom"/></summary>
        public static TView MinZoom<TView>(this TView view, double value) where TView : FlowDocumentScrollViewer { view.UI.MinZoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocumentScrollViewer { view.UI.SelectionBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Color value) where TView : FlowDocumentScrollViewer { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, string color) where TView : FlowDocumentScrollViewer { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionOpacity"/></summary>
        public static TView SelectionOpacity<TView>(this TView view, double value) where TView : FlowDocumentScrollViewer { view.UI.SelectionOpacity = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static TView VerticalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : FlowDocumentScrollViewer { view.UI.VerticalScrollBarVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.Zoom"/></summary>
        public static TView Zoom<TView>(this TView view, double value) where TView : FlowDocumentScrollViewer { view.UI.Zoom = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.FlowDocumentScrollViewer.ZoomIncrement"/></summary>
        public static TView ZoomIncrement<TView>(this TView view, double value) where TView : FlowDocumentScrollViewer { view.UI.ZoomIncrement = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.CanDecreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanDecreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.CanDecreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.CanIncreaseZoom"/></summary>
        public static DependencyProperty<TTarget, bool> CanIncreaseZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.CanIncreaseZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.Document"/></summary>
        public static DependencyProperty<TTarget, Windows.Documents.FlowDocument> Document<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, Windows.Documents.FlowDocument>.Get(target, Windows.Controls.FlowDocumentScrollViewer.DocumentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.FlowDocumentScrollViewer.HorizontalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.IsInactiveSelectionHighlightEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactiveSelectionHighlightEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.IsInactiveSelectionHighlightEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.IsSelectionActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.IsSelectionEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionEnabled<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.IsSelectionEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.IsToolBarVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsToolBarVisible<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.FlowDocumentScrollViewer.IsToolBarVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.MaxZoom"/></summary>
        public static DependencyProperty<TTarget, double> MaxZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentScrollViewer.MaxZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.MinZoom"/></summary>
        public static DependencyProperty<TTarget, double> MinZoom<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentScrollViewer.MinZoomProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionBrush<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.FlowDocumentScrollViewer.SelectionBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.SelectionOpacity"/></summary>
        public static DependencyProperty<TTarget, double> SelectionOpacity<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentScrollViewer.SelectionOpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.FlowDocumentScrollViewer.VerticalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.ZoomIncrement"/></summary>
        public static DependencyProperty<TTarget, double> ZoomIncrement<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentScrollViewer.ZoomIncrementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.FlowDocumentScrollViewer.Zoom"/></summary>
        public static DependencyProperty<TTarget, double> Zoom<TTarget>(this TTarget target) where TTarget : FlowDocumentScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.FlowDocumentScrollViewer.ZoomProperty);
    }
}

namespace CSharpMarkup.Wpf // Frame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Frame"/></summary>
        public static Frame Frame(O<Windows.Navigation.JournalOwnership> JournalOwnership = default, O<Windows.Navigation.NavigationUIVisibility> NavigationUIVisibility = default, O<bool> SandboxExternalContent = default, O<Uri> Source = default)
        {
            var ui = new Windows.Controls.Frame();
            if (JournalOwnership.HasValue) ui.JournalOwnership = JournalOwnership.Value;
            if (NavigationUIVisibility.HasValue) ui.NavigationUIVisibility = NavigationUIVisibility.Value;
            if (SandboxExternalContent.HasValue) ui.SandboxExternalContent = SandboxExternalContent.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.Frame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Frame"/></summary>
        public static Frame Frame()
        {
            var ui = new Windows.Controls.Frame();
            return global::CSharpMarkup.Wpf.Frame.StartChain(ui);
        }
    }

    public partial class Frame : ContentControl, IUI<System.Windows.Controls.Frame>
    {
        static Frame instance;

        internal static Frame StartChain(Windows.Controls.Frame ui)
        {
            if (instance == null) instance = new Frame();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Frame ui;

        public new Windows.Controls.Frame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Frame view) => view?.UI;

        public static implicit operator Windows.Controls.Frame(Frame view) => view?.UI;

        public static implicit operator Frame(Windows.Controls.Frame ui) => Frame.StartChain(ui);

        protected Frame() { }
    }

    public static partial class FrameExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Frame.JournalOwnership"/></summary>
        public static TView JournalOwnership<TView>(this TView view, Windows.Navigation.JournalOwnership value) where TView : Frame { view.UI.JournalOwnership = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Frame.NavigationUIVisibility"/></summary>
        public static TView NavigationUIVisibility<TView>(this TView view, Windows.Navigation.NavigationUIVisibility value) where TView : Frame { view.UI.NavigationUIVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Frame.SandboxExternalContent"/></summary>
        public static TView SandboxExternalContent<TView>(this TView view, bool value) where TView : Frame { view.UI.SandboxExternalContent = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Frame.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : Frame { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.BackStack"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> BackStack<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Controls.Frame.BackStackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.CanGoBack"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoBack<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Frame.CanGoBackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.CanGoForward"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoForward<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Frame.CanGoForwardProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.ForwardStack"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> ForwardStack<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Controls.Frame.ForwardStackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.JournalOwnership"/></summary>
        public static DependencyProperty<TTarget, Windows.Navigation.JournalOwnership> JournalOwnership<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, Windows.Navigation.JournalOwnership>.Get(target, Windows.Controls.Frame.JournalOwnershipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.NavigationUIVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Navigation.NavigationUIVisibility> NavigationUIVisibility<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, Windows.Navigation.NavigationUIVisibility>.Get(target, Windows.Controls.Frame.NavigationUIVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.SandboxExternalContent"/></summary>
        public static DependencyProperty<TTarget, bool> SandboxExternalContent<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Frame.SandboxExternalContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Frame.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : Frame
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Controls.Frame.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // Grid
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Grid"/></summary>
        public static Grid Grid(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Grid();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Grid.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Grid"/></summary>
        public static Grid Grid(O<bool> ShowGridLines = default)
        {
            var ui = new Windows.Controls.Grid();
            if (ShowGridLines.HasValue) ui.ShowGridLines = ShowGridLines.Value;
            return global::CSharpMarkup.Wpf.Grid.StartChain(ui);
        }
    }

    public partial class Grid : Panel, IUI<System.Windows.Controls.Grid>
    {
        static Grid instance;

        internal static Grid StartChain(Windows.Controls.Grid ui)
        {
            if (instance == null) instance = new Grid();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Grid ui;

        public new Windows.Controls.Grid UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Grid view) => view?.UI;

        public static implicit operator Windows.Controls.Grid(Grid view) => view?.UI;

        public static implicit operator Grid(Windows.Controls.Grid ui) => Grid.StartChain(ui);

        protected Grid() { }
    }

    public static partial class GridExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Grid.ShowGridLines"/></summary>
        public static TView ShowGridLines<TView>(this TView view, bool value) where TView : Grid { view.UI.ShowGridLines = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.ShowGridLines"/></summary>
        public static DependencyProperty<TTarget, bool> ShowGridLines<TTarget>(this TTarget target) where TTarget : Grid
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Grid.ShowGridLinesProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid.Column"/></summary>
        public static TTarget Grid_Column<TTarget>(this TTarget target, int value) where TTarget : UIElement
        { Windows.Controls.Grid.SetColumn(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.Column"/></summary>
        public static DependencyProperty<TTarget, int> Grid_Column<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Grid.ColumnProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid.ColumnSpan"/></summary>
        public static TTarget Grid_ColumnSpan<TTarget>(this TTarget target, int value) where TTarget : UIElement
        { Windows.Controls.Grid.SetColumnSpan(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.ColumnSpan"/></summary>
        public static DependencyProperty<TTarget, int> Grid_ColumnSpan<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Grid.ColumnSpanProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid.IsSharedSizeScope"/></summary>
        public static TTarget Grid_IsSharedSizeScope<TTarget>(this TTarget target, bool value) where TTarget : UIElement
        { Windows.Controls.Grid.SetIsSharedSizeScope(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.IsSharedSizeScope"/></summary>
        public static DependencyProperty<TTarget, bool> Grid_IsSharedSizeScope<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Grid.IsSharedSizeScopeProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid.Row"/></summary>
        public static TTarget Grid_Row<TTarget>(this TTarget target, int value) where TTarget : UIElement
        { Windows.Controls.Grid.SetRow(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.Row"/></summary>
        public static DependencyProperty<TTarget, int> Grid_Row<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Grid.RowProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid.RowSpan"/></summary>
        public static TTarget Grid_RowSpan<TTarget>(this TTarget target, int value) where TTarget : UIElement
        { Windows.Controls.Grid.SetRowSpan(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Grid.RowSpan"/></summary>
        public static DependencyProperty<TTarget, int> Grid_RowSpan<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Grid.RowSpanProperty);

        /// <summary>Set <see cref="Windows.Controls.Grid"/> attached properties</summary>
        public static TTarget Grid<TTarget>(this TTarget target

            , O<int> Column = default

            , O<int> ColumnSpan = default

            , O<bool> IsSharedSizeScope = default

            , O<int> Row = default

            , O<int> RowSpan = default

        ) where TTarget : UIElement
        {
            if (Column.HasValue) Windows.Controls.Grid.SetColumn(target.UI, Column.Value);

            if (ColumnSpan.HasValue) Windows.Controls.Grid.SetColumnSpan(target.UI, ColumnSpan.Value);

            if (IsSharedSizeScope.HasValue) Windows.Controls.Grid.SetIsSharedSizeScope(target.UI, IsSharedSizeScope.Value);

            if (Row.HasValue) Windows.Controls.Grid.SetRow(target.UI, Row.Value);

            if (RowSpan.HasValue) Windows.Controls.Grid.SetRowSpan(target.UI, RowSpan.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // GridSplitter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridSplitter"/></summary>
        public static GridSplitter GridSplitter(O<double> DragIncrement = default, O<double> KeyboardIncrement = default, O<Windows.Style> PreviewStyle = default, O<Windows.Controls.GridResizeBehavior> ResizeBehavior = default, O<Windows.Controls.GridResizeDirection> ResizeDirection = default, O<bool> ShowsPreview = default)
        {
            var ui = new Windows.Controls.GridSplitter();
            if (DragIncrement.HasValue) ui.DragIncrement = DragIncrement.Value;
            if (KeyboardIncrement.HasValue) ui.KeyboardIncrement = KeyboardIncrement.Value;
            if (PreviewStyle.HasValue) ui.PreviewStyle = PreviewStyle.Value;
            if (ResizeBehavior.HasValue) ui.ResizeBehavior = ResizeBehavior.Value;
            if (ResizeDirection.HasValue) ui.ResizeDirection = ResizeDirection.Value;
            if (ShowsPreview.HasValue) ui.ShowsPreview = ShowsPreview.Value;
            return global::CSharpMarkup.Wpf.GridSplitter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridSplitter"/></summary>
        public static GridSplitter GridSplitter()
        {
            var ui = new Windows.Controls.GridSplitter();
            return global::CSharpMarkup.Wpf.GridSplitter.StartChain(ui);
        }
    }

    public partial class GridSplitter : Thumb, IUI<System.Windows.Controls.GridSplitter>
    {
        static GridSplitter instance;

        internal static GridSplitter StartChain(Windows.Controls.GridSplitter ui)
        {
            if (instance == null) instance = new GridSplitter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridSplitter ui;

        public new Windows.Controls.GridSplitter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GridSplitter view) => view?.UI;

        public static implicit operator Windows.Controls.GridSplitter(GridSplitter view) => view?.UI;

        public static implicit operator GridSplitter(Windows.Controls.GridSplitter ui) => GridSplitter.StartChain(ui);

        protected GridSplitter() { }
    }

    public static partial class GridSplitterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.GridSplitter.DragIncrement"/></summary>
        public static TView DragIncrement<TView>(this TView view, double value) where TView : GridSplitter { view.UI.DragIncrement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridSplitter.KeyboardIncrement"/></summary>
        public static TView KeyboardIncrement<TView>(this TView view, double value) where TView : GridSplitter { view.UI.KeyboardIncrement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridSplitter.PreviewStyle"/></summary>
        public static TView PreviewStyle<TView>(this TView view, Windows.Style value) where TView : GridSplitter { view.UI.PreviewStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridSplitter.ResizeBehavior"/></summary>
        public static TView ResizeBehavior<TView>(this TView view, Windows.Controls.GridResizeBehavior value) where TView : GridSplitter { view.UI.ResizeBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridSplitter.ResizeDirection"/></summary>
        public static TView ResizeDirection<TView>(this TView view, Windows.Controls.GridResizeDirection value) where TView : GridSplitter { view.UI.ResizeDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridSplitter.ShowsPreview"/></summary>
        public static TView ShowsPreview<TView>(this TView view, bool value) where TView : GridSplitter { view.UI.ShowsPreview = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.DragIncrement"/></summary>
        public static DependencyProperty<TTarget, double> DragIncrement<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.GridSplitter.DragIncrementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.KeyboardIncrement"/></summary>
        public static DependencyProperty<TTarget, double> KeyboardIncrement<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.GridSplitter.KeyboardIncrementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.PreviewStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> PreviewStyle<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.GridSplitter.PreviewStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.ResizeBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior> ResizeBehavior<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior>.Get(target, Windows.Controls.GridSplitter.ResizeBehaviorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.ResizeDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridResizeDirection> ResizeDirection<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, Windows.Controls.GridResizeDirection>.Get(target, Windows.Controls.GridSplitter.ResizeDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridSplitter.ShowsPreview"/></summary>
        public static DependencyProperty<TTarget, bool> ShowsPreview<TTarget>(this TTarget target) where TTarget : GridSplitter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.GridSplitter.ShowsPreviewProperty);
    }
}

namespace CSharpMarkup.Wpf // GridView
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridView"/></summary>
        public static GridView GridView(
            params System.Windows.Controls.GridViewColumn[] Columns
)
        {
            var ui = new Windows.Controls.GridView();
            foreach (var child in Columns) if (child is not null) ui.Columns.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Columns);
            return global::CSharpMarkup.Wpf.GridView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridView"/></summary>
        public static GridView GridView(O<bool> AllowsColumnReorder = default, O<Windows.Style> ColumnHeaderContainerStyle = default, O<Windows.Controls.ContextMenu> ColumnHeaderContextMenu = default, O<string> ColumnHeaderStringFormat = default, O<Windows.DataTemplate> ColumnHeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> ColumnHeaderTemplateSelector = default, O<object> ColumnHeaderToolTip = default)
        {
            var ui = new Windows.Controls.GridView();
            if (AllowsColumnReorder.HasValue) ui.AllowsColumnReorder = AllowsColumnReorder.Value;
            if (ColumnHeaderContainerStyle.HasValue) ui.ColumnHeaderContainerStyle = ColumnHeaderContainerStyle.Value;
            if (ColumnHeaderContextMenu.HasValue) ui.ColumnHeaderContextMenu = ColumnHeaderContextMenu.Value;
            if (ColumnHeaderStringFormat.HasValue) ui.ColumnHeaderStringFormat = ColumnHeaderStringFormat.Value;
            if (ColumnHeaderTemplate.HasValue) ui.ColumnHeaderTemplate = ColumnHeaderTemplate.Value;
            if (ColumnHeaderTemplateSelector.HasValue) ui.ColumnHeaderTemplateSelector = ColumnHeaderTemplateSelector.Value;
            if (ColumnHeaderToolTip.HasValue) ui.ColumnHeaderToolTip = ColumnHeaderToolTip.Value;
            return global::CSharpMarkup.Wpf.GridView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridView"/></summary>
        public static GridView GridView()
        {
            var ui = new Windows.Controls.GridView();
            return global::CSharpMarkup.Wpf.GridView.StartChain(ui);
        }
    }

    public partial class GridView : ViewBase, IUI<System.Windows.Controls.GridView>
    {
        static GridView instance;

        internal static GridView StartChain(Windows.Controls.GridView ui)
        {
            if (instance == null) instance = new GridView();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridView ui;

        public new Windows.Controls.GridView UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.GridView(GridView view) => view?.UI;

        public static implicit operator GridView(Windows.Controls.GridView ui) => GridView.StartChain(ui);

        protected GridView() { }
    }

    public static partial class GridViewExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.GridView.AllowsColumnReorder"/></summary>
        public static TView AllowsColumnReorder<TView>(this TView view, bool value) where TView : GridView { view.UI.AllowsColumnReorder = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderContainerStyle"/></summary>
        public static TView ColumnHeaderContainerStyle<TView>(this TView view, Windows.Style value) where TView : GridView { view.UI.ColumnHeaderContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderContextMenu"/></summary>
        public static TView ColumnHeaderContextMenu<TView>(this TView view, Windows.Controls.ContextMenu value) where TView : GridView { view.UI.ColumnHeaderContextMenu = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderStringFormat"/></summary>
        public static TView ColumnHeaderStringFormat<TView>(this TView view, string value) where TView : GridView { view.UI.ColumnHeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderTemplate"/></summary>
        public static TView ColumnHeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : GridView { view.UI.ColumnHeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderTemplateSelector"/></summary>
        public static TView ColumnHeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : GridView { view.UI.ColumnHeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnHeaderToolTip"/></summary>
        public static TView ColumnHeaderToolTip<TView>(this TView view, object value) where TView : GridView { view.UI.ColumnHeaderToolTip = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.AllowsColumnReorder"/></summary>
        public static DependencyProperty<TTarget, bool> AllowsColumnReorder<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.GridView.AllowsColumnReorderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ColumnHeaderContainerStyle<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.GridView.ColumnHeaderContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderContextMenu"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ContextMenu> ColumnHeaderContextMenu<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, Windows.Controls.ContextMenu>.Get(target, Windows.Controls.GridView.ColumnHeaderContextMenuProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ColumnHeaderStringFormat<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.GridView.ColumnHeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ColumnHeaderTemplate<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.GridView.ColumnHeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ColumnHeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.GridView.ColumnHeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnHeaderToolTip"/></summary>
        public static DependencyProperty<TTarget, object> ColumnHeaderToolTip<TTarget>(this TTarget target) where TTarget : GridView
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.GridView.ColumnHeaderToolTipProperty);

        /// <summary>Set <see cref="Windows.Controls.GridView.ColumnCollection"/></summary>
        public static TTarget GridView_ColumnCollection<TTarget>(this TTarget target, Windows.Controls.GridViewColumnCollection value) where TTarget : DependencyObject
        { Windows.Controls.GridView.SetColumnCollection(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridView.ColumnCollection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridViewColumnCollection> GridView_ColumnCollection<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.GridViewColumnCollection>.Get(target, Windows.Controls.GridView.ColumnCollectionProperty);
    }
}

namespace CSharpMarkup.Wpf // GridViewColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridViewColumn"/></summary>
        public static GridViewColumn GridViewColumn(
            object Header
)
        {
            var ui = new Windows.Controls.GridViewColumn();
            if (Header is not null) ui.Header = Header;
            return global::CSharpMarkup.Wpf.GridViewColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridViewColumn"/></summary>
        public static GridViewColumn GridViewColumn(O<Windows.DataTemplate> CellTemplate = default, O<Windows.Controls.DataTemplateSelector> CellTemplateSelector = default, O<Windows.Data.BindingBase> DisplayMemberBinding = default, O<object> Header = default, O<Windows.Style> HeaderContainerStyle = default, O<string> HeaderStringFormat = default, O<Windows.DataTemplate> HeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> HeaderTemplateSelector = default, O<double> Width = default)
        {
            var ui = new Windows.Controls.GridViewColumn();
            if (CellTemplate.HasValue) ui.CellTemplate = CellTemplate.Value;
            if (CellTemplateSelector.HasValue) ui.CellTemplateSelector = CellTemplateSelector.Value;
            if (DisplayMemberBinding.HasValue) ui.DisplayMemberBinding = DisplayMemberBinding.Value;
            if (Header.HasValue) ui.Header = Header.Value;
            if (HeaderContainerStyle.HasValue) ui.HeaderContainerStyle = HeaderContainerStyle.Value;
            if (HeaderStringFormat.HasValue) ui.HeaderStringFormat = HeaderStringFormat.Value;
            if (HeaderTemplate.HasValue) ui.HeaderTemplate = HeaderTemplate.Value;
            if (HeaderTemplateSelector.HasValue) ui.HeaderTemplateSelector = HeaderTemplateSelector.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.GridViewColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridViewColumn"/></summary>
        public static GridViewColumn GridViewColumn()
        {
            var ui = new Windows.Controls.GridViewColumn();
            return global::CSharpMarkup.Wpf.GridViewColumn.StartChain(ui);
        }
    }

    public partial class GridViewColumn : DependencyObject, IUI<System.Windows.Controls.GridViewColumn>
    {
        static GridViewColumn instance;

        internal static GridViewColumn StartChain(Windows.Controls.GridViewColumn ui)
        {
            if (instance == null) instance = new GridViewColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridViewColumn ui;

        public new Windows.Controls.GridViewColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.GridViewColumn(GridViewColumn view) => view?.UI;

        public static implicit operator GridViewColumn(Windows.Controls.GridViewColumn ui) => GridViewColumn.StartChain(ui);

        protected GridViewColumn() { }
    }

    public static partial class GridViewColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.CellTemplate"/></summary>
        public static TView CellTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : GridViewColumn { view.UI.CellTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.CellTemplateSelector"/></summary>
        public static TView CellTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : GridViewColumn { view.UI.CellTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.DisplayMemberBinding"/></summary>
        public static TView DisplayMemberBinding<TView>(this TView view, Windows.Data.BindingBase value) where TView : GridViewColumn { view.UI.DisplayMemberBinding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : GridViewColumn { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.HeaderContainerStyle"/></summary>
        public static TView HeaderContainerStyle<TView>(this TView view, Windows.Style value) where TView : GridViewColumn { view.UI.HeaderContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.HeaderStringFormat"/></summary>
        public static TView HeaderStringFormat<TView>(this TView view, string value) where TView : GridViewColumn { view.UI.HeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : GridViewColumn { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : GridViewColumn { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewColumn.Width"/></summary>
        public static TView Width<TView>(this TView view, double value) where TView : GridViewColumn { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.CellTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> CellTemplate<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.GridViewColumn.CellTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.CellTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> CellTemplateSelector<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.GridViewColumn.CellTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.HeaderContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> HeaderContainerStyle<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.GridViewColumn.HeaderContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.GridViewColumn.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.HeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> HeaderStringFormat<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.GridViewColumn.HeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.GridViewColumn.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.GridViewColumn.HeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumn.Width"/></summary>
        public static DependencyProperty<TTarget, double> Width<TTarget>(this TTarget target) where TTarget : GridViewColumn
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.GridViewColumn.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // GridViewColumnHeader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridViewColumnHeader"/></summary>
        public static GridViewColumnHeader GridViewColumnHeader(
            object Content
)
        {
            var ui = new Windows.Controls.GridViewColumnHeader();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.GridViewColumnHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridViewColumnHeader"/></summary>
        public static GridViewColumnHeader GridViewColumnHeader()
        {
            var ui = new Windows.Controls.GridViewColumnHeader();
            return global::CSharpMarkup.Wpf.GridViewColumnHeader.StartChain(ui);
        }
    }

    public partial class GridViewColumnHeader : ButtonBase, IUI<System.Windows.Controls.GridViewColumnHeader>
    {
        static GridViewColumnHeader instance;

        internal static GridViewColumnHeader StartChain(Windows.Controls.GridViewColumnHeader ui)
        {
            if (instance == null) instance = new GridViewColumnHeader();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridViewColumnHeader ui;

        public new Windows.Controls.GridViewColumnHeader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GridViewColumnHeader view) => view?.UI;

        public static implicit operator Windows.Controls.GridViewColumnHeader(GridViewColumnHeader view) => view?.UI;

        public static implicit operator GridViewColumnHeader(Windows.Controls.GridViewColumnHeader ui) => GridViewColumnHeader.StartChain(ui);

        protected GridViewColumnHeader() { }
    }

    public static partial class GridViewColumnHeaderExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumnHeader.Column"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridViewColumn> Column<TTarget>(this TTarget target) where TTarget : GridViewColumnHeader
        => DependencyProperty<TTarget, Windows.Controls.GridViewColumn>.Get(target, Windows.Controls.GridViewColumnHeader.ColumnProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewColumnHeader.Role"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridViewColumnHeaderRole> Role<TTarget>(this TTarget target) where TTarget : GridViewColumnHeader
        => DependencyProperty<TTarget, Windows.Controls.GridViewColumnHeaderRole>.Get(target, Windows.Controls.GridViewColumnHeader.RoleProperty);
    }
}

namespace CSharpMarkup.Wpf // GridViewHeaderRowPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridViewHeaderRowPresenter"/></summary>
        public static GridViewHeaderRowPresenter GridViewHeaderRowPresenter(O<bool> AllowsColumnReorder = default, O<Windows.Style> ColumnHeaderContainerStyle = default, O<Windows.Controls.ContextMenu> ColumnHeaderContextMenu = default, O<string> ColumnHeaderStringFormat = default, O<Windows.DataTemplate> ColumnHeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> ColumnHeaderTemplateSelector = default, O<object> ColumnHeaderToolTip = default)
        {
            var ui = new Windows.Controls.GridViewHeaderRowPresenter();
            if (AllowsColumnReorder.HasValue) ui.AllowsColumnReorder = AllowsColumnReorder.Value;
            if (ColumnHeaderContainerStyle.HasValue) ui.ColumnHeaderContainerStyle = ColumnHeaderContainerStyle.Value;
            if (ColumnHeaderContextMenu.HasValue) ui.ColumnHeaderContextMenu = ColumnHeaderContextMenu.Value;
            if (ColumnHeaderStringFormat.HasValue) ui.ColumnHeaderStringFormat = ColumnHeaderStringFormat.Value;
            if (ColumnHeaderTemplate.HasValue) ui.ColumnHeaderTemplate = ColumnHeaderTemplate.Value;
            if (ColumnHeaderTemplateSelector.HasValue) ui.ColumnHeaderTemplateSelector = ColumnHeaderTemplateSelector.Value;
            if (ColumnHeaderToolTip.HasValue) ui.ColumnHeaderToolTip = ColumnHeaderToolTip.Value;
            return global::CSharpMarkup.Wpf.GridViewHeaderRowPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridViewHeaderRowPresenter"/></summary>
        public static GridViewHeaderRowPresenter GridViewHeaderRowPresenter()
        {
            var ui = new Windows.Controls.GridViewHeaderRowPresenter();
            return global::CSharpMarkup.Wpf.GridViewHeaderRowPresenter.StartChain(ui);
        }
    }

    public partial class GridViewHeaderRowPresenter : GridViewRowPresenterBase, IUI<System.Windows.Controls.GridViewHeaderRowPresenter>
    {
        static GridViewHeaderRowPresenter instance;

        internal static GridViewHeaderRowPresenter StartChain(Windows.Controls.GridViewHeaderRowPresenter ui)
        {
            if (instance == null) instance = new GridViewHeaderRowPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridViewHeaderRowPresenter ui;

        public new Windows.Controls.GridViewHeaderRowPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GridViewHeaderRowPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.GridViewHeaderRowPresenter(GridViewHeaderRowPresenter view) => view?.UI;

        public static implicit operator GridViewHeaderRowPresenter(Windows.Controls.GridViewHeaderRowPresenter ui) => GridViewHeaderRowPresenter.StartChain(ui);

        protected GridViewHeaderRowPresenter() { }
    }

    public static partial class GridViewHeaderRowPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.AllowsColumnReorder"/></summary>
        public static TView AllowsColumnReorder<TView>(this TView view, bool value) where TView : GridViewHeaderRowPresenter { view.UI.AllowsColumnReorder = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContainerStyle"/></summary>
        public static TView ColumnHeaderContainerStyle<TView>(this TView view, Windows.Style value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContextMenu"/></summary>
        public static TView ColumnHeaderContextMenu<TView>(this TView view, Windows.Controls.ContextMenu value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderContextMenu = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderStringFormat"/></summary>
        public static TView ColumnHeaderStringFormat<TView>(this TView view, string value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplate"/></summary>
        public static TView ColumnHeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplateSelector"/></summary>
        public static TView ColumnHeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderToolTip"/></summary>
        public static TView ColumnHeaderToolTip<TView>(this TView view, object value) where TView : GridViewHeaderRowPresenter { view.UI.ColumnHeaderToolTip = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.AllowsColumnReorder"/></summary>
        public static DependencyProperty<TTarget, bool> AllowsColumnReorder<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.AllowsColumnReorderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ColumnHeaderContainerStyle<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContextMenu"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ContextMenu> ColumnHeaderContextMenu<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, Windows.Controls.ContextMenu>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderContextMenuProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ColumnHeaderStringFormat<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ColumnHeaderTemplate<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ColumnHeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderToolTip"/></summary>
        public static DependencyProperty<TTarget, object> ColumnHeaderToolTip<TTarget>(this TTarget target) where TTarget : GridViewHeaderRowPresenter
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.GridViewHeaderRowPresenter.ColumnHeaderToolTipProperty);
    }
}

namespace CSharpMarkup.Wpf // GridViewRowPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GridViewRowPresenter"/></summary>
        public static GridViewRowPresenter GridViewRowPresenter(O<object> Content = default)
        {
            var ui = new Windows.Controls.GridViewRowPresenter();
            if (Content.HasValue) ui.Content = Content.Value;
            return global::CSharpMarkup.Wpf.GridViewRowPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GridViewRowPresenter"/></summary>
        public static GridViewRowPresenter GridViewRowPresenter()
        {
            var ui = new Windows.Controls.GridViewRowPresenter();
            return global::CSharpMarkup.Wpf.GridViewRowPresenter.StartChain(ui);
        }
    }

    public partial class GridViewRowPresenter : GridViewRowPresenterBase, IUI<System.Windows.Controls.GridViewRowPresenter>
    {
        static GridViewRowPresenter instance;

        internal static GridViewRowPresenter StartChain(Windows.Controls.GridViewRowPresenter ui)
        {
            if (instance == null) instance = new GridViewRowPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GridViewRowPresenter ui;

        public new Windows.Controls.GridViewRowPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GridViewRowPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.GridViewRowPresenter(GridViewRowPresenter view) => view?.UI;

        public static implicit operator GridViewRowPresenter(Windows.Controls.GridViewRowPresenter ui) => GridViewRowPresenter.StartChain(ui);

        protected GridViewRowPresenter() { }
    }

    public static partial class GridViewRowPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.GridViewRowPresenter.Content"/></summary>
        public static TView Content<TView>(this TView view, object value) where TView : GridViewRowPresenter { view.UI.Content = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.GridViewRowPresenter.Content"/></summary>
        public static DependencyProperty<TTarget, object> Content<TTarget>(this TTarget target) where TTarget : GridViewRowPresenter
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.GridViewRowPresenter.ContentProperty);
    }
}

namespace CSharpMarkup.Wpf // GroupBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GroupBox"/></summary>
        public static GroupBox GroupBox(
            object Content
)
        {
            var ui = new Windows.Controls.GroupBox();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.GroupBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GroupBox"/></summary>
        public static GroupBox GroupBox()
        {
            var ui = new Windows.Controls.GroupBox();
            return global::CSharpMarkup.Wpf.GroupBox.StartChain(ui);
        }
    }

    public partial class GroupBox : HeaderedContentControl, IUI<System.Windows.Controls.GroupBox>
    {
        static GroupBox instance;

        internal static GroupBox StartChain(Windows.Controls.GroupBox ui)
        {
            if (instance == null) instance = new GroupBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GroupBox ui;

        public new Windows.Controls.GroupBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GroupBox view) => view?.UI;

        public static implicit operator Windows.Controls.GroupBox(GroupBox view) => view?.UI;

        public static implicit operator GroupBox(Windows.Controls.GroupBox ui) => GroupBox.StartChain(ui);

        protected GroupBox() { }
    }
}

namespace CSharpMarkup.Wpf // GroupItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.GroupItem"/></summary>
        public static GroupItem GroupItem(
            object Content
)
        {
            var ui = new Windows.Controls.GroupItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.GroupItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.GroupItem"/></summary>
        public static GroupItem GroupItem()
        {
            var ui = new Windows.Controls.GroupItem();
            return global::CSharpMarkup.Wpf.GroupItem.StartChain(ui);
        }
    }

    public partial class GroupItem : ContentControl, IUI<System.Windows.Controls.GroupItem>
    {
        static GroupItem instance;

        internal static GroupItem StartChain(Windows.Controls.GroupItem ui)
        {
            if (instance == null) instance = new GroupItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.GroupItem ui;

        public new Windows.Controls.GroupItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(GroupItem view) => view?.UI;

        public static implicit operator Windows.Controls.GroupItem(GroupItem view) => view?.UI;

        public static implicit operator GroupItem(Windows.Controls.GroupItem ui) => GroupItem.StartChain(ui);

        protected GroupItem() { }
    }
}

namespace CSharpMarkup.Wpf // HeaderedContentControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.HeaderedContentControl"/></summary>
        public static HeaderedContentControl HeaderedContentControl(
            object Content
)
        {
            var ui = new Windows.Controls.HeaderedContentControl();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.HeaderedContentControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.HeaderedContentControl"/></summary>
        public static HeaderedContentControl HeaderedContentControl(O<object> Header = default, O<string> HeaderStringFormat = default, O<Windows.DataTemplate> HeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> HeaderTemplateSelector = default)
        {
            var ui = new Windows.Controls.HeaderedContentControl();
            if (Header.HasValue) ui.Header = Header.Value;
            if (HeaderStringFormat.HasValue) ui.HeaderStringFormat = HeaderStringFormat.Value;
            if (HeaderTemplate.HasValue) ui.HeaderTemplate = HeaderTemplate.Value;
            if (HeaderTemplateSelector.HasValue) ui.HeaderTemplateSelector = HeaderTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.HeaderedContentControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.HeaderedContentControl"/></summary>
        public static HeaderedContentControl HeaderedContentControl()
        {
            var ui = new Windows.Controls.HeaderedContentControl();
            return global::CSharpMarkup.Wpf.HeaderedContentControl.StartChain(ui);
        }
    }

    public partial class HeaderedContentControl : ContentControl, IUI<System.Windows.Controls.HeaderedContentControl>
    {
        static HeaderedContentControl instance;

        internal static HeaderedContentControl StartChain(Windows.Controls.HeaderedContentControl ui)
        {
            if (instance == null) instance = new HeaderedContentControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.HeaderedContentControl ui;

        public new Windows.Controls.HeaderedContentControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(HeaderedContentControl view) => view?.UI;

        public static implicit operator Windows.Controls.HeaderedContentControl(HeaderedContentControl view) => view?.UI;

        public static implicit operator HeaderedContentControl(Windows.Controls.HeaderedContentControl ui) => HeaderedContentControl.StartChain(ui);

        protected HeaderedContentControl() { }
    }

    public static partial class HeaderedContentControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.HeaderedContentControl.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : HeaderedContentControl { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedContentControl.HeaderStringFormat"/></summary>
        public static TView HeaderStringFormat<TView>(this TView view, string value) where TView : HeaderedContentControl { view.UI.HeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedContentControl.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : HeaderedContentControl { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedContentControl.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : HeaderedContentControl { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedContentControl.HasHeader"/></summary>
        public static DependencyProperty<TTarget, bool> HasHeader<TTarget>(this TTarget target) where TTarget : HeaderedContentControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.HeaderedContentControl.HasHeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedContentControl.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : HeaderedContentControl
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.HeaderedContentControl.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedContentControl.HeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> HeaderStringFormat<TTarget>(this TTarget target) where TTarget : HeaderedContentControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.HeaderedContentControl.HeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedContentControl.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : HeaderedContentControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.HeaderedContentControl.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedContentControl.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : HeaderedContentControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.HeaderedContentControl.HeaderTemplateSelectorProperty);
    }
}

namespace CSharpMarkup.Wpf // HeaderedItemsControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.HeaderedItemsControl"/></summary>
        public static HeaderedItemsControl HeaderedItemsControl(
            params object[] Items
)
        {
            var ui = new Windows.Controls.HeaderedItemsControl();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.HeaderedItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.HeaderedItemsControl"/></summary>
        public static HeaderedItemsControl HeaderedItemsControl(O<object> Header = default, O<string> HeaderStringFormat = default, O<Windows.DataTemplate> HeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> HeaderTemplateSelector = default)
        {
            var ui = new Windows.Controls.HeaderedItemsControl();
            if (Header.HasValue) ui.Header = Header.Value;
            if (HeaderStringFormat.HasValue) ui.HeaderStringFormat = HeaderStringFormat.Value;
            if (HeaderTemplate.HasValue) ui.HeaderTemplate = HeaderTemplate.Value;
            if (HeaderTemplateSelector.HasValue) ui.HeaderTemplateSelector = HeaderTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.HeaderedItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.HeaderedItemsControl"/></summary>
        public static HeaderedItemsControl HeaderedItemsControl()
        {
            var ui = new Windows.Controls.HeaderedItemsControl();
            return global::CSharpMarkup.Wpf.HeaderedItemsControl.StartChain(ui);
        }
    }

    public partial class HeaderedItemsControl : ItemsControl, IUI<System.Windows.Controls.HeaderedItemsControl>
    {
        static HeaderedItemsControl instance;

        internal static HeaderedItemsControl StartChain(Windows.Controls.HeaderedItemsControl ui)
        {
            if (instance == null) instance = new HeaderedItemsControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.HeaderedItemsControl ui;

        public new Windows.Controls.HeaderedItemsControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(HeaderedItemsControl view) => view?.UI;

        public static implicit operator Windows.Controls.HeaderedItemsControl(HeaderedItemsControl view) => view?.UI;

        public static implicit operator HeaderedItemsControl(Windows.Controls.HeaderedItemsControl ui) => HeaderedItemsControl.StartChain(ui);

        protected HeaderedItemsControl() { }
    }

    public static partial class HeaderedItemsControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.HeaderedItemsControl.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : HeaderedItemsControl { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedItemsControl.HeaderStringFormat"/></summary>
        public static TView HeaderStringFormat<TView>(this TView view, string value) where TView : HeaderedItemsControl { view.UI.HeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedItemsControl.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : HeaderedItemsControl { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : HeaderedItemsControl { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedItemsControl.HasHeader"/></summary>
        public static DependencyProperty<TTarget, bool> HasHeader<TTarget>(this TTarget target) where TTarget : HeaderedItemsControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.HeaderedItemsControl.HasHeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedItemsControl.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : HeaderedItemsControl
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.HeaderedItemsControl.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedItemsControl.HeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> HeaderStringFormat<TTarget>(this TTarget target) where TTarget : HeaderedItemsControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.HeaderedItemsControl.HeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedItemsControl.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : HeaderedItemsControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.HeaderedItemsControl.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : HeaderedItemsControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.HeaderedItemsControl.HeaderTemplateSelectorProperty);
    }
}

namespace CSharpMarkup.Wpf // Image
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Image"/></summary>
        /// <remarks>Remark: Image().Bind() binds to <see cref="Windows.Controls.Image.SourceProperty"/></remarks>
        public static Image Image(O<Windows.Media.ImageSource> Source = default, O<Windows.Media.Stretch> Stretch = default, O<Windows.Controls.StretchDirection> StretchDirection = default)
        {
            var ui = new Windows.Controls.Image();
            if (Source.HasValue) ui.Source = Source.Value;
            if (Stretch.HasValue) ui.Stretch = Stretch.Value;
            if (StretchDirection.HasValue) ui.StretchDirection = StretchDirection.Value;
            return global::CSharpMarkup.Wpf.Image.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Image"/></summary>
        /// <remarks>Remark: Image().Bind() binds to <see cref="Windows.Controls.Image.SourceProperty"/></remarks>
        public static Image Image()
        {
            var ui = new Windows.Controls.Image();
            return global::CSharpMarkup.Wpf.Image.StartChain(ui);
        }
    }

    public partial class Image : FrameworkElement, IUI<System.Windows.Controls.Image>, IDefaultBindProperty
    {
        static Image instance;

        internal static Image StartChain(Windows.Controls.Image ui)
        {
            if (instance == null) instance = new Image();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Image ui;

        public new Windows.Controls.Image UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Image.SourceProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Image.SourceProperty;

        public static implicit operator Windows.UIElement(Image view) => view?.UI;

        public static implicit operator Windows.Controls.Image(Image view) => view?.UI;

        public static implicit operator Image(Windows.Controls.Image ui) => Image.StartChain(ui);

        protected Image() { }
    }

    public static partial class ImageExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Image.Source"/></summary>
        public static TView Source<TView>(this TView view, Windows.Media.ImageSource value) where TView : Image { view.UI.Source = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Image.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : Image { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Image.StretchDirection"/></summary>
        public static TView StretchDirection<TView>(this TView view, Windows.Controls.StretchDirection value) where TView : Image { view.UI.StretchDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Image.Source"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> Source<TTarget>(this TTarget target) where TTarget : Image
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Image.SourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Image.StretchDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StretchDirection> StretchDirection<TTarget>(this TTarget target) where TTarget : Image
        => DependencyProperty<TTarget, Windows.Controls.StretchDirection>.Get(target, Windows.Controls.Image.StretchDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Image.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : Image
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Controls.Image.StretchProperty);
    }
}

namespace CSharpMarkup.Wpf // InkCanvas
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.InkCanvas"/></summary>
        public static InkCanvas InkCanvas(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.InkCanvas();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.InkCanvas.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.InkCanvas"/></summary>
        public static InkCanvas InkCanvas(O<Windows.Media.Brush> Background = default, O<Windows.Ink.DrawingAttributes> DefaultDrawingAttributes = default, O<Windows.Input.StylusPointDescription> DefaultStylusPointDescription = default, O<Windows.Controls.InkCanvasEditingMode> EditingMode = default, O<Windows.Controls.InkCanvasEditingMode> EditingModeInverted = default, O<Windows.Ink.StylusShape> EraserShape = default, O<bool> MoveEnabled = default, O<IEnumerable<Windows.Controls.InkCanvasClipboardFormat>> PreferredPasteFormats = default, O<bool> ResizeEnabled = default, O<Windows.Ink.StrokeCollection> Strokes = default, O<bool> UseCustomCursor = default)
        {
            var ui = new Windows.Controls.InkCanvas();
            if (Background.HasValue) ui.Background = Background.Value;
            if (DefaultDrawingAttributes.HasValue) ui.DefaultDrawingAttributes = DefaultDrawingAttributes.Value;
            if (DefaultStylusPointDescription.HasValue) ui.DefaultStylusPointDescription = DefaultStylusPointDescription.Value;
            if (EditingMode.HasValue) ui.EditingMode = EditingMode.Value;
            if (EditingModeInverted.HasValue) ui.EditingModeInverted = EditingModeInverted.Value;
            if (EraserShape.HasValue) ui.EraserShape = EraserShape.Value;
            if (MoveEnabled.HasValue) ui.MoveEnabled = MoveEnabled.Value;
            if (PreferredPasteFormats.HasValue) ui.PreferredPasteFormats = PreferredPasteFormats.Value;
            if (ResizeEnabled.HasValue) ui.ResizeEnabled = ResizeEnabled.Value;
            if (Strokes.HasValue) ui.Strokes = Strokes.Value;
            if (UseCustomCursor.HasValue) ui.UseCustomCursor = UseCustomCursor.Value;
            return global::CSharpMarkup.Wpf.InkCanvas.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.InkCanvas"/></summary>
        public static InkCanvas InkCanvas()
        {
            var ui = new Windows.Controls.InkCanvas();
            return global::CSharpMarkup.Wpf.InkCanvas.StartChain(ui);
        }
    }

    public partial class InkCanvas : FrameworkElement, IUI<System.Windows.Controls.InkCanvas>
    {
        static InkCanvas instance;

        internal static InkCanvas StartChain(Windows.Controls.InkCanvas ui)
        {
            if (instance == null) instance = new InkCanvas();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.InkCanvas ui;

        public new Windows.Controls.InkCanvas UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(InkCanvas view) => view?.UI;

        public static implicit operator Windows.Controls.InkCanvas(InkCanvas view) => view?.UI;

        public static implicit operator InkCanvas(Windows.Controls.InkCanvas ui) => InkCanvas.StartChain(ui);

        protected InkCanvas() { }
    }

    public static partial class InkCanvasExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : InkCanvas { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : InkCanvas { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : InkCanvas { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.DefaultDrawingAttributes"/></summary>
        public static TView DefaultDrawingAttributes<TView>(this TView view, Windows.Ink.DrawingAttributes value) where TView : InkCanvas { view.UI.DefaultDrawingAttributes = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.DefaultStylusPointDescription"/></summary>
        public static TView DefaultStylusPointDescription<TView>(this TView view, Windows.Input.StylusPointDescription value) where TView : InkCanvas { view.UI.DefaultStylusPointDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.EditingMode"/></summary>
        public static TView EditingMode<TView>(this TView view, Windows.Controls.InkCanvasEditingMode value) where TView : InkCanvas { view.UI.EditingMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.EditingModeInverted"/></summary>
        public static TView EditingModeInverted<TView>(this TView view, Windows.Controls.InkCanvasEditingMode value) where TView : InkCanvas { view.UI.EditingModeInverted = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.EraserShape"/></summary>
        public static TView EraserShape<TView>(this TView view, Windows.Ink.StylusShape value) where TView : InkCanvas { view.UI.EraserShape = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.MoveEnabled"/></summary>
        public static TView MoveEnabled<TView>(this TView view, bool value) where TView : InkCanvas { view.UI.MoveEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.PreferredPasteFormats"/></summary>
        public static TView PreferredPasteFormats<TView>(this TView view, IEnumerable<Windows.Controls.InkCanvasClipboardFormat> value) where TView : InkCanvas { view.UI.PreferredPasteFormats = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.ResizeEnabled"/></summary>
        public static TView ResizeEnabled<TView>(this TView view, bool value) where TView : InkCanvas { view.UI.ResizeEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Strokes"/></summary>
        public static TView Strokes<TView>(this TView view, Windows.Ink.StrokeCollection value) where TView : InkCanvas { view.UI.Strokes = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.UseCustomCursor"/></summary>
        public static TView UseCustomCursor<TView>(this TView view, bool value) where TView : InkCanvas { view.UI.UseCustomCursor = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.ActiveEditingMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> ActiveEditingMode<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode>.Get(target, Windows.Controls.InkCanvas.ActiveEditingModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.InkCanvas.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.DefaultDrawingAttributes"/></summary>
        public static DependencyProperty<TTarget, Windows.Ink.DrawingAttributes> DefaultDrawingAttributes<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Ink.DrawingAttributes>.Get(target, Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.EditingModeInverted"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> EditingModeInverted<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode>.Get(target, Windows.Controls.InkCanvas.EditingModeInvertedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.EditingMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> EditingMode<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode>.Get(target, Windows.Controls.InkCanvas.EditingModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Strokes"/></summary>
        public static DependencyProperty<TTarget, Windows.Ink.StrokeCollection> Strokes<TTarget>(this TTarget target) where TTarget : InkCanvas
        => DependencyProperty<TTarget, Windows.Ink.StrokeCollection>.Get(target, Windows.Controls.InkCanvas.StrokesProperty);

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Bottom"/></summary>
        public static TTarget InkCanvas_Bottom<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.InkCanvas.SetBottom(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Bottom"/></summary>
        public static DependencyProperty<TTarget, double> InkCanvas_Bottom<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.InkCanvas.BottomProperty);

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Left"/></summary>
        public static TTarget InkCanvas_Left<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.InkCanvas.SetLeft(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Left"/></summary>
        public static DependencyProperty<TTarget, double> InkCanvas_Left<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.InkCanvas.LeftProperty);

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Right"/></summary>
        public static TTarget InkCanvas_Right<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.InkCanvas.SetRight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Right"/></summary>
        public static DependencyProperty<TTarget, double> InkCanvas_Right<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.InkCanvas.RightProperty);

        /// <summary>Set <see cref="Windows.Controls.InkCanvas.Top"/></summary>
        public static TTarget InkCanvas_Top<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Controls.InkCanvas.SetTop(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkCanvas.Top"/></summary>
        public static DependencyProperty<TTarget, double> InkCanvas_Top<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.InkCanvas.TopProperty);

        /// <summary>Set <see cref="Windows.Controls.InkCanvas"/> attached properties</summary>
        public static TTarget InkCanvas<TTarget>(this TTarget target

            , O<double> Bottom = default

            , O<double> Left = default

            , O<double> Right = default

            , O<double> Top = default

        ) where TTarget : UIElement
        {
            if (Bottom.HasValue) Windows.Controls.InkCanvas.SetBottom(target.UI, Bottom.Value);

            if (Left.HasValue) Windows.Controls.InkCanvas.SetLeft(target.UI, Left.Value);

            if (Right.HasValue) Windows.Controls.InkCanvas.SetRight(target.UI, Right.Value);

            if (Top.HasValue) Windows.Controls.InkCanvas.SetTop(target.UI, Top.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // InkPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.InkPresenter"/></summary>
        /// <remarks>Remark: InkPresenter().Bind() binds to <see cref="Windows.Controls.InkPresenter.StrokesProperty"/></remarks>
        public static InkPresenter InkPresenter(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.InkPresenter();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.InkPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.InkPresenter"/></summary>
        /// <remarks>Remark: InkPresenter().Bind() binds to <see cref="Windows.Controls.InkPresenter.StrokesProperty"/></remarks>
        public static InkPresenter InkPresenter(O<Windows.Ink.StrokeCollection> Strokes = default)
        {
            var ui = new Windows.Controls.InkPresenter();
            if (Strokes.HasValue) ui.Strokes = Strokes.Value;
            return global::CSharpMarkup.Wpf.InkPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.InkPresenter"/></summary>
        /// <remarks>Remark: InkPresenter().Bind() binds to <see cref="Windows.Controls.InkPresenter.StrokesProperty"/></remarks>
        public static InkPresenter InkPresenter()
        {
            var ui = new Windows.Controls.InkPresenter();
            return global::CSharpMarkup.Wpf.InkPresenter.StartChain(ui);
        }
    }

    public partial class InkPresenter : Decorator, IUI<System.Windows.Controls.InkPresenter>, IDefaultBindProperty
    {
        static InkPresenter instance;

        internal static InkPresenter StartChain(Windows.Controls.InkPresenter ui)
        {
            if (instance == null) instance = new InkPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.InkPresenter ui;

        public new Windows.Controls.InkPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.InkPresenter.StrokesProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.InkPresenter.StrokesProperty;

        public static implicit operator Windows.UIElement(InkPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.InkPresenter(InkPresenter view) => view?.UI;

        public static implicit operator InkPresenter(Windows.Controls.InkPresenter ui) => InkPresenter.StartChain(ui);

        protected InkPresenter() { }
    }

    public static partial class InkPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.InkPresenter.Strokes"/></summary>
        public static TView Strokes<TView>(this TView view, Windows.Ink.StrokeCollection value) where TView : InkPresenter { view.UI.Strokes = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.InkPresenter.Strokes"/></summary>
        public static DependencyProperty<TTarget, Windows.Ink.StrokeCollection> Strokes<TTarget>(this TTarget target) where TTarget : InkPresenter
        => DependencyProperty<TTarget, Windows.Ink.StrokeCollection>.Get(target, Windows.Controls.InkPresenter.StrokesProperty);
    }
}

namespace CSharpMarkup.Wpf // ItemsControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ItemsControl"/></summary>
        /// <remarks>Remark: ItemsControl().Bind() binds to <see cref="Windows.Controls.ItemsControl.ItemsSourceProperty"/></remarks>
        public static ItemsControl ItemsControl(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ItemsControl();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ItemsControl"/></summary>
        /// <remarks>Remark: ItemsControl().Bind() binds to <see cref="Windows.Controls.ItemsControl.ItemsSourceProperty"/></remarks>
        public static ItemsControl ItemsControl(O<int> AlternationCount = default, O<string> DisplayMemberPath = default, O<Windows.Controls.GroupStyleSelector> GroupStyleSelector = default, O<bool> IsTextSearchCaseSensitive = default, O<bool> IsTextSearchEnabled = default, O<Windows.Data.BindingGroup> ItemBindingGroup = default, O<Windows.Style> ItemContainerStyle = default, O<Windows.Controls.StyleSelector> ItemContainerStyleSelector = default, O<Windows.Controls.ItemsPanelTemplate> ItemsPanel = default, O<IEnumerable> ItemsSource = default, O<string> ItemStringFormat = default, O<Windows.DataTemplate> ItemTemplate = default, O<Windows.Controls.DataTemplateSelector> ItemTemplateSelector = default)
        {
            var ui = new Windows.Controls.ItemsControl();
            if (AlternationCount.HasValue) ui.AlternationCount = AlternationCount.Value;
            if (DisplayMemberPath.HasValue) ui.DisplayMemberPath = DisplayMemberPath.Value;
            if (GroupStyleSelector.HasValue) ui.GroupStyleSelector = GroupStyleSelector.Value;
            if (IsTextSearchCaseSensitive.HasValue) ui.IsTextSearchCaseSensitive = IsTextSearchCaseSensitive.Value;
            if (IsTextSearchEnabled.HasValue) ui.IsTextSearchEnabled = IsTextSearchEnabled.Value;
            if (ItemBindingGroup.HasValue) ui.ItemBindingGroup = ItemBindingGroup.Value;
            if (ItemContainerStyle.HasValue) ui.ItemContainerStyle = ItemContainerStyle.Value;
            if (ItemContainerStyleSelector.HasValue) ui.ItemContainerStyleSelector = ItemContainerStyleSelector.Value;
            if (ItemsPanel.HasValue) ui.ItemsPanel = ItemsPanel.Value;
            if (ItemsSource.HasValue) ui.ItemsSource = ItemsSource.Value;
            if (ItemStringFormat.HasValue) ui.ItemStringFormat = ItemStringFormat.Value;
            if (ItemTemplate.HasValue) ui.ItemTemplate = ItemTemplate.Value;
            if (ItemTemplateSelector.HasValue) ui.ItemTemplateSelector = ItemTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.ItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ItemsControl"/></summary>
        /// <remarks>Remark: ItemsControl().Bind() binds to <see cref="Windows.Controls.ItemsControl.ItemsSourceProperty"/></remarks>
        public static ItemsControl ItemsControl()
        {
            var ui = new Windows.Controls.ItemsControl();
            return global::CSharpMarkup.Wpf.ItemsControl.StartChain(ui);
        }
    }

    public partial class ItemsControl : Control, IUI<System.Windows.Controls.ItemsControl>, IDefaultBindProperty
    {
        static ItemsControl instance;

        internal static ItemsControl StartChain(Windows.Controls.ItemsControl ui)
        {
            if (instance == null) instance = new ItemsControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ItemsControl ui;

        public new Windows.Controls.ItemsControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.ItemsControl.ItemsSourceProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.ItemsControl.ItemsSourceProperty;

        public static implicit operator Windows.UIElement(ItemsControl view) => view?.UI;

        public static implicit operator Windows.Controls.ItemsControl(ItemsControl view) => view?.UI;

        public static implicit operator ItemsControl(Windows.Controls.ItemsControl ui) => ItemsControl.StartChain(ui);

        protected ItemsControl() { }
    }

    public static partial class ItemsControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ItemsControl.AlternationCount"/></summary>
        public static TView AlternationCount<TView>(this TView view, int value) where TView : ItemsControl { view.UI.AlternationCount = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.DisplayMemberPath"/></summary>
        public static TView DisplayMemberPath<TView>(this TView view, string value) where TView : ItemsControl { view.UI.DisplayMemberPath = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.GroupStyleSelector"/></summary>
        public static TView GroupStyleSelector<TView>(this TView view, Windows.Controls.GroupStyleSelector value) where TView : ItemsControl { view.UI.GroupStyleSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.IsTextSearchCaseSensitive"/></summary>
        public static TView IsTextSearchCaseSensitive<TView>(this TView view, bool value) where TView : ItemsControl { view.UI.IsTextSearchCaseSensitive = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.IsTextSearchEnabled"/></summary>
        public static TView IsTextSearchEnabled<TView>(this TView view, bool value) where TView : ItemsControl { view.UI.IsTextSearchEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemBindingGroup"/></summary>
        public static TView ItemBindingGroup<TView>(this TView view, Windows.Data.BindingGroup value) where TView : ItemsControl { view.UI.ItemBindingGroup = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemContainerStyle"/></summary>
        public static TView ItemContainerStyle<TView>(this TView view, Windows.Style value) where TView : ItemsControl { view.UI.ItemContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemContainerStyleSelector"/></summary>
        public static TView ItemContainerStyleSelector<TView>(this TView view, Windows.Controls.StyleSelector value) where TView : ItemsControl { view.UI.ItemContainerStyleSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemsPanel"/></summary>
        public static TView ItemsPanel<TView>(this TView view, Windows.Controls.ItemsPanelTemplate value) where TView : ItemsControl { view.UI.ItemsPanel = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemsSource"/></summary>
        public static TView ItemsSource<TView>(this TView view, IEnumerable value) where TView : ItemsControl { view.UI.ItemsSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemStringFormat"/></summary>
        public static TView ItemStringFormat<TView>(this TView view, string value) where TView : ItemsControl { view.UI.ItemStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemTemplate"/></summary>
        public static TView ItemTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : ItemsControl { view.UI.ItemTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ItemsControl.ItemTemplateSelector"/></summary>
        public static TView ItemTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : ItemsControl { view.UI.ItemTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.AlternationCount"/></summary>
        public static DependencyProperty<TTarget, int> AlternationCount<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.ItemsControl.AlternationCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.DisplayMemberPath"/></summary>
        public static DependencyProperty<TTarget, string> DisplayMemberPath<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ItemsControl.DisplayMemberPathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.GroupStyleSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GroupStyleSelector> GroupStyleSelector<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Controls.GroupStyleSelector>.Get(target, Windows.Controls.ItemsControl.GroupStyleSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.HasItems"/></summary>
        public static DependencyProperty<TTarget, bool> HasItems<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ItemsControl.HasItemsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.IsGrouping"/></summary>
        public static DependencyProperty<TTarget, bool> IsGrouping<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ItemsControl.IsGroupingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.IsTextSearchCaseSensitive"/></summary>
        public static DependencyProperty<TTarget, bool> IsTextSearchCaseSensitive<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.IsTextSearchEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsTextSearchEnabled<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ItemsControl.IsTextSearchEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemBindingGroup"/></summary>
        public static DependencyProperty<TTarget, Windows.Data.BindingGroup> ItemBindingGroup<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Data.BindingGroup>.Get(target, Windows.Controls.ItemsControl.ItemBindingGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ItemContainerStyle<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.ItemsControl.ItemContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemContainerStyleSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StyleSelector> ItemContainerStyleSelector<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Controls.StyleSelector>.Get(target, Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemsPanel"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ItemsPanelTemplate> ItemsPanel<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Controls.ItemsPanelTemplate>.Get(target, Windows.Controls.ItemsControl.ItemsPanelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemsSource"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> ItemsSource<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Controls.ItemsControl.ItemsSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ItemStringFormat<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.ItemsControl.ItemStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ItemTemplate<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.ItemsControl.ItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ItemsControl.ItemTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ItemTemplateSelector<TTarget>(this TTarget target) where TTarget : ItemsControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.ItemsControl.ItemTemplateSelectorProperty);
    }
}

namespace CSharpMarkup.Wpf // ItemsPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ItemsPresenter"/></summary>
        public static ItemsPresenter ItemsPresenter()
        {
            var ui = new Windows.Controls.ItemsPresenter();
            return global::CSharpMarkup.Wpf.ItemsPresenter.StartChain(ui);
        }
    }

    public partial class ItemsPresenter : FrameworkElement, IUI<System.Windows.Controls.ItemsPresenter>
    {
        static ItemsPresenter instance;

        internal static ItemsPresenter StartChain(Windows.Controls.ItemsPresenter ui)
        {
            if (instance == null) instance = new ItemsPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ItemsPresenter ui;

        public new Windows.Controls.ItemsPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ItemsPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.ItemsPresenter(ItemsPresenter view) => view?.UI;

        public static implicit operator ItemsPresenter(Windows.Controls.ItemsPresenter ui) => ItemsPresenter.StartChain(ui);

        protected ItemsPresenter() { }
    }
}

namespace CSharpMarkup.Wpf // Label
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Label"/></summary>
        /// <remarks>Remark: Label().Bind() binds to <see cref="Windows.Controls.Label.TargetProperty"/></remarks>
        public static Label Label(
            object Content
)
        {
            var ui = new Windows.Controls.Label();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.Label.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Label"/></summary>
        /// <remarks>Remark: Label().Bind() binds to <see cref="Windows.Controls.Label.TargetProperty"/></remarks>
        public static Label Label(O<Windows.UIElement> Target = default)
        {
            var ui = new Windows.Controls.Label();
            if (Target.HasValue) ui.Target = Target.Value;
            return global::CSharpMarkup.Wpf.Label.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Label"/></summary>
        /// <remarks>Remark: Label().Bind() binds to <see cref="Windows.Controls.Label.TargetProperty"/></remarks>
        public static Label Label()
        {
            var ui = new Windows.Controls.Label();
            return global::CSharpMarkup.Wpf.Label.StartChain(ui);
        }
    }

    public partial class Label : ContentControl, IUI<System.Windows.Controls.Label>, IDefaultBindProperty
    {
        static Label instance;

        internal static Label StartChain(Windows.Controls.Label ui)
        {
            if (instance == null) instance = new Label();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Label ui;

        public new Windows.Controls.Label UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Label.TargetProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Label.TargetProperty;

        public static implicit operator Windows.UIElement(Label view) => view?.UI;

        public static implicit operator Windows.Controls.Label(Label view) => view?.UI;

        public static implicit operator Label(Windows.Controls.Label ui) => Label.StartChain(ui);

        protected Label() { }
    }

    public static partial class LabelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Label.Target"/></summary>
        public static TView Target<TView>(this TView view, Windows.UIElement value) where TView : Label { view.UI.Target = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Label.Target"/></summary>
        public static DependencyProperty<TTarget, Windows.UIElement> Target<TTarget>(this TTarget target) where TTarget : Label
        => DependencyProperty<TTarget, Windows.UIElement>.Get(target, Windows.Controls.Label.TargetProperty);
    }
}

namespace CSharpMarkup.Wpf // ListBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ListBox"/></summary>
        public static ListBox ListBox(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ListBox();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ListBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListBox"/></summary>
        public static ListBox ListBox(O<Windows.Controls.SelectionMode> SelectionMode = default)
        {
            var ui = new Windows.Controls.ListBox();
            if (SelectionMode.HasValue) ui.SelectionMode = SelectionMode.Value;
            return global::CSharpMarkup.Wpf.ListBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListBox"/></summary>
        public static ListBox ListBox()
        {
            var ui = new Windows.Controls.ListBox();
            return global::CSharpMarkup.Wpf.ListBox.StartChain(ui);
        }
    }

    public partial class ListBox : Selector, IUI<System.Windows.Controls.ListBox>
    {
        static ListBox instance;

        internal static ListBox StartChain(Windows.Controls.ListBox ui)
        {
            if (instance == null) instance = new ListBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ListBox ui;

        public new Windows.Controls.ListBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ListBox view) => view?.UI;

        public static implicit operator Windows.Controls.ListBox(ListBox view) => view?.UI;

        public static implicit operator ListBox(Windows.Controls.ListBox ui) => ListBox.StartChain(ui);

        protected ListBox() { }
    }

    public static partial class ListBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ListBox.SelectionMode"/></summary>
        public static TView SelectionMode<TView>(this TView view, Windows.Controls.SelectionMode value) where TView : ListBox { view.UI.SelectionMode = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ListBox.SelectedItems"/></summary>
        public static DependencyProperty<TTarget, IList> SelectedItems<TTarget>(this TTarget target) where TTarget : ListBox
        => DependencyProperty<TTarget, IList>.Get(target, Windows.Controls.ListBox.SelectedItemsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ListBox.SelectionMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.SelectionMode> SelectionMode<TTarget>(this TTarget target) where TTarget : ListBox
        => DependencyProperty<TTarget, Windows.Controls.SelectionMode>.Get(target, Windows.Controls.ListBox.SelectionModeProperty);
    }
}

namespace CSharpMarkup.Wpf // ListBoxItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ListBoxItem"/></summary>
        public static ListBoxItem ListBoxItem(
            object Content
)
        {
            var ui = new Windows.Controls.ListBoxItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ListBoxItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListBoxItem"/></summary>
        public static ListBoxItem ListBoxItem(O<bool> IsSelected = default)
        {
            var ui = new Windows.Controls.ListBoxItem();
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            return global::CSharpMarkup.Wpf.ListBoxItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListBoxItem"/></summary>
        public static ListBoxItem ListBoxItem()
        {
            var ui = new Windows.Controls.ListBoxItem();
            return global::CSharpMarkup.Wpf.ListBoxItem.StartChain(ui);
        }
    }

    public partial class ListBoxItem : ContentControl, IUI<System.Windows.Controls.ListBoxItem>
    {
        static ListBoxItem instance;

        internal static ListBoxItem StartChain(Windows.Controls.ListBoxItem ui)
        {
            if (instance == null) instance = new ListBoxItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ListBoxItem ui;

        public new Windows.Controls.ListBoxItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ListBoxItem view) => view?.UI;

        public static implicit operator Windows.Controls.ListBoxItem(ListBoxItem view) => view?.UI;

        public static implicit operator ListBoxItem(Windows.Controls.ListBoxItem ui) => ListBoxItem.StartChain(ui);

        protected ListBoxItem() { }
    }

    public static partial class ListBoxItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ListBoxItem.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : ListBoxItem { view.UI.IsSelected = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ListBoxItem.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : ListBoxItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ListBoxItem.IsSelectedProperty);
    }
}

namespace CSharpMarkup.Wpf // ListView
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ListView"/></summary>
        public static ListView ListView(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ListView();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ListView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListView"/></summary>
        public static ListView ListView(O<Windows.Controls.ViewBase> View = default)
        {
            var ui = new Windows.Controls.ListView();
            if (View.HasValue) ui.View = View.Value;
            return global::CSharpMarkup.Wpf.ListView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListView"/></summary>
        public static ListView ListView()
        {
            var ui = new Windows.Controls.ListView();
            return global::CSharpMarkup.Wpf.ListView.StartChain(ui);
        }
    }

    public partial class ListView : ListBox, IUI<System.Windows.Controls.ListView>
    {
        static ListView instance;

        internal static ListView StartChain(Windows.Controls.ListView ui)
        {
            if (instance == null) instance = new ListView();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ListView ui;

        public new Windows.Controls.ListView UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ListView view) => view?.UI;

        public static implicit operator Windows.Controls.ListView(ListView view) => view?.UI;

        public static implicit operator ListView(Windows.Controls.ListView ui) => ListView.StartChain(ui);

        protected ListView() { }
    }

    public static partial class ListViewExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ListView.View"/></summary>
        public static TView View<TView>(this TView view, Windows.Controls.ViewBase value) where TView : ListView { view.UI.View = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ListView.View"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ViewBase> View<TTarget>(this TTarget target) where TTarget : ListView
        => DependencyProperty<TTarget, Windows.Controls.ViewBase>.Get(target, Windows.Controls.ListView.ViewProperty);
    }
}

namespace CSharpMarkup.Wpf // ListViewItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ListViewItem"/></summary>
        public static ListViewItem ListViewItem(
            object Content
)
        {
            var ui = new Windows.Controls.ListViewItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ListViewItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ListViewItem"/></summary>
        public static ListViewItem ListViewItem()
        {
            var ui = new Windows.Controls.ListViewItem();
            return global::CSharpMarkup.Wpf.ListViewItem.StartChain(ui);
        }
    }

    public partial class ListViewItem : ListBoxItem, IUI<System.Windows.Controls.ListViewItem>
    {
        static ListViewItem instance;

        internal static ListViewItem StartChain(Windows.Controls.ListViewItem ui)
        {
            if (instance == null) instance = new ListViewItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ListViewItem ui;

        public new Windows.Controls.ListViewItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ListViewItem view) => view?.UI;

        public static implicit operator Windows.Controls.ListViewItem(ListViewItem view) => view?.UI;

        public static implicit operator ListViewItem(Windows.Controls.ListViewItem ui) => ListViewItem.StartChain(ui);

        protected ListViewItem() { }
    }
}

namespace CSharpMarkup.Wpf // MediaElement
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.MediaElement"/></summary>
        /// <remarks>Remark: MediaElement().Bind() binds to <see cref="Windows.Controls.MediaElement.SourceProperty"/></remarks>
        public static MediaElement MediaElement(O<double> Balance = default, O<Windows.Media.MediaClock> Clock = default, O<bool> IsMuted = default, O<Windows.Controls.MediaState> LoadedBehavior = default, O<TimeSpan> Position = default, O<bool> ScrubbingEnabled = default, O<Uri> Source = default, O<double> SpeedRatio = default, O<Windows.Media.Stretch> Stretch = default, O<Windows.Controls.StretchDirection> StretchDirection = default, O<Windows.Controls.MediaState> UnloadedBehavior = default, O<double> Volume = default)
        {
            var ui = new Windows.Controls.MediaElement();
            if (Balance.HasValue) ui.Balance = Balance.Value;
            if (Clock.HasValue) ui.Clock = Clock.Value;
            if (IsMuted.HasValue) ui.IsMuted = IsMuted.Value;
            if (LoadedBehavior.HasValue) ui.LoadedBehavior = LoadedBehavior.Value;
            if (Position.HasValue) ui.Position = Position.Value;
            if (ScrubbingEnabled.HasValue) ui.ScrubbingEnabled = ScrubbingEnabled.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            if (SpeedRatio.HasValue) ui.SpeedRatio = SpeedRatio.Value;
            if (Stretch.HasValue) ui.Stretch = Stretch.Value;
            if (StretchDirection.HasValue) ui.StretchDirection = StretchDirection.Value;
            if (UnloadedBehavior.HasValue) ui.UnloadedBehavior = UnloadedBehavior.Value;
            if (Volume.HasValue) ui.Volume = Volume.Value;
            return global::CSharpMarkup.Wpf.MediaElement.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.MediaElement"/></summary>
        /// <remarks>Remark: MediaElement().Bind() binds to <see cref="Windows.Controls.MediaElement.SourceProperty"/></remarks>
        public static MediaElement MediaElement()
        {
            var ui = new Windows.Controls.MediaElement();
            return global::CSharpMarkup.Wpf.MediaElement.StartChain(ui);
        }
    }

    public partial class MediaElement : FrameworkElement, IUI<System.Windows.Controls.MediaElement>, IDefaultBindProperty
    {
        static MediaElement instance;

        internal static MediaElement StartChain(Windows.Controls.MediaElement ui)
        {
            if (instance == null) instance = new MediaElement();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.MediaElement ui;

        public new Windows.Controls.MediaElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.MediaElement.SourceProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.MediaElement.SourceProperty;

        public static implicit operator Windows.UIElement(MediaElement view) => view?.UI;

        public static implicit operator Windows.Controls.MediaElement(MediaElement view) => view?.UI;

        public static implicit operator MediaElement(Windows.Controls.MediaElement ui) => MediaElement.StartChain(ui);

        protected MediaElement() { }
    }

    public static partial class MediaElementExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.MediaElement.Balance"/></summary>
        public static TView Balance<TView>(this TView view, double value) where TView : MediaElement { view.UI.Balance = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.Clock"/></summary>
        public static TView Clock<TView>(this TView view, Windows.Media.MediaClock value) where TView : MediaElement { view.UI.Clock = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.IsMuted"/></summary>
        public static TView IsMuted<TView>(this TView view, bool value) where TView : MediaElement { view.UI.IsMuted = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.LoadedBehavior"/></summary>
        public static TView LoadedBehavior<TView>(this TView view, Windows.Controls.MediaState value) where TView : MediaElement { view.UI.LoadedBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.Position"/></summary>
        public static TView Position<TView>(this TView view, TimeSpan value) where TView : MediaElement { view.UI.Position = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.ScrubbingEnabled"/></summary>
        public static TView ScrubbingEnabled<TView>(this TView view, bool value) where TView : MediaElement { view.UI.ScrubbingEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : MediaElement { view.UI.Source = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.SpeedRatio"/></summary>
        public static TView SpeedRatio<TView>(this TView view, double value) where TView : MediaElement { view.UI.SpeedRatio = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : MediaElement { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.StretchDirection"/></summary>
        public static TView StretchDirection<TView>(this TView view, Windows.Controls.StretchDirection value) where TView : MediaElement { view.UI.StretchDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.UnloadedBehavior"/></summary>
        public static TView UnloadedBehavior<TView>(this TView view, Windows.Controls.MediaState value) where TView : MediaElement { view.UI.UnloadedBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MediaElement.Volume"/></summary>
        public static TView Volume<TView>(this TView view, double value) where TView : MediaElement { view.UI.Volume = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.Balance"/></summary>
        public static DependencyProperty<TTarget, double> Balance<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.MediaElement.BalanceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.IsMuted"/></summary>
        public static DependencyProperty<TTarget, bool> IsMuted<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MediaElement.IsMutedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.LoadedBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.MediaState> LoadedBehavior<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, Windows.Controls.MediaState>.Get(target, Windows.Controls.MediaElement.LoadedBehaviorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.ScrubbingEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> ScrubbingEnabled<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MediaElement.ScrubbingEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Controls.MediaElement.SourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.StretchDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StretchDirection> StretchDirection<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, Windows.Controls.StretchDirection>.Get(target, Windows.Controls.MediaElement.StretchDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Controls.MediaElement.StretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.UnloadedBehavior"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.MediaState> UnloadedBehavior<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, Windows.Controls.MediaState>.Get(target, Windows.Controls.MediaElement.UnloadedBehaviorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MediaElement.Volume"/></summary>
        public static DependencyProperty<TTarget, double> Volume<TTarget>(this TTarget target) where TTarget : MediaElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.MediaElement.VolumeProperty);
    }
}

namespace CSharpMarkup.Wpf // Menu
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Menu"/></summary>
        public static Menu Menu(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Menu();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.Menu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Menu"/></summary>
        public static Menu Menu(O<bool> IsMainMenu = default)
        {
            var ui = new Windows.Controls.Menu();
            if (IsMainMenu.HasValue) ui.IsMainMenu = IsMainMenu.Value;
            return global::CSharpMarkup.Wpf.Menu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Menu"/></summary>
        public static Menu Menu()
        {
            var ui = new Windows.Controls.Menu();
            return global::CSharpMarkup.Wpf.Menu.StartChain(ui);
        }
    }

    public partial class Menu : MenuBase, IUI<System.Windows.Controls.Menu>
    {
        static Menu instance;

        internal static Menu StartChain(Windows.Controls.Menu ui)
        {
            if (instance == null) instance = new Menu();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Menu ui;

        public new Windows.Controls.Menu UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Menu view) => view?.UI;

        public static implicit operator Windows.Controls.Menu(Menu view) => view?.UI;

        public static implicit operator Menu(Windows.Controls.Menu ui) => Menu.StartChain(ui);

        protected Menu() { }
    }

    public static partial class MenuExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Menu.IsMainMenu"/></summary>
        public static TView IsMainMenu<TView>(this TView view, bool value) where TView : Menu { view.UI.IsMainMenu = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Menu.IsMainMenu"/></summary>
        public static DependencyProperty<TTarget, bool> IsMainMenu<TTarget>(this TTarget target) where TTarget : Menu
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Menu.IsMainMenuProperty);
    }
}

namespace CSharpMarkup.Wpf // MenuItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.MenuItem"/></summary>
        public static MenuItem MenuItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.MenuItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.MenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.MenuItem"/></summary>
        public static MenuItem MenuItem(O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<object> Icon = default, O<string> InputGestureText = default, O<bool> IsCheckable = default, O<bool> IsChecked = default, O<bool> IsSubmenuOpen = default, O<Windows.Controls.ItemContainerTemplateSelector> ItemContainerTemplateSelector = default, O<bool> StaysOpenOnClick = default, O<bool> UsesItemContainerTemplate = default)
        {
            var ui = new Windows.Controls.MenuItem();
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (Icon.HasValue) ui.Icon = Icon.Value;
            if (InputGestureText.HasValue) ui.InputGestureText = InputGestureText.Value;
            if (IsCheckable.HasValue) ui.IsCheckable = IsCheckable.Value;
            if (IsChecked.HasValue) ui.IsChecked = IsChecked.Value;
            if (IsSubmenuOpen.HasValue) ui.IsSubmenuOpen = IsSubmenuOpen.Value;
            if (ItemContainerTemplateSelector.HasValue) ui.ItemContainerTemplateSelector = ItemContainerTemplateSelector.Value;
            if (StaysOpenOnClick.HasValue) ui.StaysOpenOnClick = StaysOpenOnClick.Value;
            if (UsesItemContainerTemplate.HasValue) ui.UsesItemContainerTemplate = UsesItemContainerTemplate.Value;
            return global::CSharpMarkup.Wpf.MenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.MenuItem"/></summary>
        public static MenuItem MenuItem()
        {
            var ui = new Windows.Controls.MenuItem();
            return global::CSharpMarkup.Wpf.MenuItem.StartChain(ui);
        }
    }

    public partial class MenuItem : HeaderedItemsControl, IUI<System.Windows.Controls.MenuItem>
    {
        static MenuItem instance;

        internal static MenuItem StartChain(Windows.Controls.MenuItem ui)
        {
            if (instance == null) instance = new MenuItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.MenuItem ui;

        public new Windows.Controls.MenuItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(MenuItem view) => view?.UI;

        public static implicit operator Windows.Controls.MenuItem(MenuItem view) => view?.UI;

        public static implicit operator MenuItem(Windows.Controls.MenuItem ui) => MenuItem.StartChain(ui);

        protected MenuItem() { }
    }

    public static partial class MenuItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.MenuItem.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : MenuItem { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : MenuItem { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : MenuItem { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.Icon"/></summary>
        public static TView Icon<TView>(this TView view, object value) where TView : MenuItem { view.UI.Icon = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.InputGestureText"/></summary>
        public static TView InputGestureText<TView>(this TView view, string value) where TView : MenuItem { view.UI.InputGestureText = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.IsCheckable"/></summary>
        public static TView IsCheckable<TView>(this TView view, bool value) where TView : MenuItem { view.UI.IsCheckable = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.IsChecked"/></summary>
        public static TView IsChecked<TView>(this TView view, bool value) where TView : MenuItem { view.UI.IsChecked = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.IsSubmenuOpen"/></summary>
        public static TView IsSubmenuOpen<TView>(this TView view, bool value) where TView : MenuItem { view.UI.IsSubmenuOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.ItemContainerTemplateSelector"/></summary>
        public static TView ItemContainerTemplateSelector<TView>(this TView view, Windows.Controls.ItemContainerTemplateSelector value) where TView : MenuItem { view.UI.ItemContainerTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.StaysOpenOnClick"/></summary>
        public static TView StaysOpenOnClick<TView>(this TView view, bool value) where TView : MenuItem { view.UI.StaysOpenOnClick = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.MenuItem.UsesItemContainerTemplate"/></summary>
        public static TView UsesItemContainerTemplate<TView>(this TView view, bool value) where TView : MenuItem { view.UI.UsesItemContainerTemplate = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.MenuItem.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Controls.MenuItem.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Controls.MenuItem.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.Icon"/></summary>
        public static DependencyProperty<TTarget, object> Icon<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.MenuItem.IconProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.InputGestureText"/></summary>
        public static DependencyProperty<TTarget, string> InputGestureText<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.MenuItem.InputGestureTextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsCheckable"/></summary>
        public static DependencyProperty<TTarget, bool> IsCheckable<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsCheckableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsChecked"/></summary>
        public static DependencyProperty<TTarget, bool> IsChecked<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsCheckedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsHighlighted<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsHighlightedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsPressed"/></summary>
        public static DependencyProperty<TTarget, bool> IsPressed<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsPressedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsSubmenuOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsSubmenuOpen<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsSubmenuOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.IsSuspendingPopupAnimation"/></summary>
        public static DependencyProperty<TTarget, bool> IsSuspendingPopupAnimation<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.IsSuspendingPopupAnimationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.ItemContainerTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector> ItemContainerTemplateSelector<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector>.Get(target, Windows.Controls.MenuItem.ItemContainerTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.Role"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.MenuItemRole> Role<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, Windows.Controls.MenuItemRole>.Get(target, Windows.Controls.MenuItem.RoleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.StaysOpenOnClick"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpenOnClick<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.StaysOpenOnClickProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.MenuItem.UsesItemContainerTemplate"/></summary>
        public static DependencyProperty<TTarget, bool> UsesItemContainerTemplate<TTarget>(this TTarget target) where TTarget : MenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.MenuItem.UsesItemContainerTemplateProperty);
    }
}

namespace CSharpMarkup.Wpf // Page
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Page"/></summary>
        /// <remarks>Remark: Page().Bind() binds to <see cref="Windows.Controls.Page.TitleProperty"/></remarks>
        public static Page Page(
            object Content
)
        {
            var ui = new Windows.Controls.Page();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.Page.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Page"/></summary>
        /// <remarks>Remark: Page().Bind() binds to <see cref="Windows.Controls.Page.TitleProperty"/></remarks>
        public static Page Page(O<Windows.Media.Brush> Background = default, O<object> Content = default, O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.Media.Brush> Foreground = default, O<bool> KeepAlive = default, O<bool> ShowsNavigationUI = default, O<Windows.Controls.ControlTemplate> Template = default, O<string> Title = default, O<double> WindowHeight = default, O<string> WindowTitle = default, O<double> WindowWidth = default)
        {
            var ui = new Windows.Controls.Page();
            if (Background.HasValue) ui.Background = Background.Value;
            if (Content.HasValue) ui.Content = Content.Value;
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (KeepAlive.HasValue) ui.KeepAlive = KeepAlive.Value;
            if (ShowsNavigationUI.HasValue) ui.ShowsNavigationUI = ShowsNavigationUI.Value;
            if (Template.HasValue) ui.Template = Template.Value;
            if (Title.HasValue) ui.Title = Title.Value;
            if (WindowHeight.HasValue) ui.WindowHeight = WindowHeight.Value;
            if (WindowTitle.HasValue) ui.WindowTitle = WindowTitle.Value;
            if (WindowWidth.HasValue) ui.WindowWidth = WindowWidth.Value;
            return global::CSharpMarkup.Wpf.Page.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Page"/></summary>
        /// <remarks>Remark: Page().Bind() binds to <see cref="Windows.Controls.Page.TitleProperty"/></remarks>
        public static Page Page()
        {
            var ui = new Windows.Controls.Page();
            return global::CSharpMarkup.Wpf.Page.StartChain(ui);
        }
    }

    public partial class Page : FrameworkElement, IUI<System.Windows.Controls.Page>, IDefaultBindProperty
    {
        static Page instance;

        internal static Page StartChain(Windows.Controls.Page ui)
        {
            if (instance == null) instance = new Page();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Page ui;

        public new Windows.Controls.Page UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Page.TitleProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Page.TitleProperty;

        public static implicit operator Windows.UIElement(Page view) => view?.UI;

        public static implicit operator Windows.Controls.Page(Page view) => view?.UI;

        public static implicit operator Page(Windows.Controls.Page ui) => Page.StartChain(ui);

        protected Page() { }
    }

    public static partial class PageExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Page.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : Page { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : Page { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : Page { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Content"/></summary>
        public static TView Content<TView>(this TView view, object value) where TView : Page { view.UI.Content = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : Page { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : Page { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : Page { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : Page { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : Page { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.KeepAlive"/></summary>
        public static TView KeepAlive<TView>(this TView view, bool value) where TView : Page { view.UI.KeepAlive = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.ShowsNavigationUI"/></summary>
        public static TView ShowsNavigationUI<TView>(this TView view, bool value) where TView : Page { view.UI.ShowsNavigationUI = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Template"/></summary>
        public static TView Template<TView>(this TView view, Windows.Controls.ControlTemplate value) where TView : Page { view.UI.Template = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.Title"/></summary>
        public static TView Title<TView>(this TView view, string value) where TView : Page { view.UI.Title = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.WindowHeight"/></summary>
        public static TView WindowHeight<TView>(this TView view, double value) where TView : Page { view.UI.WindowHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.WindowTitle"/></summary>
        public static TView WindowTitle<TView>(this TView view, string value) where TView : Page { view.UI.WindowTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Page.WindowWidth"/></summary>
        public static TView WindowWidth<TView>(this TView view, double value) where TView : Page { view.UI.WindowWidth = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Page.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.Content"/></summary>
        public static DependencyProperty<TTarget, object> Content<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Page.ContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.Page.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Page.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Page.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.KeepAlive"/></summary>
        public static DependencyProperty<TTarget, bool> KeepAlive<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Page.KeepAliveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.Template"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ControlTemplate> Template<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, Windows.Controls.ControlTemplate>.Get(target, Windows.Controls.Page.TemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Page.Title"/></summary>
        public static DependencyProperty<TTarget, string> Title<TTarget>(this TTarget target) where TTarget : Page
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Page.TitleProperty);
    }
}

namespace CSharpMarkup.Wpf // Panel
{
    public partial class Panel : FrameworkElement, IUI<System.Windows.Controls.Panel>
    {
        Windows.Controls.Panel ui;

        public new Windows.Controls.Panel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Panel() { }
    }

    public static partial class PanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Panel.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : Panel { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Panel.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : Panel { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Panel.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : Panel { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Panel.IsItemsHost"/></summary>
        public static TView IsItemsHost<TView>(this TView view, bool value) where TView : Panel { view.UI.IsItemsHost = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Panel.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : Panel
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Panel.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Panel.IsItemsHost"/></summary>
        public static DependencyProperty<TTarget, bool> IsItemsHost<TTarget>(this TTarget target) where TTarget : Panel
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Panel.IsItemsHostProperty);

        /// <summary>Set <see cref="Windows.Controls.Panel.ZIndex"/></summary>
        public static TTarget Panel_ZIndex<TTarget>(this TTarget target, int value) where TTarget : UIElement
        { Windows.Controls.Panel.SetZIndex(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Panel.ZIndex"/></summary>
        public static DependencyProperty<TTarget, int> Panel_ZIndex<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Panel.ZIndexProperty);
    }
}

namespace CSharpMarkup.Wpf // PasswordBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.PasswordBox"/></summary>
        public static PasswordBox PasswordBox(O<Windows.Media.Brush> CaretBrush = default, O<bool> IsInactiveSelectionHighlightEnabled = default, O<int> MaxLength = default, O<string> Password = default, O<char> PasswordChar = default, O<Windows.Media.Brush> SelectionBrush = default, O<double> SelectionOpacity = default, O<Windows.Media.Brush> SelectionTextBrush = default)
        {
            var ui = new Windows.Controls.PasswordBox();
            if (CaretBrush.HasValue) ui.CaretBrush = CaretBrush.Value;
            if (IsInactiveSelectionHighlightEnabled.HasValue) ui.IsInactiveSelectionHighlightEnabled = IsInactiveSelectionHighlightEnabled.Value;
            if (MaxLength.HasValue) ui.MaxLength = MaxLength.Value;
            if (Password.HasValue) ui.Password = Password.Value;
            if (PasswordChar.HasValue) ui.PasswordChar = PasswordChar.Value;
            if (SelectionBrush.HasValue) ui.SelectionBrush = SelectionBrush.Value;
            if (SelectionOpacity.HasValue) ui.SelectionOpacity = SelectionOpacity.Value;
            if (SelectionTextBrush.HasValue) ui.SelectionTextBrush = SelectionTextBrush.Value;
            return global::CSharpMarkup.Wpf.PasswordBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.PasswordBox"/></summary>
        public static PasswordBox PasswordBox()
        {
            var ui = new Windows.Controls.PasswordBox();
            return global::CSharpMarkup.Wpf.PasswordBox.StartChain(ui);
        }
    }

    public partial class PasswordBox : Control, IUI<System.Windows.Controls.PasswordBox>
    {
        static PasswordBox instance;

        internal static PasswordBox StartChain(Windows.Controls.PasswordBox ui)
        {
            if (instance == null) instance = new PasswordBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.PasswordBox ui;

        public new Windows.Controls.PasswordBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(PasswordBox view) => view?.UI;

        public static implicit operator Windows.Controls.PasswordBox(PasswordBox view) => view?.UI;

        public static implicit operator PasswordBox(Windows.Controls.PasswordBox ui) => PasswordBox.StartChain(ui);

        protected PasswordBox() { }
    }

    public static partial class PasswordBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.PasswordBox.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, Windows.Media.Brush value) where TView : PasswordBox { view.UI.CaretBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, Color value) where TView : PasswordBox { view.UI.CaretBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, string color) where TView : PasswordBox { view.UI.CaretBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.IsInactiveSelectionHighlightEnabled"/></summary>
        public static TView IsInactiveSelectionHighlightEnabled<TView>(this TView view, bool value) where TView : PasswordBox { view.UI.IsInactiveSelectionHighlightEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.MaxLength"/></summary>
        public static TView MaxLength<TView>(this TView view, int value) where TView : PasswordBox { view.UI.MaxLength = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.Password"/></summary>
        public static TView Password<TView>(this TView view, string value) where TView : PasswordBox { view.UI.Password = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.PasswordChar"/></summary>
        public static TView PasswordChar<TView>(this TView view, char value) where TView : PasswordBox { view.UI.PasswordChar = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Windows.Media.Brush value) where TView : PasswordBox { view.UI.SelectionBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Color value) where TView : PasswordBox { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, string color) where TView : PasswordBox { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionOpacity"/></summary>
        public static TView SelectionOpacity<TView>(this TView view, double value) where TView : PasswordBox { view.UI.SelectionOpacity = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, Windows.Media.Brush value) where TView : PasswordBox { view.UI.SelectionTextBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, Color value) where TView : PasswordBox { view.UI.SelectionTextBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.PasswordBox.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, string color) where TView : PasswordBox { view.UI.SelectionTextBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.CaretBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CaretBrush<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.PasswordBox.CaretBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.IsInactiveSelectionHighlightEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactiveSelectionHighlightEnabled<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.PasswordBox.IsInactiveSelectionHighlightEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.PasswordBox.IsSelectionActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.MaxLength"/></summary>
        public static DependencyProperty<TTarget, int> MaxLength<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.PasswordBox.MaxLengthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.PasswordChar"/></summary>
        public static DependencyProperty<TTarget, char> PasswordChar<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, char>.Get(target, Windows.Controls.PasswordBox.PasswordCharProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.SelectionBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionBrush<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.PasswordBox.SelectionBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.SelectionOpacity"/></summary>
        public static DependencyProperty<TTarget, double> SelectionOpacity<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.PasswordBox.SelectionOpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.PasswordBox.SelectionTextBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionTextBrush<TTarget>(this TTarget target) where TTarget : PasswordBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.PasswordBox.SelectionTextBrushProperty);
    }
}

namespace CSharpMarkup.Wpf // ProgressBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ProgressBar"/></summary>
        public static ProgressBar ProgressBar(O<bool> IsIndeterminate = default, O<Windows.Controls.Orientation> Orientation = default)
        {
            var ui = new Windows.Controls.ProgressBar();
            if (IsIndeterminate.HasValue) ui.IsIndeterminate = IsIndeterminate.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            return global::CSharpMarkup.Wpf.ProgressBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ProgressBar"/></summary>
        public static ProgressBar ProgressBar()
        {
            var ui = new Windows.Controls.ProgressBar();
            return global::CSharpMarkup.Wpf.ProgressBar.StartChain(ui);
        }
    }

    public partial class ProgressBar : RangeBase, IUI<System.Windows.Controls.ProgressBar>
    {
        static ProgressBar instance;

        internal static ProgressBar StartChain(Windows.Controls.ProgressBar ui)
        {
            if (instance == null) instance = new ProgressBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ProgressBar ui;

        public new Windows.Controls.ProgressBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ProgressBar view) => view?.UI;

        public static implicit operator Windows.Controls.ProgressBar(ProgressBar view) => view?.UI;

        public static implicit operator ProgressBar(Windows.Controls.ProgressBar ui) => ProgressBar.StartChain(ui);

        protected ProgressBar() { }
    }

    public static partial class ProgressBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ProgressBar.IsIndeterminate"/></summary>
        public static TView IsIndeterminate<TView>(this TView view, bool value) where TView : ProgressBar { view.UI.IsIndeterminate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ProgressBar.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : ProgressBar { view.UI.Orientation = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ProgressBar.IsIndeterminate"/></summary>
        public static DependencyProperty<TTarget, bool> IsIndeterminate<TTarget>(this TTarget target) where TTarget : ProgressBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ProgressBar.IsIndeterminateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ProgressBar.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : ProgressBar
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.ProgressBar.OrientationProperty);
    }
}

namespace CSharpMarkup.Wpf // RadioButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.RadioButton"/></summary>
        public static RadioButton RadioButton(
            object Content
)
        {
            var ui = new Windows.Controls.RadioButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RadioButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.RadioButton"/></summary>
        public static RadioButton RadioButton(O<string> GroupName = default)
        {
            var ui = new Windows.Controls.RadioButton();
            if (GroupName.HasValue) ui.GroupName = GroupName.Value;
            return global::CSharpMarkup.Wpf.RadioButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.RadioButton"/></summary>
        public static RadioButton RadioButton()
        {
            var ui = new Windows.Controls.RadioButton();
            return global::CSharpMarkup.Wpf.RadioButton.StartChain(ui);
        }
    }

    public partial class RadioButton : ToggleButton, IUI<System.Windows.Controls.RadioButton>
    {
        static RadioButton instance;

        internal static RadioButton StartChain(Windows.Controls.RadioButton ui)
        {
            if (instance == null) instance = new RadioButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.RadioButton ui;

        public new Windows.Controls.RadioButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RadioButton view) => view?.UI;

        public static implicit operator Windows.Controls.RadioButton(RadioButton view) => view?.UI;

        public static implicit operator RadioButton(Windows.Controls.RadioButton ui) => RadioButton.StartChain(ui);

        protected RadioButton() { }
    }

    public static partial class RadioButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.RadioButton.GroupName"/></summary>
        public static TView GroupName<TView>(this TView view, string value) where TView : RadioButton { view.UI.GroupName = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.RadioButton.GroupName"/></summary>
        public static DependencyProperty<TTarget, string> GroupName<TTarget>(this TTarget target) where TTarget : RadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.RadioButton.GroupNameProperty);
    }
}

namespace CSharpMarkup.Wpf // RichTextBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.RichTextBox"/></summary>
        public static RichTextBox RichTextBox(O<Windows.Documents.TextPointer> CaretPosition = default, O<Windows.Documents.FlowDocument> Document = default, O<bool> IsDocumentEnabled = default)
        {
            var ui = new Windows.Controls.RichTextBox();
            if (CaretPosition.HasValue) ui.CaretPosition = CaretPosition.Value;
            if (Document.HasValue) ui.Document = Document.Value;
            if (IsDocumentEnabled.HasValue) ui.IsDocumentEnabled = IsDocumentEnabled.Value;
            return global::CSharpMarkup.Wpf.RichTextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.RichTextBox"/></summary>
        public static RichTextBox RichTextBox()
        {
            var ui = new Windows.Controls.RichTextBox();
            return global::CSharpMarkup.Wpf.RichTextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.RichTextBox"/></summary>
        public static RichTextBox RichTextBox(Windows.Documents.FlowDocument document)
        {
            var ui = new Windows.Controls.RichTextBox(document);
            return global::CSharpMarkup.Wpf.RichTextBox.StartChain(ui);
        }
    }

    public partial class RichTextBox : TextBoxBase, IUI<System.Windows.Controls.RichTextBox>
    {
        static RichTextBox instance;

        internal static RichTextBox StartChain(Windows.Controls.RichTextBox ui)
        {
            if (instance == null) instance = new RichTextBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.RichTextBox ui;

        public new Windows.Controls.RichTextBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RichTextBox view) => view?.UI;

        public static implicit operator Windows.Controls.RichTextBox(RichTextBox view) => view?.UI;

        public static implicit operator RichTextBox(Windows.Controls.RichTextBox ui) => RichTextBox.StartChain(ui);

        protected RichTextBox() { }
    }

    public static partial class RichTextBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.RichTextBox.CaretPosition"/></summary>
        public static TView CaretPosition<TView>(this TView view, Windows.Documents.TextPointer value) where TView : RichTextBox { view.UI.CaretPosition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.RichTextBox.Document"/></summary>
        public static TView Document<TView>(this TView view, Windows.Documents.FlowDocument value) where TView : RichTextBox { view.UI.Document = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.RichTextBox.IsDocumentEnabled"/></summary>
        public static TView IsDocumentEnabled<TView>(this TView view, bool value) where TView : RichTextBox { view.UI.IsDocumentEnabled = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.RichTextBox.IsDocumentEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsDocumentEnabled<TTarget>(this TTarget target) where TTarget : RichTextBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.RichTextBox.IsDocumentEnabledProperty);
    }
}

namespace CSharpMarkup.Wpf // RowDefinition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.RowDefinition"/></summary>
        /// <remarks>Remark: RowDefinition().Bind() binds to <see cref="Windows.Controls.RowDefinition.HeightProperty"/></remarks>
        public static RowDefinition RowDefinition(O<Windows.GridLength> Height = default, O<double> MaxHeight = default, O<double> MinHeight = default)
        {
            var ui = new Windows.Controls.RowDefinition();
            if (Height.HasValue) ui.Height = Height.Value;
            if (MaxHeight.HasValue) ui.MaxHeight = MaxHeight.Value;
            if (MinHeight.HasValue) ui.MinHeight = MinHeight.Value;
            return global::CSharpMarkup.Wpf.RowDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.RowDefinition"/></summary>
        /// <remarks>Remark: RowDefinition().Bind() binds to <see cref="Windows.Controls.RowDefinition.HeightProperty"/></remarks>
        public static RowDefinition RowDefinition()
        {
            var ui = new Windows.Controls.RowDefinition();
            return global::CSharpMarkup.Wpf.RowDefinition.StartChain(ui);
        }
    }

    public partial class RowDefinition : DefinitionBase, IUI<System.Windows.Controls.RowDefinition>, IDefaultBindProperty
    {
        static RowDefinition instance;

        internal static RowDefinition StartChain(Windows.Controls.RowDefinition ui)
        {
            if (instance == null) instance = new RowDefinition();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.RowDefinition ui;

        public new Windows.Controls.RowDefinition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.RowDefinition.HeightProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.RowDefinition.HeightProperty;

        public static implicit operator Windows.Controls.RowDefinition(RowDefinition view) => view?.UI;

        public static implicit operator RowDefinition(Windows.Controls.RowDefinition ui) => RowDefinition.StartChain(ui);

        protected RowDefinition() { }
    }

    public static partial class RowDefinitionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.RowDefinition.Height"/></summary>
        public static TView Height<TView>(this TView view, Windows.GridLength value) where TView : RowDefinition { view.UI.Height = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.RowDefinition.MaxHeight"/></summary>
        public static TView MaxHeight<TView>(this TView view, double value) where TView : RowDefinition { view.UI.MaxHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.RowDefinition.MinHeight"/></summary>
        public static TView MinHeight<TView>(this TView view, double value) where TView : RowDefinition { view.UI.MinHeight = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.RowDefinition.Height"/></summary>
        public static DependencyProperty<TTarget, Windows.GridLength> Height<TTarget>(this TTarget target) where TTarget : RowDefinition
        => DependencyProperty<TTarget, Windows.GridLength>.Get(target, Windows.Controls.RowDefinition.HeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.RowDefinition.MaxHeight"/></summary>
        public static DependencyProperty<TTarget, double> MaxHeight<TTarget>(this TTarget target) where TTarget : RowDefinition
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.RowDefinition.MaxHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.RowDefinition.MinHeight"/></summary>
        public static DependencyProperty<TTarget, double> MinHeight<TTarget>(this TTarget target) where TTarget : RowDefinition
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.RowDefinition.MinHeightProperty);
    }
}

namespace CSharpMarkup.Wpf // ScrollContentPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ScrollContentPresenter"/></summary>
        public static ScrollContentPresenter ScrollContentPresenter(O<bool> CanContentScroll = default, O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.ScrollContentPresenter();
            if (CanContentScroll.HasValue) ui.CanContentScroll = CanContentScroll.Value;
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.ScrollContentPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ScrollContentPresenter"/></summary>
        public static ScrollContentPresenter ScrollContentPresenter()
        {
            var ui = new Windows.Controls.ScrollContentPresenter();
            return global::CSharpMarkup.Wpf.ScrollContentPresenter.StartChain(ui);
        }
    }

    public partial class ScrollContentPresenter : ContentPresenter, IUI<System.Windows.Controls.ScrollContentPresenter>
    {
        static ScrollContentPresenter instance;

        internal static ScrollContentPresenter StartChain(Windows.Controls.ScrollContentPresenter ui)
        {
            if (instance == null) instance = new ScrollContentPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ScrollContentPresenter ui;

        public new Windows.Controls.ScrollContentPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ScrollContentPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.ScrollContentPresenter(ScrollContentPresenter view) => view?.UI;

        public static implicit operator ScrollContentPresenter(Windows.Controls.ScrollContentPresenter ui) => ScrollContentPresenter.StartChain(ui);

        protected ScrollContentPresenter() { }
    }

    public static partial class ScrollContentPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ScrollContentPresenter.CanContentScroll"/></summary>
        public static TView CanContentScroll<TView>(this TView view, bool value) where TView : ScrollContentPresenter { view.UI.CanContentScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollContentPresenter.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : ScrollContentPresenter { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollContentPresenter.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : ScrollContentPresenter { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollContentPresenter.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : ScrollContentPresenter { view.UI.ScrollOwner = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollContentPresenter.CanContentScroll"/></summary>
        public static DependencyProperty<TTarget, bool> CanContentScroll<TTarget>(this TTarget target) where TTarget : ScrollContentPresenter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ScrollContentPresenter.CanContentScrollProperty);
    }
}

namespace CSharpMarkup.Wpf // ScrollViewer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ScrollViewer"/></summary>
        public static ScrollViewer ScrollViewer(
            object Content
)
        {
            var ui = new Windows.Controls.ScrollViewer();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ScrollViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ScrollViewer"/></summary>
        public static ScrollViewer ScrollViewer(O<bool> CanContentScroll = default, O<Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility = default, O<bool> IsDeferredScrollingEnabled = default, O<double> PanningDeceleration = default, O<Windows.Controls.PanningMode> PanningMode = default, O<double> PanningRatio = default, O<Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility = default)
        {
            var ui = new Windows.Controls.ScrollViewer();
            if (CanContentScroll.HasValue) ui.CanContentScroll = CanContentScroll.Value;
            if (HorizontalScrollBarVisibility.HasValue) ui.HorizontalScrollBarVisibility = HorizontalScrollBarVisibility.Value;
            if (IsDeferredScrollingEnabled.HasValue) ui.IsDeferredScrollingEnabled = IsDeferredScrollingEnabled.Value;
            if (PanningDeceleration.HasValue) ui.PanningDeceleration = PanningDeceleration.Value;
            if (PanningMode.HasValue) ui.PanningMode = PanningMode.Value;
            if (PanningRatio.HasValue) ui.PanningRatio = PanningRatio.Value;
            if (VerticalScrollBarVisibility.HasValue) ui.VerticalScrollBarVisibility = VerticalScrollBarVisibility.Value;
            return global::CSharpMarkup.Wpf.ScrollViewer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ScrollViewer"/></summary>
        public static ScrollViewer ScrollViewer()
        {
            var ui = new Windows.Controls.ScrollViewer();
            return global::CSharpMarkup.Wpf.ScrollViewer.StartChain(ui);
        }
    }

    public partial class ScrollViewer : ContentControl, IUI<System.Windows.Controls.ScrollViewer>
    {
        static ScrollViewer instance;

        internal static ScrollViewer StartChain(Windows.Controls.ScrollViewer ui)
        {
            if (instance == null) instance = new ScrollViewer();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ScrollViewer ui;

        public new Windows.Controls.ScrollViewer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ScrollViewer view) => view?.UI;

        public static implicit operator Windows.Controls.ScrollViewer(ScrollViewer view) => view?.UI;

        public static implicit operator ScrollViewer(Windows.Controls.ScrollViewer ui) => ScrollViewer.StartChain(ui);

        protected ScrollViewer() { }
    }

    public static partial class ScrollViewerExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.CanContentScroll"/></summary>
        public static TView CanContentScroll<TView>(this TView view, bool value) where TView : ScrollViewer { view.UI.CanContentScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static TView HorizontalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : ScrollViewer { view.UI.HorizontalScrollBarVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled"/></summary>
        public static TView IsDeferredScrollingEnabled<TView>(this TView view, bool value) where TView : ScrollViewer { view.UI.IsDeferredScrollingEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningDeceleration"/></summary>
        public static TView PanningDeceleration<TView>(this TView view, double value) where TView : ScrollViewer { view.UI.PanningDeceleration = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningMode"/></summary>
        public static TView PanningMode<TView>(this TView view, Windows.Controls.PanningMode value) where TView : ScrollViewer { view.UI.PanningMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningRatio"/></summary>
        public static TView PanningRatio<TView>(this TView view, double value) where TView : ScrollViewer { view.UI.PanningRatio = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static TView VerticalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : ScrollViewer { view.UI.VerticalScrollBarVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.CanContentScroll"/></summary>
        public static DependencyProperty<TTarget, bool> CanContentScroll<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ScrollViewer.CanContentScrollProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> ComputedHorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> ComputedVerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ContentHorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> ContentHorizontalOffset<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ContentHorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ContentVerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> ContentVerticalOffset<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ContentVerticalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ExtentHeight"/></summary>
        public static DependencyProperty<TTarget, double> ExtentHeight<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ExtentHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ExtentWidth"/></summary>
        public static DependencyProperty<TTarget, double> ExtentWidth<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ExtentWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsDeferredScrollingEnabled<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ScrollViewer.IsDeferredScrollingEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningDeceleration"/></summary>
        public static DependencyProperty<TTarget, double> PanningDeceleration<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.PanningDecelerationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.PanningMode> PanningMode<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, Windows.Controls.PanningMode>.Get(target, Windows.Controls.ScrollViewer.PanningModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningRatio"/></summary>
        public static DependencyProperty<TTarget, double> PanningRatio<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.PanningRatioProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ScrollableHeight"/></summary>
        public static DependencyProperty<TTarget, double> ScrollableHeight<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ScrollableHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ScrollableWidth"/></summary>
        public static DependencyProperty<TTarget, double> ScrollableWidth<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ScrollableWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.VerticalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ViewportHeight"/></summary>
        public static DependencyProperty<TTarget, double> ViewportHeight<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ViewportHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.ViewportWidth"/></summary>
        public static DependencyProperty<TTarget, double> ViewportWidth<TTarget>(this TTarget target) where TTarget : ScrollViewer
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.ViewportWidthProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.CanContentScroll"/></summary>
        public static TTarget ScrollViewer_CanContentScroll<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetCanContentScroll(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.CanContentScroll"/></summary>
        public static DependencyProperty<TTarget, bool> ScrollViewer_CanContentScroll<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ScrollViewer.CanContentScrollProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static TTarget ScrollViewer_HorizontalScrollBarVisibility<TTarget>(this TTarget target, Windows.Controls.ScrollBarVisibility value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetHorizontalScrollBarVisibility(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> ScrollViewer_HorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled"/></summary>
        public static TTarget ScrollViewer_IsDeferredScrollingEnabled<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetIsDeferredScrollingEnabled(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> ScrollViewer_IsDeferredScrollingEnabled<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ScrollViewer.IsDeferredScrollingEnabledProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningDeceleration"/></summary>
        public static TTarget ScrollViewer_PanningDeceleration<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetPanningDeceleration(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningDeceleration"/></summary>
        public static DependencyProperty<TTarget, double> ScrollViewer_PanningDeceleration<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.PanningDecelerationProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningMode"/></summary>
        public static TTarget ScrollViewer_PanningMode<TTarget>(this TTarget target, Windows.Controls.PanningMode value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetPanningMode(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.PanningMode> ScrollViewer_PanningMode<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.PanningMode>.Get(target, Windows.Controls.ScrollViewer.PanningModeProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.PanningRatio"/></summary>
        public static TTarget ScrollViewer_PanningRatio<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetPanningRatio(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.PanningRatio"/></summary>
        public static DependencyProperty<TTarget, double> ScrollViewer_PanningRatio<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ScrollViewer.PanningRatioProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static TTarget ScrollViewer_VerticalScrollBarVisibility<TTarget>(this TTarget target, Windows.Controls.ScrollBarVisibility value) where TTarget : DependencyObject
        { Windows.Controls.ScrollViewer.SetVerticalScrollBarVisibility(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ScrollViewer.VerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> ScrollViewer_VerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty);

        /// <summary>Set <see cref="Windows.Controls.ScrollViewer"/> attached properties</summary>
        public static TTarget ScrollViewer<TTarget>(this TTarget target

            , O<bool> CanContentScroll = default

            , O<Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility = default

            , O<bool> IsDeferredScrollingEnabled = default

            , O<double> PanningDeceleration = default

            , O<Windows.Controls.PanningMode> PanningMode = default

            , O<double> PanningRatio = default

            , O<Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility = default

        ) where TTarget : DependencyObject
        {
            if (CanContentScroll.HasValue) Windows.Controls.ScrollViewer.SetCanContentScroll(target.UI, CanContentScroll.Value);

            if (HorizontalScrollBarVisibility.HasValue) Windows.Controls.ScrollViewer.SetHorizontalScrollBarVisibility(target.UI, HorizontalScrollBarVisibility.Value);

            if (IsDeferredScrollingEnabled.HasValue) Windows.Controls.ScrollViewer.SetIsDeferredScrollingEnabled(target.UI, IsDeferredScrollingEnabled.Value);

            if (PanningDeceleration.HasValue) Windows.Controls.ScrollViewer.SetPanningDeceleration(target.UI, PanningDeceleration.Value);

            if (PanningMode.HasValue) Windows.Controls.ScrollViewer.SetPanningMode(target.UI, PanningMode.Value);

            if (PanningRatio.HasValue) Windows.Controls.ScrollViewer.SetPanningRatio(target.UI, PanningRatio.Value);

            if (VerticalScrollBarVisibility.HasValue) Windows.Controls.ScrollViewer.SetVerticalScrollBarVisibility(target.UI, VerticalScrollBarVisibility.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // Separator
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Separator"/></summary>
        public static Separator Separator()
        {
            var ui = new Windows.Controls.Separator();
            return global::CSharpMarkup.Wpf.Separator.StartChain(ui);
        }
    }

    public partial class Separator : Control, IUI<System.Windows.Controls.Separator>
    {
        static Separator instance;

        internal static Separator StartChain(Windows.Controls.Separator ui)
        {
            if (instance == null) instance = new Separator();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Separator ui;

        public new Windows.Controls.Separator UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Separator view) => view?.UI;

        public static implicit operator Windows.Controls.Separator(Separator view) => view?.UI;

        public static implicit operator Separator(Windows.Controls.Separator ui) => Separator.StartChain(ui);

        protected Separator() { }
    }
}

namespace CSharpMarkup.Wpf // Slider
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Slider"/></summary>
        public static Slider Slider(O<Windows.Controls.Primitives.AutoToolTipPlacement> AutoToolTipPlacement = default, O<int> AutoToolTipPrecision = default, O<int> Delay = default, O<int> Interval = default, O<bool> IsDirectionReversed = default, O<bool> IsMoveToPointEnabled = default, O<bool> IsSelectionRangeEnabled = default, O<bool> IsSnapToTickEnabled = default, O<Windows.Controls.Orientation> Orientation = default, O<double> SelectionEnd = default, O<double> SelectionStart = default, O<double> TickFrequency = default, O<Windows.Controls.Primitives.TickPlacement> TickPlacement = default, O<Windows.Media.DoubleCollection> Ticks = default)
        {
            var ui = new Windows.Controls.Slider();
            if (AutoToolTipPlacement.HasValue) ui.AutoToolTipPlacement = AutoToolTipPlacement.Value;
            if (AutoToolTipPrecision.HasValue) ui.AutoToolTipPrecision = AutoToolTipPrecision.Value;
            if (Delay.HasValue) ui.Delay = Delay.Value;
            if (Interval.HasValue) ui.Interval = Interval.Value;
            if (IsDirectionReversed.HasValue) ui.IsDirectionReversed = IsDirectionReversed.Value;
            if (IsMoveToPointEnabled.HasValue) ui.IsMoveToPointEnabled = IsMoveToPointEnabled.Value;
            if (IsSelectionRangeEnabled.HasValue) ui.IsSelectionRangeEnabled = IsSelectionRangeEnabled.Value;
            if (IsSnapToTickEnabled.HasValue) ui.IsSnapToTickEnabled = IsSnapToTickEnabled.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            if (SelectionEnd.HasValue) ui.SelectionEnd = SelectionEnd.Value;
            if (SelectionStart.HasValue) ui.SelectionStart = SelectionStart.Value;
            if (TickFrequency.HasValue) ui.TickFrequency = TickFrequency.Value;
            if (TickPlacement.HasValue) ui.TickPlacement = TickPlacement.Value;
            if (Ticks.HasValue) ui.Ticks = Ticks.Value;
            return global::CSharpMarkup.Wpf.Slider.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Slider"/></summary>
        public static Slider Slider()
        {
            var ui = new Windows.Controls.Slider();
            return global::CSharpMarkup.Wpf.Slider.StartChain(ui);
        }
    }

    public partial class Slider : RangeBase, IUI<System.Windows.Controls.Slider>
    {
        static Slider instance;

        internal static Slider StartChain(Windows.Controls.Slider ui)
        {
            if (instance == null) instance = new Slider();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Slider ui;

        public new Windows.Controls.Slider UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Slider view) => view?.UI;

        public static implicit operator Windows.Controls.Slider(Slider view) => view?.UI;

        public static implicit operator Slider(Windows.Controls.Slider ui) => Slider.StartChain(ui);

        protected Slider() { }
    }

    public static partial class SliderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Slider.AutoToolTipPlacement"/></summary>
        public static TView AutoToolTipPlacement<TView>(this TView view, Windows.Controls.Primitives.AutoToolTipPlacement value) where TView : Slider { view.UI.AutoToolTipPlacement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.AutoToolTipPrecision"/></summary>
        public static TView AutoToolTipPrecision<TView>(this TView view, int value) where TView : Slider { view.UI.AutoToolTipPrecision = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.Delay"/></summary>
        public static TView Delay<TView>(this TView view, int value) where TView : Slider { view.UI.Delay = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.Interval"/></summary>
        public static TView Interval<TView>(this TView view, int value) where TView : Slider { view.UI.Interval = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.IsDirectionReversed"/></summary>
        public static TView IsDirectionReversed<TView>(this TView view, bool value) where TView : Slider { view.UI.IsDirectionReversed = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.IsMoveToPointEnabled"/></summary>
        public static TView IsMoveToPointEnabled<TView>(this TView view, bool value) where TView : Slider { view.UI.IsMoveToPointEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.IsSelectionRangeEnabled"/></summary>
        public static TView IsSelectionRangeEnabled<TView>(this TView view, bool value) where TView : Slider { view.UI.IsSelectionRangeEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.IsSnapToTickEnabled"/></summary>
        public static TView IsSnapToTickEnabled<TView>(this TView view, bool value) where TView : Slider { view.UI.IsSnapToTickEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : Slider { view.UI.Orientation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.SelectionEnd"/></summary>
        public static TView SelectionEnd<TView>(this TView view, double value) where TView : Slider { view.UI.SelectionEnd = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.SelectionStart"/></summary>
        public static TView SelectionStart<TView>(this TView view, double value) where TView : Slider { view.UI.SelectionStart = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.TickFrequency"/></summary>
        public static TView TickFrequency<TView>(this TView view, double value) where TView : Slider { view.UI.TickFrequency = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.TickPlacement"/></summary>
        public static TView TickPlacement<TView>(this TView view, Windows.Controls.Primitives.TickPlacement value) where TView : Slider { view.UI.TickPlacement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Slider.Ticks"/></summary>
        public static TView Ticks<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : Slider { view.UI.Ticks = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.AutoToolTipPlacement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.AutoToolTipPlacement> AutoToolTipPlacement<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, Windows.Controls.Primitives.AutoToolTipPlacement>.Get(target, Windows.Controls.Slider.AutoToolTipPlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.AutoToolTipPrecision"/></summary>
        public static DependencyProperty<TTarget, int> AutoToolTipPrecision<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Slider.AutoToolTipPrecisionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.Delay"/></summary>
        public static DependencyProperty<TTarget, int> Delay<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Slider.DelayProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.Interval"/></summary>
        public static DependencyProperty<TTarget, int> Interval<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Slider.IntervalProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.IsDirectionReversed"/></summary>
        public static DependencyProperty<TTarget, bool> IsDirectionReversed<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Slider.IsDirectionReversedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.IsMoveToPointEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsMoveToPointEnabled<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Slider.IsMoveToPointEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.IsSelectionRangeEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionRangeEnabled<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Slider.IsSelectionRangeEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.IsSnapToTickEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsSnapToTickEnabled<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Slider.IsSnapToTickEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.Slider.OrientationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.SelectionEnd"/></summary>
        public static DependencyProperty<TTarget, double> SelectionEnd<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Slider.SelectionEndProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.SelectionStart"/></summary>
        public static DependencyProperty<TTarget, double> SelectionStart<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Slider.SelectionStartProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.TickFrequency"/></summary>
        public static DependencyProperty<TTarget, double> TickFrequency<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Slider.TickFrequencyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.TickPlacement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement> TickPlacement<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement>.Get(target, Windows.Controls.Slider.TickPlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Slider.Ticks"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> Ticks<TTarget>(this TTarget target) where TTarget : Slider
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Controls.Slider.TicksProperty);
    }
}

namespace CSharpMarkup.Wpf // SoundPlayerAction
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.SoundPlayerAction"/></summary>
        /// <remarks>Remark: SoundPlayerAction().Bind() binds to <see cref="Windows.Controls.SoundPlayerAction.SourceProperty"/></remarks>
        public static SoundPlayerAction SoundPlayerAction(O<Uri> Source = default)
        {
            var ui = new Windows.Controls.SoundPlayerAction();
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.SoundPlayerAction.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.SoundPlayerAction"/></summary>
        /// <remarks>Remark: SoundPlayerAction().Bind() binds to <see cref="Windows.Controls.SoundPlayerAction.SourceProperty"/></remarks>
        public static SoundPlayerAction SoundPlayerAction()
        {
            var ui = new Windows.Controls.SoundPlayerAction();
            return global::CSharpMarkup.Wpf.SoundPlayerAction.StartChain(ui);
        }
    }

    public partial class SoundPlayerAction : TriggerAction, IUI<System.Windows.Controls.SoundPlayerAction>, IDefaultBindProperty
    {
        static SoundPlayerAction instance;

        internal static SoundPlayerAction StartChain(Windows.Controls.SoundPlayerAction ui)
        {
            if (instance == null) instance = new SoundPlayerAction();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.SoundPlayerAction ui;

        public new Windows.Controls.SoundPlayerAction UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.SoundPlayerAction.SourceProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.SoundPlayerAction.SourceProperty;

        public static implicit operator Windows.Controls.SoundPlayerAction(SoundPlayerAction view) => view?.UI;

        public static implicit operator SoundPlayerAction(Windows.Controls.SoundPlayerAction ui) => SoundPlayerAction.StartChain(ui);

        protected SoundPlayerAction() { }
    }

    public static partial class SoundPlayerActionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.SoundPlayerAction.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : SoundPlayerAction { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.SoundPlayerAction.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : SoundPlayerAction
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Controls.SoundPlayerAction.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // StackPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.StackPanel"/></summary>
        public static StackPanel StackPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.StackPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.StackPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.StackPanel"/></summary>
        public static StackPanel StackPanel(O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.Orientation> Orientation = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.StackPanel();
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.StackPanel.StartChain(ui);
        }
    }

    public partial class StackPanel : Panel, IUI<System.Windows.Controls.StackPanel>
    {
        static StackPanel instance;

        internal static StackPanel StartChain(Windows.Controls.StackPanel ui)
        {
            if (instance == null) instance = new StackPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.StackPanel ui;

        public new Windows.Controls.StackPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(StackPanel view) => view?.UI;

        public static implicit operator Windows.Controls.StackPanel(StackPanel view) => view?.UI;

        public static implicit operator StackPanel(Windows.Controls.StackPanel ui) => StackPanel.StartChain(ui);

        protected StackPanel() { }
    }

    public static partial class StackPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.StackPanel.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : StackPanel { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StackPanel.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : StackPanel { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StackPanel.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : StackPanel { view.UI.Orientation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StackPanel.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : StackPanel { view.UI.ScrollOwner = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StackPanel.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : StackPanel
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.StackPanel.OrientationProperty);
    }
}

namespace CSharpMarkup.Wpf // StickyNoteControl
{
    public partial class StickyNoteControl : Control, IUI<System.Windows.Controls.StickyNoteControl>
    {
        Windows.Controls.StickyNoteControl ui;

        public new Windows.Controls.StickyNoteControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected StickyNoteControl() { }
    }

    public static partial class StickyNoteControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.CaptionFontFamily"/></summary>
        public static TView CaptionFontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : StickyNoteControl { view.UI.CaptionFontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.CaptionFontSize"/></summary>
        public static TView CaptionFontSize<TView>(this TView view, double value) where TView : StickyNoteControl { view.UI.CaptionFontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.CaptionFontStretch"/></summary>
        public static TView CaptionFontStretch<TView>(this TView view, Windows.FontStretch value) where TView : StickyNoteControl { view.UI.CaptionFontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.CaptionFontStyle"/></summary>
        public static TView CaptionFontStyle<TView>(this TView view, Windows.FontStyle value) where TView : StickyNoteControl { view.UI.CaptionFontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.CaptionFontWeight"/></summary>
        public static TView CaptionFontWeight<TView>(this TView view, Windows.FontWeight value) where TView : StickyNoteControl { view.UI.CaptionFontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.IsExpanded"/></summary>
        public static TView IsExpanded<TView>(this TView view, bool value) where TView : StickyNoteControl { view.UI.IsExpanded = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.StickyNoteControl.PenWidth"/></summary>
        public static TView PenWidth<TView>(this TView view, double value) where TView : StickyNoteControl { view.UI.PenWidth = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.Author"/></summary>
        public static DependencyProperty<TTarget, string> Author<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.StickyNoteControl.AuthorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.CaptionFontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> CaptionFontFamily<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.StickyNoteControl.CaptionFontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.CaptionFontSize"/></summary>
        public static DependencyProperty<TTarget, double> CaptionFontSize<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.StickyNoteControl.CaptionFontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.CaptionFontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> CaptionFontStretch<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Controls.StickyNoteControl.CaptionFontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.CaptionFontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> CaptionFontStyle<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.StickyNoteControl.CaptionFontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.CaptionFontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> CaptionFontWeight<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.StickyNoteControl.CaptionFontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.IsActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsActive<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.StickyNoteControl.IsActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.IsExpanded"/></summary>
        public static DependencyProperty<TTarget, bool> IsExpanded<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.StickyNoteControl.IsExpandedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.IsMouseOverAnchor"/></summary>
        public static DependencyProperty<TTarget, bool> IsMouseOverAnchor<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.StickyNoteControl.IsMouseOverAnchorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.PenWidth"/></summary>
        public static DependencyProperty<TTarget, double> PenWidth<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.StickyNoteControl.PenWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.StickyNoteControl.StickyNoteType"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StickyNoteType> StickyNoteType<TTarget>(this TTarget target) where TTarget : StickyNoteControl
        => DependencyProperty<TTarget, Windows.Controls.StickyNoteType>.Get(target, Windows.Controls.StickyNoteControl.StickyNoteTypeProperty);
    }
}

namespace CSharpMarkup.Wpf // TabControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TabControl"/></summary>
        public static TabControl TabControl(
            params object[] Items
)
        {
            var ui = new Windows.Controls.TabControl();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.TabControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TabControl"/></summary>
        public static TabControl TabControl(O<string> ContentStringFormat = default, O<Windows.DataTemplate> ContentTemplate = default, O<Windows.Controls.DataTemplateSelector> ContentTemplateSelector = default, O<Windows.Controls.Dock> TabStripPlacement = default)
        {
            var ui = new Windows.Controls.TabControl();
            if (ContentStringFormat.HasValue) ui.ContentStringFormat = ContentStringFormat.Value;
            if (ContentTemplate.HasValue) ui.ContentTemplate = ContentTemplate.Value;
            if (ContentTemplateSelector.HasValue) ui.ContentTemplateSelector = ContentTemplateSelector.Value;
            if (TabStripPlacement.HasValue) ui.TabStripPlacement = TabStripPlacement.Value;
            return global::CSharpMarkup.Wpf.TabControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TabControl"/></summary>
        public static TabControl TabControl()
        {
            var ui = new Windows.Controls.TabControl();
            return global::CSharpMarkup.Wpf.TabControl.StartChain(ui);
        }
    }

    public partial class TabControl : Selector, IUI<System.Windows.Controls.TabControl>
    {
        static TabControl instance;

        internal static TabControl StartChain(Windows.Controls.TabControl ui)
        {
            if (instance == null) instance = new TabControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TabControl ui;

        public new Windows.Controls.TabControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TabControl view) => view?.UI;

        public static implicit operator Windows.Controls.TabControl(TabControl view) => view?.UI;

        public static implicit operator TabControl(Windows.Controls.TabControl ui) => TabControl.StartChain(ui);

        protected TabControl() { }
    }

    public static partial class TabControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TabControl.ContentStringFormat"/></summary>
        public static TView ContentStringFormat<TView>(this TView view, string value) where TView : TabControl { view.UI.ContentStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TabControl.ContentTemplate"/></summary>
        public static TView ContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : TabControl { view.UI.ContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TabControl.ContentTemplateSelector"/></summary>
        public static TView ContentTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : TabControl { view.UI.ContentTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TabControl.TabStripPlacement"/></summary>
        public static TView TabStripPlacement<TView>(this TView view, Windows.Controls.Dock value) where TView : TabControl { view.UI.TabStripPlacement = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.ContentStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> ContentStringFormat<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TabControl.ContentStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.ContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ContentTemplate<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.TabControl.ContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.ContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> ContentTemplateSelector<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.TabControl.ContentTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.SelectedContent"/></summary>
        public static DependencyProperty<TTarget, object> SelectedContent<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.TabControl.SelectedContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.SelectedContentStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> SelectedContentStringFormat<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TabControl.SelectedContentStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.SelectedContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> SelectedContentTemplate<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.TabControl.SelectedContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.SelectedContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> SelectedContentTemplateSelector<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.TabControl.SelectedContentTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabControl.TabStripPlacement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Dock> TabStripPlacement<TTarget>(this TTarget target) where TTarget : TabControl
        => DependencyProperty<TTarget, Windows.Controls.Dock>.Get(target, Windows.Controls.TabControl.TabStripPlacementProperty);
    }
}

namespace CSharpMarkup.Wpf // TabItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TabItem"/></summary>
        public static TabItem TabItem(
            object Content
)
        {
            var ui = new Windows.Controls.TabItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.TabItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TabItem"/></summary>
        public static TabItem TabItem(O<bool> IsSelected = default)
        {
            var ui = new Windows.Controls.TabItem();
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            return global::CSharpMarkup.Wpf.TabItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TabItem"/></summary>
        public static TabItem TabItem()
        {
            var ui = new Windows.Controls.TabItem();
            return global::CSharpMarkup.Wpf.TabItem.StartChain(ui);
        }
    }

    public partial class TabItem : HeaderedContentControl, IUI<System.Windows.Controls.TabItem>
    {
        static TabItem instance;

        internal static TabItem StartChain(Windows.Controls.TabItem ui)
        {
            if (instance == null) instance = new TabItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TabItem ui;

        public new Windows.Controls.TabItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TabItem view) => view?.UI;

        public static implicit operator Windows.Controls.TabItem(TabItem view) => view?.UI;

        public static implicit operator TabItem(Windows.Controls.TabItem ui) => TabItem.StartChain(ui);

        protected TabItem() { }
    }

    public static partial class TabItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TabItem.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : TabItem { view.UI.IsSelected = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabItem.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : TabItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.TabItem.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TabItem.TabStripPlacement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Dock> TabStripPlacement<TTarget>(this TTarget target) where TTarget : TabItem
        => DependencyProperty<TTarget, Windows.Controls.Dock>.Get(target, Windows.Controls.TabItem.TabStripPlacementProperty);
    }
}

namespace CSharpMarkup.Wpf // TextBlock
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TextBlock"/></summary>
        /// <remarks>Remark: TextBlock().Bind() binds to <see cref="Windows.Controls.TextBlock.TextProperty"/></remarks>
        public static TextBlock TextBlock(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Controls.TextBlock();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.TextBlock.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBlock"/></summary>
        /// <remarks>Remark: TextBlock().Bind() binds to <see cref="Windows.Controls.TextBlock.TextProperty"/></remarks>
        public static TextBlock TextBlock(O<Windows.Media.Brush> Background = default, O<double> BaselineOffset = default, O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.FontStretch> FontStretch = default, O<Windows.FontStyle> FontStyle = default, O<Windows.FontWeight> FontWeight = default, O<Windows.Media.Brush> Foreground = default, O<bool> IsHyphenationEnabled = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<Windows.Thickness> Padding = default, O<string> Text = default, O<Windows.TextAlignment> TextAlignment = default, O<Windows.TextDecorationCollection> TextDecorations = default, O<Windows.Media.TextEffectCollection> TextEffects = default, O<Windows.TextTrimming> TextTrimming = default, O<Windows.TextWrapping> TextWrapping = default)
        {
            var ui = new Windows.Controls.TextBlock();
            if (Background.HasValue) ui.Background = Background.Value;
            if (BaselineOffset.HasValue) ui.BaselineOffset = BaselineOffset.Value;
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (FontStretch.HasValue) ui.FontStretch = FontStretch.Value;
            if (FontStyle.HasValue) ui.FontStyle = FontStyle.Value;
            if (FontWeight.HasValue) ui.FontWeight = FontWeight.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (IsHyphenationEnabled.HasValue) ui.IsHyphenationEnabled = IsHyphenationEnabled.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            if (TextDecorations.HasValue) ui.TextDecorations = TextDecorations.Value;
            if (TextEffects.HasValue) ui.TextEffects = TextEffects.Value;
            if (TextTrimming.HasValue) ui.TextTrimming = TextTrimming.Value;
            if (TextWrapping.HasValue) ui.TextWrapping = TextWrapping.Value;
            return global::CSharpMarkup.Wpf.TextBlock.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBlock"/></summary>
        /// <remarks>Remark: TextBlock().Bind() binds to <see cref="Windows.Controls.TextBlock.TextProperty"/></remarks>
        public static partial TextBlock TextBlock(string Text)
        {
            var ui = new Windows.Controls.TextBlock();
            ui.Text = Text;
            return global::CSharpMarkup.Wpf.TextBlock.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBlock"/></summary>
        /// <remarks>Remark: TextBlock().Bind() binds to <see cref="Windows.Controls.TextBlock.TextProperty"/></remarks>
        public static TextBlock TextBlock()
        {
            var ui = new Windows.Controls.TextBlock();
            return global::CSharpMarkup.Wpf.TextBlock.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBlock"/></summary>
        /// <remarks>Remark: TextBlock().Bind() binds to <see cref="Windows.Controls.TextBlock.TextProperty"/></remarks>
        public static TextBlock TextBlock(Windows.Documents.Inline inline)
        {
            var ui = new Windows.Controls.TextBlock(inline);
            return global::CSharpMarkup.Wpf.TextBlock.StartChain(ui);
        }
    }

    public partial class TextBlock : FrameworkElement, IUI<System.Windows.Controls.TextBlock>, IDefaultBindProperty
    {
        static TextBlock instance;

        internal static TextBlock StartChain(Windows.Controls.TextBlock ui)
        {
            if (instance == null) instance = new TextBlock();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TextBlock ui;

        public new Windows.Controls.TextBlock UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.TextBlock.TextProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.TextBlock.TextProperty;

        public static implicit operator Windows.UIElement(TextBlock view) => view?.UI;

        public static implicit operator Windows.Controls.TextBlock(TextBlock view) => view?.UI;

        public static implicit operator TextBlock(Windows.Controls.TextBlock ui) => TextBlock.StartChain(ui);

        protected TextBlock() { }
    }

    public static partial class TextBlockExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TextBlock.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : TextBlock { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : TextBlock { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : TextBlock { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.BaselineOffset"/></summary>
        public static TView BaselineOffset<TView>(this TView view, double value) where TView : TextBlock { view.UI.BaselineOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : TextBlock { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : TextBlock { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontStretch"/></summary>
        public static TView FontStretch<TView>(this TView view, Windows.FontStretch value) where TView : TextBlock { view.UI.FontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : TextBlock { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : TextBlock { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : TextBlock { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : TextBlock { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : TextBlock { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.IsHyphenationEnabled"/></summary>
        public static TView IsHyphenationEnabled<TView>(this TView view, bool value) where TView : TextBlock { view.UI.IsHyphenationEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : TextBlock { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : TextBlock { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : TextBlock { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : TextBlock { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : TextBlock { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : TextBlock { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : TextBlock { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : TextBlock { view.UI.Text = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : TextBlock { view.UI.TextAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : TextBlock { view.UI.TextDecorations = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextEffects"/></summary>
        public static TView TextEffects<TView>(this TView view, Windows.Media.TextEffectCollection value) where TView : TextBlock { view.UI.TextEffects = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextTrimming"/></summary>
        public static TView TextTrimming<TView>(this TView view, Windows.TextTrimming value) where TView : TextBlock { view.UI.TextTrimming = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextWrapping"/></summary>
        public static TView TextWrapping<TView>(this TView view, Windows.TextWrapping value) where TView : TextBlock { view.UI.TextWrapping = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.TextBlock.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.BaselineOffset"/></summary>
        public static DependencyProperty<TTarget, double> BaselineOffset<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.BaselineOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.TextBlock.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> FontStretch<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Controls.TextBlock.FontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.TextBlock.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.TextBlock.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.TextBlock.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.IsHyphenationEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsHyphenationEnabled<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.TextBlock.IsHyphenationEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Controls.TextBlock.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.TextBlock.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Controls.TextBlock.TextAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Controls.TextBlock.TextDecorationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextEffects"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TextEffectCollection> TextEffects<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.Media.TextEffectCollection>.Get(target, Windows.Controls.TextBlock.TextEffectsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TextBlock.TextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextTrimming"/></summary>
        public static DependencyProperty<TTarget, Windows.TextTrimming> TextTrimming<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.TextTrimming>.Get(target, Windows.Controls.TextBlock.TextTrimmingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextWrapping"/></summary>
        public static DependencyProperty<TTarget, Windows.TextWrapping> TextWrapping<TTarget>(this TTarget target) where TTarget : TextBlock
        => DependencyProperty<TTarget, Windows.TextWrapping>.Get(target, Windows.Controls.TextBlock.TextWrappingProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.BaselineOffset"/></summary>
        public static TTarget TextBlock_BaselineOffset<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetBaselineOffset(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.BaselineOffset"/></summary>
        public static DependencyProperty<TTarget, double> TextBlock_BaselineOffset<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.BaselineOffsetProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontFamily"/></summary>
        public static TTarget TextBlock_FontFamily<TTarget>(this TTarget target, Windows.Media.FontFamily value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetFontFamily(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> TextBlock_FontFamily<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Controls.TextBlock.FontFamilyProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontSize"/></summary>
        public static TTarget TextBlock_FontSize<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetFontSize(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> TextBlock_FontSize<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.FontSizeProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontStretch"/></summary>
        public static TTarget TextBlock_FontStretch<TTarget>(this TTarget target, Windows.FontStretch value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetFontStretch(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> TextBlock_FontStretch<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Controls.TextBlock.FontStretchProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontStyle"/></summary>
        public static TTarget TextBlock_FontStyle<TTarget>(this TTarget target, Windows.FontStyle value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetFontStyle(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> TextBlock_FontStyle<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Controls.TextBlock.FontStyleProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.FontWeight"/></summary>
        public static TTarget TextBlock_FontWeight<TTarget>(this TTarget target, Windows.FontWeight value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetFontWeight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> TextBlock_FontWeight<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Controls.TextBlock.FontWeightProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static TTarget TextBlock_Foreground<TTarget>(this TTarget target, Windows.Media.Brush value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetForeground(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> TextBlock_Foreground<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.TextBlock.ForegroundProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.LineHeight"/></summary>
        public static TTarget TextBlock_LineHeight<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetLineHeight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> TextBlock_LineHeight<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.TextBlock.LineHeightProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.LineStackingStrategy"/></summary>
        public static TTarget TextBlock_LineStackingStrategy<TTarget>(this TTarget target, Windows.LineStackingStrategy value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetLineStackingStrategy(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> TextBlock_LineStackingStrategy<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Controls.TextBlock.LineStackingStrategyProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock.TextAlignment"/></summary>
        public static TTarget TextBlock_TextAlignment<TTarget>(this TTarget target, Windows.TextAlignment value) where TTarget : DependencyObject
        { Windows.Controls.TextBlock.SetTextAlignment(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBlock.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextBlock_TextAlignment<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Controls.TextBlock.TextAlignmentProperty);

        /// <summary>Set <see cref="Windows.Controls.TextBlock"/> attached properties</summary>
        public static TTarget TextBlock<TTarget>(this TTarget target

            , O<double> BaselineOffset = default

            , O<Windows.Media.FontFamily> FontFamily = default

            , O<double> FontSize = default

            , O<Windows.FontStretch> FontStretch = default

            , O<Windows.FontStyle> FontStyle = default

            , O<Windows.FontWeight> FontWeight = default

            , O<Windows.Media.Brush> Foreground = default

            , O<double> LineHeight = default

            , O<Windows.LineStackingStrategy> LineStackingStrategy = default

            , O<Windows.TextAlignment> TextAlignment = default

        ) where TTarget : DependencyObject
        {
            if (BaselineOffset.HasValue) Windows.Controls.TextBlock.SetBaselineOffset(target.UI, BaselineOffset.Value);

            if (FontFamily.HasValue) Windows.Controls.TextBlock.SetFontFamily(target.UI, FontFamily.Value);

            if (FontSize.HasValue) Windows.Controls.TextBlock.SetFontSize(target.UI, FontSize.Value);

            if (FontStretch.HasValue) Windows.Controls.TextBlock.SetFontStretch(target.UI, FontStretch.Value);

            if (FontStyle.HasValue) Windows.Controls.TextBlock.SetFontStyle(target.UI, FontStyle.Value);

            if (FontWeight.HasValue) Windows.Controls.TextBlock.SetFontWeight(target.UI, FontWeight.Value);

            if (Foreground.HasValue) Windows.Controls.TextBlock.SetForeground(target.UI, Foreground.Value);

            if (LineHeight.HasValue) Windows.Controls.TextBlock.SetLineHeight(target.UI, LineHeight.Value);

            if (LineStackingStrategy.HasValue) Windows.Controls.TextBlock.SetLineStackingStrategy(target.UI, LineStackingStrategy.Value);

            if (TextAlignment.HasValue) Windows.Controls.TextBlock.SetTextAlignment(target.UI, TextAlignment.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // TextBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TextBox"/></summary>
        /// <remarks>Remark: TextBox().Bind() binds to <see cref="Windows.Controls.TextBox.TextProperty"/></remarks>
        public static TextBox TextBox(
            string Text
)
        {
            var ui = new Windows.Controls.TextBox();
            if (Text is not null) ui.Text = Text;
            return global::CSharpMarkup.Wpf.TextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBox"/></summary>
        /// <remarks>Remark: TextBox().Bind() binds to <see cref="Windows.Controls.TextBox.TextProperty"/></remarks>
        public static TextBox TextBox(O<int> CaretIndex = default, O<Windows.Controls.CharacterCasing> CharacterCasing = default, O<int> MaxLength = default, O<int> MaxLines = default, O<int> MinLines = default, O<string> SelectedText = default, O<int> SelectionLength = default, O<int> SelectionStart = default, O<string> Text = default, O<Windows.TextAlignment> TextAlignment = default, O<Windows.TextDecorationCollection> TextDecorations = default, O<Windows.TextWrapping> TextWrapping = default)
        {
            var ui = new Windows.Controls.TextBox();
            if (CaretIndex.HasValue) ui.CaretIndex = CaretIndex.Value;
            if (CharacterCasing.HasValue) ui.CharacterCasing = CharacterCasing.Value;
            if (MaxLength.HasValue) ui.MaxLength = MaxLength.Value;
            if (MaxLines.HasValue) ui.MaxLines = MaxLines.Value;
            if (MinLines.HasValue) ui.MinLines = MinLines.Value;
            if (SelectedText.HasValue) ui.SelectedText = SelectedText.Value;
            if (SelectionLength.HasValue) ui.SelectionLength = SelectionLength.Value;
            if (SelectionStart.HasValue) ui.SelectionStart = SelectionStart.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            if (TextDecorations.HasValue) ui.TextDecorations = TextDecorations.Value;
            if (TextWrapping.HasValue) ui.TextWrapping = TextWrapping.Value;
            return global::CSharpMarkup.Wpf.TextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TextBox"/></summary>
        /// <remarks>Remark: TextBox().Bind() binds to <see cref="Windows.Controls.TextBox.TextProperty"/></remarks>
        public static TextBox TextBox()
        {
            var ui = new Windows.Controls.TextBox();
            return global::CSharpMarkup.Wpf.TextBox.StartChain(ui);
        }
    }

    public partial class TextBox : TextBoxBase, IUI<System.Windows.Controls.TextBox>, IDefaultBindProperty
    {
        static TextBox instance;

        internal static TextBox StartChain(Windows.Controls.TextBox ui)
        {
            if (instance == null) instance = new TextBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TextBox ui;

        public new Windows.Controls.TextBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.TextBox.TextProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.TextBox.TextProperty;

        public static implicit operator Windows.UIElement(TextBox view) => view?.UI;

        public static implicit operator Windows.Controls.TextBox(TextBox view) => view?.UI;

        public static implicit operator TextBox(Windows.Controls.TextBox ui) => TextBox.StartChain(ui);

        protected TextBox() { }
    }

    public static partial class TextBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TextBox.CaretIndex"/></summary>
        public static TView CaretIndex<TView>(this TView view, int value) where TView : TextBox { view.UI.CaretIndex = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.CharacterCasing"/></summary>
        public static TView CharacterCasing<TView>(this TView view, Windows.Controls.CharacterCasing value) where TView : TextBox { view.UI.CharacterCasing = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.MaxLength"/></summary>
        public static TView MaxLength<TView>(this TView view, int value) where TView : TextBox { view.UI.MaxLength = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.MaxLines"/></summary>
        public static TView MaxLines<TView>(this TView view, int value) where TView : TextBox { view.UI.MaxLines = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.MinLines"/></summary>
        public static TView MinLines<TView>(this TView view, int value) where TView : TextBox { view.UI.MinLines = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.SelectedText"/></summary>
        public static TView SelectedText<TView>(this TView view, string value) where TView : TextBox { view.UI.SelectedText = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.SelectionLength"/></summary>
        public static TView SelectionLength<TView>(this TView view, int value) where TView : TextBox { view.UI.SelectionLength = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.SelectionStart"/></summary>
        public static TView SelectionStart<TView>(this TView view, int value) where TView : TextBox { view.UI.SelectionStart = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : TextBox { view.UI.Text = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : TextBox { view.UI.TextAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : TextBox { view.UI.TextDecorations = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TextBox.TextWrapping"/></summary>
        public static TView TextWrapping<TView>(this TView view, Windows.TextWrapping value) where TView : TextBox { view.UI.TextWrapping = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.CharacterCasing"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.CharacterCasing> CharacterCasing<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, Windows.Controls.CharacterCasing>.Get(target, Windows.Controls.TextBox.CharacterCasingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.MaxLength"/></summary>
        public static DependencyProperty<TTarget, int> MaxLength<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.TextBox.MaxLengthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.MaxLines"/></summary>
        public static DependencyProperty<TTarget, int> MaxLines<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.TextBox.MaxLinesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.MinLines"/></summary>
        public static DependencyProperty<TTarget, int> MinLines<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.TextBox.MinLinesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Controls.TextBox.TextAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Controls.TextBox.TextDecorationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TextBox.TextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextBox.TextWrapping"/></summary>
        public static DependencyProperty<TTarget, Windows.TextWrapping> TextWrapping<TTarget>(this TTarget target) where TTarget : TextBox
        => DependencyProperty<TTarget, Windows.TextWrapping>.Get(target, Windows.Controls.TextBox.TextWrappingProperty);
    }
}

namespace CSharpMarkup.Wpf // TextSearch
{
    public partial class TextSearch : DependencyObject, IUI<System.Windows.Controls.TextSearch>
    {
        Windows.Controls.TextSearch ui;

        public new Windows.Controls.TextSearch UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TextSearch() { }
    }

    public static partial class TextSearchExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TextSearch.TextPath"/></summary>
        public static TTarget TextSearch_TextPath<TTarget>(this TTarget target, string value) where TTarget : DependencyObject
        { Windows.Controls.TextSearch.SetTextPath(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextSearch.TextPath"/></summary>
        public static DependencyProperty<TTarget, string> TextSearch_TextPath<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TextSearch.TextPathProperty);

        /// <summary>Set <see cref="Windows.Controls.TextSearch.Text"/></summary>
        public static TTarget TextSearch_Text<TTarget>(this TTarget target, string value) where TTarget : DependencyObject
        { Windows.Controls.TextSearch.SetText(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TextSearch.Text"/></summary>
        public static DependencyProperty<TTarget, string> TextSearch_Text<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TextSearch.TextProperty);

        /// <summary>Set <see cref="Windows.Controls.TextSearch"/> attached properties</summary>
        public static TTarget TextSearch<TTarget>(this TTarget target

            , O<string> TextPath = default

            , O<string> Text = default

        ) where TTarget : DependencyObject
        {
            if (TextPath.HasValue) Windows.Controls.TextSearch.SetTextPath(target.UI, TextPath.Value);

            if (Text.HasValue) Windows.Controls.TextSearch.SetText(target.UI, Text.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // ToolBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ToolBar"/></summary>
        public static ToolBar ToolBar(
            params object[] Items
)
        {
            var ui = new Windows.Controls.ToolBar();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.ToolBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolBar"/></summary>
        public static ToolBar ToolBar(O<int> Band = default, O<int> BandIndex = default, O<bool> IsOverflowOpen = default)
        {
            var ui = new Windows.Controls.ToolBar();
            if (Band.HasValue) ui.Band = Band.Value;
            if (BandIndex.HasValue) ui.BandIndex = BandIndex.Value;
            if (IsOverflowOpen.HasValue) ui.IsOverflowOpen = IsOverflowOpen.Value;
            return global::CSharpMarkup.Wpf.ToolBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolBar"/></summary>
        public static ToolBar ToolBar()
        {
            var ui = new Windows.Controls.ToolBar();
            return global::CSharpMarkup.Wpf.ToolBar.StartChain(ui);
        }
    }

    public partial class ToolBar : HeaderedItemsControl, IUI<System.Windows.Controls.ToolBar>
    {
        static ToolBar instance;

        internal static ToolBar StartChain(Windows.Controls.ToolBar ui)
        {
            if (instance == null) instance = new ToolBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ToolBar ui;

        public new Windows.Controls.ToolBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ToolBar view) => view?.UI;

        public static implicit operator Windows.Controls.ToolBar(ToolBar view) => view?.UI;

        public static implicit operator ToolBar(Windows.Controls.ToolBar ui) => ToolBar.StartChain(ui);

        protected ToolBar() { }
    }

    public static partial class ToolBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ToolBar.Band"/></summary>
        public static TView Band<TView>(this TView view, int value) where TView : ToolBar { view.UI.Band = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBar.BandIndex"/></summary>
        public static TView BandIndex<TView>(this TView view, int value) where TView : ToolBar { view.UI.BandIndex = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBar.IsOverflowOpen"/></summary>
        public static TView IsOverflowOpen<TView>(this TView view, bool value) where TView : ToolBar { view.UI.IsOverflowOpen = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.BandIndex"/></summary>
        public static DependencyProperty<TTarget, int> BandIndex<TTarget>(this TTarget target) where TTarget : ToolBar
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.ToolBar.BandIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.Band"/></summary>
        public static DependencyProperty<TTarget, int> Band<TTarget>(this TTarget target) where TTarget : ToolBar
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.ToolBar.BandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.HasOverflowItems"/></summary>
        public static DependencyProperty<TTarget, bool> HasOverflowItems<TTarget>(this TTarget target) where TTarget : ToolBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolBar.HasOverflowItemsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.IsOverflowOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsOverflowOpen<TTarget>(this TTarget target) where TTarget : ToolBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolBar.IsOverflowOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : ToolBar
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.ToolBar.OrientationProperty);

        /// <summary>Set <see cref="Windows.Controls.ToolBar.OverflowMode"/></summary>
        public static TTarget ToolBar_OverflowMode<TTarget>(this TTarget target, Windows.Controls.OverflowMode value) where TTarget : DependencyObject
        { Windows.Controls.ToolBar.SetOverflowMode(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBar.OverflowMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.OverflowMode> ToolBar_OverflowMode<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.OverflowMode>.Get(target, Windows.Controls.ToolBar.OverflowModeProperty);
    }
}

namespace CSharpMarkup.Wpf // ToolBarTray
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ToolBarTray"/></summary>
        public static ToolBarTray ToolBarTray(
            params System.Windows.Controls.ToolBar[] ToolBars
)
        {
            var ui = new Windows.Controls.ToolBarTray();
            foreach (var child in ToolBars) if (child is not null) ui.ToolBars.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.ToolBars);
            return global::CSharpMarkup.Wpf.ToolBarTray.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolBarTray"/></summary>
        public static ToolBarTray ToolBarTray(O<Windows.Media.Brush> Background = default, O<bool> IsLocked = default, O<Windows.Controls.Orientation> Orientation = default)
        {
            var ui = new Windows.Controls.ToolBarTray();
            if (Background.HasValue) ui.Background = Background.Value;
            if (IsLocked.HasValue) ui.IsLocked = IsLocked.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            return global::CSharpMarkup.Wpf.ToolBarTray.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolBarTray"/></summary>
        public static ToolBarTray ToolBarTray()
        {
            var ui = new Windows.Controls.ToolBarTray();
            return global::CSharpMarkup.Wpf.ToolBarTray.StartChain(ui);
        }
    }

    public partial class ToolBarTray : FrameworkElement, IUI<System.Windows.Controls.ToolBarTray>
    {
        static ToolBarTray instance;

        internal static ToolBarTray StartChain(Windows.Controls.ToolBarTray ui)
        {
            if (instance == null) instance = new ToolBarTray();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ToolBarTray ui;

        public new Windows.Controls.ToolBarTray UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ToolBarTray view) => view?.UI;

        public static implicit operator Windows.Controls.ToolBarTray(ToolBarTray view) => view?.UI;

        public static implicit operator ToolBarTray(Windows.Controls.ToolBarTray ui) => ToolBarTray.StartChain(ui);

        protected ToolBarTray() { }
    }

    public static partial class ToolBarTrayExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : ToolBarTray { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : ToolBarTray { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : ToolBarTray { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.IsLocked"/></summary>
        public static TView IsLocked<TView>(this TView view, bool value) where TView : ToolBarTray { view.UI.IsLocked = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : ToolBarTray { view.UI.Orientation = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBarTray.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : ToolBarTray
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.ToolBarTray.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBarTray.IsLocked"/></summary>
        public static DependencyProperty<TTarget, bool> IsLocked<TTarget>(this TTarget target) where TTarget : ToolBarTray
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolBarTray.IsLockedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBarTray.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : ToolBarTray
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.ToolBarTray.OrientationProperty);

        /// <summary>Set <see cref="Windows.Controls.ToolBarTray.IsLocked"/></summary>
        public static TTarget ToolBarTray_IsLocked<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.ToolBarTray.SetIsLocked(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolBarTray.IsLocked"/></summary>
        public static DependencyProperty<TTarget, bool> ToolBarTray_IsLocked<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolBarTray.IsLockedProperty);
    }
}

namespace CSharpMarkup.Wpf // ToolTip
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.ToolTip"/></summary>
        public static ToolTip ToolTip(
            object Content
)
        {
            var ui = new Windows.Controls.ToolTip();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ToolTip.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolTip"/></summary>
        public static ToolTip ToolTip(O<Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback = default, O<bool> HasDropShadow = default, O<double> HorizontalOffset = default, O<bool> IsOpen = default, O<Windows.Controls.Primitives.PlacementMode> Placement = default, O<Windows.Rect> PlacementRectangle = default, O<Windows.UIElement> PlacementTarget = default, O<bool?> ShowsToolTipOnKeyboardFocus = default, O<bool> StaysOpen = default, O<double> VerticalOffset = default)
        {
            var ui = new Windows.Controls.ToolTip();
            if (CustomPopupPlacementCallback.HasValue) ui.CustomPopupPlacementCallback = CustomPopupPlacementCallback.Value;
            if (HasDropShadow.HasValue) ui.HasDropShadow = HasDropShadow.Value;
            if (HorizontalOffset.HasValue) ui.HorizontalOffset = HorizontalOffset.Value;
            if (IsOpen.HasValue) ui.IsOpen = IsOpen.Value;
            if (Placement.HasValue) ui.Placement = Placement.Value;
            if (PlacementRectangle.HasValue) ui.PlacementRectangle = PlacementRectangle.Value;
            if (PlacementTarget.HasValue) ui.PlacementTarget = PlacementTarget.Value;
            if (ShowsToolTipOnKeyboardFocus.HasValue) ui.ShowsToolTipOnKeyboardFocus = ShowsToolTipOnKeyboardFocus.Value;
            if (StaysOpen.HasValue) ui.StaysOpen = StaysOpen.Value;
            if (VerticalOffset.HasValue) ui.VerticalOffset = VerticalOffset.Value;
            return global::CSharpMarkup.Wpf.ToolTip.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.ToolTip"/></summary>
        public static ToolTip ToolTip()
        {
            var ui = new Windows.Controls.ToolTip();
            return global::CSharpMarkup.Wpf.ToolTip.StartChain(ui);
        }
    }

    public partial class ToolTip : ContentControl, IUI<System.Windows.Controls.ToolTip>
    {
        static ToolTip instance;

        internal static ToolTip StartChain(Windows.Controls.ToolTip ui)
        {
            if (instance == null) instance = new ToolTip();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.ToolTip ui;

        public new Windows.Controls.ToolTip UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ToolTip view) => view?.UI;

        public static implicit operator Windows.Controls.ToolTip(ToolTip view) => view?.UI;

        public static implicit operator ToolTip(Windows.Controls.ToolTip ui) => ToolTip.StartChain(ui);

        protected ToolTip() { }
    }

    public static partial class ToolTipExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.ToolTip.CustomPopupPlacementCallback"/></summary>
        public static TView CustomPopupPlacementCallback<TView>(this TView view, Windows.Controls.Primitives.CustomPopupPlacementCallback value) where TView : ToolTip { view.UI.CustomPopupPlacementCallback = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.HasDropShadow"/></summary>
        public static TView HasDropShadow<TView>(this TView view, bool value) where TView : ToolTip { view.UI.HasDropShadow = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.HorizontalOffset"/></summary>
        public static TView HorizontalOffset<TView>(this TView view, double value) where TView : ToolTip { view.UI.HorizontalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.IsOpen"/></summary>
        public static TView IsOpen<TView>(this TView view, bool value) where TView : ToolTip { view.UI.IsOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.Placement"/></summary>
        public static TView Placement<TView>(this TView view, Windows.Controls.Primitives.PlacementMode value) where TView : ToolTip { view.UI.Placement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.PlacementRectangle"/></summary>
        public static TView PlacementRectangle<TView>(this TView view, Windows.Rect value) where TView : ToolTip { view.UI.PlacementRectangle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.PlacementTarget"/></summary>
        public static TView PlacementTarget<TView>(this TView view, Windows.UIElement value) where TView : ToolTip { view.UI.PlacementTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.ShowsToolTipOnKeyboardFocus"/></summary>
        public static TView ShowsToolTipOnKeyboardFocus<TView>(this TView view, bool? value) where TView : ToolTip { view.UI.ShowsToolTipOnKeyboardFocus = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.StaysOpen"/></summary>
        public static TView StaysOpen<TView>(this TView view, bool value) where TView : ToolTip { view.UI.StaysOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.ToolTip.VerticalOffset"/></summary>
        public static TView VerticalOffset<TView>(this TView view, double value) where TView : ToolTip { view.UI.VerticalOffset = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.CustomPopupPlacementCallback"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback>.Get(target, Windows.Controls.ToolTip.CustomPopupPlacementCallbackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.HasDropShadow"/></summary>
        public static DependencyProperty<TTarget, bool> HasDropShadow<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolTip.HasDropShadowProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ToolTip.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.IsOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsOpen<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolTip.IsOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.Placement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> Placement<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode>.Get(target, Windows.Controls.ToolTip.PlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.PlacementRectangle"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> PlacementRectangle<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Controls.ToolTip.PlacementRectangleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.PlacementTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.UIElement> PlacementTarget<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, Windows.UIElement>.Get(target, Windows.Controls.ToolTip.PlacementTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.ShowsToolTipOnKeyboardFocus"/></summary>
        public static DependencyProperty<TTarget, bool?> ShowsToolTipOnKeyboardFocus<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Controls.ToolTip.ShowsToolTipOnKeyboardFocusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.StaysOpen"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpen<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.ToolTip.StaysOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.ToolTip.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : ToolTip
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.ToolTip.VerticalOffsetProperty);
    }
}

namespace CSharpMarkup.Wpf // TreeView
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TreeView"/></summary>
        public static TreeView TreeView(
            params object[] Items
)
        {
            var ui = new Windows.Controls.TreeView();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.TreeView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TreeView"/></summary>
        public static TreeView TreeView(O<string> SelectedValuePath = default)
        {
            var ui = new Windows.Controls.TreeView();
            if (SelectedValuePath.HasValue) ui.SelectedValuePath = SelectedValuePath.Value;
            return global::CSharpMarkup.Wpf.TreeView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TreeView"/></summary>
        public static TreeView TreeView()
        {
            var ui = new Windows.Controls.TreeView();
            return global::CSharpMarkup.Wpf.TreeView.StartChain(ui);
        }
    }

    public partial class TreeView : ItemsControl, IUI<System.Windows.Controls.TreeView>
    {
        static TreeView instance;

        internal static TreeView StartChain(Windows.Controls.TreeView ui)
        {
            if (instance == null) instance = new TreeView();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TreeView ui;

        public new Windows.Controls.TreeView UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TreeView view) => view?.UI;

        public static implicit operator Windows.Controls.TreeView(TreeView view) => view?.UI;

        public static implicit operator TreeView(Windows.Controls.TreeView ui) => TreeView.StartChain(ui);

        protected TreeView() { }
    }

    public static partial class TreeViewExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TreeView.SelectedValuePath"/></summary>
        public static TView SelectedValuePath<TView>(this TView view, string value) where TView : TreeView { view.UI.SelectedValuePath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeView.SelectedItem"/></summary>
        public static DependencyProperty<TTarget, object> SelectedItem<TTarget>(this TTarget target) where TTarget : TreeView
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.TreeView.SelectedItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeView.SelectedValuePath"/></summary>
        public static DependencyProperty<TTarget, string> SelectedValuePath<TTarget>(this TTarget target) where TTarget : TreeView
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.TreeView.SelectedValuePathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeView.SelectedValue"/></summary>
        public static DependencyProperty<TTarget, object> SelectedValue<TTarget>(this TTarget target) where TTarget : TreeView
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.TreeView.SelectedValueProperty);
    }
}

namespace CSharpMarkup.Wpf // TreeViewItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.TreeViewItem"/></summary>
        public static TreeViewItem TreeViewItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.TreeViewItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.TreeViewItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TreeViewItem"/></summary>
        public static TreeViewItem TreeViewItem(O<bool> IsExpanded = default, O<bool> IsSelected = default)
        {
            var ui = new Windows.Controls.TreeViewItem();
            if (IsExpanded.HasValue) ui.IsExpanded = IsExpanded.Value;
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            return global::CSharpMarkup.Wpf.TreeViewItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.TreeViewItem"/></summary>
        public static TreeViewItem TreeViewItem()
        {
            var ui = new Windows.Controls.TreeViewItem();
            return global::CSharpMarkup.Wpf.TreeViewItem.StartChain(ui);
        }
    }

    public partial class TreeViewItem : HeaderedItemsControl, IUI<System.Windows.Controls.TreeViewItem>
    {
        static TreeViewItem instance;

        internal static TreeViewItem StartChain(Windows.Controls.TreeViewItem ui)
        {
            if (instance == null) instance = new TreeViewItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.TreeViewItem ui;

        public new Windows.Controls.TreeViewItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TreeViewItem view) => view?.UI;

        public static implicit operator Windows.Controls.TreeViewItem(TreeViewItem view) => view?.UI;

        public static implicit operator TreeViewItem(Windows.Controls.TreeViewItem ui) => TreeViewItem.StartChain(ui);

        protected TreeViewItem() { }
    }

    public static partial class TreeViewItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.TreeViewItem.IsExpanded"/></summary>
        public static TView IsExpanded<TView>(this TView view, bool value) where TView : TreeViewItem { view.UI.IsExpanded = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.TreeViewItem.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : TreeViewItem { view.UI.IsSelected = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeViewItem.IsExpanded"/></summary>
        public static DependencyProperty<TTarget, bool> IsExpanded<TTarget>(this TTarget target) where TTarget : TreeViewItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.TreeViewItem.IsExpandedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeViewItem.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : TreeViewItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.TreeViewItem.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.TreeViewItem.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : TreeViewItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.TreeViewItem.IsSelectionActiveProperty);
    }
}

namespace CSharpMarkup.Wpf // UserControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.UserControl"/></summary>
        public static UserControl UserControl(
            object Content
)
        {
            var ui = new Windows.Controls.UserControl();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.UserControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.UserControl"/></summary>
        public static UserControl UserControl()
        {
            var ui = new Windows.Controls.UserControl();
            return global::CSharpMarkup.Wpf.UserControl.StartChain(ui);
        }
    }

    public partial class UserControl : ContentControl, IUI<System.Windows.Controls.UserControl>
    {
        static UserControl instance;

        internal static UserControl StartChain(Windows.Controls.UserControl ui)
        {
            if (instance == null) instance = new UserControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.UserControl ui;

        public new Windows.Controls.UserControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(UserControl view) => view?.UI;

        public static implicit operator Windows.Controls.UserControl(UserControl view) => view?.UI;

        public static implicit operator UserControl(Windows.Controls.UserControl ui) => UserControl.StartChain(ui);

        protected UserControl() { }
    }
}

namespace CSharpMarkup.Wpf // ViewBase
{
    public partial class ViewBase : DependencyObject, IUI<System.Windows.Controls.ViewBase>
    {
        Windows.Controls.ViewBase ui;

        public new Windows.Controls.ViewBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ViewBase() { }
    }
}

namespace CSharpMarkup.Wpf // Viewbox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Viewbox"/></summary>
        public static Viewbox Viewbox(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.Viewbox();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.Viewbox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Viewbox"/></summary>
        public static Viewbox Viewbox(O<Windows.Media.Stretch> Stretch = default, O<Windows.Controls.StretchDirection> StretchDirection = default)
        {
            var ui = new Windows.Controls.Viewbox();
            if (Stretch.HasValue) ui.Stretch = Stretch.Value;
            if (StretchDirection.HasValue) ui.StretchDirection = StretchDirection.Value;
            return global::CSharpMarkup.Wpf.Viewbox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Viewbox"/></summary>
        public static Viewbox Viewbox()
        {
            var ui = new Windows.Controls.Viewbox();
            return global::CSharpMarkup.Wpf.Viewbox.StartChain(ui);
        }
    }

    public partial class Viewbox : Decorator, IUI<System.Windows.Controls.Viewbox>
    {
        static Viewbox instance;

        internal static Viewbox StartChain(Windows.Controls.Viewbox ui)
        {
            if (instance == null) instance = new Viewbox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Viewbox ui;

        public new Windows.Controls.Viewbox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Viewbox view) => view?.UI;

        public static implicit operator Windows.Controls.Viewbox(Viewbox view) => view?.UI;

        public static implicit operator Viewbox(Windows.Controls.Viewbox ui) => Viewbox.StartChain(ui);

        protected Viewbox() { }
    }

    public static partial class ViewboxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Viewbox.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : Viewbox { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Viewbox.StretchDirection"/></summary>
        public static TView StretchDirection<TView>(this TView view, Windows.Controls.StretchDirection value) where TView : Viewbox { view.UI.StretchDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Viewbox.StretchDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StretchDirection> StretchDirection<TTarget>(this TTarget target) where TTarget : Viewbox
        => DependencyProperty<TTarget, Windows.Controls.StretchDirection>.Get(target, Windows.Controls.Viewbox.StretchDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Viewbox.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : Viewbox
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Controls.Viewbox.StretchProperty);
    }
}

namespace CSharpMarkup.Wpf // Viewport3D
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Viewport3D"/></summary>
        /// <remarks>Remark: Viewport3D().Bind() binds to <see cref="Windows.Controls.Viewport3D.ChildrenProperty"/></remarks>
        public static Viewport3D Viewport3D(
            params System.Windows.Media.Media3D.Visual3D[] Children
)
        {
            var ui = new Windows.Controls.Viewport3D();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Viewport3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Viewport3D"/></summary>
        /// <remarks>Remark: Viewport3D().Bind() binds to <see cref="Windows.Controls.Viewport3D.ChildrenProperty"/></remarks>
        public static Viewport3D Viewport3D(O<Windows.Media.Media3D.Camera> Camera = default)
        {
            var ui = new Windows.Controls.Viewport3D();
            if (Camera.HasValue) ui.Camera = Camera.Value;
            return global::CSharpMarkup.Wpf.Viewport3D.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Viewport3D"/></summary>
        /// <remarks>Remark: Viewport3D().Bind() binds to <see cref="Windows.Controls.Viewport3D.ChildrenProperty"/></remarks>
        public static Viewport3D Viewport3D()
        {
            var ui = new Windows.Controls.Viewport3D();
            return global::CSharpMarkup.Wpf.Viewport3D.StartChain(ui);
        }
    }

    public partial class Viewport3D : FrameworkElement, IUI<System.Windows.Controls.Viewport3D>, IDefaultBindProperty
    {
        static Viewport3D instance;

        internal static Viewport3D StartChain(Windows.Controls.Viewport3D ui)
        {
            if (instance == null) instance = new Viewport3D();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Viewport3D ui;

        public new Windows.Controls.Viewport3D UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Viewport3D.ChildrenProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Viewport3D.ChildrenProperty;

        public static implicit operator Windows.UIElement(Viewport3D view) => view?.UI;

        public static implicit operator Windows.Controls.Viewport3D(Viewport3D view) => view?.UI;

        public static implicit operator Viewport3D(Windows.Controls.Viewport3D ui) => Viewport3D.StartChain(ui);

        protected Viewport3D() { }
    }

    public static partial class Viewport3DExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Viewport3D.Camera"/></summary>
        public static TView Camera<TView>(this TView view, Windows.Media.Media3D.Camera value) where TView : Viewport3D { view.UI.Camera = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Viewport3D.Camera"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Camera> Camera<TTarget>(this TTarget target) where TTarget : Viewport3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Camera>.Get(target, Windows.Controls.Viewport3D.CameraProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Viewport3D.Children"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Media3D.Visual3DCollection> Children<TTarget>(this TTarget target) where TTarget : Viewport3D
        => DependencyProperty<TTarget, Windows.Media.Media3D.Visual3DCollection>.Get(target, Windows.Controls.Viewport3D.ChildrenProperty);
    }
}

namespace CSharpMarkup.Wpf // VirtualizingPanel
{
    public partial class VirtualizingPanel : Panel, IUI<System.Windows.Controls.VirtualizingPanel>
    {
        Windows.Controls.VirtualizingPanel ui;

        public new Windows.Controls.VirtualizingPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected VirtualizingPanel() { }
    }

    public static partial class VirtualizingPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.CacheLength"/></summary>
        public static TTarget VirtualizingPanel_CacheLength<TTarget>(this TTarget target, Windows.Controls.VirtualizationCacheLength value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetCacheLength(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.CacheLength"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLength> VirtualizingPanel_CacheLength<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLength>.Get(target, Windows.Controls.VirtualizingPanel.CacheLengthProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.CacheLengthUnit"/></summary>
        public static TTarget VirtualizingPanel_CacheLengthUnit<TTarget>(this TTarget target, Windows.Controls.VirtualizationCacheLengthUnit value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetCacheLengthUnit(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.CacheLengthUnit"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLengthUnit> VirtualizingPanel_CacheLengthUnit<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLengthUnit>.Get(target, Windows.Controls.VirtualizingPanel.CacheLengthUnitProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.IsContainerVirtualizable"/></summary>
        public static TTarget VirtualizingPanel_IsContainerVirtualizable<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetIsContainerVirtualizable(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.IsContainerVirtualizable"/></summary>
        public static DependencyProperty<TTarget, bool> VirtualizingPanel_IsContainerVirtualizable<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.VirtualizingPanel.IsContainerVirtualizableProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.IsVirtualizing"/></summary>
        public static TTarget VirtualizingPanel_IsVirtualizing<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetIsVirtualizing(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.IsVirtualizing"/></summary>
        public static DependencyProperty<TTarget, bool> VirtualizingPanel_IsVirtualizing<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.VirtualizingPanel.IsVirtualizingProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping"/></summary>
        public static TTarget VirtualizingPanel_IsVirtualizingWhenGrouping<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetIsVirtualizingWhenGrouping(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping"/></summary>
        public static DependencyProperty<TTarget, bool> VirtualizingPanel_IsVirtualizingWhenGrouping<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGroupingProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.ScrollUnit"/></summary>
        public static TTarget VirtualizingPanel_ScrollUnit<TTarget>(this TTarget target, Windows.Controls.ScrollUnit value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetScrollUnit(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.ScrollUnit"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollUnit> VirtualizingPanel_ScrollUnit<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.ScrollUnit>.Get(target, Windows.Controls.VirtualizingPanel.ScrollUnitProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel.VirtualizationMode"/></summary>
        public static TTarget VirtualizingPanel_VirtualizationMode<TTarget>(this TTarget target, Windows.Controls.VirtualizationMode value) where TTarget : DependencyObject
        { Windows.Controls.VirtualizingPanel.SetVirtualizationMode(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingPanel.VirtualizationMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.VirtualizationMode> VirtualizingPanel_VirtualizationMode<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.VirtualizationMode>.Get(target, Windows.Controls.VirtualizingPanel.VirtualizationModeProperty);

        /// <summary>Set <see cref="Windows.Controls.VirtualizingPanel"/> attached properties</summary>
        public static TTarget VirtualizingPanel<TTarget>(this TTarget target

            , O<Windows.Controls.VirtualizationCacheLength> CacheLength = default

            , O<Windows.Controls.VirtualizationCacheLengthUnit> CacheLengthUnit = default

            , O<bool> IsContainerVirtualizable = default

            , O<bool> IsVirtualizing = default

            , O<bool> IsVirtualizingWhenGrouping = default

            , O<Windows.Controls.ScrollUnit> ScrollUnit = default

            , O<Windows.Controls.VirtualizationMode> VirtualizationMode = default

        ) where TTarget : DependencyObject
        {
            if (CacheLength.HasValue) Windows.Controls.VirtualizingPanel.SetCacheLength(target.UI, CacheLength.Value);

            if (CacheLengthUnit.HasValue) Windows.Controls.VirtualizingPanel.SetCacheLengthUnit(target.UI, CacheLengthUnit.Value);

            if (IsContainerVirtualizable.HasValue) Windows.Controls.VirtualizingPanel.SetIsContainerVirtualizable(target.UI, IsContainerVirtualizable.Value);

            if (IsVirtualizing.HasValue) Windows.Controls.VirtualizingPanel.SetIsVirtualizing(target.UI, IsVirtualizing.Value);

            if (IsVirtualizingWhenGrouping.HasValue) Windows.Controls.VirtualizingPanel.SetIsVirtualizingWhenGrouping(target.UI, IsVirtualizingWhenGrouping.Value);

            if (ScrollUnit.HasValue) Windows.Controls.VirtualizingPanel.SetScrollUnit(target.UI, ScrollUnit.Value);

            if (VirtualizationMode.HasValue) Windows.Controls.VirtualizingPanel.SetVirtualizationMode(target.UI, VirtualizationMode.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // VirtualizingStackPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.VirtualizingStackPanel"/></summary>
        public static VirtualizingStackPanel VirtualizingStackPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.VirtualizingStackPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.VirtualizingStackPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.VirtualizingStackPanel"/></summary>
        public static VirtualizingStackPanel VirtualizingStackPanel(O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.Orientation> Orientation = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.VirtualizingStackPanel();
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.VirtualizingStackPanel.StartChain(ui);
        }
    }

    public partial class VirtualizingStackPanel : VirtualizingPanel, IUI<System.Windows.Controls.VirtualizingStackPanel>
    {
        static VirtualizingStackPanel instance;

        internal static VirtualizingStackPanel StartChain(Windows.Controls.VirtualizingStackPanel ui)
        {
            if (instance == null) instance = new VirtualizingStackPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.VirtualizingStackPanel ui;

        public new Windows.Controls.VirtualizingStackPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(VirtualizingStackPanel view) => view?.UI;

        public static implicit operator Windows.Controls.VirtualizingStackPanel(VirtualizingStackPanel view) => view?.UI;

        public static implicit operator VirtualizingStackPanel(Windows.Controls.VirtualizingStackPanel ui) => VirtualizingStackPanel.StartChain(ui);

        protected VirtualizingStackPanel() { }
    }

    public static partial class VirtualizingStackPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.VirtualizingStackPanel.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : VirtualizingStackPanel { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.VirtualizingStackPanel.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : VirtualizingStackPanel { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.VirtualizingStackPanel.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : VirtualizingStackPanel { view.UI.Orientation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.VirtualizingStackPanel.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : VirtualizingStackPanel { view.UI.ScrollOwner = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.VirtualizingStackPanel.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : VirtualizingStackPanel
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.VirtualizingStackPanel.OrientationProperty);
    }
}

namespace CSharpMarkup.Wpf // WebBrowser
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.WebBrowser"/></summary>
        public static WebBrowser WebBrowser(O<object> ObjectForScripting = default, O<Uri> Source = default)
        {
            var ui = new Windows.Controls.WebBrowser();
            if (ObjectForScripting.HasValue) ui.ObjectForScripting = ObjectForScripting.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.WebBrowser.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.WebBrowser"/></summary>
        public static WebBrowser WebBrowser()
        {
            var ui = new Windows.Controls.WebBrowser();
            return global::CSharpMarkup.Wpf.WebBrowser.StartChain(ui);
        }
    }

    public partial class WebBrowser : ActiveXHost, IUI<System.Windows.Controls.WebBrowser>
    {
        static WebBrowser instance;

        internal static WebBrowser StartChain(Windows.Controls.WebBrowser ui)
        {
            if (instance == null) instance = new WebBrowser();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.WebBrowser ui;

        public new Windows.Controls.WebBrowser UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(WebBrowser view) => view?.UI;

        public static implicit operator Windows.Controls.WebBrowser(WebBrowser view) => view?.UI;

        public static implicit operator WebBrowser(Windows.Controls.WebBrowser ui) => WebBrowser.StartChain(ui);

        protected WebBrowser() { }
    }

    public static partial class WebBrowserExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.WebBrowser.ObjectForScripting"/></summary>
        public static TView ObjectForScripting<TView>(this TView view, object value) where TView : WebBrowser { view.UI.ObjectForScripting = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.WebBrowser.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : WebBrowser { view.UI.Source = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // WrapPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.WrapPanel"/></summary>
        public static WrapPanel WrapPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.WrapPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.WrapPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.WrapPanel"/></summary>
        public static WrapPanel WrapPanel(O<double> ItemHeight = default, O<double> ItemWidth = default, O<Windows.Controls.Orientation> Orientation = default)
        {
            var ui = new Windows.Controls.WrapPanel();
            if (ItemHeight.HasValue) ui.ItemHeight = ItemHeight.Value;
            if (ItemWidth.HasValue) ui.ItemWidth = ItemWidth.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            return global::CSharpMarkup.Wpf.WrapPanel.StartChain(ui);
        }
    }

    public partial class WrapPanel : Panel, IUI<System.Windows.Controls.WrapPanel>
    {
        static WrapPanel instance;

        internal static WrapPanel StartChain(Windows.Controls.WrapPanel ui)
        {
            if (instance == null) instance = new WrapPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.WrapPanel ui;

        public new Windows.Controls.WrapPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(WrapPanel view) => view?.UI;

        public static implicit operator Windows.Controls.WrapPanel(WrapPanel view) => view?.UI;

        public static implicit operator WrapPanel(Windows.Controls.WrapPanel ui) => WrapPanel.StartChain(ui);

        protected WrapPanel() { }
    }

    public static partial class WrapPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.WrapPanel.ItemHeight"/></summary>
        public static TView ItemHeight<TView>(this TView view, double value) where TView : WrapPanel { view.UI.ItemHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.WrapPanel.ItemWidth"/></summary>
        public static TView ItemWidth<TView>(this TView view, double value) where TView : WrapPanel { view.UI.ItemWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.WrapPanel.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : WrapPanel { view.UI.Orientation = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.WrapPanel.ItemHeight"/></summary>
        public static DependencyProperty<TTarget, double> ItemHeight<TTarget>(this TTarget target) where TTarget : WrapPanel
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.WrapPanel.ItemHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.WrapPanel.ItemWidth"/></summary>
        public static DependencyProperty<TTarget, double> ItemWidth<TTarget>(this TTarget target) where TTarget : WrapPanel
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.WrapPanel.ItemWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.WrapPanel.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : WrapPanel
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.WrapPanel.OrientationProperty);
    }
}

namespace CSharpMarkup.Wpf // BulletDecorator
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.BulletDecorator"/></summary>
        public static BulletDecorator BulletDecorator(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.Primitives.BulletDecorator();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.BulletDecorator.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.BulletDecorator"/></summary>
        public static BulletDecorator BulletDecorator(O<Windows.Media.Brush> Background = default, O<Windows.UIElement> Bullet = default)
        {
            var ui = new Windows.Controls.Primitives.BulletDecorator();
            if (Background.HasValue) ui.Background = Background.Value;
            if (Bullet.HasValue) ui.Bullet = Bullet.Value;
            return global::CSharpMarkup.Wpf.BulletDecorator.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.BulletDecorator"/></summary>
        public static BulletDecorator BulletDecorator()
        {
            var ui = new Windows.Controls.Primitives.BulletDecorator();
            return global::CSharpMarkup.Wpf.BulletDecorator.StartChain(ui);
        }
    }

    public partial class BulletDecorator : Decorator, IUI<System.Windows.Controls.Primitives.BulletDecorator>
    {
        static BulletDecorator instance;

        internal static BulletDecorator StartChain(Windows.Controls.Primitives.BulletDecorator ui)
        {
            if (instance == null) instance = new BulletDecorator();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.BulletDecorator ui;

        public new Windows.Controls.Primitives.BulletDecorator UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(BulletDecorator view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.BulletDecorator(BulletDecorator view) => view?.UI;

        public static implicit operator BulletDecorator(Windows.Controls.Primitives.BulletDecorator ui) => BulletDecorator.StartChain(ui);

        protected BulletDecorator() { }
    }

    public static partial class BulletDecoratorExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.BulletDecorator.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : BulletDecorator { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.BulletDecorator.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : BulletDecorator { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.BulletDecorator.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : BulletDecorator { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.BulletDecorator.Bullet"/></summary>
        public static TView Bullet<TView>(this TView view, Windows.UIElement value) where TView : BulletDecorator { view.UI.Bullet = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.BulletDecorator.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : BulletDecorator
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.BulletDecorator.BackgroundProperty);
    }
}

namespace CSharpMarkup.Wpf // ButtonBase
{
    public partial class ButtonBase : ContentControl, IUI<System.Windows.Controls.Primitives.ButtonBase>, IDefaultBindProperty
    {
        Windows.Controls.Primitives.ButtonBase ui;

        public new Windows.Controls.Primitives.ButtonBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.ButtonBase.CommandProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.ButtonBase.CommandProperty;

        protected ButtonBase() { }
    }

    public static partial class ButtonBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.ButtonBase.ClickMode"/></summary>
        public static TView ClickMode<TView>(this TView view, Windows.Controls.ClickMode value) where TView : ButtonBase { view.UI.ClickMode = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.ButtonBase.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : ButtonBase { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.ButtonBase.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : ButtonBase { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.ButtonBase.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : ButtonBase { view.UI.CommandTarget = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ButtonBase.ClickMode"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ClickMode> ClickMode<TTarget>(this TTarget target) where TTarget : ButtonBase
        => DependencyProperty<TTarget, Windows.Controls.ClickMode>.Get(target, Windows.Controls.Primitives.ButtonBase.ClickModeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ButtonBase.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : ButtonBase
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Primitives.ButtonBase.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ButtonBase.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : ButtonBase
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Controls.Primitives.ButtonBase.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ButtonBase.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : ButtonBase
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Controls.Primitives.ButtonBase.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ButtonBase.IsPressed"/></summary>
        public static DependencyProperty<TTarget, bool> IsPressed<TTarget>(this TTarget target) where TTarget : ButtonBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.ButtonBase.IsPressedProperty);
    }
}

namespace CSharpMarkup.Wpf // CalendarButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.CalendarButton"/></summary>
        public static CalendarButton CalendarButton(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.CalendarButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.CalendarButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.CalendarButton"/></summary>
        public static CalendarButton CalendarButton()
        {
            var ui = new Windows.Controls.Primitives.CalendarButton();
            return global::CSharpMarkup.Wpf.CalendarButton.StartChain(ui);
        }
    }

    public partial class CalendarButton : Button, IUI<System.Windows.Controls.Primitives.CalendarButton>
    {
        static CalendarButton instance;

        internal static CalendarButton StartChain(Windows.Controls.Primitives.CalendarButton ui)
        {
            if (instance == null) instance = new CalendarButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.CalendarButton ui;

        public new Windows.Controls.Primitives.CalendarButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(CalendarButton view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.CalendarButton(CalendarButton view) => view?.UI;

        public static implicit operator CalendarButton(Windows.Controls.Primitives.CalendarButton ui) => CalendarButton.StartChain(ui);

        protected CalendarButton() { }
    }

    public static partial class CalendarButtonExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarButton.HasSelectedDays"/></summary>
        public static DependencyProperty<TTarget, bool> HasSelectedDays<TTarget>(this TTarget target) where TTarget : CalendarButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarButton.HasSelectedDaysProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarButton.IsInactive"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactive<TTarget>(this TTarget target) where TTarget : CalendarButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarButton.IsInactiveProperty);
    }
}

namespace CSharpMarkup.Wpf // CalendarDayButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.CalendarDayButton"/></summary>
        public static CalendarDayButton CalendarDayButton(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.CalendarDayButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.CalendarDayButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.CalendarDayButton"/></summary>
        public static CalendarDayButton CalendarDayButton()
        {
            var ui = new Windows.Controls.Primitives.CalendarDayButton();
            return global::CSharpMarkup.Wpf.CalendarDayButton.StartChain(ui);
        }
    }

    public partial class CalendarDayButton : Button, IUI<System.Windows.Controls.Primitives.CalendarDayButton>
    {
        static CalendarDayButton instance;

        internal static CalendarDayButton StartChain(Windows.Controls.Primitives.CalendarDayButton ui)
        {
            if (instance == null) instance = new CalendarDayButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.CalendarDayButton ui;

        public new Windows.Controls.Primitives.CalendarDayButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(CalendarDayButton view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.CalendarDayButton(CalendarDayButton view) => view?.UI;

        public static implicit operator CalendarDayButton(Windows.Controls.Primitives.CalendarDayButton ui) => CalendarDayButton.StartChain(ui);

        protected CalendarDayButton() { }
    }

    public static partial class CalendarDayButtonExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarDayButton.IsBlackedOut"/></summary>
        public static DependencyProperty<TTarget, bool> IsBlackedOut<TTarget>(this TTarget target) where TTarget : CalendarDayButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarDayButton.IsBlackedOutProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarDayButton.IsHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsHighlighted<TTarget>(this TTarget target) where TTarget : CalendarDayButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarDayButton.IsHighlightedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarDayButton.IsInactive"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactive<TTarget>(this TTarget target) where TTarget : CalendarDayButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarDayButton.IsInactiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarDayButton.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : CalendarDayButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarDayButton.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.CalendarDayButton.IsToday"/></summary>
        public static DependencyProperty<TTarget, bool> IsToday<TTarget>(this TTarget target) where TTarget : CalendarDayButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.CalendarDayButton.IsTodayProperty);
    }
}

namespace CSharpMarkup.Wpf // CalendarItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.CalendarItem"/></summary>
        public static CalendarItem CalendarItem()
        {
            var ui = new Windows.Controls.Primitives.CalendarItem();
            return global::CSharpMarkup.Wpf.CalendarItem.StartChain(ui);
        }
    }

    public partial class CalendarItem : Control, IUI<System.Windows.Controls.Primitives.CalendarItem>
    {
        static CalendarItem instance;

        internal static CalendarItem StartChain(Windows.Controls.Primitives.CalendarItem ui)
        {
            if (instance == null) instance = new CalendarItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.CalendarItem ui;

        public new Windows.Controls.Primitives.CalendarItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(CalendarItem view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.CalendarItem(CalendarItem view) => view?.UI;

        public static implicit operator CalendarItem(Windows.Controls.Primitives.CalendarItem ui) => CalendarItem.StartChain(ui);

        protected CalendarItem() { }
    }
}

namespace CSharpMarkup.Wpf // DataGridCellsPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridCellsPresenter"/></summary>
        public static DataGridCellsPresenter DataGridCellsPresenter(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Primitives.DataGridCellsPresenter();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.DataGridCellsPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridCellsPresenter"/></summary>
        public static DataGridCellsPresenter DataGridCellsPresenter()
        {
            var ui = new Windows.Controls.Primitives.DataGridCellsPresenter();
            return global::CSharpMarkup.Wpf.DataGridCellsPresenter.StartChain(ui);
        }
    }

    public partial class DataGridCellsPresenter : ItemsControl, IUI<System.Windows.Controls.Primitives.DataGridCellsPresenter>
    {
        static DataGridCellsPresenter instance;

        internal static DataGridCellsPresenter StartChain(Windows.Controls.Primitives.DataGridCellsPresenter ui)
        {
            if (instance == null) instance = new DataGridCellsPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridCellsPresenter ui;

        public new Windows.Controls.Primitives.DataGridCellsPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridCellsPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridCellsPresenter(DataGridCellsPresenter view) => view?.UI;

        public static implicit operator DataGridCellsPresenter(Windows.Controls.Primitives.DataGridCellsPresenter ui) => DataGridCellsPresenter.StartChain(ui);

        protected DataGridCellsPresenter() { }
    }
}

namespace CSharpMarkup.Wpf // DataGridColumnHeader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridColumnHeader"/></summary>
        public static DataGridColumnHeader DataGridColumnHeader(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.DataGridColumnHeader();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.DataGridColumnHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridColumnHeader"/></summary>
        public static DataGridColumnHeader DataGridColumnHeader(O<Windows.Media.Brush> SeparatorBrush = default, O<Windows.Visibility> SeparatorVisibility = default)
        {
            var ui = new Windows.Controls.Primitives.DataGridColumnHeader();
            if (SeparatorBrush.HasValue) ui.SeparatorBrush = SeparatorBrush.Value;
            if (SeparatorVisibility.HasValue) ui.SeparatorVisibility = SeparatorVisibility.Value;
            return global::CSharpMarkup.Wpf.DataGridColumnHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridColumnHeader"/></summary>
        public static DataGridColumnHeader DataGridColumnHeader()
        {
            var ui = new Windows.Controls.Primitives.DataGridColumnHeader();
            return global::CSharpMarkup.Wpf.DataGridColumnHeader.StartChain(ui);
        }
    }

    public partial class DataGridColumnHeader : ButtonBase, IUI<System.Windows.Controls.Primitives.DataGridColumnHeader>
    {
        static DataGridColumnHeader instance;

        internal static DataGridColumnHeader StartChain(Windows.Controls.Primitives.DataGridColumnHeader ui)
        {
            if (instance == null) instance = new DataGridColumnHeader();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridColumnHeader ui;

        public new Windows.Controls.Primitives.DataGridColumnHeader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridColumnHeader view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridColumnHeader(DataGridColumnHeader view) => view?.UI;

        public static implicit operator DataGridColumnHeader(Windows.Controls.Primitives.DataGridColumnHeader ui) => DataGridColumnHeader.StartChain(ui);

        protected DataGridColumnHeader() { }
    }

    public static partial class DataGridColumnHeaderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, Windows.Media.Brush value) where TView : DataGridColumnHeader { view.UI.SeparatorBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, Color value) where TView : DataGridColumnHeader { view.UI.SeparatorBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, string color) where TView : DataGridColumnHeader { view.UI.SeparatorBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorVisibility"/></summary>
        public static TView SeparatorVisibility<TView>(this TView view, Windows.Visibility value) where TView : DataGridColumnHeader { view.UI.SeparatorVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.CanUserSort"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserSort<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.CanUserSortProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.DisplayIndex"/></summary>
        public static DependencyProperty<TTarget, int> DisplayIndex<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.DisplayIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.IsFrozen"/></summary>
        public static DependencyProperty<TTarget, bool> IsFrozen<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.IsFrozenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SeparatorBrush<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.SeparatorBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SeparatorVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> SeparatorVisibility<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.SeparatorVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridColumnHeader.SortDirection"/></summary>
        public static DependencyProperty<TTarget, ListSortDirection?> SortDirection<TTarget>(this TTarget target) where TTarget : DataGridColumnHeader
        => DependencyProperty<TTarget, ListSortDirection?>.Get(target, Windows.Controls.Primitives.DataGridColumnHeader.SortDirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridColumnHeadersPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridColumnHeadersPresenter"/></summary>
        public static DataGridColumnHeadersPresenter DataGridColumnHeadersPresenter(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Primitives.DataGridColumnHeadersPresenter();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.DataGridColumnHeadersPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridColumnHeadersPresenter"/></summary>
        public static DataGridColumnHeadersPresenter DataGridColumnHeadersPresenter()
        {
            var ui = new Windows.Controls.Primitives.DataGridColumnHeadersPresenter();
            return global::CSharpMarkup.Wpf.DataGridColumnHeadersPresenter.StartChain(ui);
        }
    }

    public partial class DataGridColumnHeadersPresenter : ItemsControl, IUI<System.Windows.Controls.Primitives.DataGridColumnHeadersPresenter>
    {
        static DataGridColumnHeadersPresenter instance;

        internal static DataGridColumnHeadersPresenter StartChain(Windows.Controls.Primitives.DataGridColumnHeadersPresenter ui)
        {
            if (instance == null) instance = new DataGridColumnHeadersPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridColumnHeadersPresenter ui;

        public new Windows.Controls.Primitives.DataGridColumnHeadersPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridColumnHeadersPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridColumnHeadersPresenter(DataGridColumnHeadersPresenter view) => view?.UI;

        public static implicit operator DataGridColumnHeadersPresenter(Windows.Controls.Primitives.DataGridColumnHeadersPresenter ui) => DataGridColumnHeadersPresenter.StartChain(ui);

        protected DataGridColumnHeadersPresenter() { }
    }
}

namespace CSharpMarkup.Wpf // DataGridDetailsPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridDetailsPresenter"/></summary>
        public static DataGridDetailsPresenter DataGridDetailsPresenter()
        {
            var ui = new Windows.Controls.Primitives.DataGridDetailsPresenter();
            return global::CSharpMarkup.Wpf.DataGridDetailsPresenter.StartChain(ui);
        }
    }

    public partial class DataGridDetailsPresenter : ContentPresenter, IUI<System.Windows.Controls.Primitives.DataGridDetailsPresenter>
    {
        static DataGridDetailsPresenter instance;

        internal static DataGridDetailsPresenter StartChain(Windows.Controls.Primitives.DataGridDetailsPresenter ui)
        {
            if (instance == null) instance = new DataGridDetailsPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridDetailsPresenter ui;

        public new Windows.Controls.Primitives.DataGridDetailsPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridDetailsPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridDetailsPresenter(DataGridDetailsPresenter view) => view?.UI;

        public static implicit operator DataGridDetailsPresenter(Windows.Controls.Primitives.DataGridDetailsPresenter ui) => DataGridDetailsPresenter.StartChain(ui);

        protected DataGridDetailsPresenter() { }
    }
}

namespace CSharpMarkup.Wpf // DataGridRowHeader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridRowHeader"/></summary>
        public static DataGridRowHeader DataGridRowHeader(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.DataGridRowHeader();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.DataGridRowHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridRowHeader"/></summary>
        public static DataGridRowHeader DataGridRowHeader(O<Windows.Media.Brush> SeparatorBrush = default, O<Windows.Visibility> SeparatorVisibility = default)
        {
            var ui = new Windows.Controls.Primitives.DataGridRowHeader();
            if (SeparatorBrush.HasValue) ui.SeparatorBrush = SeparatorBrush.Value;
            if (SeparatorVisibility.HasValue) ui.SeparatorVisibility = SeparatorVisibility.Value;
            return global::CSharpMarkup.Wpf.DataGridRowHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridRowHeader"/></summary>
        public static DataGridRowHeader DataGridRowHeader()
        {
            var ui = new Windows.Controls.Primitives.DataGridRowHeader();
            return global::CSharpMarkup.Wpf.DataGridRowHeader.StartChain(ui);
        }
    }

    public partial class DataGridRowHeader : ButtonBase, IUI<System.Windows.Controls.Primitives.DataGridRowHeader>
    {
        static DataGridRowHeader instance;

        internal static DataGridRowHeader StartChain(Windows.Controls.Primitives.DataGridRowHeader ui)
        {
            if (instance == null) instance = new DataGridRowHeader();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridRowHeader ui;

        public new Windows.Controls.Primitives.DataGridRowHeader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridRowHeader view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridRowHeader(DataGridRowHeader view) => view?.UI;

        public static implicit operator DataGridRowHeader(Windows.Controls.Primitives.DataGridRowHeader ui) => DataGridRowHeader.StartChain(ui);

        protected DataGridRowHeader() { }
    }

    public static partial class DataGridRowHeaderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, Windows.Media.Brush value) where TView : DataGridRowHeader { view.UI.SeparatorBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, Color value) where TView : DataGridRowHeader { view.UI.SeparatorBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorBrush"/></summary>
        public static TView SeparatorBrush<TView>(this TView view, string color) where TView : DataGridRowHeader { view.UI.SeparatorBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorVisibility"/></summary>
        public static TView SeparatorVisibility<TView>(this TView view, Windows.Visibility value) where TView : DataGridRowHeader { view.UI.SeparatorVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridRowHeader.IsRowSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsRowSelected<TTarget>(this TTarget target) where TTarget : DataGridRowHeader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DataGridRowHeader.IsRowSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SeparatorBrush<TTarget>(this TTarget target) where TTarget : DataGridRowHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.DataGridRowHeader.SeparatorBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DataGridRowHeader.SeparatorVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> SeparatorVisibility<TTarget>(this TTarget target) where TTarget : DataGridRowHeader
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.Primitives.DataGridRowHeader.SeparatorVisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // DataGridRowsPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DataGridRowsPresenter"/></summary>
        public static DataGridRowsPresenter DataGridRowsPresenter(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.DataGridRowsPresenter();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.DataGridRowsPresenter.StartChain(ui);
        }
    }

    public partial class DataGridRowsPresenter : VirtualizingStackPanel, IUI<System.Windows.Controls.Primitives.DataGridRowsPresenter>
    {
        static DataGridRowsPresenter instance;

        internal static DataGridRowsPresenter StartChain(Windows.Controls.Primitives.DataGridRowsPresenter ui)
        {
            if (instance == null) instance = new DataGridRowsPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DataGridRowsPresenter ui;

        public new Windows.Controls.Primitives.DataGridRowsPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DataGridRowsPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DataGridRowsPresenter(DataGridRowsPresenter view) => view?.UI;

        public static implicit operator DataGridRowsPresenter(Windows.Controls.Primitives.DataGridRowsPresenter ui) => DataGridRowsPresenter.StartChain(ui);

        protected DataGridRowsPresenter() { }
    }
}

namespace CSharpMarkup.Wpf // DatePickerTextBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DatePickerTextBox"/></summary>
        public static DatePickerTextBox DatePickerTextBox(
            string Text
)
        {
            var ui = new Windows.Controls.Primitives.DatePickerTextBox();
            if (Text is not null) ui.Text = Text;
            return global::CSharpMarkup.Wpf.DatePickerTextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DatePickerTextBox"/></summary>
        public static DatePickerTextBox DatePickerTextBox()
        {
            var ui = new Windows.Controls.Primitives.DatePickerTextBox();
            return global::CSharpMarkup.Wpf.DatePickerTextBox.StartChain(ui);
        }
    }

    public partial class DatePickerTextBox : TextBox, IUI<System.Windows.Controls.Primitives.DatePickerTextBox>
    {
        static DatePickerTextBox instance;

        internal static DatePickerTextBox StartChain(Windows.Controls.Primitives.DatePickerTextBox ui)
        {
            if (instance == null) instance = new DatePickerTextBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DatePickerTextBox ui;

        public new Windows.Controls.Primitives.DatePickerTextBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DatePickerTextBox view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DatePickerTextBox(DatePickerTextBox view) => view?.UI;

        public static implicit operator DatePickerTextBox(Windows.Controls.Primitives.DatePickerTextBox ui) => DatePickerTextBox.StartChain(ui);

        protected DatePickerTextBox() { }
    }
}

namespace CSharpMarkup.Wpf // DocumentPageView
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.DocumentPageView"/></summary>
        public static DocumentPageView DocumentPageView(O<Windows.Documents.DocumentPaginator> DocumentPaginator = default, O<int> PageNumber = default, O<Windows.Media.Stretch> Stretch = default, O<Windows.Controls.StretchDirection> StretchDirection = default)
        {
            var ui = new Windows.Controls.Primitives.DocumentPageView();
            if (DocumentPaginator.HasValue) ui.DocumentPaginator = DocumentPaginator.Value;
            if (PageNumber.HasValue) ui.PageNumber = PageNumber.Value;
            if (Stretch.HasValue) ui.Stretch = Stretch.Value;
            if (StretchDirection.HasValue) ui.StretchDirection = StretchDirection.Value;
            return global::CSharpMarkup.Wpf.DocumentPageView.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.DocumentPageView"/></summary>
        public static DocumentPageView DocumentPageView()
        {
            var ui = new Windows.Controls.Primitives.DocumentPageView();
            return global::CSharpMarkup.Wpf.DocumentPageView.StartChain(ui);
        }
    }

    public partial class DocumentPageView : FrameworkElement, IUI<System.Windows.Controls.Primitives.DocumentPageView>
    {
        static DocumentPageView instance;

        internal static DocumentPageView StartChain(Windows.Controls.Primitives.DocumentPageView ui)
        {
            if (instance == null) instance = new DocumentPageView();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.DocumentPageView ui;

        public new Windows.Controls.Primitives.DocumentPageView UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DocumentPageView view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.DocumentPageView(DocumentPageView view) => view?.UI;

        public static implicit operator DocumentPageView(Windows.Controls.Primitives.DocumentPageView ui) => DocumentPageView.StartChain(ui);

        protected DocumentPageView() { }
    }

    public static partial class DocumentPageViewExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentPageView.DocumentPaginator"/></summary>
        public static TView DocumentPaginator<TView>(this TView view, Windows.Documents.DocumentPaginator value) where TView : DocumentPageView { view.UI.DocumentPaginator = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentPageView.PageNumber"/></summary>
        public static TView PageNumber<TView>(this TView view, int value) where TView : DocumentPageView { view.UI.PageNumber = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentPageView.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : DocumentPageView { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentPageView.StretchDirection"/></summary>
        public static TView StretchDirection<TView>(this TView view, Windows.Controls.StretchDirection value) where TView : DocumentPageView { view.UI.StretchDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentPageView.PageNumber"/></summary>
        public static DependencyProperty<TTarget, int> PageNumber<TTarget>(this TTarget target) where TTarget : DocumentPageView
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.DocumentPageView.PageNumberProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentPageView.StretchDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StretchDirection> StretchDirection<TTarget>(this TTarget target) where TTarget : DocumentPageView
        => DependencyProperty<TTarget, Windows.Controls.StretchDirection>.Get(target, Windows.Controls.Primitives.DocumentPageView.StretchDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentPageView.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : DocumentPageView
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Controls.Primitives.DocumentPageView.StretchProperty);
    }
}

namespace CSharpMarkup.Wpf // DocumentViewerBase
{
    public partial class DocumentViewerBase : Control, IUI<System.Windows.Controls.Primitives.DocumentViewerBase>, IDefaultBindProperty
    {
        Windows.Controls.Primitives.DocumentViewerBase ui;

        public new Windows.Controls.Primitives.DocumentViewerBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.DocumentViewerBase.DocumentProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.DocumentViewerBase.DocumentProperty;

        protected DocumentViewerBase() { }
    }

    public static partial class DocumentViewerBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentViewerBase.Document"/></summary>
        public static TView Document<TView>(this TView view, Windows.Documents.IDocumentPaginatorSource value) where TView : DocumentViewerBase { view.UI.Document = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.CanGoToNextPage"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoToNextPage<TTarget>(this TTarget target) where TTarget : DocumentViewerBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.CanGoToNextPageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.CanGoToPreviousPage"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoToPreviousPage<TTarget>(this TTarget target) where TTarget : DocumentViewerBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.CanGoToPreviousPageProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.Document"/></summary>
        public static DependencyProperty<TTarget, Windows.Documents.IDocumentPaginatorSource> Document<TTarget>(this TTarget target) where TTarget : DocumentViewerBase
        => DependencyProperty<TTarget, Windows.Documents.IDocumentPaginatorSource>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.DocumentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.MasterPageNumber"/></summary>
        public static DependencyProperty<TTarget, int> MasterPageNumber<TTarget>(this TTarget target) where TTarget : DocumentViewerBase
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.MasterPageNumberProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.PageCount"/></summary>
        public static DependencyProperty<TTarget, int> PageCount<TTarget>(this TTarget target) where TTarget : DocumentViewerBase
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.PageCountProperty);

        /// <summary>Set <see cref="Windows.Controls.Primitives.DocumentViewerBase.IsMasterPage"/></summary>
        public static TTarget DocumentViewerBase_IsMasterPage<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.Primitives.DocumentViewerBase.SetIsMasterPage(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.DocumentViewerBase.IsMasterPage"/></summary>
        public static DependencyProperty<TTarget, bool> DocumentViewerBase_IsMasterPage<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.DocumentViewerBase.IsMasterPageProperty);
    }
}

namespace CSharpMarkup.Wpf // GridViewRowPresenterBase
{
    public partial class GridViewRowPresenterBase : FrameworkElement, IUI<System.Windows.Controls.Primitives.GridViewRowPresenterBase>, IDefaultBindProperty
    {
        Windows.Controls.Primitives.GridViewRowPresenterBase ui;

        public new Windows.Controls.Primitives.GridViewRowPresenterBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.GridViewRowPresenterBase.ColumnsProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.GridViewRowPresenterBase.ColumnsProperty;

        protected GridViewRowPresenterBase() { }
    }

    public static partial class GridViewRowPresenterBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.GridViewRowPresenterBase.Columns"/></summary>
        public static TView Columns<TView>(this TView view, Windows.Controls.GridViewColumnCollection value) where TView : GridViewRowPresenterBase { view.UI.Columns = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.GridViewRowPresenterBase.Columns"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.GridViewColumnCollection> Columns<TTarget>(this TTarget target) where TTarget : GridViewRowPresenterBase
        => DependencyProperty<TTarget, Windows.Controls.GridViewColumnCollection>.Get(target, Windows.Controls.Primitives.GridViewRowPresenterBase.ColumnsProperty);
    }
}

namespace CSharpMarkup.Wpf // MenuBase
{
    public partial class MenuBase : ItemsControl, IUI<System.Windows.Controls.Primitives.MenuBase>
    {
        Windows.Controls.Primitives.MenuBase ui;

        public new Windows.Controls.Primitives.MenuBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected MenuBase() { }
    }

    public static partial class MenuBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.MenuBase.ItemContainerTemplateSelector"/></summary>
        public static TView ItemContainerTemplateSelector<TView>(this TView view, Windows.Controls.ItemContainerTemplateSelector value) where TView : MenuBase { view.UI.ItemContainerTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.MenuBase.UsesItemContainerTemplate"/></summary>
        public static TView UsesItemContainerTemplate<TView>(this TView view, bool value) where TView : MenuBase { view.UI.UsesItemContainerTemplate = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.MenuBase.ItemContainerTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector> ItemContainerTemplateSelector<TTarget>(this TTarget target) where TTarget : MenuBase
        => DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector>.Get(target, Windows.Controls.Primitives.MenuBase.ItemContainerTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.MenuBase.UsesItemContainerTemplate"/></summary>
        public static DependencyProperty<TTarget, bool> UsesItemContainerTemplate<TTarget>(this TTarget target) where TTarget : MenuBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.MenuBase.UsesItemContainerTemplateProperty);
    }
}

namespace CSharpMarkup.Wpf // MultiSelector
{
    public partial class MultiSelector : Selector, IUI<System.Windows.Controls.Primitives.MultiSelector>
    {
        Windows.Controls.Primitives.MultiSelector ui;

        public new Windows.Controls.Primitives.MultiSelector UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected MultiSelector() { }
    }
}

namespace CSharpMarkup.Wpf // Popup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.Popup"/></summary>
        public static Popup Popup(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Controls.Primitives.Popup();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.Popup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.Popup"/></summary>
        public static Popup Popup(O<bool> AllowsTransparency = default, O<Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback = default, O<double> HorizontalOffset = default, O<bool> IsOpen = default, O<Windows.Controls.Primitives.PlacementMode> Placement = default, O<Windows.Rect> PlacementRectangle = default, O<Windows.UIElement> PlacementTarget = default, O<Windows.Controls.Primitives.PopupAnimation> PopupAnimation = default, O<bool> StaysOpen = default, O<double> VerticalOffset = default)
        {
            var ui = new Windows.Controls.Primitives.Popup();
            if (AllowsTransparency.HasValue) ui.AllowsTransparency = AllowsTransparency.Value;
            if (CustomPopupPlacementCallback.HasValue) ui.CustomPopupPlacementCallback = CustomPopupPlacementCallback.Value;
            if (HorizontalOffset.HasValue) ui.HorizontalOffset = HorizontalOffset.Value;
            if (IsOpen.HasValue) ui.IsOpen = IsOpen.Value;
            if (Placement.HasValue) ui.Placement = Placement.Value;
            if (PlacementRectangle.HasValue) ui.PlacementRectangle = PlacementRectangle.Value;
            if (PlacementTarget.HasValue) ui.PlacementTarget = PlacementTarget.Value;
            if (PopupAnimation.HasValue) ui.PopupAnimation = PopupAnimation.Value;
            if (StaysOpen.HasValue) ui.StaysOpen = StaysOpen.Value;
            if (VerticalOffset.HasValue) ui.VerticalOffset = VerticalOffset.Value;
            return global::CSharpMarkup.Wpf.Popup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.Popup"/></summary>
        public static Popup Popup()
        {
            var ui = new Windows.Controls.Primitives.Popup();
            return global::CSharpMarkup.Wpf.Popup.StartChain(ui);
        }
    }

    public partial class Popup : FrameworkElement, IUI<System.Windows.Controls.Primitives.Popup>
    {
        static Popup instance;

        internal static Popup StartChain(Windows.Controls.Primitives.Popup ui)
        {
            if (instance == null) instance = new Popup();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.Popup ui;

        public new Windows.Controls.Primitives.Popup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Popup view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.Popup(Popup view) => view?.UI;

        public static implicit operator Popup(Windows.Controls.Primitives.Popup ui) => Popup.StartChain(ui);

        protected Popup() { }
    }

    public static partial class PopupExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.AllowsTransparency"/></summary>
        public static TView AllowsTransparency<TView>(this TView view, bool value) where TView : Popup { view.UI.AllowsTransparency = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.CustomPopupPlacementCallback"/></summary>
        public static TView CustomPopupPlacementCallback<TView>(this TView view, Windows.Controls.Primitives.CustomPopupPlacementCallback value) where TView : Popup { view.UI.CustomPopupPlacementCallback = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.HorizontalOffset"/></summary>
        public static TView HorizontalOffset<TView>(this TView view, double value) where TView : Popup { view.UI.HorizontalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.IsOpen"/></summary>
        public static TView IsOpen<TView>(this TView view, bool value) where TView : Popup { view.UI.IsOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.Placement"/></summary>
        public static TView Placement<TView>(this TView view, Windows.Controls.Primitives.PlacementMode value) where TView : Popup { view.UI.Placement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.PlacementRectangle"/></summary>
        public static TView PlacementRectangle<TView>(this TView view, Windows.Rect value) where TView : Popup { view.UI.PlacementRectangle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.PlacementTarget"/></summary>
        public static TView PlacementTarget<TView>(this TView view, Windows.UIElement value) where TView : Popup { view.UI.PlacementTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.PopupAnimation"/></summary>
        public static TView PopupAnimation<TView>(this TView view, Windows.Controls.Primitives.PopupAnimation value) where TView : Popup { view.UI.PopupAnimation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.StaysOpen"/></summary>
        public static TView StaysOpen<TView>(this TView view, bool value) where TView : Popup { view.UI.StaysOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Popup.VerticalOffset"/></summary>
        public static TView VerticalOffset<TView>(this TView view, double value) where TView : Popup { view.UI.VerticalOffset = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.AllowsTransparency"/></summary>
        public static DependencyProperty<TTarget, bool> AllowsTransparency<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Popup.AllowsTransparencyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.Child"/></summary>
        public static DependencyProperty<TTarget, Windows.UIElement> Child<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.UIElement>.Get(target, Windows.Controls.Primitives.Popup.ChildProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.CustomPopupPlacementCallback"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback> CustomPopupPlacementCallback<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.Controls.Primitives.CustomPopupPlacementCallback>.Get(target, Windows.Controls.Primitives.Popup.CustomPopupPlacementCallbackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.HasDropShadow"/></summary>
        public static DependencyProperty<TTarget, bool> HasDropShadow<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Popup.HasDropShadowProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Popup.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.IsOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsOpen<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Popup.IsOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.Placement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> Placement<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode>.Get(target, Windows.Controls.Primitives.Popup.PlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.PlacementRectangle"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> PlacementRectangle<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Controls.Primitives.Popup.PlacementRectangleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.PlacementTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.UIElement> PlacementTarget<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.UIElement>.Get(target, Windows.Controls.Primitives.Popup.PlacementTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.PopupAnimation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation> PopupAnimation<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation>.Get(target, Windows.Controls.Primitives.Popup.PopupAnimationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.StaysOpen"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpen<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Popup.StaysOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Popup.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : Popup
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Popup.VerticalOffsetProperty);
    }
}

namespace CSharpMarkup.Wpf // RangeBase
{
    public partial class RangeBase : Control, IUI<System.Windows.Controls.Primitives.RangeBase>, IDefaultBindProperty
    {
        Windows.Controls.Primitives.RangeBase ui;

        public new Windows.Controls.Primitives.RangeBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.RangeBase.ValueProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.RangeBase.ValueProperty;

        protected RangeBase() { }
    }

    public static partial class RangeBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.RangeBase.LargeChange"/></summary>
        public static TView LargeChange<TView>(this TView view, double value) where TView : RangeBase { view.UI.LargeChange = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.RangeBase.Maximum"/></summary>
        public static TView Maximum<TView>(this TView view, double value) where TView : RangeBase { view.UI.Maximum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.RangeBase.Minimum"/></summary>
        public static TView Minimum<TView>(this TView view, double value) where TView : RangeBase { view.UI.Minimum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.RangeBase.SmallChange"/></summary>
        public static TView SmallChange<TView>(this TView view, double value) where TView : RangeBase { view.UI.SmallChange = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.RangeBase.Value"/></summary>
        public static TView Value<TView>(this TView view, double value) where TView : RangeBase { view.UI.Value = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RangeBase.LargeChange"/></summary>
        public static DependencyProperty<TTarget, double> LargeChange<TTarget>(this TTarget target) where TTarget : RangeBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.RangeBase.LargeChangeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RangeBase.Maximum"/></summary>
        public static DependencyProperty<TTarget, double> Maximum<TTarget>(this TTarget target) where TTarget : RangeBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.RangeBase.MaximumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RangeBase.Minimum"/></summary>
        public static DependencyProperty<TTarget, double> Minimum<TTarget>(this TTarget target) where TTarget : RangeBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.RangeBase.MinimumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RangeBase.SmallChange"/></summary>
        public static DependencyProperty<TTarget, double> SmallChange<TTarget>(this TTarget target) where TTarget : RangeBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.RangeBase.SmallChangeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RangeBase.Value"/></summary>
        public static DependencyProperty<TTarget, double> Value<TTarget>(this TTarget target) where TTarget : RangeBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.RangeBase.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // RepeatButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.RepeatButton"/></summary>
        public static RepeatButton RepeatButton(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.RepeatButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RepeatButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.RepeatButton"/></summary>
        public static RepeatButton RepeatButton(O<int> Delay = default, O<int> Interval = default)
        {
            var ui = new Windows.Controls.Primitives.RepeatButton();
            if (Delay.HasValue) ui.Delay = Delay.Value;
            if (Interval.HasValue) ui.Interval = Interval.Value;
            return global::CSharpMarkup.Wpf.RepeatButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.RepeatButton"/></summary>
        public static RepeatButton RepeatButton()
        {
            var ui = new Windows.Controls.Primitives.RepeatButton();
            return global::CSharpMarkup.Wpf.RepeatButton.StartChain(ui);
        }
    }

    public partial class RepeatButton : ButtonBase, IUI<System.Windows.Controls.Primitives.RepeatButton>
    {
        static RepeatButton instance;

        internal static RepeatButton StartChain(Windows.Controls.Primitives.RepeatButton ui)
        {
            if (instance == null) instance = new RepeatButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.RepeatButton ui;

        public new Windows.Controls.Primitives.RepeatButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RepeatButton view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.RepeatButton(RepeatButton view) => view?.UI;

        public static implicit operator RepeatButton(Windows.Controls.Primitives.RepeatButton ui) => RepeatButton.StartChain(ui);

        protected RepeatButton() { }
    }

    public static partial class RepeatButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.RepeatButton.Delay"/></summary>
        public static TView Delay<TView>(this TView view, int value) where TView : RepeatButton { view.UI.Delay = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.RepeatButton.Interval"/></summary>
        public static TView Interval<TView>(this TView view, int value) where TView : RepeatButton { view.UI.Interval = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RepeatButton.Delay"/></summary>
        public static DependencyProperty<TTarget, int> Delay<TTarget>(this TTarget target) where TTarget : RepeatButton
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.RepeatButton.DelayProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.RepeatButton.Interval"/></summary>
        public static DependencyProperty<TTarget, int> Interval<TTarget>(this TTarget target) where TTarget : RepeatButton
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.RepeatButton.IntervalProperty);
    }
}

namespace CSharpMarkup.Wpf // ResizeGrip
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.ResizeGrip"/></summary>
        public static ResizeGrip ResizeGrip()
        {
            var ui = new Windows.Controls.Primitives.ResizeGrip();
            return global::CSharpMarkup.Wpf.ResizeGrip.StartChain(ui);
        }
    }

    public partial class ResizeGrip : Control, IUI<System.Windows.Controls.Primitives.ResizeGrip>
    {
        static ResizeGrip instance;

        internal static ResizeGrip StartChain(Windows.Controls.Primitives.ResizeGrip ui)
        {
            if (instance == null) instance = new ResizeGrip();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.ResizeGrip ui;

        public new Windows.Controls.Primitives.ResizeGrip UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ResizeGrip view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.ResizeGrip(ResizeGrip view) => view?.UI;

        public static implicit operator ResizeGrip(Windows.Controls.Primitives.ResizeGrip ui) => ResizeGrip.StartChain(ui);

        protected ResizeGrip() { }
    }
}

namespace CSharpMarkup.Wpf // ScrollBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.ScrollBar"/></summary>
        public static ScrollBar ScrollBar(O<Windows.Controls.Orientation> Orientation = default, O<double> ViewportSize = default)
        {
            var ui = new Windows.Controls.Primitives.ScrollBar();
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            if (ViewportSize.HasValue) ui.ViewportSize = ViewportSize.Value;
            return global::CSharpMarkup.Wpf.ScrollBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.ScrollBar"/></summary>
        public static ScrollBar ScrollBar()
        {
            var ui = new Windows.Controls.Primitives.ScrollBar();
            return global::CSharpMarkup.Wpf.ScrollBar.StartChain(ui);
        }
    }

    public partial class ScrollBar : RangeBase, IUI<System.Windows.Controls.Primitives.ScrollBar>
    {
        static ScrollBar instance;

        internal static ScrollBar StartChain(Windows.Controls.Primitives.ScrollBar ui)
        {
            if (instance == null) instance = new ScrollBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.ScrollBar ui;

        public new Windows.Controls.Primitives.ScrollBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ScrollBar view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.ScrollBar(ScrollBar view) => view?.UI;

        public static implicit operator ScrollBar(Windows.Controls.Primitives.ScrollBar ui) => ScrollBar.StartChain(ui);

        protected ScrollBar() { }
    }

    public static partial class ScrollBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.ScrollBar.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : ScrollBar { view.UI.Orientation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.ScrollBar.ViewportSize"/></summary>
        public static TView ViewportSize<TView>(this TView view, double value) where TView : ScrollBar { view.UI.ViewportSize = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ScrollBar.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : ScrollBar
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.Primitives.ScrollBar.OrientationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ScrollBar.ViewportSize"/></summary>
        public static DependencyProperty<TTarget, double> ViewportSize<TTarget>(this TTarget target) where TTarget : ScrollBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty);
    }
}

namespace CSharpMarkup.Wpf // SelectiveScrollingGrid
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.SelectiveScrollingGrid"/></summary>
        /// <remarks>Remark: SelectiveScrollingGrid().Bind() binds to <see cref="Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientationProperty"/></remarks>
        public static SelectiveScrollingGrid SelectiveScrollingGrid(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.SelectiveScrollingGrid();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.SelectiveScrollingGrid.StartChain(ui);
        }
    }

    public partial class SelectiveScrollingGrid : Grid, IUI<System.Windows.Controls.Primitives.SelectiveScrollingGrid>, IDefaultBindProperty
    {
        static SelectiveScrollingGrid instance;

        internal static SelectiveScrollingGrid StartChain(Windows.Controls.Primitives.SelectiveScrollingGrid ui)
        {
            if (instance == null) instance = new SelectiveScrollingGrid();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.SelectiveScrollingGrid ui;

        public new Windows.Controls.Primitives.SelectiveScrollingGrid UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientationProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientationProperty;

        public static implicit operator Windows.UIElement(SelectiveScrollingGrid view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.SelectiveScrollingGrid(SelectiveScrollingGrid view) => view?.UI;

        public static implicit operator SelectiveScrollingGrid(Windows.Controls.Primitives.SelectiveScrollingGrid ui) => SelectiveScrollingGrid.StartChain(ui);

        protected SelectiveScrollingGrid() { }
    }

    public static partial class SelectiveScrollingGridExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientation"/></summary>
        public static TTarget SelectiveScrollingGrid_SelectiveScrollingOrientation<TTarget>(this TTarget target, Windows.Controls.SelectiveScrollingOrientation value) where TTarget : DependencyObject
        { Windows.Controls.Primitives.SelectiveScrollingGrid.SetSelectiveScrollingOrientation(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation> SelectiveScrollingGrid_SelectiveScrollingOrientation<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation>.Get(target, Windows.Controls.Primitives.SelectiveScrollingGrid.SelectiveScrollingOrientationProperty);
    }
}

namespace CSharpMarkup.Wpf // Selector
{
    public partial class Selector : ItemsControl, IUI<System.Windows.Controls.Primitives.Selector>
    {
        Windows.Controls.Primitives.Selector ui;

        public new Windows.Controls.Primitives.Selector UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Selector() { }
    }

    public static partial class SelectorExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem"/></summary>
        public static TView IsSynchronizedWithCurrentItem<TView>(this TView view, bool? value) where TView : Selector { view.UI.IsSynchronizedWithCurrentItem = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.SelectedIndex"/></summary>
        public static TView SelectedIndex<TView>(this TView view, int value) where TView : Selector { view.UI.SelectedIndex = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.SelectedItem"/></summary>
        public static TView SelectedItem<TView>(this TView view, object value) where TView : Selector { view.UI.SelectedItem = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.SelectedValue"/></summary>
        public static TView SelectedValue<TView>(this TView view, object value) where TView : Selector { view.UI.SelectedValue = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.SelectedValuePath"/></summary>
        public static TView SelectedValuePath<TView>(this TView view, string value) where TView : Selector { view.UI.SelectedValuePath = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem"/></summary>
        public static DependencyProperty<TTarget, bool?> IsSynchronizedWithCurrentItem<TTarget>(this TTarget target) where TTarget : Selector
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.SelectedIndex"/></summary>
        public static DependencyProperty<TTarget, int> SelectedIndex<TTarget>(this TTarget target) where TTarget : Selector
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.Selector.SelectedIndexProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.SelectedItem"/></summary>
        public static DependencyProperty<TTarget, object> SelectedItem<TTarget>(this TTarget target) where TTarget : Selector
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Primitives.Selector.SelectedItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.SelectedValuePath"/></summary>
        public static DependencyProperty<TTarget, string> SelectedValuePath<TTarget>(this TTarget target) where TTarget : Selector
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Primitives.Selector.SelectedValuePathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.SelectedValue"/></summary>
        public static DependencyProperty<TTarget, object> SelectedValue<TTarget>(this TTarget target) where TTarget : Selector
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Primitives.Selector.SelectedValueProperty);

        /// <summary>Set <see cref="Windows.Controls.Primitives.Selector.IsSelected"/></summary>
        public static TTarget Selector_IsSelected<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.Primitives.Selector.SetIsSelected(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Selector.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> Selector_IsSelected<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Selector.IsSelectedProperty);
    }
}

namespace CSharpMarkup.Wpf // StatusBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.StatusBar"/></summary>
        public static StatusBar StatusBar(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Primitives.StatusBar();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.StatusBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.StatusBar"/></summary>
        public static StatusBar StatusBar(O<Windows.Controls.ItemContainerTemplateSelector> ItemContainerTemplateSelector = default, O<bool> UsesItemContainerTemplate = default)
        {
            var ui = new Windows.Controls.Primitives.StatusBar();
            if (ItemContainerTemplateSelector.HasValue) ui.ItemContainerTemplateSelector = ItemContainerTemplateSelector.Value;
            if (UsesItemContainerTemplate.HasValue) ui.UsesItemContainerTemplate = UsesItemContainerTemplate.Value;
            return global::CSharpMarkup.Wpf.StatusBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.StatusBar"/></summary>
        public static StatusBar StatusBar()
        {
            var ui = new Windows.Controls.Primitives.StatusBar();
            return global::CSharpMarkup.Wpf.StatusBar.StartChain(ui);
        }
    }

    public partial class StatusBar : ItemsControl, IUI<System.Windows.Controls.Primitives.StatusBar>
    {
        static StatusBar instance;

        internal static StatusBar StartChain(Windows.Controls.Primitives.StatusBar ui)
        {
            if (instance == null) instance = new StatusBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.StatusBar ui;

        public new Windows.Controls.Primitives.StatusBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(StatusBar view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.StatusBar(StatusBar view) => view?.UI;

        public static implicit operator StatusBar(Windows.Controls.Primitives.StatusBar ui) => StatusBar.StartChain(ui);

        protected StatusBar() { }
    }

    public static partial class StatusBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.StatusBar.ItemContainerTemplateSelector"/></summary>
        public static TView ItemContainerTemplateSelector<TView>(this TView view, Windows.Controls.ItemContainerTemplateSelector value) where TView : StatusBar { view.UI.ItemContainerTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.StatusBar.UsesItemContainerTemplate"/></summary>
        public static TView UsesItemContainerTemplate<TView>(this TView view, bool value) where TView : StatusBar { view.UI.UsesItemContainerTemplate = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.StatusBar.ItemContainerTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector> ItemContainerTemplateSelector<TTarget>(this TTarget target) where TTarget : StatusBar
        => DependencyProperty<TTarget, Windows.Controls.ItemContainerTemplateSelector>.Get(target, Windows.Controls.Primitives.StatusBar.ItemContainerTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.StatusBar.UsesItemContainerTemplate"/></summary>
        public static DependencyProperty<TTarget, bool> UsesItemContainerTemplate<TTarget>(this TTarget target) where TTarget : StatusBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.StatusBar.UsesItemContainerTemplateProperty);
    }
}

namespace CSharpMarkup.Wpf // StatusBarItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.StatusBarItem"/></summary>
        public static StatusBarItem StatusBarItem(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.StatusBarItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.StatusBarItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.StatusBarItem"/></summary>
        public static StatusBarItem StatusBarItem()
        {
            var ui = new Windows.Controls.Primitives.StatusBarItem();
            return global::CSharpMarkup.Wpf.StatusBarItem.StartChain(ui);
        }
    }

    public partial class StatusBarItem : ContentControl, IUI<System.Windows.Controls.Primitives.StatusBarItem>
    {
        static StatusBarItem instance;

        internal static StatusBarItem StartChain(Windows.Controls.Primitives.StatusBarItem ui)
        {
            if (instance == null) instance = new StatusBarItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.StatusBarItem ui;

        public new Windows.Controls.Primitives.StatusBarItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(StatusBarItem view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.StatusBarItem(StatusBarItem view) => view?.UI;

        public static implicit operator StatusBarItem(Windows.Controls.Primitives.StatusBarItem ui) => StatusBarItem.StartChain(ui);

        protected StatusBarItem() { }
    }
}

namespace CSharpMarkup.Wpf // TabPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.TabPanel"/></summary>
        public static TabPanel TabPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.TabPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.TabPanel.StartChain(ui);
        }
    }

    public partial class TabPanel : Panel, IUI<System.Windows.Controls.Primitives.TabPanel>
    {
        static TabPanel instance;

        internal static TabPanel StartChain(Windows.Controls.Primitives.TabPanel ui)
        {
            if (instance == null) instance = new TabPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.TabPanel ui;

        public new Windows.Controls.Primitives.TabPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TabPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.TabPanel(TabPanel view) => view?.UI;

        public static implicit operator TabPanel(Windows.Controls.Primitives.TabPanel ui) => TabPanel.StartChain(ui);

        protected TabPanel() { }
    }
}

namespace CSharpMarkup.Wpf // TextBoxBase
{
    public partial class TextBoxBase : Control, IUI<System.Windows.Controls.Primitives.TextBoxBase>
    {
        Windows.Controls.Primitives.TextBoxBase ui;

        public new Windows.Controls.Primitives.TextBoxBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TextBoxBase() { }
    }

    public static partial class TextBoxBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.AcceptsReturn"/></summary>
        public static TView AcceptsReturn<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.AcceptsReturn = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.AcceptsTab"/></summary>
        public static TView AcceptsTab<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.AcceptsTab = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.AutoWordSelection"/></summary>
        public static TView AutoWordSelection<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.AutoWordSelection = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, Windows.Media.Brush value) where TView : TextBoxBase { view.UI.CaretBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, Color value) where TView : TextBoxBase { view.UI.CaretBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.CaretBrush"/></summary>
        public static TView CaretBrush<TView>(this TView view, string color) where TView : TextBoxBase { view.UI.CaretBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility"/></summary>
        public static TView HorizontalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : TextBoxBase { view.UI.HorizontalScrollBarVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled"/></summary>
        public static TView IsInactiveSelectionHighlightEnabled<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.IsInactiveSelectionHighlightEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.IsReadOnly"/></summary>
        public static TView IsReadOnly<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.IsReadOnly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible"/></summary>
        public static TView IsReadOnlyCaretVisible<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.IsReadOnlyCaretVisible = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled"/></summary>
        public static TView IsUndoEnabled<TView>(this TView view, bool value) where TView : TextBoxBase { view.UI.IsUndoEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Windows.Media.Brush value) where TView : TextBoxBase { view.UI.SelectionBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, Color value) where TView : TextBoxBase { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionBrush"/></summary>
        public static TView SelectionBrush<TView>(this TView view, string color) where TView : TextBoxBase { view.UI.SelectionBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionOpacity"/></summary>
        public static TView SelectionOpacity<TView>(this TView view, double value) where TView : TextBoxBase { view.UI.SelectionOpacity = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, Windows.Media.Brush value) where TView : TextBoxBase { view.UI.SelectionTextBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, Color value) where TView : TextBoxBase { view.UI.SelectionTextBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionTextBrush"/></summary>
        public static TView SelectionTextBrush<TView>(this TView view, string color) where TView : TextBoxBase { view.UI.SelectionTextBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.UndoLimit"/></summary>
        public static TView UndoLimit<TView>(this TView view, int value) where TView : TextBoxBase { view.UI.UndoLimit = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility"/></summary>
        public static TView VerticalScrollBarVisibility<TView>(this TView view, Windows.Controls.ScrollBarVisibility value) where TView : TextBoxBase { view.UI.VerticalScrollBarVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.AcceptsReturn"/></summary>
        public static DependencyProperty<TTarget, bool> AcceptsReturn<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.AcceptsTab"/></summary>
        public static DependencyProperty<TTarget, bool> AcceptsTab<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.AutoWordSelection"/></summary>
        public static DependencyProperty<TTarget, bool> AutoWordSelection<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.AutoWordSelectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.CaretBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CaretBrush<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.TextBoxBase.CaretBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> HorizontalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsInactiveSelectionHighlightEnabled<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnlyCaretVisible<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.IsSelectionActive"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionActive<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.IsSelectionActiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsUndoEnabled<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TextBoxBase.IsUndoEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionBrush<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.TextBoxBase.SelectionBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionOpacity"/></summary>
        public static DependencyProperty<TTarget, double> SelectionOpacity<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TextBoxBase.SelectionOpacityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.SelectionTextBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> SelectionTextBrush<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.TextBoxBase.SelectionTextBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.UndoLimit"/></summary>
        public static DependencyProperty<TTarget, int> UndoLimit<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.TextBoxBase.UndoLimitProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> VerticalScrollBarVisibility<TTarget>(this TTarget target) where TTarget : TextBoxBase
        => DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility>.Get(target, Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // Thumb
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.Thumb"/></summary>
        public static Thumb Thumb()
        {
            var ui = new Windows.Controls.Primitives.Thumb();
            return global::CSharpMarkup.Wpf.Thumb.StartChain(ui);
        }
    }

    public partial class Thumb : Control, IUI<System.Windows.Controls.Primitives.Thumb>
    {
        static Thumb instance;

        internal static Thumb StartChain(Windows.Controls.Primitives.Thumb ui)
        {
            if (instance == null) instance = new Thumb();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.Thumb ui;

        public new Windows.Controls.Primitives.Thumb UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Thumb view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.Thumb(Thumb view) => view?.UI;

        public static implicit operator Thumb(Windows.Controls.Primitives.Thumb ui) => Thumb.StartChain(ui);

        protected Thumb() { }
    }

    public static partial class ThumbExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Thumb.IsDragging"/></summary>
        public static DependencyProperty<TTarget, bool> IsDragging<TTarget>(this TTarget target) where TTarget : Thumb
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Thumb.IsDraggingProperty);
    }
}

namespace CSharpMarkup.Wpf // TickBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.TickBar"/></summary>
        public static TickBar TickBar(O<Windows.Media.Brush> Fill = default, O<bool> IsDirectionReversed = default, O<bool> IsSelectionRangeEnabled = default, O<double> Maximum = default, O<double> Minimum = default, O<Windows.Controls.Primitives.TickBarPlacement> Placement = default, O<double> ReservedSpace = default, O<double> SelectionEnd = default, O<double> SelectionStart = default, O<double> TickFrequency = default, O<Windows.Media.DoubleCollection> Ticks = default)
        {
            var ui = new Windows.Controls.Primitives.TickBar();
            if (Fill.HasValue) ui.Fill = Fill.Value;
            if (IsDirectionReversed.HasValue) ui.IsDirectionReversed = IsDirectionReversed.Value;
            if (IsSelectionRangeEnabled.HasValue) ui.IsSelectionRangeEnabled = IsSelectionRangeEnabled.Value;
            if (Maximum.HasValue) ui.Maximum = Maximum.Value;
            if (Minimum.HasValue) ui.Minimum = Minimum.Value;
            if (Placement.HasValue) ui.Placement = Placement.Value;
            if (ReservedSpace.HasValue) ui.ReservedSpace = ReservedSpace.Value;
            if (SelectionEnd.HasValue) ui.SelectionEnd = SelectionEnd.Value;
            if (SelectionStart.HasValue) ui.SelectionStart = SelectionStart.Value;
            if (TickFrequency.HasValue) ui.TickFrequency = TickFrequency.Value;
            if (Ticks.HasValue) ui.Ticks = Ticks.Value;
            return global::CSharpMarkup.Wpf.TickBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.TickBar"/></summary>
        public static TickBar TickBar()
        {
            var ui = new Windows.Controls.Primitives.TickBar();
            return global::CSharpMarkup.Wpf.TickBar.StartChain(ui);
        }
    }

    public partial class TickBar : FrameworkElement, IUI<System.Windows.Controls.Primitives.TickBar>
    {
        static TickBar instance;

        internal static TickBar StartChain(Windows.Controls.Primitives.TickBar ui)
        {
            if (instance == null) instance = new TickBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.TickBar ui;

        public new Windows.Controls.Primitives.TickBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(TickBar view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.TickBar(TickBar view) => view?.UI;

        public static implicit operator TickBar(Windows.Controls.Primitives.TickBar ui) => TickBar.StartChain(ui);

        protected TickBar() { }
    }

    public static partial class TickBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Windows.Media.Brush value) where TView : TickBar { view.UI.Fill = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Color value) where TView : TickBar { view.UI.Fill = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Fill"/></summary>
        public static TView Fill<TView>(this TView view, string color) where TView : TickBar { view.UI.Fill = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.IsDirectionReversed"/></summary>
        public static TView IsDirectionReversed<TView>(this TView view, bool value) where TView : TickBar { view.UI.IsDirectionReversed = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.IsSelectionRangeEnabled"/></summary>
        public static TView IsSelectionRangeEnabled<TView>(this TView view, bool value) where TView : TickBar { view.UI.IsSelectionRangeEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Maximum"/></summary>
        public static TView Maximum<TView>(this TView view, double value) where TView : TickBar { view.UI.Maximum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Minimum"/></summary>
        public static TView Minimum<TView>(this TView view, double value) where TView : TickBar { view.UI.Minimum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Placement"/></summary>
        public static TView Placement<TView>(this TView view, Windows.Controls.Primitives.TickBarPlacement value) where TView : TickBar { view.UI.Placement = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.ReservedSpace"/></summary>
        public static TView ReservedSpace<TView>(this TView view, double value) where TView : TickBar { view.UI.ReservedSpace = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.SelectionEnd"/></summary>
        public static TView SelectionEnd<TView>(this TView view, double value) where TView : TickBar { view.UI.SelectionEnd = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.SelectionStart"/></summary>
        public static TView SelectionStart<TView>(this TView view, double value) where TView : TickBar { view.UI.SelectionStart = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.TickFrequency"/></summary>
        public static TView TickFrequency<TView>(this TView view, double value) where TView : TickBar { view.UI.TickFrequency = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.TickBar.Ticks"/></summary>
        public static TView Ticks<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : TickBar { view.UI.Ticks = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.Fill"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Fill<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Primitives.TickBar.FillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.IsDirectionReversed"/></summary>
        public static DependencyProperty<TTarget, bool> IsDirectionReversed<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TickBar.IsDirectionReversedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.IsSelectionRangeEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelectionRangeEnabled<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.TickBar.IsSelectionRangeEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.Maximum"/></summary>
        public static DependencyProperty<TTarget, double> Maximum<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.MaximumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.Minimum"/></summary>
        public static DependencyProperty<TTarget, double> Minimum<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.MinimumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.Placement"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement> Placement<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement>.Get(target, Windows.Controls.Primitives.TickBar.PlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.ReservedSpace"/></summary>
        public static DependencyProperty<TTarget, double> ReservedSpace<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.ReservedSpaceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.SelectionEnd"/></summary>
        public static DependencyProperty<TTarget, double> SelectionEnd<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.SelectionEndProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.SelectionStart"/></summary>
        public static DependencyProperty<TTarget, double> SelectionStart<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.SelectionStartProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.TickFrequency"/></summary>
        public static DependencyProperty<TTarget, double> TickFrequency<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.TickBar.TickFrequencyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.TickBar.Ticks"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> Ticks<TTarget>(this TTarget target) where TTarget : TickBar
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Controls.Primitives.TickBar.TicksProperty);
    }
}

namespace CSharpMarkup.Wpf // ToggleButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToggleButton"/></summary>
        /// <remarks>Remark: ToggleButton().Bind() binds to <see cref="Windows.Controls.Primitives.ToggleButton.IsCheckedProperty"/></remarks>
        public static ToggleButton ToggleButton(
            object Content
)
        {
            var ui = new Windows.Controls.Primitives.ToggleButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.ToggleButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToggleButton"/></summary>
        /// <remarks>Remark: ToggleButton().Bind() binds to <see cref="Windows.Controls.Primitives.ToggleButton.IsCheckedProperty"/></remarks>
        public static ToggleButton ToggleButton(O<bool?> IsChecked = default, O<bool> IsThreeState = default)
        {
            var ui = new Windows.Controls.Primitives.ToggleButton();
            if (IsChecked.HasValue) ui.IsChecked = IsChecked.Value;
            if (IsThreeState.HasValue) ui.IsThreeState = IsThreeState.Value;
            return global::CSharpMarkup.Wpf.ToggleButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToggleButton"/></summary>
        /// <remarks>Remark: ToggleButton().Bind() binds to <see cref="Windows.Controls.Primitives.ToggleButton.IsCheckedProperty"/></remarks>
        public static ToggleButton ToggleButton()
        {
            var ui = new Windows.Controls.Primitives.ToggleButton();
            return global::CSharpMarkup.Wpf.ToggleButton.StartChain(ui);
        }
    }

    public partial class ToggleButton : ButtonBase, IUI<System.Windows.Controls.Primitives.ToggleButton>, IDefaultBindProperty
    {
        static ToggleButton instance;

        internal static ToggleButton StartChain(Windows.Controls.Primitives.ToggleButton ui)
        {
            if (instance == null) instance = new ToggleButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.ToggleButton ui;

        public new Windows.Controls.Primitives.ToggleButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.ToggleButton.IsCheckedProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.ToggleButton.IsCheckedProperty;

        public static implicit operator Windows.UIElement(ToggleButton view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.ToggleButton(ToggleButton view) => view?.UI;

        public static implicit operator ToggleButton(Windows.Controls.Primitives.ToggleButton ui) => ToggleButton.StartChain(ui);

        protected ToggleButton() { }
    }

    public static partial class ToggleButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.ToggleButton.IsChecked"/></summary>
        public static TView IsChecked<TView>(this TView view, bool? value) where TView : ToggleButton { view.UI.IsChecked = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.ToggleButton.IsThreeState"/></summary>
        public static TView IsThreeState<TView>(this TView view, bool value) where TView : ToggleButton { view.UI.IsThreeState = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ToggleButton.IsChecked"/></summary>
        public static DependencyProperty<TTarget, bool?> IsChecked<TTarget>(this TTarget target) where TTarget : ToggleButton
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Controls.Primitives.ToggleButton.IsCheckedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ToggleButton.IsThreeState"/></summary>
        public static DependencyProperty<TTarget, bool> IsThreeState<TTarget>(this TTarget target) where TTarget : ToggleButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.ToggleButton.IsThreeStateProperty);
    }
}

namespace CSharpMarkup.Wpf // ToolBarOverflowPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToolBarOverflowPanel"/></summary>
        public static ToolBarOverflowPanel ToolBarOverflowPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.ToolBarOverflowPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.ToolBarOverflowPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToolBarOverflowPanel"/></summary>
        public static ToolBarOverflowPanel ToolBarOverflowPanel(O<double> WrapWidth = default)
        {
            var ui = new Windows.Controls.Primitives.ToolBarOverflowPanel();
            if (WrapWidth.HasValue) ui.WrapWidth = WrapWidth.Value;
            return global::CSharpMarkup.Wpf.ToolBarOverflowPanel.StartChain(ui);
        }
    }

    public partial class ToolBarOverflowPanel : Panel, IUI<System.Windows.Controls.Primitives.ToolBarOverflowPanel>
    {
        static ToolBarOverflowPanel instance;

        internal static ToolBarOverflowPanel StartChain(Windows.Controls.Primitives.ToolBarOverflowPanel ui)
        {
            if (instance == null) instance = new ToolBarOverflowPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.ToolBarOverflowPanel ui;

        public new Windows.Controls.Primitives.ToolBarOverflowPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ToolBarOverflowPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.ToolBarOverflowPanel(ToolBarOverflowPanel view) => view?.UI;

        public static implicit operator ToolBarOverflowPanel(Windows.Controls.Primitives.ToolBarOverflowPanel ui) => ToolBarOverflowPanel.StartChain(ui);

        protected ToolBarOverflowPanel() { }
    }

    public static partial class ToolBarOverflowPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.ToolBarOverflowPanel.WrapWidth"/></summary>
        public static TView WrapWidth<TView>(this TView view, double value) where TView : ToolBarOverflowPanel { view.UI.WrapWidth = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.ToolBarOverflowPanel.WrapWidth"/></summary>
        public static DependencyProperty<TTarget, double> WrapWidth<TTarget>(this TTarget target) where TTarget : ToolBarOverflowPanel
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.ToolBarOverflowPanel.WrapWidthProperty);
    }
}

namespace CSharpMarkup.Wpf // ToolBarPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.ToolBarPanel"/></summary>
        public static ToolBarPanel ToolBarPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.ToolBarPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.ToolBarPanel.StartChain(ui);
        }
    }

    public partial class ToolBarPanel : StackPanel, IUI<System.Windows.Controls.Primitives.ToolBarPanel>
    {
        static ToolBarPanel instance;

        internal static ToolBarPanel StartChain(Windows.Controls.Primitives.ToolBarPanel ui)
        {
            if (instance == null) instance = new ToolBarPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.ToolBarPanel ui;

        public new Windows.Controls.Primitives.ToolBarPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(ToolBarPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.ToolBarPanel(ToolBarPanel view) => view?.UI;

        public static implicit operator ToolBarPanel(Windows.Controls.Primitives.ToolBarPanel ui) => ToolBarPanel.StartChain(ui);

        protected ToolBarPanel() { }
    }
}

namespace CSharpMarkup.Wpf // Track
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.Track"/></summary>
        /// <remarks>Remark: Track().Bind() binds to <see cref="Windows.Controls.Primitives.Track.ValueProperty"/></remarks>
        public static Track Track(O<Windows.Controls.Primitives.RepeatButton> DecreaseRepeatButton = default, O<Windows.Controls.Primitives.RepeatButton> IncreaseRepeatButton = default, O<bool> IsDirectionReversed = default, O<double> Maximum = default, O<double> Minimum = default, O<Windows.Controls.Orientation> Orientation = default, O<Windows.Controls.Primitives.Thumb> Thumb = default, O<double> Value = default, O<double> ViewportSize = default)
        {
            var ui = new Windows.Controls.Primitives.Track();
            if (DecreaseRepeatButton.HasValue) ui.DecreaseRepeatButton = DecreaseRepeatButton.Value;
            if (IncreaseRepeatButton.HasValue) ui.IncreaseRepeatButton = IncreaseRepeatButton.Value;
            if (IsDirectionReversed.HasValue) ui.IsDirectionReversed = IsDirectionReversed.Value;
            if (Maximum.HasValue) ui.Maximum = Maximum.Value;
            if (Minimum.HasValue) ui.Minimum = Minimum.Value;
            if (Orientation.HasValue) ui.Orientation = Orientation.Value;
            if (Thumb.HasValue) ui.Thumb = Thumb.Value;
            if (Value.HasValue) ui.Value = Value.Value;
            if (ViewportSize.HasValue) ui.ViewportSize = ViewportSize.Value;
            return global::CSharpMarkup.Wpf.Track.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.Track"/></summary>
        /// <remarks>Remark: Track().Bind() binds to <see cref="Windows.Controls.Primitives.Track.ValueProperty"/></remarks>
        public static Track Track()
        {
            var ui = new Windows.Controls.Primitives.Track();
            return global::CSharpMarkup.Wpf.Track.StartChain(ui);
        }
    }

    public partial class Track : FrameworkElement, IUI<System.Windows.Controls.Primitives.Track>, IDefaultBindProperty
    {
        static Track instance;

        internal static Track StartChain(Windows.Controls.Primitives.Track ui)
        {
            if (instance == null) instance = new Track();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.Track ui;

        public new Windows.Controls.Primitives.Track UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.Primitives.Track.ValueProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.Primitives.Track.ValueProperty;

        public static implicit operator Windows.UIElement(Track view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.Track(Track view) => view?.UI;

        public static implicit operator Track(Windows.Controls.Primitives.Track ui) => Track.StartChain(ui);

        protected Track() { }
    }

    public static partial class TrackExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.DecreaseRepeatButton"/></summary>
        public static TView DecreaseRepeatButton<TView>(this TView view, Windows.Controls.Primitives.RepeatButton value) where TView : Track { view.UI.DecreaseRepeatButton = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.IncreaseRepeatButton"/></summary>
        public static TView IncreaseRepeatButton<TView>(this TView view, Windows.Controls.Primitives.RepeatButton value) where TView : Track { view.UI.IncreaseRepeatButton = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.IsDirectionReversed"/></summary>
        public static TView IsDirectionReversed<TView>(this TView view, bool value) where TView : Track { view.UI.IsDirectionReversed = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.Maximum"/></summary>
        public static TView Maximum<TView>(this TView view, double value) where TView : Track { view.UI.Maximum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.Minimum"/></summary>
        public static TView Minimum<TView>(this TView view, double value) where TView : Track { view.UI.Minimum = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.Orientation"/></summary>
        public static TView Orientation<TView>(this TView view, Windows.Controls.Orientation value) where TView : Track { view.UI.Orientation = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.Thumb"/></summary>
        public static TView Thumb<TView>(this TView view, Windows.Controls.Primitives.Thumb value) where TView : Track { view.UI.Thumb = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.Value"/></summary>
        public static TView Value<TView>(this TView view, double value) where TView : Track { view.UI.Value = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.Track.ViewportSize"/></summary>
        public static TView ViewportSize<TView>(this TView view, double value) where TView : Track { view.UI.ViewportSize = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.IsDirectionReversed"/></summary>
        public static DependencyProperty<TTarget, bool> IsDirectionReversed<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Primitives.Track.IsDirectionReversedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.Maximum"/></summary>
        public static DependencyProperty<TTarget, double> Maximum<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Track.MaximumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.Minimum"/></summary>
        public static DependencyProperty<TTarget, double> Minimum<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Track.MinimumProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.Orientation"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Orientation> Orientation<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, Windows.Controls.Orientation>.Get(target, Windows.Controls.Primitives.Track.OrientationProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.Value"/></summary>
        public static DependencyProperty<TTarget, double> Value<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Track.ValueProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.Track.ViewportSize"/></summary>
        public static DependencyProperty<TTarget, double> ViewportSize<TTarget>(this TTarget target) where TTarget : Track
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Primitives.Track.ViewportSizeProperty);
    }
}

namespace CSharpMarkup.Wpf // UniformGrid
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Primitives.UniformGrid"/></summary>
        public static UniformGrid UniformGrid(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Primitives.UniformGrid();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.UniformGrid.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Primitives.UniformGrid"/></summary>
        public static UniformGrid UniformGrid(O<int> Columns = default, O<int> FirstColumn = default, O<int> Rows = default)
        {
            var ui = new Windows.Controls.Primitives.UniformGrid();
            if (Columns.HasValue) ui.Columns = Columns.Value;
            if (FirstColumn.HasValue) ui.FirstColumn = FirstColumn.Value;
            if (Rows.HasValue) ui.Rows = Rows.Value;
            return global::CSharpMarkup.Wpf.UniformGrid.StartChain(ui);
        }
    }

    public partial class UniformGrid : Panel, IUI<System.Windows.Controls.Primitives.UniformGrid>
    {
        static UniformGrid instance;

        internal static UniformGrid StartChain(Windows.Controls.Primitives.UniformGrid ui)
        {
            if (instance == null) instance = new UniformGrid();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Primitives.UniformGrid ui;

        public new Windows.Controls.Primitives.UniformGrid UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(UniformGrid view) => view?.UI;

        public static implicit operator Windows.Controls.Primitives.UniformGrid(UniformGrid view) => view?.UI;

        public static implicit operator UniformGrid(Windows.Controls.Primitives.UniformGrid ui) => UniformGrid.StartChain(ui);

        protected UniformGrid() { }
    }

    public static partial class UniformGridExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Primitives.UniformGrid.Columns"/></summary>
        public static TView Columns<TView>(this TView view, int value) where TView : UniformGrid { view.UI.Columns = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.UniformGrid.FirstColumn"/></summary>
        public static TView FirstColumn<TView>(this TView view, int value) where TView : UniformGrid { view.UI.FirstColumn = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Primitives.UniformGrid.Rows"/></summary>
        public static TView Rows<TView>(this TView view, int value) where TView : UniformGrid { view.UI.Rows = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.UniformGrid.Columns"/></summary>
        public static DependencyProperty<TTarget, int> Columns<TTarget>(this TTarget target) where TTarget : UniformGrid
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.UniformGrid.ColumnsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.UniformGrid.FirstColumn"/></summary>
        public static DependencyProperty<TTarget, int> FirstColumn<TTarget>(this TTarget target) where TTarget : UniformGrid
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.UniformGrid.FirstColumnProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Primitives.UniformGrid.Rows"/></summary>
        public static DependencyProperty<TTarget, int> Rows<TTarget>(this TTarget target) where TTarget : UniformGrid
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Primitives.UniformGrid.RowsProperty);
    }
}

namespace CSharpMarkup.Wpf // BindingGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Data.BindingGroup"/></summary>
        public static BindingGroup BindingGroup(O<string> Name = default, O<bool> NotifyOnValidationError = default, O<bool> SharesProposedValues = default, O<bool> ValidatesOnNotifyDataError = default)
        {
            var ui = new Windows.Data.BindingGroup();
            if (Name.HasValue) ui.Name = Name.Value;
            if (NotifyOnValidationError.HasValue) ui.NotifyOnValidationError = NotifyOnValidationError.Value;
            if (SharesProposedValues.HasValue) ui.SharesProposedValues = SharesProposedValues.Value;
            if (ValidatesOnNotifyDataError.HasValue) ui.ValidatesOnNotifyDataError = ValidatesOnNotifyDataError.Value;
            return global::CSharpMarkup.Wpf.BindingGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Data.BindingGroup"/></summary>
        public static BindingGroup BindingGroup()
        {
            var ui = new Windows.Data.BindingGroup();
            return global::CSharpMarkup.Wpf.BindingGroup.StartChain(ui);
        }
    }

    public partial class BindingGroup : DependencyObject, IUI<System.Windows.Data.BindingGroup>
    {
        static BindingGroup instance;

        internal static BindingGroup StartChain(Windows.Data.BindingGroup ui)
        {
            if (instance == null) instance = new BindingGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Data.BindingGroup ui;

        public new Windows.Data.BindingGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Data.BindingGroup(BindingGroup view) => view?.UI;

        public static implicit operator BindingGroup(Windows.Data.BindingGroup ui) => BindingGroup.StartChain(ui);

        protected BindingGroup() { }
    }

    public static partial class BindingGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Data.BindingGroup.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : BindingGroup { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.Data.BindingGroup.NotifyOnValidationError"/></summary>
        public static TView NotifyOnValidationError<TView>(this TView view, bool value) where TView : BindingGroup { view.UI.NotifyOnValidationError = value; return view; }

        /// <summary>Set <see cref="Windows.Data.BindingGroup.SharesProposedValues"/></summary>
        public static TView SharesProposedValues<TView>(this TView view, bool value) where TView : BindingGroup { view.UI.SharesProposedValues = value; return view; }

        /// <summary>Set <see cref="Windows.Data.BindingGroup.ValidatesOnNotifyDataError"/></summary>
        public static TView ValidatesOnNotifyDataError<TView>(this TView view, bool value) where TView : BindingGroup { view.UI.ValidatesOnNotifyDataError = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // CollectionContainer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Data.CollectionContainer"/></summary>
        public static CollectionContainer CollectionContainer(O<IEnumerable> Collection = default)
        {
            var ui = new Windows.Data.CollectionContainer();
            if (Collection.HasValue) ui.Collection = Collection.Value;
            return global::CSharpMarkup.Wpf.CollectionContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Data.CollectionContainer"/></summary>
        public static CollectionContainer CollectionContainer()
        {
            var ui = new Windows.Data.CollectionContainer();
            return global::CSharpMarkup.Wpf.CollectionContainer.StartChain(ui);
        }
    }

    public partial class CollectionContainer : DependencyObject, IUI<System.Windows.Data.CollectionContainer>
    {
        static CollectionContainer instance;

        internal static CollectionContainer StartChain(Windows.Data.CollectionContainer ui)
        {
            if (instance == null) instance = new CollectionContainer();
            instance.UI = ui;
            return instance;
        }

        Windows.Data.CollectionContainer ui;

        public new Windows.Data.CollectionContainer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Data.CollectionContainer(CollectionContainer view) => view?.UI;

        public static implicit operator CollectionContainer(Windows.Data.CollectionContainer ui) => CollectionContainer.StartChain(ui);

        protected CollectionContainer() { }
    }

    public static partial class CollectionContainerExtensions
    {
        /// <summary>Set <see cref="Windows.Data.CollectionContainer.Collection"/></summary>
        public static TView Collection<TView>(this TView view, IEnumerable value) where TView : CollectionContainer { view.UI.Collection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionContainer.Collection"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> Collection<TTarget>(this TTarget target) where TTarget : CollectionContainer
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Data.CollectionContainer.CollectionProperty);
    }
}

namespace CSharpMarkup.Wpf // CollectionViewSource
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Data.CollectionViewSource"/></summary>
        public static CollectionViewSource CollectionViewSource(O<Type> CollectionViewType = default, O<CultureInfo> Culture = default, O<bool> IsLiveFilteringRequested = default, O<bool> IsLiveGroupingRequested = default, O<bool> IsLiveSortingRequested = default, O<object> Source = default)
        {
            var ui = new Windows.Data.CollectionViewSource();
            if (CollectionViewType.HasValue) ui.CollectionViewType = CollectionViewType.Value;
            if (Culture.HasValue) ui.Culture = Culture.Value;
            if (IsLiveFilteringRequested.HasValue) ui.IsLiveFilteringRequested = IsLiveFilteringRequested.Value;
            if (IsLiveGroupingRequested.HasValue) ui.IsLiveGroupingRequested = IsLiveGroupingRequested.Value;
            if (IsLiveSortingRequested.HasValue) ui.IsLiveSortingRequested = IsLiveSortingRequested.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.CollectionViewSource.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Data.CollectionViewSource"/></summary>
        public static CollectionViewSource CollectionViewSource()
        {
            var ui = new Windows.Data.CollectionViewSource();
            return global::CSharpMarkup.Wpf.CollectionViewSource.StartChain(ui);
        }
    }

    public partial class CollectionViewSource : DependencyObject, IUI<System.Windows.Data.CollectionViewSource>
    {
        static CollectionViewSource instance;

        internal static CollectionViewSource StartChain(Windows.Data.CollectionViewSource ui)
        {
            if (instance == null) instance = new CollectionViewSource();
            instance.UI = ui;
            return instance;
        }

        Windows.Data.CollectionViewSource ui;

        public new Windows.Data.CollectionViewSource UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Data.CollectionViewSource(CollectionViewSource view) => view?.UI;

        public static implicit operator CollectionViewSource(Windows.Data.CollectionViewSource ui) => CollectionViewSource.StartChain(ui);

        protected CollectionViewSource() { }
    }

    public static partial class CollectionViewSourceExtensions
    {
        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.CollectionViewType"/></summary>
        public static TView CollectionViewType<TView>(this TView view, Type value) where TView : CollectionViewSource { view.UI.CollectionViewType = value; return view; }

        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.Culture"/></summary>
        public static TView Culture<TView>(this TView view, CultureInfo value) where TView : CollectionViewSource { view.UI.Culture = value; return view; }

        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.IsLiveFilteringRequested"/></summary>
        public static TView IsLiveFilteringRequested<TView>(this TView view, bool value) where TView : CollectionViewSource { view.UI.IsLiveFilteringRequested = value; return view; }

        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.IsLiveGroupingRequested"/></summary>
        public static TView IsLiveGroupingRequested<TView>(this TView view, bool value) where TView : CollectionViewSource { view.UI.IsLiveGroupingRequested = value; return view; }

        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.IsLiveSortingRequested"/></summary>
        public static TView IsLiveSortingRequested<TView>(this TView view, bool value) where TView : CollectionViewSource { view.UI.IsLiveSortingRequested = value; return view; }

        /// <summary>Set <see cref="Windows.Data.CollectionViewSource.Source"/></summary>
        public static TView Source<TView>(this TView view, object value) where TView : CollectionViewSource { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.CanChangeLiveFiltering"/></summary>
        public static DependencyProperty<TTarget, bool> CanChangeLiveFiltering<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.CanChangeLiveFilteringProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.CanChangeLiveGrouping"/></summary>
        public static DependencyProperty<TTarget, bool> CanChangeLiveGrouping<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.CanChangeLiveGroupingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.CanChangeLiveSorting"/></summary>
        public static DependencyProperty<TTarget, bool> CanChangeLiveSorting<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.CanChangeLiveSortingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.CollectionViewType"/></summary>
        public static DependencyProperty<TTarget, Type> CollectionViewType<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, Type>.Get(target, Windows.Data.CollectionViewSource.CollectionViewTypeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveFiltering"/></summary>
        public static DependencyProperty<TTarget, bool?> IsLiveFiltering<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Data.CollectionViewSource.IsLiveFilteringProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveFilteringRequested"/></summary>
        public static DependencyProperty<TTarget, bool> IsLiveFilteringRequested<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.IsLiveFilteringRequestedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveGrouping"/></summary>
        public static DependencyProperty<TTarget, bool?> IsLiveGrouping<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Data.CollectionViewSource.IsLiveGroupingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveGroupingRequested"/></summary>
        public static DependencyProperty<TTarget, bool> IsLiveGroupingRequested<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.IsLiveGroupingRequestedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveSorting"/></summary>
        public static DependencyProperty<TTarget, bool?> IsLiveSorting<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Data.CollectionViewSource.IsLiveSortingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.IsLiveSortingRequested"/></summary>
        public static DependencyProperty<TTarget, bool> IsLiveSortingRequested<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Data.CollectionViewSource.IsLiveSortingRequestedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.Source"/></summary>
        public static DependencyProperty<TTarget, object> Source<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, object>.Get(target, Windows.Data.CollectionViewSource.SourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Data.CollectionViewSource.View"/></summary>
        public static DependencyProperty<TTarget, ICollectionView> View<TTarget>(this TTarget target) where TTarget : CollectionViewSource
        => DependencyProperty<TTarget, ICollectionView>.Get(target, Windows.Data.CollectionViewSource.ViewProperty);
    }
}

namespace CSharpMarkup.Wpf // Adorner
{
    public partial class Adorner : FrameworkElement, IUI<System.Windows.Documents.Adorner>
    {
        Windows.Documents.Adorner ui;

        public new Windows.Documents.Adorner UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Adorner() { }
    }

    public static partial class AdornerExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Adorner.IsClipEnabled"/></summary>
        public static TView IsClipEnabled<TView>(this TView view, bool value) where TView : Adorner { view.UI.IsClipEnabled = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // AdornerDecorator
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.AdornerDecorator"/></summary>
        public static AdornerDecorator AdornerDecorator(
            System.Windows.UIElement Child
)
        {
            var ui = new Windows.Documents.AdornerDecorator();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.AdornerDecorator.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.AdornerDecorator"/></summary>
        public static AdornerDecorator AdornerDecorator()
        {
            var ui = new Windows.Documents.AdornerDecorator();
            return global::CSharpMarkup.Wpf.AdornerDecorator.StartChain(ui);
        }
    }

    public partial class AdornerDecorator : Decorator, IUI<System.Windows.Documents.AdornerDecorator>
    {
        static AdornerDecorator instance;

        internal static AdornerDecorator StartChain(Windows.Documents.AdornerDecorator ui)
        {
            if (instance == null) instance = new AdornerDecorator();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.AdornerDecorator ui;

        public new Windows.Documents.AdornerDecorator UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(AdornerDecorator view) => view?.UI;

        public static implicit operator Windows.Documents.AdornerDecorator(AdornerDecorator view) => view?.UI;

        public static implicit operator AdornerDecorator(Windows.Documents.AdornerDecorator ui) => AdornerDecorator.StartChain(ui);

        protected AdornerDecorator() { }
    }
}

namespace CSharpMarkup.Wpf // AdornerLayer
{
    public partial class AdornerLayer : FrameworkElement, IUI<System.Windows.Documents.AdornerLayer>
    {
        Windows.Documents.AdornerLayer ui;

        public new Windows.Documents.AdornerLayer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected AdornerLayer() { }
    }
}

namespace CSharpMarkup.Wpf // AnchoredBlock
{
    public partial class AnchoredBlock : Inline, IUI<System.Windows.Documents.AnchoredBlock>
    {
        Windows.Documents.AnchoredBlock ui;

        public new Windows.Documents.AnchoredBlock UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected AnchoredBlock() { }
    }

    public static partial class AnchoredBlockExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : AnchoredBlock { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : AnchoredBlock { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : AnchoredBlock { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : AnchoredBlock { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : AnchoredBlock { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : AnchoredBlock { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : AnchoredBlock { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : AnchoredBlock { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : AnchoredBlock { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : AnchoredBlock { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static TView Margin<TView>(this TView view, Windows.Thickness value) where TView : AnchoredBlock { view.UI.Margin = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double uniform) where TView : AnchoredBlock { view.UI.Margin = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double horizontal, double vertical) where TView : AnchoredBlock { view.UI.Margin = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double left, double top, double right, double bottom) where TView : AnchoredBlock { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static TView Margins<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : AnchoredBlock { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : AnchoredBlock { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : AnchoredBlock { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : AnchoredBlock { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : AnchoredBlock { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : AnchoredBlock { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.AnchoredBlock.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : AnchoredBlock { view.UI.TextAlignment = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.AnchoredBlock.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.AnchoredBlock.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.AnchoredBlock.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.AnchoredBlock.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.Margin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Margin<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.AnchoredBlock.MarginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.AnchoredBlock.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.AnchoredBlock.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : AnchoredBlock
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.AnchoredBlock.TextAlignmentProperty);
    }
}

namespace CSharpMarkup.Wpf // Block
{
    public partial class Block : TextElement, IUI<System.Windows.Documents.Block>
    {
        Windows.Documents.Block ui;

        public new Windows.Documents.Block UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Block() { }
    }

    public static partial class BlockExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Block.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Block { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : Block { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : Block { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : Block { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : Block { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : Block { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : Block { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Block { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BreakColumnBefore"/></summary>
        public static TView BreakColumnBefore<TView>(this TView view, bool value) where TView : Block { view.UI.BreakColumnBefore = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.BreakPageBefore"/></summary>
        public static TView BreakPageBefore<TView>(this TView view, bool value) where TView : Block { view.UI.BreakPageBefore = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.ClearFloaters"/></summary>
        public static TView ClearFloaters<TView>(this TView view, Windows.WrapDirection value) where TView : Block { view.UI.ClearFloaters = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : Block { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.IsHyphenationEnabled"/></summary>
        public static TView IsHyphenationEnabled<TView>(this TView view, bool value) where TView : Block { view.UI.IsHyphenationEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : Block { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : Block { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Margin"/></summary>
        public static TView Margin<TView>(this TView view, Windows.Thickness value) where TView : Block { view.UI.Margin = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double uniform) where TView : Block { view.UI.Margin = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double horizontal, double vertical) where TView : Block { view.UI.Margin = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double left, double top, double right, double bottom) where TView : Block { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Margin"/></summary>
        public static TView Margins<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Block { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : Block { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : Block { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : Block { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : Block { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : Block { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.Block.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : Block { view.UI.TextAlignment = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.Block.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.Block.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.BreakColumnBefore"/></summary>
        public static DependencyProperty<TTarget, bool> BreakColumnBefore<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Block.BreakColumnBeforeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.BreakPageBefore"/></summary>
        public static DependencyProperty<TTarget, bool> BreakPageBefore<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Block.BreakPageBeforeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.ClearFloaters"/></summary>
        public static DependencyProperty<TTarget, Windows.WrapDirection> ClearFloaters<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.WrapDirection>.Get(target, Windows.Documents.Block.ClearFloatersProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.Documents.Block.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.IsHyphenationEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsHyphenationEnabled<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Block.IsHyphenationEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Block.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.Block.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.Margin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Margin<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.Block.MarginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.Block.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : Block
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.Block.TextAlignmentProperty);

        /// <summary>Set <see cref="Windows.Documents.Block.IsHyphenationEnabled"/></summary>
        public static TTarget Block_IsHyphenationEnabled<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Documents.Block.SetIsHyphenationEnabled(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.IsHyphenationEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> Block_IsHyphenationEnabled<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Block.IsHyphenationEnabledProperty);

        /// <summary>Set <see cref="Windows.Documents.Block.LineHeight"/></summary>
        public static TTarget Block_LineHeight<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Documents.Block.SetLineHeight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> Block_LineHeight<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Block.LineHeightProperty);

        /// <summary>Set <see cref="Windows.Documents.Block.LineStackingStrategy"/></summary>
        public static TTarget Block_LineStackingStrategy<TTarget>(this TTarget target, Windows.LineStackingStrategy value) where TTarget : DependencyObject
        { Windows.Documents.Block.SetLineStackingStrategy(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> Block_LineStackingStrategy<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.Block.LineStackingStrategyProperty);

        /// <summary>Set <see cref="Windows.Documents.Block.TextAlignment"/></summary>
        public static TTarget Block_TextAlignment<TTarget>(this TTarget target, Windows.TextAlignment value) where TTarget : DependencyObject
        { Windows.Documents.Block.SetTextAlignment(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Block.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> Block_TextAlignment<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.Block.TextAlignmentProperty);

        /// <summary>Set <see cref="Windows.Documents.Block"/> attached properties</summary>
        public static TTarget Block<TTarget>(this TTarget target

            , O<bool> IsHyphenationEnabled = default

            , O<double> LineHeight = default

            , O<Windows.LineStackingStrategy> LineStackingStrategy = default

            , O<Windows.TextAlignment> TextAlignment = default

        ) where TTarget : DependencyObject
        {
            if (IsHyphenationEnabled.HasValue) Windows.Documents.Block.SetIsHyphenationEnabled(target.UI, IsHyphenationEnabled.Value);

            if (LineHeight.HasValue) Windows.Documents.Block.SetLineHeight(target.UI, LineHeight.Value);

            if (LineStackingStrategy.HasValue) Windows.Documents.Block.SetLineStackingStrategy(target.UI, LineStackingStrategy.Value);

            if (TextAlignment.HasValue) Windows.Documents.Block.SetTextAlignment(target.UI, TextAlignment.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // BlockUIContainer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.BlockUIContainer"/></summary>
        public static BlockUIContainer BlockUIContainer(O<Windows.UIElement> Child = default)
        {
            var ui = new Windows.Documents.BlockUIContainer();
            if (Child.HasValue) ui.Child = Child.Value;
            return global::CSharpMarkup.Wpf.BlockUIContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.BlockUIContainer"/></summary>
        public static BlockUIContainer BlockUIContainer()
        {
            var ui = new Windows.Documents.BlockUIContainer();
            return global::CSharpMarkup.Wpf.BlockUIContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.BlockUIContainer"/></summary>
        public static BlockUIContainer BlockUIContainer(Windows.UIElement uiElement)
        {
            var ui = new Windows.Documents.BlockUIContainer(uiElement);
            return global::CSharpMarkup.Wpf.BlockUIContainer.StartChain(ui);
        }
    }

    public partial class BlockUIContainer : Block, IUI<System.Windows.Documents.BlockUIContainer>
    {
        static BlockUIContainer instance;

        internal static BlockUIContainer StartChain(Windows.Documents.BlockUIContainer ui)
        {
            if (instance == null) instance = new BlockUIContainer();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.BlockUIContainer ui;

        public new Windows.Documents.BlockUIContainer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.BlockUIContainer(BlockUIContainer view) => view?.UI;

        public static implicit operator BlockUIContainer(Windows.Documents.BlockUIContainer ui) => BlockUIContainer.StartChain(ui);

        protected BlockUIContainer() { }
    }

    public static partial class BlockUIContainerExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.BlockUIContainer.Child"/></summary>
        public static TView Child<TView>(this TView view, Windows.UIElement value) where TView : BlockUIContainer { view.UI.Child = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Bold
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Bold"/></summary>
        public static Bold Bold(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Bold();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Bold.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Bold"/></summary>
        public static Bold Bold()
        {
            var ui = new Windows.Documents.Bold();
            return global::CSharpMarkup.Wpf.Bold.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Bold"/></summary>
        public static Bold Bold(Windows.Documents.Inline childInline)
        {
            var ui = new Windows.Documents.Bold(childInline);
            return global::CSharpMarkup.Wpf.Bold.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Bold"/></summary>
        public static Bold Bold(Windows.Documents.Inline childInline, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Bold(childInline, insertionPosition);
            return global::CSharpMarkup.Wpf.Bold.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Bold"/></summary>
        public static Bold Bold(Windows.Documents.TextPointer start, Windows.Documents.TextPointer end)
        {
            var ui = new Windows.Documents.Bold(start, end);
            return global::CSharpMarkup.Wpf.Bold.StartChain(ui);
        }
    }

    public partial class Bold : Span, IUI<System.Windows.Documents.Bold>
    {
        static Bold instance;

        internal static Bold StartChain(Windows.Documents.Bold ui)
        {
            if (instance == null) instance = new Bold();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Bold ui;

        public new Windows.Documents.Bold UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Bold view) => view?.UI;

        public static implicit operator Windows.Documents.Bold(Bold view) => view?.UI;

        public static implicit operator Bold(Windows.Documents.Bold ui) => Bold.StartChain(ui);

        protected Bold() { }
    }
}

namespace CSharpMarkup.Wpf // DocumentReference
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.DocumentReference"/></summary>
        public static DocumentReference DocumentReference(O<Uri> Source = default)
        {
            var ui = new Windows.Documents.DocumentReference();
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.DocumentReference.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.DocumentReference"/></summary>
        public static DocumentReference DocumentReference()
        {
            var ui = new Windows.Documents.DocumentReference();
            return global::CSharpMarkup.Wpf.DocumentReference.StartChain(ui);
        }
    }

    public partial class DocumentReference : FrameworkElement, IUI<System.Windows.Documents.DocumentReference>
    {
        static DocumentReference instance;

        internal static DocumentReference StartChain(Windows.Documents.DocumentReference ui)
        {
            if (instance == null) instance = new DocumentReference();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.DocumentReference ui;

        public new Windows.Documents.DocumentReference UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(DocumentReference view) => view?.UI;

        public static implicit operator Windows.Documents.DocumentReference(DocumentReference view) => view?.UI;

        public static implicit operator DocumentReference(Windows.Documents.DocumentReference ui) => DocumentReference.StartChain(ui);

        protected DocumentReference() { }
    }

    public static partial class DocumentReferenceExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.DocumentReference.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : DocumentReference { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.DocumentReference.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : DocumentReference
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Documents.DocumentReference.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // Figure
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Figure"/></summary>
        public static Figure Figure(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.Figure();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.Figure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Figure"/></summary>
        public static Figure Figure(O<bool> CanDelayPlacement = default, O<Windows.FigureLength> Height = default, O<Windows.FigureHorizontalAnchor> HorizontalAnchor = default, O<double> HorizontalOffset = default, O<Windows.FigureVerticalAnchor> VerticalAnchor = default, O<double> VerticalOffset = default, O<Windows.FigureLength> Width = default, O<Windows.WrapDirection> WrapDirection = default)
        {
            var ui = new Windows.Documents.Figure();
            if (CanDelayPlacement.HasValue) ui.CanDelayPlacement = CanDelayPlacement.Value;
            if (Height.HasValue) ui.Height = Height.Value;
            if (HorizontalAnchor.HasValue) ui.HorizontalAnchor = HorizontalAnchor.Value;
            if (HorizontalOffset.HasValue) ui.HorizontalOffset = HorizontalOffset.Value;
            if (VerticalAnchor.HasValue) ui.VerticalAnchor = VerticalAnchor.Value;
            if (VerticalOffset.HasValue) ui.VerticalOffset = VerticalOffset.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            if (WrapDirection.HasValue) ui.WrapDirection = WrapDirection.Value;
            return global::CSharpMarkup.Wpf.Figure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Figure"/></summary>
        public static Figure Figure()
        {
            var ui = new Windows.Documents.Figure();
            return global::CSharpMarkup.Wpf.Figure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Figure"/></summary>
        public static Figure Figure(Windows.Documents.Block childBlock)
        {
            var ui = new Windows.Documents.Figure(childBlock);
            return global::CSharpMarkup.Wpf.Figure.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Figure"/></summary>
        public static Figure Figure(Windows.Documents.Block childBlock, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Figure(childBlock, insertionPosition);
            return global::CSharpMarkup.Wpf.Figure.StartChain(ui);
        }
    }

    public partial class Figure : AnchoredBlock, IUI<System.Windows.Documents.Figure>
    {
        static Figure instance;

        internal static Figure StartChain(Windows.Documents.Figure ui)
        {
            if (instance == null) instance = new Figure();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Figure ui;

        public new Windows.Documents.Figure UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Figure view) => view?.UI;

        public static implicit operator Windows.Documents.Figure(Figure view) => view?.UI;

        public static implicit operator Figure(Windows.Documents.Figure ui) => Figure.StartChain(ui);

        protected Figure() { }
    }

    public static partial class FigureExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Figure.CanDelayPlacement"/></summary>
        public static TView CanDelayPlacement<TView>(this TView view, bool value) where TView : Figure { view.UI.CanDelayPlacement = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.Height"/></summary>
        public static TView Height<TView>(this TView view, Windows.FigureLength value) where TView : Figure { view.UI.Height = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.HorizontalAnchor"/></summary>
        public static TView HorizontalAnchor<TView>(this TView view, Windows.FigureHorizontalAnchor value) where TView : Figure { view.UI.HorizontalAnchor = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.HorizontalOffset"/></summary>
        public static TView HorizontalOffset<TView>(this TView view, double value) where TView : Figure { view.UI.HorizontalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.VerticalAnchor"/></summary>
        public static TView VerticalAnchor<TView>(this TView view, Windows.FigureVerticalAnchor value) where TView : Figure { view.UI.VerticalAnchor = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.VerticalOffset"/></summary>
        public static TView VerticalOffset<TView>(this TView view, double value) where TView : Figure { view.UI.VerticalOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.Width"/></summary>
        public static TView Width<TView>(this TView view, Windows.FigureLength value) where TView : Figure { view.UI.Width = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Figure.WrapDirection"/></summary>
        public static TView WrapDirection<TView>(this TView view, Windows.WrapDirection value) where TView : Figure { view.UI.WrapDirection = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.CanDelayPlacement"/></summary>
        public static DependencyProperty<TTarget, bool> CanDelayPlacement<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Figure.CanDelayPlacementProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.Height"/></summary>
        public static DependencyProperty<TTarget, Windows.FigureLength> Height<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, Windows.FigureLength>.Get(target, Windows.Documents.Figure.HeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.HorizontalAnchor"/></summary>
        public static DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> HorizontalAnchor<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, Windows.FigureHorizontalAnchor>.Get(target, Windows.Documents.Figure.HorizontalAnchorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.HorizontalOffset"/></summary>
        public static DependencyProperty<TTarget, double> HorizontalOffset<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Figure.HorizontalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.VerticalAnchor"/></summary>
        public static DependencyProperty<TTarget, Windows.FigureVerticalAnchor> VerticalAnchor<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, Windows.FigureVerticalAnchor>.Get(target, Windows.Documents.Figure.VerticalAnchorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.VerticalOffset"/></summary>
        public static DependencyProperty<TTarget, double> VerticalOffset<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Figure.VerticalOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.Width"/></summary>
        public static DependencyProperty<TTarget, Windows.FigureLength> Width<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, Windows.FigureLength>.Get(target, Windows.Documents.Figure.WidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Figure.WrapDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.WrapDirection> WrapDirection<TTarget>(this TTarget target) where TTarget : Figure
        => DependencyProperty<TTarget, Windows.WrapDirection>.Get(target, Windows.Documents.Figure.WrapDirectionProperty);
    }
}

namespace CSharpMarkup.Wpf // FixedDocument
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.FixedDocument"/></summary>
        public static FixedDocument FixedDocument(
            params System.Windows.Documents.PageContent[] Pages
)
        {
            var ui = new Windows.Documents.FixedDocument();
            foreach (var child in Pages) if (child is not null) ui.Pages.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Pages);
            return global::CSharpMarkup.Wpf.FixedDocument.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedDocument"/></summary>
        public static FixedDocument FixedDocument(O<object> PrintTicket = default)
        {
            var ui = new Windows.Documents.FixedDocument();
            if (PrintTicket.HasValue) ui.PrintTicket = PrintTicket.Value;
            return global::CSharpMarkup.Wpf.FixedDocument.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedDocument"/></summary>
        public static FixedDocument FixedDocument()
        {
            var ui = new Windows.Documents.FixedDocument();
            return global::CSharpMarkup.Wpf.FixedDocument.StartChain(ui);
        }
    }

    public partial class FixedDocument : FrameworkContentElement, IUI<System.Windows.Documents.FixedDocument>
    {
        static FixedDocument instance;

        internal static FixedDocument StartChain(Windows.Documents.FixedDocument ui)
        {
            if (instance == null) instance = new FixedDocument();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.FixedDocument ui;

        public new Windows.Documents.FixedDocument UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.FixedDocument(FixedDocument view) => view?.UI;

        public static implicit operator FixedDocument(Windows.Documents.FixedDocument ui) => FixedDocument.StartChain(ui);

        protected FixedDocument() { }
    }

    public static partial class FixedDocumentExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.FixedDocument.PrintTicket"/></summary>
        public static TView PrintTicket<TView>(this TView view, object value) where TView : FixedDocument { view.UI.PrintTicket = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedDocument.PrintTicket"/></summary>
        public static DependencyProperty<TTarget, object> PrintTicket<TTarget>(this TTarget target) where TTarget : FixedDocument
        => DependencyProperty<TTarget, object>.Get(target, Windows.Documents.FixedDocument.PrintTicketProperty);
    }
}

namespace CSharpMarkup.Wpf // FixedDocumentSequence
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.FixedDocumentSequence"/></summary>
        public static FixedDocumentSequence FixedDocumentSequence(
            params System.Windows.Documents.DocumentReference[] References
)
        {
            var ui = new Windows.Documents.FixedDocumentSequence();
            foreach (var child in References) if (child is not null) ui.References.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.References);
            return global::CSharpMarkup.Wpf.FixedDocumentSequence.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedDocumentSequence"/></summary>
        public static FixedDocumentSequence FixedDocumentSequence(O<object> PrintTicket = default)
        {
            var ui = new Windows.Documents.FixedDocumentSequence();
            if (PrintTicket.HasValue) ui.PrintTicket = PrintTicket.Value;
            return global::CSharpMarkup.Wpf.FixedDocumentSequence.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedDocumentSequence"/></summary>
        public static FixedDocumentSequence FixedDocumentSequence()
        {
            var ui = new Windows.Documents.FixedDocumentSequence();
            return global::CSharpMarkup.Wpf.FixedDocumentSequence.StartChain(ui);
        }
    }

    public partial class FixedDocumentSequence : FrameworkContentElement, IUI<System.Windows.Documents.FixedDocumentSequence>
    {
        static FixedDocumentSequence instance;

        internal static FixedDocumentSequence StartChain(Windows.Documents.FixedDocumentSequence ui)
        {
            if (instance == null) instance = new FixedDocumentSequence();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.FixedDocumentSequence ui;

        public new Windows.Documents.FixedDocumentSequence UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.FixedDocumentSequence(FixedDocumentSequence view) => view?.UI;

        public static implicit operator FixedDocumentSequence(Windows.Documents.FixedDocumentSequence ui) => FixedDocumentSequence.StartChain(ui);

        protected FixedDocumentSequence() { }
    }

    public static partial class FixedDocumentSequenceExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.FixedDocumentSequence.PrintTicket"/></summary>
        public static TView PrintTicket<TView>(this TView view, object value) where TView : FixedDocumentSequence { view.UI.PrintTicket = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedDocumentSequence.PrintTicket"/></summary>
        public static DependencyProperty<TTarget, object> PrintTicket<TTarget>(this TTarget target) where TTarget : FixedDocumentSequence
        => DependencyProperty<TTarget, object>.Get(target, Windows.Documents.FixedDocumentSequence.PrintTicketProperty);
    }
}

namespace CSharpMarkup.Wpf // FixedPage
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.FixedPage"/></summary>
        public static FixedPage FixedPage(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Documents.FixedPage();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.FixedPage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedPage"/></summary>
        public static FixedPage FixedPage(O<Windows.Media.Brush> Background = default, O<Windows.Rect> BleedBox = default, O<Windows.Rect> ContentBox = default, O<object> PrintTicket = default)
        {
            var ui = new Windows.Documents.FixedPage();
            if (Background.HasValue) ui.Background = Background.Value;
            if (BleedBox.HasValue) ui.BleedBox = BleedBox.Value;
            if (ContentBox.HasValue) ui.ContentBox = ContentBox.Value;
            if (PrintTicket.HasValue) ui.PrintTicket = PrintTicket.Value;
            return global::CSharpMarkup.Wpf.FixedPage.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FixedPage"/></summary>
        public static FixedPage FixedPage()
        {
            var ui = new Windows.Documents.FixedPage();
            return global::CSharpMarkup.Wpf.FixedPage.StartChain(ui);
        }
    }

    public partial class FixedPage : FrameworkElement, IUI<System.Windows.Documents.FixedPage>
    {
        static FixedPage instance;

        internal static FixedPage StartChain(Windows.Documents.FixedPage ui)
        {
            if (instance == null) instance = new FixedPage();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.FixedPage ui;

        public new Windows.Documents.FixedPage UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(FixedPage view) => view?.UI;

        public static implicit operator Windows.Documents.FixedPage(FixedPage view) => view?.UI;

        public static implicit operator FixedPage(Windows.Documents.FixedPage ui) => FixedPage.StartChain(ui);

        protected FixedPage() { }
    }

    public static partial class FixedPageExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.FixedPage.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : FixedPage { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : FixedPage { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : FixedPage { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.FixedPage.BleedBox"/></summary>
        public static TView BleedBox<TView>(this TView view, Windows.Rect value) where TView : FixedPage { view.UI.BleedBox = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FixedPage.ContentBox"/></summary>
        public static TView ContentBox<TView>(this TView view, Windows.Rect value) where TView : FixedPage { view.UI.ContentBox = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FixedPage.PrintTicket"/></summary>
        public static TView PrintTicket<TView>(this TView view, object value) where TView : FixedPage { view.UI.PrintTicket = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : FixedPage
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.FixedPage.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.BleedBox"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> BleedBox<TTarget>(this TTarget target) where TTarget : FixedPage
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Documents.FixedPage.BleedBoxProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.ContentBox"/></summary>
        public static DependencyProperty<TTarget, Windows.Rect> ContentBox<TTarget>(this TTarget target) where TTarget : FixedPage
        => DependencyProperty<TTarget, Windows.Rect>.Get(target, Windows.Documents.FixedPage.ContentBoxProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.PrintTicket"/></summary>
        public static DependencyProperty<TTarget, object> PrintTicket<TTarget>(this TTarget target) where TTarget : FixedPage
        => DependencyProperty<TTarget, object>.Get(target, Windows.Documents.FixedPage.PrintTicketProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Bottom"/></summary>
        public static TTarget FixedPage_Bottom<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Documents.FixedPage.SetBottom(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.Bottom"/></summary>
        public static DependencyProperty<TTarget, double> FixedPage_Bottom<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FixedPage.BottomProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Left"/></summary>
        public static TTarget FixedPage_Left<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Documents.FixedPage.SetLeft(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.Left"/></summary>
        public static DependencyProperty<TTarget, double> FixedPage_Left<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FixedPage.LeftProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage.NavigateUri"/></summary>
        public static TTarget FixedPage_NavigateUri<TTarget>(this TTarget target, Uri value) where TTarget : UIElement
        { Windows.Documents.FixedPage.SetNavigateUri(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.NavigateUri"/></summary>
        public static DependencyProperty<TTarget, Uri> FixedPage_NavigateUri<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Documents.FixedPage.NavigateUriProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Right"/></summary>
        public static TTarget FixedPage_Right<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Documents.FixedPage.SetRight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.Right"/></summary>
        public static DependencyProperty<TTarget, double> FixedPage_Right<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FixedPage.RightProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage.Top"/></summary>
        public static TTarget FixedPage_Top<TTarget>(this TTarget target, double value) where TTarget : UIElement
        { Windows.Documents.FixedPage.SetTop(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FixedPage.Top"/></summary>
        public static DependencyProperty<TTarget, double> FixedPage_Top<TTarget>(this TTarget target) where TTarget : UIElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FixedPage.TopProperty);

        /// <summary>Set <see cref="Windows.Documents.FixedPage"/> attached properties</summary>
        public static TTarget FixedPage<TTarget>(this TTarget target

            , O<double> Bottom = default

            , O<double> Left = default

            , O<Uri> NavigateUri = default

            , O<double> Right = default

            , O<double> Top = default

        ) where TTarget : UIElement
        {
            if (Bottom.HasValue) Windows.Documents.FixedPage.SetBottom(target.UI, Bottom.Value);

            if (Left.HasValue) Windows.Documents.FixedPage.SetLeft(target.UI, Left.Value);

            if (NavigateUri.HasValue) Windows.Documents.FixedPage.SetNavigateUri(target.UI, NavigateUri.Value);

            if (Right.HasValue) Windows.Documents.FixedPage.SetRight(target.UI, Right.Value);

            if (Top.HasValue) Windows.Documents.FixedPage.SetTop(target.UI, Top.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // Floater
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Floater"/></summary>
        public static Floater Floater(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.Floater();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.Floater.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Floater"/></summary>
        public static Floater Floater(O<Windows.HorizontalAlignment> HorizontalAlignment = default, O<double> Width = default)
        {
            var ui = new Windows.Documents.Floater();
            if (HorizontalAlignment.HasValue) ui.HorizontalAlignment = HorizontalAlignment.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.Floater.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Floater"/></summary>
        public static Floater Floater()
        {
            var ui = new Windows.Documents.Floater();
            return global::CSharpMarkup.Wpf.Floater.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Floater"/></summary>
        public static Floater Floater(Windows.Documents.Block childBlock)
        {
            var ui = new Windows.Documents.Floater(childBlock);
            return global::CSharpMarkup.Wpf.Floater.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Floater"/></summary>
        public static Floater Floater(Windows.Documents.Block childBlock, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Floater(childBlock, insertionPosition);
            return global::CSharpMarkup.Wpf.Floater.StartChain(ui);
        }
    }

    public partial class Floater : AnchoredBlock, IUI<System.Windows.Documents.Floater>
    {
        static Floater instance;

        internal static Floater StartChain(Windows.Documents.Floater ui)
        {
            if (instance == null) instance = new Floater();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Floater ui;

        public new Windows.Documents.Floater UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Floater view) => view?.UI;

        public static implicit operator Windows.Documents.Floater(Floater view) => view?.UI;

        public static implicit operator Floater(Windows.Documents.Floater ui) => Floater.StartChain(ui);

        protected Floater() { }
    }

    public static partial class FloaterExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Floater.HorizontalAlignment"/></summary>
        public static TView HorizontalAlignment<TView>(this TView view, Windows.HorizontalAlignment value) where TView : Floater { view.UI.HorizontalAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Floater.Width"/></summary>
        public static TView Width<TView>(this TView view, double value) where TView : Floater { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Floater.HorizontalAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.HorizontalAlignment> HorizontalAlignment<TTarget>(this TTarget target) where TTarget : Floater
        => DependencyProperty<TTarget, Windows.HorizontalAlignment>.Get(target, Windows.Documents.Floater.HorizontalAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Floater.Width"/></summary>
        public static DependencyProperty<TTarget, double> Width<TTarget>(this TTarget target) where TTarget : Floater
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Floater.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // FlowDocument
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.FlowDocument"/></summary>
        public static FlowDocument FlowDocument(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.FlowDocument();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.FlowDocument.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FlowDocument"/></summary>
        public static FlowDocument FlowDocument(O<Windows.Media.Brush> Background = default, O<double> ColumnGap = default, O<Windows.Media.Brush> ColumnRuleBrush = default, O<double> ColumnRuleWidth = default, O<double> ColumnWidth = default, O<Windows.FlowDirection> FlowDirection = default, O<Windows.Media.FontFamily> FontFamily = default, O<double> FontSize = default, O<Windows.FontStretch> FontStretch = default, O<Windows.FontStyle> FontStyle = default, O<Windows.FontWeight> FontWeight = default, O<Windows.Media.Brush> Foreground = default, O<bool> IsColumnWidthFlexible = default, O<bool> IsHyphenationEnabled = default, O<bool> IsOptimalParagraphEnabled = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<double> MaxPageHeight = default, O<double> MaxPageWidth = default, O<double> MinPageHeight = default, O<double> MinPageWidth = default, O<double> PageHeight = default, O<Windows.Thickness> PagePadding = default, O<double> PageWidth = default, O<Windows.TextAlignment> TextAlignment = default, O<Windows.Media.TextEffectCollection> TextEffects = default)
        {
            var ui = new Windows.Documents.FlowDocument();
            if (Background.HasValue) ui.Background = Background.Value;
            if (ColumnGap.HasValue) ui.ColumnGap = ColumnGap.Value;
            if (ColumnRuleBrush.HasValue) ui.ColumnRuleBrush = ColumnRuleBrush.Value;
            if (ColumnRuleWidth.HasValue) ui.ColumnRuleWidth = ColumnRuleWidth.Value;
            if (ColumnWidth.HasValue) ui.ColumnWidth = ColumnWidth.Value;
            if (FlowDirection.HasValue) ui.FlowDirection = FlowDirection.Value;
            if (FontFamily.HasValue) ui.FontFamily = FontFamily.Value;
            if (FontSize.HasValue) ui.FontSize = FontSize.Value;
            if (FontStretch.HasValue) ui.FontStretch = FontStretch.Value;
            if (FontStyle.HasValue) ui.FontStyle = FontStyle.Value;
            if (FontWeight.HasValue) ui.FontWeight = FontWeight.Value;
            if (Foreground.HasValue) ui.Foreground = Foreground.Value;
            if (IsColumnWidthFlexible.HasValue) ui.IsColumnWidthFlexible = IsColumnWidthFlexible.Value;
            if (IsHyphenationEnabled.HasValue) ui.IsHyphenationEnabled = IsHyphenationEnabled.Value;
            if (IsOptimalParagraphEnabled.HasValue) ui.IsOptimalParagraphEnabled = IsOptimalParagraphEnabled.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (MaxPageHeight.HasValue) ui.MaxPageHeight = MaxPageHeight.Value;
            if (MaxPageWidth.HasValue) ui.MaxPageWidth = MaxPageWidth.Value;
            if (MinPageHeight.HasValue) ui.MinPageHeight = MinPageHeight.Value;
            if (MinPageWidth.HasValue) ui.MinPageWidth = MinPageWidth.Value;
            if (PageHeight.HasValue) ui.PageHeight = PageHeight.Value;
            if (PagePadding.HasValue) ui.PagePadding = PagePadding.Value;
            if (PageWidth.HasValue) ui.PageWidth = PageWidth.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            if (TextEffects.HasValue) ui.TextEffects = TextEffects.Value;
            return global::CSharpMarkup.Wpf.FlowDocument.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FlowDocument"/></summary>
        public static FlowDocument FlowDocument()
        {
            var ui = new Windows.Documents.FlowDocument();
            return global::CSharpMarkup.Wpf.FlowDocument.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.FlowDocument"/></summary>
        public static FlowDocument FlowDocument(Windows.Documents.Block block)
        {
            var ui = new Windows.Documents.FlowDocument(block);
            return global::CSharpMarkup.Wpf.FlowDocument.StartChain(ui);
        }
    }

    public partial class FlowDocument : FrameworkContentElement, IUI<System.Windows.Documents.FlowDocument>
    {
        static FlowDocument instance;

        internal static FlowDocument StartChain(Windows.Documents.FlowDocument ui)
        {
            if (instance == null) instance = new FlowDocument();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.FlowDocument ui;

        public new Windows.Documents.FlowDocument UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.FlowDocument(FlowDocument view) => view?.UI;

        public static implicit operator FlowDocument(Windows.Documents.FlowDocument ui) => FlowDocument.StartChain(ui);

        protected FlowDocument() { }
    }

    public static partial class FlowDocumentExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocument { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : FlowDocument { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : FlowDocument { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnGap"/></summary>
        public static TView ColumnGap<TView>(this TView view, double value) where TView : FlowDocument { view.UI.ColumnGap = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnRuleBrush"/></summary>
        public static TView ColumnRuleBrush<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocument { view.UI.ColumnRuleBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnRuleBrush"/></summary>
        public static TView ColumnRuleBrush<TView>(this TView view, Color value) where TView : FlowDocument { view.UI.ColumnRuleBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnRuleBrush"/></summary>
        public static TView ColumnRuleBrush<TView>(this TView view, string color) where TView : FlowDocument { view.UI.ColumnRuleBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnRuleWidth"/></summary>
        public static TView ColumnRuleWidth<TView>(this TView view, double value) where TView : FlowDocument { view.UI.ColumnRuleWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.ColumnWidth"/></summary>
        public static TView ColumnWidth<TView>(this TView view, double value) where TView : FlowDocument { view.UI.ColumnWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : FlowDocument { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : FlowDocument { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : FlowDocument { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FontStretch"/></summary>
        public static TView FontStretch<TView>(this TView view, Windows.FontStretch value) where TView : FlowDocument { view.UI.FontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : FlowDocument { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : FlowDocument { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : FlowDocument { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : FlowDocument { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : FlowDocument { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.IsColumnWidthFlexible"/></summary>
        public static TView IsColumnWidthFlexible<TView>(this TView view, bool value) where TView : FlowDocument { view.UI.IsColumnWidthFlexible = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.IsHyphenationEnabled"/></summary>
        public static TView IsHyphenationEnabled<TView>(this TView view, bool value) where TView : FlowDocument { view.UI.IsHyphenationEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.IsOptimalParagraphEnabled"/></summary>
        public static TView IsOptimalParagraphEnabled<TView>(this TView view, bool value) where TView : FlowDocument { view.UI.IsOptimalParagraphEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : FlowDocument { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : FlowDocument { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.MaxPageHeight"/></summary>
        public static TView MaxPageHeight<TView>(this TView view, double value) where TView : FlowDocument { view.UI.MaxPageHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.MaxPageWidth"/></summary>
        public static TView MaxPageWidth<TView>(this TView view, double value) where TView : FlowDocument { view.UI.MaxPageWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.MinPageHeight"/></summary>
        public static TView MinPageHeight<TView>(this TView view, double value) where TView : FlowDocument { view.UI.MinPageHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.MinPageWidth"/></summary>
        public static TView MinPageWidth<TView>(this TView view, double value) where TView : FlowDocument { view.UI.MinPageWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PageHeight"/></summary>
        public static TView PageHeight<TView>(this TView view, double value) where TView : FlowDocument { view.UI.PageHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static TView PagePadding<TView>(this TView view, Windows.Thickness value) where TView : FlowDocument { view.UI.PagePadding = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static TView PagePadding<TView>(this TView view, double uniform) where TView : FlowDocument { view.UI.PagePadding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static TView PagePadding<TView>(this TView view, double horizontal, double vertical) where TView : FlowDocument { view.UI.PagePadding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static TView PagePadding<TView>(this TView view, double left, double top, double right, double bottom) where TView : FlowDocument { view.UI.PagePadding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static TView PagePaddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : FlowDocument { view.UI.PagePadding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.PageWidth"/></summary>
        public static TView PageWidth<TView>(this TView view, double value) where TView : FlowDocument { view.UI.PageWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : FlowDocument { view.UI.TextAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.FlowDocument.TextEffects"/></summary>
        public static TView TextEffects<TView>(this TView view, Windows.Media.TextEffectCollection value) where TView : FlowDocument { view.UI.TextEffects = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.FlowDocument.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.ColumnGap"/></summary>
        public static DependencyProperty<TTarget, double> ColumnGap<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.ColumnGapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.ColumnRuleBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> ColumnRuleBrush<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.FlowDocument.ColumnRuleBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.ColumnRuleWidth"/></summary>
        public static DependencyProperty<TTarget, double> ColumnRuleWidth<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.ColumnRuleWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.ColumnWidth"/></summary>
        public static DependencyProperty<TTarget, double> ColumnWidth<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.ColumnWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.Documents.FlowDocument.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Documents.FlowDocument.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> FontStretch<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Documents.FlowDocument.FontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Documents.FlowDocument.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Documents.FlowDocument.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.FlowDocument.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.IsColumnWidthFlexible"/></summary>
        public static DependencyProperty<TTarget, bool> IsColumnWidthFlexible<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.FlowDocument.IsColumnWidthFlexibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.IsHyphenationEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsHyphenationEnabled<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.FlowDocument.IsHyphenationEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.IsOptimalParagraphEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsOptimalParagraphEnabled<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.FlowDocument.IsOptimalParagraphEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.FlowDocument.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.MaxPageHeight"/></summary>
        public static DependencyProperty<TTarget, double> MaxPageHeight<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.MaxPageHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.MaxPageWidth"/></summary>
        public static DependencyProperty<TTarget, double> MaxPageWidth<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.MaxPageWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.MinPageHeight"/></summary>
        public static DependencyProperty<TTarget, double> MinPageHeight<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.MinPageHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.MinPageWidth"/></summary>
        public static DependencyProperty<TTarget, double> MinPageWidth<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.MinPageWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.PageHeight"/></summary>
        public static DependencyProperty<TTarget, double> PageHeight<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.PageHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.PagePadding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> PagePadding<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.FlowDocument.PagePaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.PageWidth"/></summary>
        public static DependencyProperty<TTarget, double> PageWidth<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.FlowDocument.PageWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.FlowDocument.TextAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.FlowDocument.TextEffects"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TextEffectCollection> TextEffects<TTarget>(this TTarget target) where TTarget : FlowDocument
        => DependencyProperty<TTarget, Windows.Media.TextEffectCollection>.Get(target, Windows.Documents.FlowDocument.TextEffectsProperty);
    }
}

namespace CSharpMarkup.Wpf // Glyphs
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Glyphs"/></summary>
        public static Glyphs Glyphs(O<int> BidiLevel = default, O<string> CaretStops = default, O<string> DeviceFontName = default, O<Windows.Media.Brush> Fill = default, O<double> FontRenderingEmSize = default, O<Uri> FontUri = default, O<string> Indices = default, O<bool> IsSideways = default, O<double> OriginX = default, O<double> OriginY = default, O<Windows.Media.StyleSimulations> StyleSimulations = default, O<string> UnicodeString = default)
        {
            var ui = new Windows.Documents.Glyphs();
            if (BidiLevel.HasValue) ui.BidiLevel = BidiLevel.Value;
            if (CaretStops.HasValue) ui.CaretStops = CaretStops.Value;
            if (DeviceFontName.HasValue) ui.DeviceFontName = DeviceFontName.Value;
            if (Fill.HasValue) ui.Fill = Fill.Value;
            if (FontRenderingEmSize.HasValue) ui.FontRenderingEmSize = FontRenderingEmSize.Value;
            if (FontUri.HasValue) ui.FontUri = FontUri.Value;
            if (Indices.HasValue) ui.Indices = Indices.Value;
            if (IsSideways.HasValue) ui.IsSideways = IsSideways.Value;
            if (OriginX.HasValue) ui.OriginX = OriginX.Value;
            if (OriginY.HasValue) ui.OriginY = OriginY.Value;
            if (StyleSimulations.HasValue) ui.StyleSimulations = StyleSimulations.Value;
            if (UnicodeString.HasValue) ui.UnicodeString = UnicodeString.Value;
            return global::CSharpMarkup.Wpf.Glyphs.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Glyphs"/></summary>
        public static Glyphs Glyphs()
        {
            var ui = new Windows.Documents.Glyphs();
            return global::CSharpMarkup.Wpf.Glyphs.StartChain(ui);
        }
    }

    public partial class Glyphs : FrameworkElement, IUI<System.Windows.Documents.Glyphs>
    {
        static Glyphs instance;

        internal static Glyphs StartChain(Windows.Documents.Glyphs ui)
        {
            if (instance == null) instance = new Glyphs();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Glyphs ui;

        public new Windows.Documents.Glyphs UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Glyphs view) => view?.UI;

        public static implicit operator Windows.Documents.Glyphs(Glyphs view) => view?.UI;

        public static implicit operator Glyphs(Windows.Documents.Glyphs ui) => Glyphs.StartChain(ui);

        protected Glyphs() { }
    }

    public static partial class GlyphsExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Glyphs.BidiLevel"/></summary>
        public static TView BidiLevel<TView>(this TView view, int value) where TView : Glyphs { view.UI.BidiLevel = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.CaretStops"/></summary>
        public static TView CaretStops<TView>(this TView view, string value) where TView : Glyphs { view.UI.CaretStops = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.DeviceFontName"/></summary>
        public static TView DeviceFontName<TView>(this TView view, string value) where TView : Glyphs { view.UI.DeviceFontName = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Windows.Media.Brush value) where TView : Glyphs { view.UI.Fill = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Color value) where TView : Glyphs { view.UI.Fill = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.Fill"/></summary>
        public static TView Fill<TView>(this TView view, string color) where TView : Glyphs { view.UI.Fill = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.FontRenderingEmSize"/></summary>
        public static TView FontRenderingEmSize<TView>(this TView view, double value) where TView : Glyphs { view.UI.FontRenderingEmSize = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.FontUri"/></summary>
        public static TView FontUri<TView>(this TView view, Uri value) where TView : Glyphs { view.UI.FontUri = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.Indices"/></summary>
        public static TView Indices<TView>(this TView view, string value) where TView : Glyphs { view.UI.Indices = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.IsSideways"/></summary>
        public static TView IsSideways<TView>(this TView view, bool value) where TView : Glyphs { view.UI.IsSideways = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.OriginX"/></summary>
        public static TView OriginX<TView>(this TView view, double value) where TView : Glyphs { view.UI.OriginX = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.OriginY"/></summary>
        public static TView OriginY<TView>(this TView view, double value) where TView : Glyphs { view.UI.OriginY = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.StyleSimulations"/></summary>
        public static TView StyleSimulations<TView>(this TView view, Windows.Media.StyleSimulations value) where TView : Glyphs { view.UI.StyleSimulations = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Glyphs.UnicodeString"/></summary>
        public static TView UnicodeString<TView>(this TView view, string value) where TView : Glyphs { view.UI.UnicodeString = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.BidiLevel"/></summary>
        public static DependencyProperty<TTarget, int> BidiLevel<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.Glyphs.BidiLevelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.CaretStops"/></summary>
        public static DependencyProperty<TTarget, string> CaretStops<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Glyphs.CaretStopsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.DeviceFontName"/></summary>
        public static DependencyProperty<TTarget, string> DeviceFontName<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Glyphs.DeviceFontNameProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.Fill"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Fill<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.Glyphs.FillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.FontRenderingEmSize"/></summary>
        public static DependencyProperty<TTarget, double> FontRenderingEmSize<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Glyphs.FontRenderingEmSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.FontUri"/></summary>
        public static DependencyProperty<TTarget, Uri> FontUri<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Documents.Glyphs.FontUriProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.Indices"/></summary>
        public static DependencyProperty<TTarget, string> Indices<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Glyphs.IndicesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.IsSideways"/></summary>
        public static DependencyProperty<TTarget, bool> IsSideways<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Glyphs.IsSidewaysProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.OriginX"/></summary>
        public static DependencyProperty<TTarget, double> OriginX<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Glyphs.OriginXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.OriginY"/></summary>
        public static DependencyProperty<TTarget, double> OriginY<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Glyphs.OriginYProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.StyleSimulations"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.StyleSimulations> StyleSimulations<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, Windows.Media.StyleSimulations>.Get(target, Windows.Documents.Glyphs.StyleSimulationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Glyphs.UnicodeString"/></summary>
        public static DependencyProperty<TTarget, string> UnicodeString<TTarget>(this TTarget target) where TTarget : Glyphs
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Glyphs.UnicodeStringProperty);
    }
}

namespace CSharpMarkup.Wpf // Hyperlink
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Hyperlink();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink(O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<Uri> NavigateUri = default, O<string> TargetName = default)
        {
            var ui = new Windows.Documents.Hyperlink();
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (NavigateUri.HasValue) ui.NavigateUri = NavigateUri.Value;
            if (TargetName.HasValue) ui.TargetName = TargetName.Value;
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink()
        {
            var ui = new Windows.Documents.Hyperlink();
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink(Windows.Documents.Inline childInline)
        {
            var ui = new Windows.Documents.Hyperlink(childInline);
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink(Windows.Documents.Inline childInline, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Hyperlink(childInline, insertionPosition);
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Hyperlink"/></summary>
        public static Hyperlink Hyperlink(Windows.Documents.TextPointer start, Windows.Documents.TextPointer end)
        {
            var ui = new Windows.Documents.Hyperlink(start, end);
            return global::CSharpMarkup.Wpf.Hyperlink.StartChain(ui);
        }
    }

    public partial class Hyperlink : Span, IUI<System.Windows.Documents.Hyperlink>
    {
        static Hyperlink instance;

        internal static Hyperlink StartChain(Windows.Documents.Hyperlink ui)
        {
            if (instance == null) instance = new Hyperlink();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Hyperlink ui;

        public new Windows.Documents.Hyperlink UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Hyperlink view) => view?.UI;

        public static implicit operator Windows.Documents.Hyperlink(Hyperlink view) => view?.UI;

        public static implicit operator Hyperlink(Windows.Documents.Hyperlink ui) => Hyperlink.StartChain(ui);

        protected Hyperlink() { }
    }

    public static partial class HyperlinkExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Hyperlink.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : Hyperlink { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Hyperlink.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : Hyperlink { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Hyperlink.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : Hyperlink { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Hyperlink.NavigateUri"/></summary>
        public static TView NavigateUri<TView>(this TView view, Uri value) where TView : Hyperlink { view.UI.NavigateUri = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Hyperlink.TargetName"/></summary>
        public static TView TargetName<TView>(this TView view, string value) where TView : Hyperlink { view.UI.TargetName = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Hyperlink.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : Hyperlink
        => DependencyProperty<TTarget, object>.Get(target, Windows.Documents.Hyperlink.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Hyperlink.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : Hyperlink
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Documents.Hyperlink.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Hyperlink.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : Hyperlink
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Documents.Hyperlink.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Hyperlink.NavigateUri"/></summary>
        public static DependencyProperty<TTarget, Uri> NavigateUri<TTarget>(this TTarget target) where TTarget : Hyperlink
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Documents.Hyperlink.NavigateUriProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Hyperlink.TargetName"/></summary>
        public static DependencyProperty<TTarget, string> TargetName<TTarget>(this TTarget target) where TTarget : Hyperlink
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Hyperlink.TargetNameProperty);
    }
}

namespace CSharpMarkup.Wpf // Inline
{
    public partial class Inline : TextElement, IUI<System.Windows.Documents.Inline>
    {
        Windows.Documents.Inline ui;

        public new Windows.Documents.Inline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Inline() { }
    }

    public static partial class InlineExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Inline.BaselineAlignment"/></summary>
        public static TView BaselineAlignment<TView>(this TView view, Windows.BaselineAlignment value) where TView : Inline { view.UI.BaselineAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Inline.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : Inline { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Inline.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : Inline { view.UI.TextDecorations = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Inline.BaselineAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.BaselineAlignment> BaselineAlignment<TTarget>(this TTarget target) where TTarget : Inline
        => DependencyProperty<TTarget, Windows.BaselineAlignment>.Get(target, Windows.Documents.Inline.BaselineAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Inline.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : Inline
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.Documents.Inline.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Inline.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : Inline
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Documents.Inline.TextDecorationsProperty);
    }
}

namespace CSharpMarkup.Wpf // InlineUIContainer
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.InlineUIContainer"/></summary>
        public static InlineUIContainer InlineUIContainer(O<Windows.UIElement> Child = default)
        {
            var ui = new Windows.Documents.InlineUIContainer();
            if (Child.HasValue) ui.Child = Child.Value;
            return global::CSharpMarkup.Wpf.InlineUIContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.InlineUIContainer"/></summary>
        public static InlineUIContainer InlineUIContainer()
        {
            var ui = new Windows.Documents.InlineUIContainer();
            return global::CSharpMarkup.Wpf.InlineUIContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.InlineUIContainer"/></summary>
        public static InlineUIContainer InlineUIContainer(Windows.UIElement childUIElement)
        {
            var ui = new Windows.Documents.InlineUIContainer(childUIElement);
            return global::CSharpMarkup.Wpf.InlineUIContainer.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.InlineUIContainer"/></summary>
        public static InlineUIContainer InlineUIContainer(Windows.UIElement childUIElement, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.InlineUIContainer(childUIElement, insertionPosition);
            return global::CSharpMarkup.Wpf.InlineUIContainer.StartChain(ui);
        }
    }

    public partial class InlineUIContainer : Inline, IUI<System.Windows.Documents.InlineUIContainer>
    {
        static InlineUIContainer instance;

        internal static InlineUIContainer StartChain(Windows.Documents.InlineUIContainer ui)
        {
            if (instance == null) instance = new InlineUIContainer();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.InlineUIContainer ui;

        public new Windows.Documents.InlineUIContainer UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(InlineUIContainer view) => view?.UI;

        public static implicit operator Windows.Documents.InlineUIContainer(InlineUIContainer view) => view?.UI;

        public static implicit operator InlineUIContainer(Windows.Documents.InlineUIContainer ui) => InlineUIContainer.StartChain(ui);

        protected InlineUIContainer() { }
    }

    public static partial class InlineUIContainerExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.InlineUIContainer.Child"/></summary>
        public static TView Child<TView>(this TView view, Windows.UIElement value) where TView : InlineUIContainer { view.UI.Child = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Italic
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Italic"/></summary>
        public static Italic Italic(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Italic();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Italic.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Italic"/></summary>
        public static Italic Italic()
        {
            var ui = new Windows.Documents.Italic();
            return global::CSharpMarkup.Wpf.Italic.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Italic"/></summary>
        public static Italic Italic(Windows.Documents.Inline childInline)
        {
            var ui = new Windows.Documents.Italic(childInline);
            return global::CSharpMarkup.Wpf.Italic.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Italic"/></summary>
        public static Italic Italic(Windows.Documents.Inline childInline, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Italic(childInline, insertionPosition);
            return global::CSharpMarkup.Wpf.Italic.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Italic"/></summary>
        public static Italic Italic(Windows.Documents.TextPointer start, Windows.Documents.TextPointer end)
        {
            var ui = new Windows.Documents.Italic(start, end);
            return global::CSharpMarkup.Wpf.Italic.StartChain(ui);
        }
    }

    public partial class Italic : Span, IUI<System.Windows.Documents.Italic>
    {
        static Italic instance;

        internal static Italic StartChain(Windows.Documents.Italic ui)
        {
            if (instance == null) instance = new Italic();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Italic ui;

        public new Windows.Documents.Italic UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Italic view) => view?.UI;

        public static implicit operator Windows.Documents.Italic(Italic view) => view?.UI;

        public static implicit operator Italic(Windows.Documents.Italic ui) => Italic.StartChain(ui);

        protected Italic() { }
    }
}

namespace CSharpMarkup.Wpf // LineBreak
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.LineBreak"/></summary>
        public static LineBreak LineBreak()
        {
            var ui = new Windows.Documents.LineBreak();
            return global::CSharpMarkup.Wpf.LineBreak.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.LineBreak"/></summary>
        public static LineBreak LineBreak(Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.LineBreak(insertionPosition);
            return global::CSharpMarkup.Wpf.LineBreak.StartChain(ui);
        }
    }

    public partial class LineBreak : Inline, IUI<System.Windows.Documents.LineBreak>
    {
        static LineBreak instance;

        internal static LineBreak StartChain(Windows.Documents.LineBreak ui)
        {
            if (instance == null) instance = new LineBreak();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.LineBreak ui;

        public new Windows.Documents.LineBreak UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(LineBreak view) => view?.UI;

        public static implicit operator Windows.Documents.LineBreak(LineBreak view) => view?.UI;

        public static implicit operator LineBreak(Windows.Documents.LineBreak ui) => LineBreak.StartChain(ui);

        protected LineBreak() { }
    }
}

namespace CSharpMarkup.Wpf // List
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.List"/></summary>
        public static List List(
            params System.Windows.Documents.ListItem[] ListItems
)
        {
            var ui = new Windows.Documents.List();
            foreach (var child in ListItems) if (child is not null) ui.ListItems.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.ListItems);
            return global::CSharpMarkup.Wpf.List.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.List"/></summary>
        public static List List(O<double> MarkerOffset = default, O<Windows.TextMarkerStyle> MarkerStyle = default, O<int> StartIndex = default)
        {
            var ui = new Windows.Documents.List();
            if (MarkerOffset.HasValue) ui.MarkerOffset = MarkerOffset.Value;
            if (MarkerStyle.HasValue) ui.MarkerStyle = MarkerStyle.Value;
            if (StartIndex.HasValue) ui.StartIndex = StartIndex.Value;
            return global::CSharpMarkup.Wpf.List.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.List"/></summary>
        public static List List()
        {
            var ui = new Windows.Documents.List();
            return global::CSharpMarkup.Wpf.List.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.List"/></summary>
        public static List List(Windows.Documents.ListItem listItem)
        {
            var ui = new Windows.Documents.List(listItem);
            return global::CSharpMarkup.Wpf.List.StartChain(ui);
        }
    }

    public partial class List : Block, IUI<System.Windows.Documents.List>
    {
        static List instance;

        internal static List StartChain(Windows.Documents.List ui)
        {
            if (instance == null) instance = new List();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.List ui;

        public new Windows.Documents.List UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.List(List view) => view?.UI;

        public static implicit operator List(Windows.Documents.List ui) => List.StartChain(ui);

        protected List() { }
    }

    public static partial class ListExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.List.MarkerOffset"/></summary>
        public static TView MarkerOffset<TView>(this TView view, double value) where TView : List { view.UI.MarkerOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.List.MarkerStyle"/></summary>
        public static TView MarkerStyle<TView>(this TView view, Windows.TextMarkerStyle value) where TView : List { view.UI.MarkerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.List.StartIndex"/></summary>
        public static TView StartIndex<TView>(this TView view, int value) where TView : List { view.UI.StartIndex = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.List.MarkerOffset"/></summary>
        public static DependencyProperty<TTarget, double> MarkerOffset<TTarget>(this TTarget target) where TTarget : List
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.List.MarkerOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.List.MarkerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.TextMarkerStyle> MarkerStyle<TTarget>(this TTarget target) where TTarget : List
        => DependencyProperty<TTarget, Windows.TextMarkerStyle>.Get(target, Windows.Documents.List.MarkerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.List.StartIndex"/></summary>
        public static DependencyProperty<TTarget, int> StartIndex<TTarget>(this TTarget target) where TTarget : List
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.List.StartIndexProperty);
    }
}

namespace CSharpMarkup.Wpf // ListItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.ListItem"/></summary>
        public static ListItem ListItem(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.ListItem();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.ListItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.ListItem"/></summary>
        public static ListItem ListItem(O<Windows.Media.Brush> BorderBrush = default, O<Windows.Thickness> BorderThickness = default, O<Windows.FlowDirection> FlowDirection = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<Windows.Thickness> Margin = default, O<Windows.Thickness> Padding = default, O<Windows.TextAlignment> TextAlignment = default)
        {
            var ui = new Windows.Documents.ListItem();
            if (BorderBrush.HasValue) ui.BorderBrush = BorderBrush.Value;
            if (BorderThickness.HasValue) ui.BorderThickness = BorderThickness.Value;
            if (FlowDirection.HasValue) ui.FlowDirection = FlowDirection.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (Margin.HasValue) ui.Margin = Margin.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            return global::CSharpMarkup.Wpf.ListItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.ListItem"/></summary>
        public static ListItem ListItem()
        {
            var ui = new Windows.Documents.ListItem();
            return global::CSharpMarkup.Wpf.ListItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.ListItem"/></summary>
        public static ListItem ListItem(Windows.Documents.Paragraph paragraph)
        {
            var ui = new Windows.Documents.ListItem(paragraph);
            return global::CSharpMarkup.Wpf.ListItem.StartChain(ui);
        }
    }

    public partial class ListItem : TextElement, IUI<System.Windows.Documents.ListItem>
    {
        static ListItem instance;

        internal static ListItem StartChain(Windows.Documents.ListItem ui)
        {
            if (instance == null) instance = new ListItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.ListItem ui;

        public new Windows.Documents.ListItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.ListItem(ListItem view) => view?.UI;

        public static implicit operator ListItem(Windows.Documents.ListItem ui) => ListItem.StartChain(ui);

        protected ListItem() { }
    }

    public static partial class ListItemExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : ListItem { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : ListItem { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : ListItem { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : ListItem { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : ListItem { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : ListItem { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : ListItem { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : ListItem { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : ListItem { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : ListItem { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : ListItem { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static TView Margin<TView>(this TView view, Windows.Thickness value) where TView : ListItem { view.UI.Margin = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double uniform) where TView : ListItem { view.UI.Margin = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double horizontal, double vertical) where TView : ListItem { view.UI.Margin = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static TView Margin<TView>(this TView view, double left, double top, double right, double bottom) where TView : ListItem { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static TView Margins<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : ListItem { view.UI.Margin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : ListItem { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : ListItem { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : ListItem { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : ListItem { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : ListItem { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.ListItem.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : ListItem { view.UI.TextAlignment = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.ListItem.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.ListItem.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.Documents.ListItem.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.ListItem.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.ListItem.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.Margin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Margin<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.ListItem.MarginProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.ListItem.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.ListItem.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : ListItem
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.ListItem.TextAlignmentProperty);
    }
}

namespace CSharpMarkup.Wpf // PageContent
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.PageContent"/></summary>
        public static PageContent PageContent(
            System.Windows.Documents.FixedPage Child
)
        {
            var ui = new Windows.Documents.PageContent();
            if (Child is not null) ui.Child = Child;
            return global::CSharpMarkup.Wpf.PageContent.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.PageContent"/></summary>
        public static PageContent PageContent(O<Windows.Documents.FixedPage> Child = default, O<Uri> Source = default)
        {
            var ui = new Windows.Documents.PageContent();
            if (Child.HasValue) ui.Child = Child.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.PageContent.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.PageContent"/></summary>
        public static PageContent PageContent()
        {
            var ui = new Windows.Documents.PageContent();
            return global::CSharpMarkup.Wpf.PageContent.StartChain(ui);
        }
    }

    public partial class PageContent : FrameworkElement, IUI<System.Windows.Documents.PageContent>
    {
        static PageContent instance;

        internal static PageContent StartChain(Windows.Documents.PageContent ui)
        {
            if (instance == null) instance = new PageContent();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.PageContent ui;

        public new Windows.Documents.PageContent UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(PageContent view) => view?.UI;

        public static implicit operator Windows.Documents.PageContent(PageContent view) => view?.UI;

        public static implicit operator PageContent(Windows.Documents.PageContent ui) => PageContent.StartChain(ui);

        protected PageContent() { }
    }

    public static partial class PageContentExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.PageContent.Child"/></summary>
        public static TView Child<TView>(this TView view, Windows.Documents.FixedPage value) where TView : PageContent { view.UI.Child = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.PageContent.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : PageContent { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.PageContent.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : PageContent
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Documents.PageContent.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // Paragraph
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Paragraph"/></summary>
        public static Paragraph Paragraph(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Paragraph();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Paragraph.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Paragraph"/></summary>
        public static Paragraph Paragraph(O<bool> KeepTogether = default, O<bool> KeepWithNext = default, O<int> MinOrphanLines = default, O<int> MinWidowLines = default, O<Windows.TextDecorationCollection> TextDecorations = default, O<double> TextIndent = default)
        {
            var ui = new Windows.Documents.Paragraph();
            if (KeepTogether.HasValue) ui.KeepTogether = KeepTogether.Value;
            if (KeepWithNext.HasValue) ui.KeepWithNext = KeepWithNext.Value;
            if (MinOrphanLines.HasValue) ui.MinOrphanLines = MinOrphanLines.Value;
            if (MinWidowLines.HasValue) ui.MinWidowLines = MinWidowLines.Value;
            if (TextDecorations.HasValue) ui.TextDecorations = TextDecorations.Value;
            if (TextIndent.HasValue) ui.TextIndent = TextIndent.Value;
            return global::CSharpMarkup.Wpf.Paragraph.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Paragraph"/></summary>
        public static Paragraph Paragraph()
        {
            var ui = new Windows.Documents.Paragraph();
            return global::CSharpMarkup.Wpf.Paragraph.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Paragraph"/></summary>
        public static Paragraph Paragraph(Windows.Documents.Inline inline)
        {
            var ui = new Windows.Documents.Paragraph(inline);
            return global::CSharpMarkup.Wpf.Paragraph.StartChain(ui);
        }
    }

    public partial class Paragraph : Block, IUI<System.Windows.Documents.Paragraph>
    {
        static Paragraph instance;

        internal static Paragraph StartChain(Windows.Documents.Paragraph ui)
        {
            if (instance == null) instance = new Paragraph();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Paragraph ui;

        public new Windows.Documents.Paragraph UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Paragraph(Paragraph view) => view?.UI;

        public static implicit operator Paragraph(Windows.Documents.Paragraph ui) => Paragraph.StartChain(ui);

        protected Paragraph() { }
    }

    public static partial class ParagraphExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Paragraph.KeepTogether"/></summary>
        public static TView KeepTogether<TView>(this TView view, bool value) where TView : Paragraph { view.UI.KeepTogether = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Paragraph.KeepWithNext"/></summary>
        public static TView KeepWithNext<TView>(this TView view, bool value) where TView : Paragraph { view.UI.KeepWithNext = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Paragraph.MinOrphanLines"/></summary>
        public static TView MinOrphanLines<TView>(this TView view, int value) where TView : Paragraph { view.UI.MinOrphanLines = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Paragraph.MinWidowLines"/></summary>
        public static TView MinWidowLines<TView>(this TView view, int value) where TView : Paragraph { view.UI.MinWidowLines = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Paragraph.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : Paragraph { view.UI.TextDecorations = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.Paragraph.TextIndent"/></summary>
        public static TView TextIndent<TView>(this TView view, double value) where TView : Paragraph { view.UI.TextIndent = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.KeepTogether"/></summary>
        public static DependencyProperty<TTarget, bool> KeepTogether<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Paragraph.KeepTogetherProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.KeepWithNext"/></summary>
        public static DependencyProperty<TTarget, bool> KeepWithNext<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Documents.Paragraph.KeepWithNextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.MinOrphanLines"/></summary>
        public static DependencyProperty<TTarget, int> MinOrphanLines<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.Paragraph.MinOrphanLinesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.MinWidowLines"/></summary>
        public static DependencyProperty<TTarget, int> MinWidowLines<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.Paragraph.MinWidowLinesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Documents.Paragraph.TextDecorationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Paragraph.TextIndent"/></summary>
        public static DependencyProperty<TTarget, double> TextIndent<TTarget>(this TTarget target) where TTarget : Paragraph
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Paragraph.TextIndentProperty);
    }
}

namespace CSharpMarkup.Wpf // Run
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Run"/></summary>
        public static Run Run(O<string> Text = default)
        {
            var ui = new Windows.Documents.Run();
            if (Text.HasValue) ui.Text = Text.Value;
            return global::CSharpMarkup.Wpf.Run.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Run"/></summary>
        public static Run Run()
        {
            var ui = new Windows.Documents.Run();
            return global::CSharpMarkup.Wpf.Run.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Run"/></summary>
        public static Run Run(string text)
        {
            var ui = new Windows.Documents.Run(text);
            return global::CSharpMarkup.Wpf.Run.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Run"/></summary>
        public static Run Run(string text, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Run(text, insertionPosition);
            return global::CSharpMarkup.Wpf.Run.StartChain(ui);
        }
    }

    public partial class Run : Inline, IUI<System.Windows.Documents.Run>
    {
        static Run instance;

        internal static Run StartChain(Windows.Documents.Run ui)
        {
            if (instance == null) instance = new Run();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Run ui;

        public new Windows.Documents.Run UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Run view) => view?.UI;

        public static implicit operator Windows.Documents.Run(Run view) => view?.UI;

        public static implicit operator Run(Windows.Documents.Run ui) => Run.StartChain(ui);

        protected Run() { }
    }

    public static partial class RunExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Run.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : Run { view.UI.Text = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Run.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : Run
        => DependencyProperty<TTarget, string>.Get(target, Windows.Documents.Run.TextProperty);
    }
}

namespace CSharpMarkup.Wpf // Section
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Section"/></summary>
        public static Section Section(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.Section();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.Section.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Section"/></summary>
        public static Section Section(O<bool> HasTrailingParagraphBreakOnPaste = default)
        {
            var ui = new Windows.Documents.Section();
            if (HasTrailingParagraphBreakOnPaste.HasValue) ui.HasTrailingParagraphBreakOnPaste = HasTrailingParagraphBreakOnPaste.Value;
            return global::CSharpMarkup.Wpf.Section.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Section"/></summary>
        public static Section Section()
        {
            var ui = new Windows.Documents.Section();
            return global::CSharpMarkup.Wpf.Section.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Section"/></summary>
        public static Section Section(Windows.Documents.Block block)
        {
            var ui = new Windows.Documents.Section(block);
            return global::CSharpMarkup.Wpf.Section.StartChain(ui);
        }
    }

    public partial class Section : Block, IUI<System.Windows.Documents.Section>
    {
        static Section instance;

        internal static Section StartChain(Windows.Documents.Section ui)
        {
            if (instance == null) instance = new Section();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Section ui;

        public new Windows.Documents.Section UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Section(Section view) => view?.UI;

        public static implicit operator Section(Windows.Documents.Section ui) => Section.StartChain(ui);

        protected Section() { }
    }

    public static partial class SectionExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Section.HasTrailingParagraphBreakOnPaste"/></summary>
        public static TView HasTrailingParagraphBreakOnPaste<TView>(this TView view, bool value) where TView : Section { view.UI.HasTrailingParagraphBreakOnPaste = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Span
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Span"/></summary>
        public static Span Span(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Span();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Span.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Span"/></summary>
        public static Span Span()
        {
            var ui = new Windows.Documents.Span();
            return global::CSharpMarkup.Wpf.Span.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Span"/></summary>
        public static Span Span(Windows.Documents.Inline childInline)
        {
            var ui = new Windows.Documents.Span(childInline);
            return global::CSharpMarkup.Wpf.Span.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Span"/></summary>
        public static Span Span(Windows.Documents.Inline childInline, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Span(childInline, insertionPosition);
            return global::CSharpMarkup.Wpf.Span.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Span"/></summary>
        public static Span Span(Windows.Documents.TextPointer start, Windows.Documents.TextPointer end)
        {
            var ui = new Windows.Documents.Span(start, end);
            return global::CSharpMarkup.Wpf.Span.StartChain(ui);
        }
    }

    public partial class Span : Inline, IUI<System.Windows.Documents.Span>
    {
        static Span instance;

        internal static Span StartChain(Windows.Documents.Span ui)
        {
            if (instance == null) instance = new Span();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Span ui;

        public new Windows.Documents.Span UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Span view) => view?.UI;

        public static implicit operator Windows.Documents.Span(Span view) => view?.UI;

        public static implicit operator Span(Windows.Documents.Span ui) => Span.StartChain(ui);

        protected Span() { }
    }
}

namespace CSharpMarkup.Wpf // Table
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Table"/></summary>
        public static Table Table(
            params System.Windows.Documents.TableRowGroup[] RowGroups
)
        {
            var ui = new Windows.Documents.Table();
            foreach (var child in RowGroups) if (child is not null) ui.RowGroups.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.RowGroups);
            return global::CSharpMarkup.Wpf.Table.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Table"/></summary>
        public static Table Table(O<double> CellSpacing = default)
        {
            var ui = new Windows.Documents.Table();
            if (CellSpacing.HasValue) ui.CellSpacing = CellSpacing.Value;
            return global::CSharpMarkup.Wpf.Table.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Table"/></summary>
        public static Table Table()
        {
            var ui = new Windows.Documents.Table();
            return global::CSharpMarkup.Wpf.Table.StartChain(ui);
        }
    }

    public partial class Table : Block, IUI<System.Windows.Documents.Table>
    {
        static Table instance;

        internal static Table StartChain(Windows.Documents.Table ui)
        {
            if (instance == null) instance = new Table();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Table ui;

        public new Windows.Documents.Table UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Table(Table view) => view?.UI;

        public static implicit operator Table(Windows.Documents.Table ui) => Table.StartChain(ui);

        protected Table() { }
    }

    public static partial class TableExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.Table.CellSpacing"/></summary>
        public static TView CellSpacing<TView>(this TView view, double value) where TView : Table { view.UI.CellSpacing = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.Table.CellSpacing"/></summary>
        public static DependencyProperty<TTarget, double> CellSpacing<TTarget>(this TTarget target) where TTarget : Table
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.Table.CellSpacingProperty);
    }
}

namespace CSharpMarkup.Wpf // TableCell
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.TableCell"/></summary>
        public static TableCell TableCell(
            params System.Windows.Documents.Block[] Blocks
)
        {
            var ui = new Windows.Documents.TableCell();
            foreach (var child in Blocks) if (child is not null) ui.Blocks.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Blocks);
            return global::CSharpMarkup.Wpf.TableCell.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableCell"/></summary>
        public static TableCell TableCell(O<Windows.Media.Brush> BorderBrush = default, O<Windows.Thickness> BorderThickness = default, O<int> ColumnSpan = default, O<Windows.FlowDirection> FlowDirection = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<Windows.Thickness> Padding = default, O<int> RowSpan = default, O<Windows.TextAlignment> TextAlignment = default)
        {
            var ui = new Windows.Documents.TableCell();
            if (BorderBrush.HasValue) ui.BorderBrush = BorderBrush.Value;
            if (BorderThickness.HasValue) ui.BorderThickness = BorderThickness.Value;
            if (ColumnSpan.HasValue) ui.ColumnSpan = ColumnSpan.Value;
            if (FlowDirection.HasValue) ui.FlowDirection = FlowDirection.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            if (RowSpan.HasValue) ui.RowSpan = RowSpan.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            return global::CSharpMarkup.Wpf.TableCell.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableCell"/></summary>
        public static TableCell TableCell()
        {
            var ui = new Windows.Documents.TableCell();
            return global::CSharpMarkup.Wpf.TableCell.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableCell"/></summary>
        public static TableCell TableCell(Windows.Documents.Block blockItem)
        {
            var ui = new Windows.Documents.TableCell(blockItem);
            return global::CSharpMarkup.Wpf.TableCell.StartChain(ui);
        }
    }

    public partial class TableCell : TextElement, IUI<System.Windows.Documents.TableCell>
    {
        static TableCell instance;

        internal static TableCell StartChain(Windows.Documents.TableCell ui)
        {
            if (instance == null) instance = new TableCell();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.TableCell ui;

        public new Windows.Documents.TableCell UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.TableCell(TableCell view) => view?.UI;

        public static implicit operator TableCell(Windows.Documents.TableCell ui) => TableCell.StartChain(ui);

        protected TableCell() { }
    }

    public static partial class TableCellExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : TableCell { view.UI.BorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, Color value) where TView : TableCell { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderBrush"/></summary>
        public static TView BorderBrush<TView>(this TView view, string color) where TView : TableCell { view.UI.BorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, Windows.Thickness value) where TView : TableCell { view.UI.BorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double uniform) where TView : TableCell { view.UI.BorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : TableCell { view.UI.BorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static TView BorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : TableCell { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static TView BorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : TableCell { view.UI.BorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.ColumnSpan"/></summary>
        public static TView ColumnSpan<TView>(this TView view, int value) where TView : TableCell { view.UI.ColumnSpan = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.FlowDirection"/></summary>
        public static TView FlowDirection<TView>(this TView view, Windows.FlowDirection value) where TView : TableCell { view.UI.FlowDirection = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : TableCell { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : TableCell { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : TableCell { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : TableCell { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : TableCell { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : TableCell { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : TableCell { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.RowSpan"/></summary>
        public static TView RowSpan<TView>(this TView view, int value) where TView : TableCell { view.UI.RowSpan = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableCell.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : TableCell { view.UI.TextAlignment = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.BorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> BorderBrush<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.TableCell.BorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.BorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> BorderThickness<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.TableCell.BorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.ColumnSpan"/></summary>
        public static DependencyProperty<TTarget, int> ColumnSpan<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.TableCell.ColumnSpanProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.FlowDirection"/></summary>
        public static DependencyProperty<TTarget, Windows.FlowDirection> FlowDirection<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.FlowDirection>.Get(target, Windows.Documents.TableCell.FlowDirectionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.TableCell.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Documents.TableCell.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Documents.TableCell.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.RowSpan"/></summary>
        public static DependencyProperty<TTarget, int> RowSpan<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, int>.Get(target, Windows.Documents.TableCell.RowSpanProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableCell.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : TableCell
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Documents.TableCell.TextAlignmentProperty);
    }
}

namespace CSharpMarkup.Wpf // TableColumn
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.TableColumn"/></summary>
        public static TableColumn TableColumn(O<Windows.Media.Brush> Background = default, O<Windows.GridLength> Width = default)
        {
            var ui = new Windows.Documents.TableColumn();
            if (Background.HasValue) ui.Background = Background.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.TableColumn.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableColumn"/></summary>
        public static TableColumn TableColumn()
        {
            var ui = new Windows.Documents.TableColumn();
            return global::CSharpMarkup.Wpf.TableColumn.StartChain(ui);
        }
    }

    public partial class TableColumn : FrameworkContentElement, IUI<System.Windows.Documents.TableColumn>
    {
        static TableColumn instance;

        internal static TableColumn StartChain(Windows.Documents.TableColumn ui)
        {
            if (instance == null) instance = new TableColumn();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.TableColumn ui;

        public new Windows.Documents.TableColumn UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.TableColumn(TableColumn view) => view?.UI;

        public static implicit operator TableColumn(Windows.Documents.TableColumn ui) => TableColumn.StartChain(ui);

        protected TableColumn() { }
    }

    public static partial class TableColumnExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.TableColumn.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : TableColumn { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TableColumn.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : TableColumn { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableColumn.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : TableColumn { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.TableColumn.Width"/></summary>
        public static TView Width<TView>(this TView view, Windows.GridLength value) where TView : TableColumn { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableColumn.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : TableColumn
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.TableColumn.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TableColumn.Width"/></summary>
        public static DependencyProperty<TTarget, Windows.GridLength> Width<TTarget>(this TTarget target) where TTarget : TableColumn
        => DependencyProperty<TTarget, Windows.GridLength>.Get(target, Windows.Documents.TableColumn.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // TableRow
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.TableRow"/></summary>
        public static TableRow TableRow(
            params System.Windows.Documents.TableCell[] Cells
)
        {
            var ui = new Windows.Documents.TableRow();
            foreach (var child in Cells) if (child is not null) ui.Cells.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Cells);
            return global::CSharpMarkup.Wpf.TableRow.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableRow"/></summary>
        public static TableRow TableRow()
        {
            var ui = new Windows.Documents.TableRow();
            return global::CSharpMarkup.Wpf.TableRow.StartChain(ui);
        }
    }

    public partial class TableRow : TextElement, IUI<System.Windows.Documents.TableRow>
    {
        static TableRow instance;

        internal static TableRow StartChain(Windows.Documents.TableRow ui)
        {
            if (instance == null) instance = new TableRow();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.TableRow ui;

        public new Windows.Documents.TableRow UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.TableRow(TableRow view) => view?.UI;

        public static implicit operator TableRow(Windows.Documents.TableRow ui) => TableRow.StartChain(ui);

        protected TableRow() { }
    }
}

namespace CSharpMarkup.Wpf // TableRowGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.TableRowGroup"/></summary>
        public static TableRowGroup TableRowGroup(
            params System.Windows.Documents.TableRow[] Rows
)
        {
            var ui = new Windows.Documents.TableRowGroup();
            foreach (var child in Rows) if (child is not null) ui.Rows.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Rows);
            return global::CSharpMarkup.Wpf.TableRowGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.TableRowGroup"/></summary>
        public static TableRowGroup TableRowGroup()
        {
            var ui = new Windows.Documents.TableRowGroup();
            return global::CSharpMarkup.Wpf.TableRowGroup.StartChain(ui);
        }
    }

    public partial class TableRowGroup : TextElement, IUI<System.Windows.Documents.TableRowGroup>
    {
        static TableRowGroup instance;

        internal static TableRowGroup StartChain(Windows.Documents.TableRowGroup ui)
        {
            if (instance == null) instance = new TableRowGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.TableRowGroup ui;

        public new Windows.Documents.TableRowGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.TableRowGroup(TableRowGroup view) => view?.UI;

        public static implicit operator TableRowGroup(Windows.Documents.TableRowGroup ui) => TableRowGroup.StartChain(ui);

        protected TableRowGroup() { }
    }
}

namespace CSharpMarkup.Wpf // TextElement
{
    public partial class TextElement : FrameworkContentElement, IUI<System.Windows.Documents.TextElement>
    {
        Windows.Documents.TextElement ui;

        public new Windows.Documents.TextElement UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected TextElement() { }
    }

    public static partial class TextElementExtensions
    {
        /// <summary>Set <see cref="Windows.Documents.TextElement.Background"/></summary>
        public static TView Background<TView>(this TView view, Windows.Media.Brush value) where TView : TextElement { view.UI.Background = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.Background"/></summary>
        public static TView Background<TView>(this TView view, Color value) where TView : TextElement { view.UI.Background = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.Background"/></summary>
        public static TView Background<TView>(this TView view, string color) where TView : TextElement { view.UI.Background = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontFamily"/></summary>
        public static TView FontFamily<TView>(this TView view, Windows.Media.FontFamily value) where TView : TextElement { view.UI.FontFamily = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontSize"/></summary>
        public static TView FontSize<TView>(this TView view, double value) where TView : TextElement { view.UI.FontSize = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontStretch"/></summary>
        public static TView FontStretch<TView>(this TView view, Windows.FontStretch value) where TView : TextElement { view.UI.FontStretch = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontStyle"/></summary>
        public static TView FontStyle<TView>(this TView view, Windows.FontStyle value) where TView : TextElement { view.UI.FontStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontWeight"/></summary>
        public static TView FontWeight<TView>(this TView view, Windows.FontWeight value) where TView : TextElement { view.UI.FontWeight = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Windows.Media.Brush value) where TView : TextElement { view.UI.Foreground = value; return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, Color value) where TView : TextElement { view.UI.Foreground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static TView Foreground<TView>(this TView view, string color) where TView : TextElement { view.UI.Foreground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Documents.TextElement.TextEffects"/></summary>
        public static TView TextEffects<TView>(this TView view, Windows.Media.TextEffectCollection value) where TView : TextElement { view.UI.TextEffects = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.Background"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Background<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.TextElement.BackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> FontFamily<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Documents.TextElement.FontFamilyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> FontSize<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.TextElement.FontSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> FontStretch<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Documents.TextElement.FontStretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> FontStyle<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Documents.TextElement.FontStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> FontWeight<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Documents.TextElement.FontWeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Foreground<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.TextElement.ForegroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.TextEffects"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TextEffectCollection> TextEffects<TTarget>(this TTarget target) where TTarget : TextElement
        => DependencyProperty<TTarget, Windows.Media.TextEffectCollection>.Get(target, Windows.Documents.TextElement.TextEffectsProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontFamily"/></summary>
        public static TTarget TextElement_FontFamily<TTarget>(this TTarget target, Windows.Media.FontFamily value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetFontFamily(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontFamily"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FontFamily> TextElement_FontFamily<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Media.FontFamily>.Get(target, Windows.Documents.TextElement.FontFamilyProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontSize"/></summary>
        public static TTarget TextElement_FontSize<TTarget>(this TTarget target, double value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetFontSize(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontSize"/></summary>
        public static DependencyProperty<TTarget, double> TextElement_FontSize<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, double>.Get(target, Windows.Documents.TextElement.FontSizeProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontStretch"/></summary>
        public static TTarget TextElement_FontStretch<TTarget>(this TTarget target, Windows.FontStretch value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetFontStretch(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontStretch"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStretch> TextElement_FontStretch<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontStretch>.Get(target, Windows.Documents.TextElement.FontStretchProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontStyle"/></summary>
        public static TTarget TextElement_FontStyle<TTarget>(this TTarget target, Windows.FontStyle value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetFontStyle(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.FontStyle> TextElement_FontStyle<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontStyle>.Get(target, Windows.Documents.TextElement.FontStyleProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.FontWeight"/></summary>
        public static TTarget TextElement_FontWeight<TTarget>(this TTarget target, Windows.FontWeight value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetFontWeight(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.FontWeight"/></summary>
        public static DependencyProperty<TTarget, Windows.FontWeight> TextElement_FontWeight<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.FontWeight>.Get(target, Windows.Documents.TextElement.FontWeightProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static TTarget TextElement_Foreground<TTarget>(this TTarget target, Windows.Media.Brush value) where TTarget : DependencyObject
        { Windows.Documents.TextElement.SetForeground(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Documents.TextElement.Foreground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> TextElement_Foreground<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Documents.TextElement.ForegroundProperty);

        /// <summary>Set <see cref="Windows.Documents.TextElement"/> attached properties</summary>
        public static TTarget TextElement<TTarget>(this TTarget target

            , O<Windows.Media.FontFamily> FontFamily = default

            , O<double> FontSize = default

            , O<Windows.FontStretch> FontStretch = default

            , O<Windows.FontStyle> FontStyle = default

            , O<Windows.FontWeight> FontWeight = default

            , O<Windows.Media.Brush> Foreground = default

        ) where TTarget : DependencyObject
        {
            if (FontFamily.HasValue) Windows.Documents.TextElement.SetFontFamily(target.UI, FontFamily.Value);

            if (FontSize.HasValue) Windows.Documents.TextElement.SetFontSize(target.UI, FontSize.Value);

            if (FontStretch.HasValue) Windows.Documents.TextElement.SetFontStretch(target.UI, FontStretch.Value);

            if (FontStyle.HasValue) Windows.Documents.TextElement.SetFontStyle(target.UI, FontStyle.Value);

            if (FontWeight.HasValue) Windows.Documents.TextElement.SetFontWeight(target.UI, FontWeight.Value);

            if (Foreground.HasValue) Windows.Documents.TextElement.SetForeground(target.UI, Foreground.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // Underline
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Documents.Underline"/></summary>
        public static Underline Underline(
            params CSharpMarkup.Wpf.InlineCollectionItem[] Inlines
)
        {
            var ui = new Windows.Documents.Underline();
            foreach (var child in Inlines) if (child is not null) ui.Inlines.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Inlines);
            return global::CSharpMarkup.Wpf.Underline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Underline"/></summary>
        public static Underline Underline()
        {
            var ui = new Windows.Documents.Underline();
            return global::CSharpMarkup.Wpf.Underline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Underline"/></summary>
        public static Underline Underline(Windows.Documents.Inline childInline)
        {
            var ui = new Windows.Documents.Underline(childInline);
            return global::CSharpMarkup.Wpf.Underline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Underline"/></summary>
        public static Underline Underline(Windows.Documents.Inline childInline, Windows.Documents.TextPointer insertionPosition)
        {
            var ui = new Windows.Documents.Underline(childInline, insertionPosition);
            return global::CSharpMarkup.Wpf.Underline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Documents.Underline"/></summary>
        public static Underline Underline(Windows.Documents.TextPointer start, Windows.Documents.TextPointer end)
        {
            var ui = new Windows.Documents.Underline(start, end);
            return global::CSharpMarkup.Wpf.Underline.StartChain(ui);
        }
    }

    public partial class Underline : Span, IUI<System.Windows.Documents.Underline>
    {
        static Underline instance;

        internal static Underline StartChain(Windows.Documents.Underline ui)
        {
            if (instance == null) instance = new Underline();
            instance.UI = ui;
            return instance;
        }

        Windows.Documents.Underline ui;

        public new Windows.Documents.Underline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Documents.Inline(Underline view) => view?.UI;

        public static implicit operator Windows.Documents.Underline(Underline view) => view?.UI;

        public static implicit operator Underline(Windows.Documents.Underline ui) => Underline.StartChain(ui);

        protected Underline() { }
    }
}

namespace CSharpMarkup.Wpf // ActiveXHost
{
    public partial class ActiveXHost : HwndHost, IUI<System.Windows.Interop.ActiveXHost>
    {
        Windows.Interop.ActiveXHost ui;

        public new Windows.Interop.ActiveXHost UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ActiveXHost() { }
    }
}

namespace CSharpMarkup.Wpf // HwndHost
{
    public partial class HwndHost : FrameworkElement, IUI<System.Windows.Interop.HwndHost>
    {
        Windows.Interop.HwndHost ui;

        public new Windows.Interop.HwndHost UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected HwndHost() { }
    }
}

namespace CSharpMarkup.Wpf // BeginStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.BeginStoryboard"/></summary>
        public static BeginStoryboard BeginStoryboard(
            System.Windows.Media.Animation.Storyboard Storyboard
)
        {
            var ui = new Windows.Media.Animation.BeginStoryboard();
            if (Storyboard is not null) ui.Storyboard = Storyboard;
            return global::CSharpMarkup.Wpf.BeginStoryboard.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BeginStoryboard"/></summary>
        public static BeginStoryboard BeginStoryboard(O<Windows.Media.Animation.HandoffBehavior> HandoffBehavior = default, O<string> Name = default, O<Windows.Media.Animation.Storyboard> Storyboard = default)
        {
            var ui = new Windows.Media.Animation.BeginStoryboard();
            if (HandoffBehavior.HasValue) ui.HandoffBehavior = HandoffBehavior.Value;
            if (Name.HasValue) ui.Name = Name.Value;
            if (Storyboard.HasValue) ui.Storyboard = Storyboard.Value;
            return global::CSharpMarkup.Wpf.BeginStoryboard.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.BeginStoryboard"/></summary>
        public static BeginStoryboard BeginStoryboard()
        {
            var ui = new Windows.Media.Animation.BeginStoryboard();
            return global::CSharpMarkup.Wpf.BeginStoryboard.StartChain(ui);
        }
    }

    public partial class BeginStoryboard : TriggerAction, IUI<System.Windows.Media.Animation.BeginStoryboard>
    {
        static BeginStoryboard instance;

        internal static BeginStoryboard StartChain(Windows.Media.Animation.BeginStoryboard ui)
        {
            if (instance == null) instance = new BeginStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.BeginStoryboard ui;

        public new Windows.Media.Animation.BeginStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.BeginStoryboard(BeginStoryboard view) => view?.UI;

        public static implicit operator BeginStoryboard(Windows.Media.Animation.BeginStoryboard ui) => BeginStoryboard.StartChain(ui);

        protected BeginStoryboard() { }
    }

    public static partial class BeginStoryboardExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.BeginStoryboard.HandoffBehavior"/></summary>
        public static TView HandoffBehavior<TView>(this TView view, Windows.Media.Animation.HandoffBehavior value) where TView : BeginStoryboard { view.UI.HandoffBehavior = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.BeginStoryboard.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : BeginStoryboard { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.BeginStoryboard.Storyboard"/></summary>
        public static TView Storyboard<TView>(this TView view, Windows.Media.Animation.Storyboard value) where TView : BeginStoryboard { view.UI.Storyboard = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.BeginStoryboard.Storyboard"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.Storyboard> Storyboard<TTarget>(this TTarget target) where TTarget : BeginStoryboard
        => DependencyProperty<TTarget, Windows.Media.Animation.Storyboard>.Get(target, Windows.Media.Animation.BeginStoryboard.StoryboardProperty);
    }
}

namespace CSharpMarkup.Wpf // ControllableStoryboardAction
{
    public partial class ControllableStoryboardAction : TriggerAction, IUI<System.Windows.Media.Animation.ControllableStoryboardAction>
    {
        Windows.Media.Animation.ControllableStoryboardAction ui;

        public new Windows.Media.Animation.ControllableStoryboardAction UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ControllableStoryboardAction() { }
    }

    public static partial class ControllableStoryboardActionExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ControllableStoryboardAction.BeginStoryboardName"/></summary>
        public static TView BeginStoryboardName<TView>(this TView view, string value) where TView : ControllableStoryboardAction { view.UI.BeginStoryboardName = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // DiscreteThicknessKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteThicknessKeyFrame"/></summary>
        public static DiscreteThicknessKeyFrame DiscreteThicknessKeyFrame()
        {
            var ui = new Windows.Media.Animation.DiscreteThicknessKeyFrame();
            return global::CSharpMarkup.Wpf.DiscreteThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteThicknessKeyFrame"/></summary>
        public static DiscreteThicknessKeyFrame DiscreteThicknessKeyFrame(Windows.Thickness value)
        {
            var ui = new Windows.Media.Animation.DiscreteThicknessKeyFrame(value);
            return global::CSharpMarkup.Wpf.DiscreteThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.DiscreteThicknessKeyFrame"/></summary>
        public static DiscreteThicknessKeyFrame DiscreteThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.DiscreteThicknessKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.DiscreteThicknessKeyFrame.StartChain(ui);
        }
    }

    public partial class DiscreteThicknessKeyFrame : ThicknessKeyFrame, IUI<System.Windows.Media.Animation.DiscreteThicknessKeyFrame>
    {
        static DiscreteThicknessKeyFrame instance;

        internal static DiscreteThicknessKeyFrame StartChain(Windows.Media.Animation.DiscreteThicknessKeyFrame ui)
        {
            if (instance == null) instance = new DiscreteThicknessKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.DiscreteThicknessKeyFrame ui;

        public new Windows.Media.Animation.DiscreteThicknessKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.DiscreteThicknessKeyFrame(DiscreteThicknessKeyFrame view) => view?.UI;

        public static implicit operator DiscreteThicknessKeyFrame(Windows.Media.Animation.DiscreteThicknessKeyFrame ui) => DiscreteThicknessKeyFrame.StartChain(ui);

        protected DiscreteThicknessKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // EasingThicknessKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.EasingThicknessKeyFrame"/></summary>
        public static EasingThicknessKeyFrame EasingThicknessKeyFrame(O<Windows.Media.Animation.IEasingFunction> EasingFunction = default)
        {
            var ui = new Windows.Media.Animation.EasingThicknessKeyFrame();
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            return global::CSharpMarkup.Wpf.EasingThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingThicknessKeyFrame"/></summary>
        public static EasingThicknessKeyFrame EasingThicknessKeyFrame()
        {
            var ui = new Windows.Media.Animation.EasingThicknessKeyFrame();
            return global::CSharpMarkup.Wpf.EasingThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingThicknessKeyFrame"/></summary>
        public static EasingThicknessKeyFrame EasingThicknessKeyFrame(Windows.Thickness value)
        {
            var ui = new Windows.Media.Animation.EasingThicknessKeyFrame(value);
            return global::CSharpMarkup.Wpf.EasingThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingThicknessKeyFrame"/></summary>
        public static EasingThicknessKeyFrame EasingThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.EasingThicknessKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.EasingThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.EasingThicknessKeyFrame"/></summary>
        public static EasingThicknessKeyFrame EasingThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.IEasingFunction easingFunction)
        {
            var ui = new Windows.Media.Animation.EasingThicknessKeyFrame(value, keyTime, easingFunction);
            return global::CSharpMarkup.Wpf.EasingThicknessKeyFrame.StartChain(ui);
        }
    }

    public partial class EasingThicknessKeyFrame : ThicknessKeyFrame, IUI<System.Windows.Media.Animation.EasingThicknessKeyFrame>
    {
        static EasingThicknessKeyFrame instance;

        internal static EasingThicknessKeyFrame StartChain(Windows.Media.Animation.EasingThicknessKeyFrame ui)
        {
            if (instance == null) instance = new EasingThicknessKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.EasingThicknessKeyFrame ui;

        public new Windows.Media.Animation.EasingThicknessKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.EasingThicknessKeyFrame(EasingThicknessKeyFrame view) => view?.UI;

        public static implicit operator EasingThicknessKeyFrame(Windows.Media.Animation.EasingThicknessKeyFrame ui) => EasingThicknessKeyFrame.StartChain(ui);

        protected EasingThicknessKeyFrame() { }
    }

    public static partial class EasingThicknessKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.EasingThicknessKeyFrame.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : EasingThicknessKeyFrame { view.UI.EasingFunction = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.EasingThicknessKeyFrame.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : EasingThicknessKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.EasingThicknessKeyFrame.EasingFunctionProperty);
    }
}

namespace CSharpMarkup.Wpf // LinearThicknessKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.LinearThicknessKeyFrame"/></summary>
        public static LinearThicknessKeyFrame LinearThicknessKeyFrame()
        {
            var ui = new Windows.Media.Animation.LinearThicknessKeyFrame();
            return global::CSharpMarkup.Wpf.LinearThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearThicknessKeyFrame"/></summary>
        public static LinearThicknessKeyFrame LinearThicknessKeyFrame(Windows.Thickness value)
        {
            var ui = new Windows.Media.Animation.LinearThicknessKeyFrame(value);
            return global::CSharpMarkup.Wpf.LinearThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.LinearThicknessKeyFrame"/></summary>
        public static LinearThicknessKeyFrame LinearThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.LinearThicknessKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.LinearThicknessKeyFrame.StartChain(ui);
        }
    }

    public partial class LinearThicknessKeyFrame : ThicknessKeyFrame, IUI<System.Windows.Media.Animation.LinearThicknessKeyFrame>
    {
        static LinearThicknessKeyFrame instance;

        internal static LinearThicknessKeyFrame StartChain(Windows.Media.Animation.LinearThicknessKeyFrame ui)
        {
            if (instance == null) instance = new LinearThicknessKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.LinearThicknessKeyFrame ui;

        public new Windows.Media.Animation.LinearThicknessKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.LinearThicknessKeyFrame(LinearThicknessKeyFrame view) => view?.UI;

        public static implicit operator LinearThicknessKeyFrame(Windows.Media.Animation.LinearThicknessKeyFrame ui) => LinearThicknessKeyFrame.StartChain(ui);

        protected LinearThicknessKeyFrame() { }
    }
}

namespace CSharpMarkup.Wpf // PauseStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.PauseStoryboard"/></summary>
        public static PauseStoryboard PauseStoryboard()
        {
            var ui = new Windows.Media.Animation.PauseStoryboard();
            return global::CSharpMarkup.Wpf.PauseStoryboard.StartChain(ui);
        }
    }

    public partial class PauseStoryboard : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.PauseStoryboard>
    {
        static PauseStoryboard instance;

        internal static PauseStoryboard StartChain(Windows.Media.Animation.PauseStoryboard ui)
        {
            if (instance == null) instance = new PauseStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.PauseStoryboard ui;

        public new Windows.Media.Animation.PauseStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.PauseStoryboard(PauseStoryboard view) => view?.UI;

        public static implicit operator PauseStoryboard(Windows.Media.Animation.PauseStoryboard ui) => PauseStoryboard.StartChain(ui);

        protected PauseStoryboard() { }
    }
}

namespace CSharpMarkup.Wpf // RemoveStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.RemoveStoryboard"/></summary>
        public static RemoveStoryboard RemoveStoryboard()
        {
            var ui = new Windows.Media.Animation.RemoveStoryboard();
            return global::CSharpMarkup.Wpf.RemoveStoryboard.StartChain(ui);
        }
    }

    public partial class RemoveStoryboard : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.RemoveStoryboard>
    {
        static RemoveStoryboard instance;

        internal static RemoveStoryboard StartChain(Windows.Media.Animation.RemoveStoryboard ui)
        {
            if (instance == null) instance = new RemoveStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.RemoveStoryboard ui;

        public new Windows.Media.Animation.RemoveStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.RemoveStoryboard(RemoveStoryboard view) => view?.UI;

        public static implicit operator RemoveStoryboard(Windows.Media.Animation.RemoveStoryboard ui) => RemoveStoryboard.StartChain(ui);

        protected RemoveStoryboard() { }
    }
}

namespace CSharpMarkup.Wpf // ResumeStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ResumeStoryboard"/></summary>
        public static ResumeStoryboard ResumeStoryboard()
        {
            var ui = new Windows.Media.Animation.ResumeStoryboard();
            return global::CSharpMarkup.Wpf.ResumeStoryboard.StartChain(ui);
        }
    }

    public partial class ResumeStoryboard : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.ResumeStoryboard>
    {
        static ResumeStoryboard instance;

        internal static ResumeStoryboard StartChain(Windows.Media.Animation.ResumeStoryboard ui)
        {
            if (instance == null) instance = new ResumeStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ResumeStoryboard ui;

        public new Windows.Media.Animation.ResumeStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ResumeStoryboard(ResumeStoryboard view) => view?.UI;

        public static implicit operator ResumeStoryboard(Windows.Media.Animation.ResumeStoryboard ui) => ResumeStoryboard.StartChain(ui);

        protected ResumeStoryboard() { }
    }
}

namespace CSharpMarkup.Wpf // SeekStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SeekStoryboard"/></summary>
        public static SeekStoryboard SeekStoryboard(O<TimeSpan> Offset = default, O<Windows.Media.Animation.TimeSeekOrigin> Origin = default)
        {
            var ui = new Windows.Media.Animation.SeekStoryboard();
            if (Offset.HasValue) ui.Offset = Offset.Value;
            if (Origin.HasValue) ui.Origin = Origin.Value;
            return global::CSharpMarkup.Wpf.SeekStoryboard.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SeekStoryboard"/></summary>
        public static SeekStoryboard SeekStoryboard()
        {
            var ui = new Windows.Media.Animation.SeekStoryboard();
            return global::CSharpMarkup.Wpf.SeekStoryboard.StartChain(ui);
        }
    }

    public partial class SeekStoryboard : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.SeekStoryboard>
    {
        static SeekStoryboard instance;

        internal static SeekStoryboard StartChain(Windows.Media.Animation.SeekStoryboard ui)
        {
            if (instance == null) instance = new SeekStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SeekStoryboard ui;

        public new Windows.Media.Animation.SeekStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SeekStoryboard(SeekStoryboard view) => view?.UI;

        public static implicit operator SeekStoryboard(Windows.Media.Animation.SeekStoryboard ui) => SeekStoryboard.StartChain(ui);

        protected SeekStoryboard() { }
    }

    public static partial class SeekStoryboardExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SeekStoryboard.Offset"/></summary>
        public static TView Offset<TView>(this TView view, TimeSpan value) where TView : SeekStoryboard { view.UI.Offset = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.SeekStoryboard.Origin"/></summary>
        public static TView Origin<TView>(this TView view, Windows.Media.Animation.TimeSeekOrigin value) where TView : SeekStoryboard { view.UI.Origin = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // SetStoryboardSpeedRatio
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SetStoryboardSpeedRatio"/></summary>
        public static SetStoryboardSpeedRatio SetStoryboardSpeedRatio(O<double> SpeedRatio = default)
        {
            var ui = new Windows.Media.Animation.SetStoryboardSpeedRatio();
            if (SpeedRatio.HasValue) ui.SpeedRatio = SpeedRatio.Value;
            return global::CSharpMarkup.Wpf.SetStoryboardSpeedRatio.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SetStoryboardSpeedRatio"/></summary>
        public static SetStoryboardSpeedRatio SetStoryboardSpeedRatio()
        {
            var ui = new Windows.Media.Animation.SetStoryboardSpeedRatio();
            return global::CSharpMarkup.Wpf.SetStoryboardSpeedRatio.StartChain(ui);
        }
    }

    public partial class SetStoryboardSpeedRatio : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.SetStoryboardSpeedRatio>
    {
        static SetStoryboardSpeedRatio instance;

        internal static SetStoryboardSpeedRatio StartChain(Windows.Media.Animation.SetStoryboardSpeedRatio ui)
        {
            if (instance == null) instance = new SetStoryboardSpeedRatio();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SetStoryboardSpeedRatio ui;

        public new Windows.Media.Animation.SetStoryboardSpeedRatio UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SetStoryboardSpeedRatio(SetStoryboardSpeedRatio view) => view?.UI;

        public static implicit operator SetStoryboardSpeedRatio(Windows.Media.Animation.SetStoryboardSpeedRatio ui) => SetStoryboardSpeedRatio.StartChain(ui);

        protected SetStoryboardSpeedRatio() { }
    }

    public static partial class SetStoryboardSpeedRatioExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SetStoryboardSpeedRatio.SpeedRatio"/></summary>
        public static TView SpeedRatio<TView>(this TView view, double value) where TView : SetStoryboardSpeedRatio { view.UI.SpeedRatio = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // SkipStoryboardToFill
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SkipStoryboardToFill"/></summary>
        public static SkipStoryboardToFill SkipStoryboardToFill()
        {
            var ui = new Windows.Media.Animation.SkipStoryboardToFill();
            return global::CSharpMarkup.Wpf.SkipStoryboardToFill.StartChain(ui);
        }
    }

    public partial class SkipStoryboardToFill : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.SkipStoryboardToFill>
    {
        static SkipStoryboardToFill instance;

        internal static SkipStoryboardToFill StartChain(Windows.Media.Animation.SkipStoryboardToFill ui)
        {
            if (instance == null) instance = new SkipStoryboardToFill();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SkipStoryboardToFill ui;

        public new Windows.Media.Animation.SkipStoryboardToFill UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SkipStoryboardToFill(SkipStoryboardToFill view) => view?.UI;

        public static implicit operator SkipStoryboardToFill(Windows.Media.Animation.SkipStoryboardToFill ui) => SkipStoryboardToFill.StartChain(ui);

        protected SkipStoryboardToFill() { }
    }
}

namespace CSharpMarkup.Wpf // SplineThicknessKeyFrame
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.SplineThicknessKeyFrame"/></summary>
        public static SplineThicknessKeyFrame SplineThicknessKeyFrame(O<Windows.Media.Animation.KeySpline> KeySpline = default)
        {
            var ui = new Windows.Media.Animation.SplineThicknessKeyFrame();
            if (KeySpline.HasValue) ui.KeySpline = KeySpline.Value;
            return global::CSharpMarkup.Wpf.SplineThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineThicknessKeyFrame"/></summary>
        public static SplineThicknessKeyFrame SplineThicknessKeyFrame()
        {
            var ui = new Windows.Media.Animation.SplineThicknessKeyFrame();
            return global::CSharpMarkup.Wpf.SplineThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineThicknessKeyFrame"/></summary>
        public static SplineThicknessKeyFrame SplineThicknessKeyFrame(Windows.Thickness value)
        {
            var ui = new Windows.Media.Animation.SplineThicknessKeyFrame(value);
            return global::CSharpMarkup.Wpf.SplineThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineThicknessKeyFrame"/></summary>
        public static SplineThicknessKeyFrame SplineThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime)
        {
            var ui = new Windows.Media.Animation.SplineThicknessKeyFrame(value, keyTime);
            return global::CSharpMarkup.Wpf.SplineThicknessKeyFrame.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.SplineThicknessKeyFrame"/></summary>
        public static SplineThicknessKeyFrame SplineThicknessKeyFrame(Windows.Thickness value, Windows.Media.Animation.KeyTime keyTime, Windows.Media.Animation.KeySpline keySpline)
        {
            var ui = new Windows.Media.Animation.SplineThicknessKeyFrame(value, keyTime, keySpline);
            return global::CSharpMarkup.Wpf.SplineThicknessKeyFrame.StartChain(ui);
        }
    }

    public partial class SplineThicknessKeyFrame : ThicknessKeyFrame, IUI<System.Windows.Media.Animation.SplineThicknessKeyFrame>
    {
        static SplineThicknessKeyFrame instance;

        internal static SplineThicknessKeyFrame StartChain(Windows.Media.Animation.SplineThicknessKeyFrame ui)
        {
            if (instance == null) instance = new SplineThicknessKeyFrame();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.SplineThicknessKeyFrame ui;

        public new Windows.Media.Animation.SplineThicknessKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.SplineThicknessKeyFrame(SplineThicknessKeyFrame view) => view?.UI;

        public static implicit operator SplineThicknessKeyFrame(Windows.Media.Animation.SplineThicknessKeyFrame ui) => SplineThicknessKeyFrame.StartChain(ui);

        protected SplineThicknessKeyFrame() { }
    }

    public static partial class SplineThicknessKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.SplineThicknessKeyFrame.KeySpline"/></summary>
        public static TView KeySpline<TView>(this TView view, Windows.Media.Animation.KeySpline value) where TView : SplineThicknessKeyFrame { view.UI.KeySpline = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.SplineThicknessKeyFrame.KeySpline"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeySpline> KeySpline<TTarget>(this TTarget target) where TTarget : SplineThicknessKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeySpline>.Get(target, Windows.Media.Animation.SplineThicknessKeyFrame.KeySplineProperty);
    }
}

namespace CSharpMarkup.Wpf // StopStoryboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.StopStoryboard"/></summary>
        public static StopStoryboard StopStoryboard()
        {
            var ui = new Windows.Media.Animation.StopStoryboard();
            return global::CSharpMarkup.Wpf.StopStoryboard.StartChain(ui);
        }
    }

    public partial class StopStoryboard : ControllableStoryboardAction, IUI<System.Windows.Media.Animation.StopStoryboard>
    {
        static StopStoryboard instance;

        internal static StopStoryboard StartChain(Windows.Media.Animation.StopStoryboard ui)
        {
            if (instance == null) instance = new StopStoryboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.StopStoryboard ui;

        public new Windows.Media.Animation.StopStoryboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.StopStoryboard(StopStoryboard view) => view?.UI;

        public static implicit operator StopStoryboard(Windows.Media.Animation.StopStoryboard ui) => StopStoryboard.StartChain(ui);

        protected StopStoryboard() { }
    }
}

namespace CSharpMarkup.Wpf // Storyboard
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.Storyboard"/></summary>
        public static Storyboard Storyboard(
            params System.Windows.Media.Animation.Timeline[] Children
)
        {
            var ui = new Windows.Media.Animation.Storyboard();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.Storyboard.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.Storyboard"/></summary>
        public static Storyboard Storyboard()
        {
            var ui = new Windows.Media.Animation.Storyboard();
            return global::CSharpMarkup.Wpf.Storyboard.StartChain(ui);
        }
    }

    public partial class Storyboard : ParallelTimeline, IUI<System.Windows.Media.Animation.Storyboard>
    {
        static Storyboard instance;

        internal static Storyboard StartChain(Windows.Media.Animation.Storyboard ui)
        {
            if (instance == null) instance = new Storyboard();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.Storyboard ui;

        public new Windows.Media.Animation.Storyboard UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.Storyboard(Storyboard view) => view?.UI;

        public static implicit operator Storyboard(Windows.Media.Animation.Storyboard ui) => Storyboard.StartChain(ui);

        protected Storyboard() { }
    }

    public static partial class StoryboardExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.Storyboard.TargetName"/></summary>
        public static TTarget Storyboard_TargetName<TTarget>(this TTarget target, string value) where TTarget : DependencyObject
        { Windows.Media.Animation.Storyboard.SetTargetName(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Storyboard.TargetName"/></summary>
        public static DependencyProperty<TTarget, string> Storyboard_TargetName<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, string>.Get(target, Windows.Media.Animation.Storyboard.TargetNameProperty);

        /// <summary>Set <see cref="Windows.Media.Animation.Storyboard.Target"/></summary>
        public static TTarget Storyboard_Target<TTarget>(this TTarget target, Windows.DependencyObject value) where TTarget : DependencyObject
        { Windows.Media.Animation.Storyboard.SetTarget(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Storyboard.Target"/></summary>
        public static DependencyProperty<TTarget, Windows.DependencyObject> Storyboard_Target<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.DependencyObject>.Get(target, Windows.Media.Animation.Storyboard.TargetProperty);

        /// <summary>Set <see cref="Windows.Media.Animation.Storyboard.TargetProperty"/></summary>
        public static TTarget Storyboard_TargetProperty<TTarget>(this TTarget target, Windows.PropertyPath value) where TTarget : DependencyObject
        { Windows.Media.Animation.Storyboard.SetTargetProperty(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.Storyboard.TargetProperty"/></summary>
        public static DependencyProperty<TTarget, Windows.PropertyPath> Storyboard_TargetProperty<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.PropertyPath>.Get(target, Windows.Media.Animation.Storyboard.TargetPropertyProperty);

        /// <summary>Set <see cref="Windows.Media.Animation.Storyboard"/> attached properties</summary>
        public static TTarget Storyboard<TTarget>(this TTarget target

            , O<string> TargetName = default

            , O<Windows.DependencyObject> Target = default

            , O<Windows.PropertyPath> TargetProperty = default

        ) where TTarget : DependencyObject
        {
            if (TargetName.HasValue) Windows.Media.Animation.Storyboard.SetTargetName(target.UI, TargetName.Value);

            if (Target.HasValue) Windows.Media.Animation.Storyboard.SetTarget(target.UI, Target.Value);

            if (TargetProperty.HasValue) Windows.Media.Animation.Storyboard.SetTargetProperty(target.UI, TargetProperty.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // ThicknessAnimation
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation(O<Windows.Thickness?> By = default, O<Windows.Media.Animation.IEasingFunction> EasingFunction = default, O<Windows.Thickness?> From = default, O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Thickness?> To = default)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation();
            if (By.HasValue) ui.By = By.Value;
            if (EasingFunction.HasValue) ui.EasingFunction = EasingFunction.Value;
            if (From.HasValue) ui.From = From.Value;
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (To.HasValue) ui.To = To.Value;
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation()
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation();
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation(Windows.Thickness toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation(toValue, duration);
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation(Windows.Thickness toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation(toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation(Windows.Thickness fromValue, Windows.Thickness toValue, Windows.Duration duration)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation(fromValue, toValue, duration);
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimation"/></summary>
        public static ThicknessAnimation ThicknessAnimation(Windows.Thickness fromValue, Windows.Thickness toValue, Windows.Duration duration, Windows.Media.Animation.FillBehavior fillBehavior)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimation(fromValue, toValue, duration, fillBehavior);
            return global::CSharpMarkup.Wpf.ThicknessAnimation.StartChain(ui);
        }
    }

    public partial class ThicknessAnimation : ThicknessAnimationBase, IUI<System.Windows.Media.Animation.ThicknessAnimation>
    {
        static ThicknessAnimation instance;

        internal static ThicknessAnimation StartChain(Windows.Media.Animation.ThicknessAnimation ui)
        {
            if (instance == null) instance = new ThicknessAnimation();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ThicknessAnimation ui;

        public new Windows.Media.Animation.ThicknessAnimation UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ThicknessAnimation(ThicknessAnimation view) => view?.UI;

        public static implicit operator ThicknessAnimation(Windows.Media.Animation.ThicknessAnimation ui) => ThicknessAnimation.StartChain(ui);

        protected ThicknessAnimation() { }
    }

    public static partial class ThicknessAnimationExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.By"/></summary>
        public static TView By<TView>(this TView view, Windows.Thickness? value) where TView : ThicknessAnimation { view.UI.By = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.EasingFunction"/></summary>
        public static TView EasingFunction<TView>(this TView view, Windows.Media.Animation.IEasingFunction value) where TView : ThicknessAnimation { view.UI.EasingFunction = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.From"/></summary>
        public static TView From<TView>(this TView view, Windows.Thickness? value) where TView : ThicknessAnimation { view.UI.From = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ThicknessAnimation { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ThicknessAnimation { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimation.To"/></summary>
        public static TView To<TView>(this TView view, Windows.Thickness? value) where TView : ThicknessAnimation { view.UI.To = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessAnimation.By"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness?> By<TTarget>(this TTarget target) where TTarget : ThicknessAnimation
        => DependencyProperty<TTarget, Windows.Thickness?>.Get(target, Windows.Media.Animation.ThicknessAnimation.ByProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessAnimation.EasingFunction"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction> EasingFunction<TTarget>(this TTarget target) where TTarget : ThicknessAnimation
        => DependencyProperty<TTarget, Windows.Media.Animation.IEasingFunction>.Get(target, Windows.Media.Animation.ThicknessAnimation.EasingFunctionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessAnimation.From"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness?> From<TTarget>(this TTarget target) where TTarget : ThicknessAnimation
        => DependencyProperty<TTarget, Windows.Thickness?>.Get(target, Windows.Media.Animation.ThicknessAnimation.FromProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessAnimation.To"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness?> To<TTarget>(this TTarget target) where TTarget : ThicknessAnimation
        => DependencyProperty<TTarget, Windows.Thickness?>.Get(target, Windows.Media.Animation.ThicknessAnimation.ToProperty);
    }
}

namespace CSharpMarkup.Wpf // ThicknessAnimationBase
{
    public partial class ThicknessAnimationBase : AnimationTimeline, IUI<System.Windows.Media.Animation.ThicknessAnimationBase>
    {
        Windows.Media.Animation.ThicknessAnimationBase ui;

        public new Windows.Media.Animation.ThicknessAnimationBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ThicknessAnimationBase() { }
    }
}

namespace CSharpMarkup.Wpf // ThicknessAnimationUsingKeyFrames
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames"/></summary>
        public static ThicknessAnimationUsingKeyFrames ThicknessAnimationUsingKeyFrames(
            params System.Windows.Media.Animation.ThicknessKeyFrame[] KeyFrames
)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimationUsingKeyFrames();
            foreach (var child in KeyFrames) if (child is not null) ui.KeyFrames.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.KeyFrames);
            return global::CSharpMarkup.Wpf.ThicknessAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames"/></summary>
        public static ThicknessAnimationUsingKeyFrames ThicknessAnimationUsingKeyFrames(O<bool> IsAdditive = default, O<bool> IsCumulative = default, O<Windows.Media.Animation.ThicknessKeyFrameCollection> KeyFrames = default)
        {
            var ui = new Windows.Media.Animation.ThicknessAnimationUsingKeyFrames();
            if (IsAdditive.HasValue) ui.IsAdditive = IsAdditive.Value;
            if (IsCumulative.HasValue) ui.IsCumulative = IsCumulative.Value;
            if (KeyFrames.HasValue) ui.KeyFrames = KeyFrames.Value;
            return global::CSharpMarkup.Wpf.ThicknessAnimationUsingKeyFrames.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames"/></summary>
        public static ThicknessAnimationUsingKeyFrames ThicknessAnimationUsingKeyFrames()
        {
            var ui = new Windows.Media.Animation.ThicknessAnimationUsingKeyFrames();
            return global::CSharpMarkup.Wpf.ThicknessAnimationUsingKeyFrames.StartChain(ui);
        }
    }

    public partial class ThicknessAnimationUsingKeyFrames : ThicknessAnimationBase, IUI<System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames>
    {
        static ThicknessAnimationUsingKeyFrames instance;

        internal static ThicknessAnimationUsingKeyFrames StartChain(Windows.Media.Animation.ThicknessAnimationUsingKeyFrames ui)
        {
            if (instance == null) instance = new ThicknessAnimationUsingKeyFrames();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ThicknessAnimationUsingKeyFrames ui;

        public new Windows.Media.Animation.ThicknessAnimationUsingKeyFrames UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ThicknessAnimationUsingKeyFrames(ThicknessAnimationUsingKeyFrames view) => view?.UI;

        public static implicit operator ThicknessAnimationUsingKeyFrames(Windows.Media.Animation.ThicknessAnimationUsingKeyFrames ui) => ThicknessAnimationUsingKeyFrames.StartChain(ui);

        protected ThicknessAnimationUsingKeyFrames() { }
    }

    public static partial class ThicknessAnimationUsingKeyFramesExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames.IsAdditive"/></summary>
        public static TView IsAdditive<TView>(this TView view, bool value) where TView : ThicknessAnimationUsingKeyFrames { view.UI.IsAdditive = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames.IsCumulative"/></summary>
        public static TView IsCumulative<TView>(this TView view, bool value) where TView : ThicknessAnimationUsingKeyFrames { view.UI.IsCumulative = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessAnimationUsingKeyFrames.KeyFrames"/></summary>
        public static TView KeyFrames<TView>(this TView view, Windows.Media.Animation.ThicknessKeyFrameCollection value) where TView : ThicknessAnimationUsingKeyFrames { view.UI.KeyFrames = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // ThicknessKeyFrame
{
    public partial class ThicknessKeyFrame : Freezable, IUI<System.Windows.Media.Animation.ThicknessKeyFrame>
    {
        Windows.Media.Animation.ThicknessKeyFrame ui;

        public new Windows.Media.Animation.ThicknessKeyFrame UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected ThicknessKeyFrame() { }
    }

    public static partial class ThicknessKeyFrameExtensions
    {
        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.KeyTime"/></summary>
        public static TView KeyTime<TView>(this TView view, Windows.Media.Animation.KeyTime value) where TView : ThicknessKeyFrame { view.UI.KeyTime = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, Windows.Thickness value) where TView : ThicknessKeyFrame { view.UI.Value = value; return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, double uniform) where TView : ThicknessKeyFrame { view.UI.Value = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, double horizontal, double vertical) where TView : ThicknessKeyFrame { view.UI.Value = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static TView Value<TView>(this TView view, double left, double top, double right, double bottom) where TView : ThicknessKeyFrame { view.UI.Value = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static TView Values<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : ThicknessKeyFrame { view.UI.Value = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessKeyFrame.KeyTime"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Animation.KeyTime> KeyTime<TTarget>(this TTarget target) where TTarget : ThicknessKeyFrame
        => DependencyProperty<TTarget, Windows.Media.Animation.KeyTime>.Get(target, Windows.Media.Animation.ThicknessKeyFrame.KeyTimeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Media.Animation.ThicknessKeyFrame.Value"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Value<TTarget>(this TTarget target) where TTarget : ThicknessKeyFrame
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Media.Animation.ThicknessKeyFrame.ValueProperty);
    }
}

namespace CSharpMarkup.Wpf // ThicknessKeyFrameCollection
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Media.Animation.ThicknessKeyFrameCollection"/></summary>
        public static ThicknessKeyFrameCollection ThicknessKeyFrameCollection()
        {
            var ui = new Windows.Media.Animation.ThicknessKeyFrameCollection();
            return global::CSharpMarkup.Wpf.ThicknessKeyFrameCollection.StartChain(ui);
        }
    }

    public partial class ThicknessKeyFrameCollection : Freezable, IUI<System.Windows.Media.Animation.ThicknessKeyFrameCollection>
    {
        static ThicknessKeyFrameCollection instance;

        internal static ThicknessKeyFrameCollection StartChain(Windows.Media.Animation.ThicknessKeyFrameCollection ui)
        {
            if (instance == null) instance = new ThicknessKeyFrameCollection();
            instance.UI = ui;
            return instance;
        }

        Windows.Media.Animation.ThicknessKeyFrameCollection ui;

        public new Windows.Media.Animation.ThicknessKeyFrameCollection UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Media.Animation.ThicknessKeyFrameCollection(ThicknessKeyFrameCollection view) => view?.UI;

        public static implicit operator ThicknessKeyFrameCollection(Windows.Media.Animation.ThicknessKeyFrameCollection ui) => ThicknessKeyFrameCollection.StartChain(ui);

        protected ThicknessKeyFrameCollection() { }
    }
}

namespace CSharpMarkup.Wpf // JournalEntry
{
    public partial class JournalEntry : DependencyObject, IUI<System.Windows.Navigation.JournalEntry>
    {
        Windows.Navigation.JournalEntry ui;

        public new Windows.Navigation.JournalEntry UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected JournalEntry() { }
    }

    public static partial class JournalEntryExtensions
    {
        /// <summary>Set <see cref="Windows.Navigation.JournalEntry.Name"/></summary>
        public static TView Name<TView>(this TView view, string value) where TView : JournalEntry { view.UI.Name = value; return view; }

        /// <summary>Set <see cref="Windows.Navigation.JournalEntry.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : JournalEntry { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.JournalEntry.Name"/></summary>
        public static DependencyProperty<TTarget, string> Name<TTarget>(this TTarget target) where TTarget : JournalEntry
        => DependencyProperty<TTarget, string>.Get(target, Windows.Navigation.JournalEntry.NameProperty);

        /// <summary>Set <see cref="Windows.Navigation.JournalEntry.KeepAlive"/></summary>
        public static TTarget JournalEntry_KeepAlive<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Navigation.JournalEntry.SetKeepAlive(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.JournalEntry.KeepAlive"/></summary>
        public static DependencyProperty<TTarget, bool> JournalEntry_KeepAlive<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Navigation.JournalEntry.KeepAliveProperty);

        /// <summary>Set <see cref="Windows.Navigation.JournalEntry.Name"/></summary>
        public static TTarget JournalEntry_Name<TTarget>(this TTarget target, string value) where TTarget : DependencyObject
        { Windows.Navigation.JournalEntry.SetName(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.JournalEntry.Name"/></summary>
        public static DependencyProperty<TTarget, string> JournalEntry_Name<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, string>.Get(target, Windows.Navigation.JournalEntry.NameProperty);

        /// <summary>Set <see cref="Windows.Navigation.JournalEntry"/> attached properties</summary>
        public static TTarget JournalEntry<TTarget>(this TTarget target

            , O<bool> KeepAlive = default

            , O<string> Name = default

        ) where TTarget : DependencyObject
        {
            if (KeepAlive.HasValue) Windows.Navigation.JournalEntry.SetKeepAlive(target.UI, KeepAlive.Value);

            if (Name.HasValue) Windows.Navigation.JournalEntry.SetName(target.UI, Name.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // NavigationWindow
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Navigation.NavigationWindow"/></summary>
        public static NavigationWindow NavigationWindow(O<bool> SandboxExternalContent = default, O<bool> ShowsNavigationUI = default, O<Uri> Source = default)
        {
            var ui = new Windows.Navigation.NavigationWindow();
            if (SandboxExternalContent.HasValue) ui.SandboxExternalContent = SandboxExternalContent.Value;
            if (ShowsNavigationUI.HasValue) ui.ShowsNavigationUI = ShowsNavigationUI.Value;
            if (Source.HasValue) ui.Source = Source.Value;
            return global::CSharpMarkup.Wpf.NavigationWindow.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Navigation.NavigationWindow"/></summary>
        public static NavigationWindow NavigationWindow()
        {
            var ui = new Windows.Navigation.NavigationWindow();
            return global::CSharpMarkup.Wpf.NavigationWindow.StartChain(ui);
        }
    }

    public partial class NavigationWindow : Window, IUI<System.Windows.Navigation.NavigationWindow>
    {
        static NavigationWindow instance;

        internal static NavigationWindow StartChain(Windows.Navigation.NavigationWindow ui)
        {
            if (instance == null) instance = new NavigationWindow();
            instance.UI = ui;
            return instance;
        }

        Windows.Navigation.NavigationWindow ui;

        public new Windows.Navigation.NavigationWindow UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(NavigationWindow view) => view?.UI;

        public static implicit operator Windows.Navigation.NavigationWindow(NavigationWindow view) => view?.UI;

        public static implicit operator NavigationWindow(Windows.Navigation.NavigationWindow ui) => NavigationWindow.StartChain(ui);

        protected NavigationWindow() { }
    }

    public static partial class NavigationWindowExtensions
    {
        /// <summary>Set <see cref="Windows.Navigation.NavigationWindow.SandboxExternalContent"/></summary>
        public static TView SandboxExternalContent<TView>(this TView view, bool value) where TView : NavigationWindow { view.UI.SandboxExternalContent = value; return view; }

        /// <summary>Set <see cref="Windows.Navigation.NavigationWindow.ShowsNavigationUI"/></summary>
        public static TView ShowsNavigationUI<TView>(this TView view, bool value) where TView : NavigationWindow { view.UI.ShowsNavigationUI = value; return view; }

        /// <summary>Set <see cref="Windows.Navigation.NavigationWindow.Source"/></summary>
        public static TView Source<TView>(this TView view, Uri value) where TView : NavigationWindow { view.UI.Source = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.BackStack"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> BackStack<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Navigation.NavigationWindow.BackStackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.CanGoBack"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoBack<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Navigation.NavigationWindow.CanGoBackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.CanGoForward"/></summary>
        public static DependencyProperty<TTarget, bool> CanGoForward<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Navigation.NavigationWindow.CanGoForwardProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.ForwardStack"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> ForwardStack<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Navigation.NavigationWindow.ForwardStackProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.SandboxExternalContent"/></summary>
        public static DependencyProperty<TTarget, bool> SandboxExternalContent<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Navigation.NavigationWindow.SandboxExternalContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.ShowsNavigationUI"/></summary>
        public static DependencyProperty<TTarget, bool> ShowsNavigationUI<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Navigation.NavigationWindow.ShowsNavigationUIProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Navigation.NavigationWindow.Source"/></summary>
        public static DependencyProperty<TTarget, Uri> Source<TTarget>(this TTarget target) where TTarget : NavigationWindow
        => DependencyProperty<TTarget, Uri>.Get(target, Windows.Navigation.NavigationWindow.SourceProperty);
    }
}

namespace CSharpMarkup.Wpf // PageFunctionBase
{
    public partial class PageFunctionBase : Page, IUI<System.Windows.Navigation.PageFunctionBase>
    {
        Windows.Navigation.PageFunctionBase ui;

        public new Windows.Navigation.PageFunctionBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected PageFunctionBase() { }
    }

    public static partial class PageFunctionBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Navigation.PageFunctionBase.RemoveFromJournal"/></summary>
        public static TView RemoveFromJournal<TView>(this TView view, bool value) where TView : PageFunctionBase { view.UI.RemoveFromJournal = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // Ellipse
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Ellipse"/></summary>
        public static Ellipse Ellipse()
        {
            var ui = new Windows.Shapes.Ellipse();
            return global::CSharpMarkup.Wpf.Ellipse.StartChain(ui);
        }
    }

    public partial class Ellipse : Shape, IUI<System.Windows.Shapes.Ellipse>
    {
        static Ellipse instance;

        internal static Ellipse StartChain(Windows.Shapes.Ellipse ui)
        {
            if (instance == null) instance = new Ellipse();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Ellipse ui;

        public new Windows.Shapes.Ellipse UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Ellipse view) => view?.UI;

        public static implicit operator Windows.Shapes.Ellipse(Ellipse view) => view?.UI;

        public static implicit operator Ellipse(Windows.Shapes.Ellipse ui) => Ellipse.StartChain(ui);

        protected Ellipse() { }
    }
}

namespace CSharpMarkup.Wpf // Line
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Line"/></summary>
        public static Line Line(O<double> X1 = default, O<double> X2 = default, O<double> Y1 = default, O<double> Y2 = default)
        {
            var ui = new Windows.Shapes.Line();
            if (X1.HasValue) ui.X1 = X1.Value;
            if (X2.HasValue) ui.X2 = X2.Value;
            if (Y1.HasValue) ui.Y1 = Y1.Value;
            if (Y2.HasValue) ui.Y2 = Y2.Value;
            return global::CSharpMarkup.Wpf.Line.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shapes.Line"/></summary>
        public static Line Line()
        {
            var ui = new Windows.Shapes.Line();
            return global::CSharpMarkup.Wpf.Line.StartChain(ui);
        }
    }

    public partial class Line : Shape, IUI<System.Windows.Shapes.Line>
    {
        static Line instance;

        internal static Line StartChain(Windows.Shapes.Line ui)
        {
            if (instance == null) instance = new Line();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Line ui;

        public new Windows.Shapes.Line UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Line view) => view?.UI;

        public static implicit operator Windows.Shapes.Line(Line view) => view?.UI;

        public static implicit operator Line(Windows.Shapes.Line ui) => Line.StartChain(ui);

        protected Line() { }
    }

    public static partial class LineExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Line.X1"/></summary>
        public static TView X1<TView>(this TView view, double value) where TView : Line { view.UI.X1 = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Line.X2"/></summary>
        public static TView X2<TView>(this TView view, double value) where TView : Line { view.UI.X2 = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Line.Y1"/></summary>
        public static TView Y1<TView>(this TView view, double value) where TView : Line { view.UI.Y1 = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Line.Y2"/></summary>
        public static TView Y2<TView>(this TView view, double value) where TView : Line { view.UI.Y2 = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Line.X1"/></summary>
        public static DependencyProperty<TTarget, double> X1<TTarget>(this TTarget target) where TTarget : Line
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Line.X1Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Line.X2"/></summary>
        public static DependencyProperty<TTarget, double> X2<TTarget>(this TTarget target) where TTarget : Line
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Line.X2Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Line.Y1"/></summary>
        public static DependencyProperty<TTarget, double> Y1<TTarget>(this TTarget target) where TTarget : Line
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Line.Y1Property);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Line.Y2"/></summary>
        public static DependencyProperty<TTarget, double> Y2<TTarget>(this TTarget target) where TTarget : Line
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Line.Y2Property);
    }
}

namespace CSharpMarkup.Wpf // Path
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Path"/></summary>
        public static Path Path(O<Windows.Media.Geometry> Data = default)
        {
            var ui = new Windows.Shapes.Path();
            if (Data.HasValue) ui.Data = Data.Value;
            return global::CSharpMarkup.Wpf.Path.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shapes.Path"/></summary>
        public static Path Path()
        {
            var ui = new Windows.Shapes.Path();
            return global::CSharpMarkup.Wpf.Path.StartChain(ui);
        }
    }

    public partial class Path : Shape, IUI<System.Windows.Shapes.Path>
    {
        static Path instance;

        internal static Path StartChain(Windows.Shapes.Path ui)
        {
            if (instance == null) instance = new Path();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Path ui;

        public new Windows.Shapes.Path UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Path view) => view?.UI;

        public static implicit operator Windows.Shapes.Path(Path view) => view?.UI;

        public static implicit operator Path(Windows.Shapes.Path ui) => Path.StartChain(ui);

        protected Path() { }
    }

    public static partial class PathExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Path.Data"/></summary>
        public static TView Data<TView>(this TView view, Windows.Media.Geometry value) where TView : Path { view.UI.Data = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Path.Data"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> Data<TTarget>(this TTarget target) where TTarget : Path
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Shapes.Path.DataProperty);
    }
}

namespace CSharpMarkup.Wpf // Polygon
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Polygon"/></summary>
        public static Polygon Polygon(O<Windows.Media.FillRule> FillRule = default, O<Windows.Media.PointCollection> Points = default)
        {
            var ui = new Windows.Shapes.Polygon();
            if (FillRule.HasValue) ui.FillRule = FillRule.Value;
            if (Points.HasValue) ui.Points = Points.Value;
            return global::CSharpMarkup.Wpf.Polygon.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shapes.Polygon"/></summary>
        public static Polygon Polygon()
        {
            var ui = new Windows.Shapes.Polygon();
            return global::CSharpMarkup.Wpf.Polygon.StartChain(ui);
        }
    }

    public partial class Polygon : Shape, IUI<System.Windows.Shapes.Polygon>
    {
        static Polygon instance;

        internal static Polygon StartChain(Windows.Shapes.Polygon ui)
        {
            if (instance == null) instance = new Polygon();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Polygon ui;

        public new Windows.Shapes.Polygon UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Polygon view) => view?.UI;

        public static implicit operator Windows.Shapes.Polygon(Polygon view) => view?.UI;

        public static implicit operator Polygon(Windows.Shapes.Polygon ui) => Polygon.StartChain(ui);

        protected Polygon() { }
    }

    public static partial class PolygonExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Polygon.FillRule"/></summary>
        public static TView FillRule<TView>(this TView view, Windows.Media.FillRule value) where TView : Polygon { view.UI.FillRule = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Polygon.Points"/></summary>
        public static TView Points<TView>(this TView view, Windows.Media.PointCollection value) where TView : Polygon { view.UI.Points = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Polygon.FillRule"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FillRule> FillRule<TTarget>(this TTarget target) where TTarget : Polygon
        => DependencyProperty<TTarget, Windows.Media.FillRule>.Get(target, Windows.Shapes.Polygon.FillRuleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Polygon.Points"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> Points<TTarget>(this TTarget target) where TTarget : Polygon
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Shapes.Polygon.PointsProperty);
    }
}

namespace CSharpMarkup.Wpf // Polyline
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Polyline"/></summary>
        public static Polyline Polyline(O<Windows.Media.FillRule> FillRule = default, O<Windows.Media.PointCollection> Points = default)
        {
            var ui = new Windows.Shapes.Polyline();
            if (FillRule.HasValue) ui.FillRule = FillRule.Value;
            if (Points.HasValue) ui.Points = Points.Value;
            return global::CSharpMarkup.Wpf.Polyline.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shapes.Polyline"/></summary>
        public static Polyline Polyline()
        {
            var ui = new Windows.Shapes.Polyline();
            return global::CSharpMarkup.Wpf.Polyline.StartChain(ui);
        }
    }

    public partial class Polyline : Shape, IUI<System.Windows.Shapes.Polyline>
    {
        static Polyline instance;

        internal static Polyline StartChain(Windows.Shapes.Polyline ui)
        {
            if (instance == null) instance = new Polyline();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Polyline ui;

        public new Windows.Shapes.Polyline UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Polyline view) => view?.UI;

        public static implicit operator Windows.Shapes.Polyline(Polyline view) => view?.UI;

        public static implicit operator Polyline(Windows.Shapes.Polyline ui) => Polyline.StartChain(ui);

        protected Polyline() { }
    }

    public static partial class PolylineExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Polyline.FillRule"/></summary>
        public static TView FillRule<TView>(this TView view, Windows.Media.FillRule value) where TView : Polyline { view.UI.FillRule = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Polyline.Points"/></summary>
        public static TView Points<TView>(this TView view, Windows.Media.PointCollection value) where TView : Polyline { view.UI.Points = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Polyline.FillRule"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.FillRule> FillRule<TTarget>(this TTarget target) where TTarget : Polyline
        => DependencyProperty<TTarget, Windows.Media.FillRule>.Get(target, Windows.Shapes.Polyline.FillRuleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Polyline.Points"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PointCollection> Points<TTarget>(this TTarget target) where TTarget : Polyline
        => DependencyProperty<TTarget, Windows.Media.PointCollection>.Get(target, Windows.Shapes.Polyline.PointsProperty);
    }
}

namespace CSharpMarkup.Wpf // Rectangle
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shapes.Rectangle"/></summary>
        public static Rectangle Rectangle(O<double> RadiusX = default, O<double> RadiusY = default)
        {
            var ui = new Windows.Shapes.Rectangle();
            if (RadiusX.HasValue) ui.RadiusX = RadiusX.Value;
            if (RadiusY.HasValue) ui.RadiusY = RadiusY.Value;
            return global::CSharpMarkup.Wpf.Rectangle.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shapes.Rectangle"/></summary>
        public static Rectangle Rectangle()
        {
            var ui = new Windows.Shapes.Rectangle();
            return global::CSharpMarkup.Wpf.Rectangle.StartChain(ui);
        }
    }

    public partial class Rectangle : Shape, IUI<System.Windows.Shapes.Rectangle>
    {
        static Rectangle instance;

        internal static Rectangle StartChain(Windows.Shapes.Rectangle ui)
        {
            if (instance == null) instance = new Rectangle();
            instance.UI = ui;
            return instance;
        }

        Windows.Shapes.Rectangle ui;

        public new Windows.Shapes.Rectangle UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Rectangle view) => view?.UI;

        public static implicit operator Windows.Shapes.Rectangle(Rectangle view) => view?.UI;

        public static implicit operator Rectangle(Windows.Shapes.Rectangle ui) => Rectangle.StartChain(ui);

        protected Rectangle() { }
    }

    public static partial class RectangleExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Rectangle.RadiusX"/></summary>
        public static TView RadiusX<TView>(this TView view, double value) where TView : Rectangle { view.UI.RadiusX = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Rectangle.RadiusY"/></summary>
        public static TView RadiusY<TView>(this TView view, double value) where TView : Rectangle { view.UI.RadiusY = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Rectangle.RadiusX"/></summary>
        public static DependencyProperty<TTarget, double> RadiusX<TTarget>(this TTarget target) where TTarget : Rectangle
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Rectangle.RadiusXProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Rectangle.RadiusY"/></summary>
        public static DependencyProperty<TTarget, double> RadiusY<TTarget>(this TTarget target) where TTarget : Rectangle
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Rectangle.RadiusYProperty);
    }
}

namespace CSharpMarkup.Wpf // Shape
{
    public partial class Shape : FrameworkElement, IUI<System.Windows.Shapes.Shape>
    {
        Windows.Shapes.Shape ui;

        public new Windows.Shapes.Shape UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Shape() { }
    }

    public static partial class ShapeExtensions
    {
        /// <summary>Set <see cref="Windows.Shapes.Shape.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Windows.Media.Brush value) where TView : Shape { view.UI.Fill = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Fill"/></summary>
        public static TView Fill<TView>(this TView view, Color value) where TView : Shape { view.UI.Fill = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Fill"/></summary>
        public static TView Fill<TView>(this TView view, string color) where TView : Shape { view.UI.Fill = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Stretch"/></summary>
        public static TView Stretch<TView>(this TView view, Windows.Media.Stretch value) where TView : Shape { view.UI.Stretch = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Stroke"/></summary>
        public static TView Stroke<TView>(this TView view, Windows.Media.Brush value) where TView : Shape { view.UI.Stroke = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Stroke"/></summary>
        public static TView Stroke<TView>(this TView view, Color value) where TView : Shape { view.UI.Stroke = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.Stroke"/></summary>
        public static TView Stroke<TView>(this TView view, string color) where TView : Shape { view.UI.Stroke = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeDashArray"/></summary>
        public static TView StrokeDashArray<TView>(this TView view, Windows.Media.DoubleCollection value) where TView : Shape { view.UI.StrokeDashArray = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeDashCap"/></summary>
        public static TView StrokeDashCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Shape { view.UI.StrokeDashCap = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeDashOffset"/></summary>
        public static TView StrokeDashOffset<TView>(this TView view, double value) where TView : Shape { view.UI.StrokeDashOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeEndLineCap"/></summary>
        public static TView StrokeEndLineCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Shape { view.UI.StrokeEndLineCap = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeLineJoin"/></summary>
        public static TView StrokeLineJoin<TView>(this TView view, Windows.Media.PenLineJoin value) where TView : Shape { view.UI.StrokeLineJoin = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeMiterLimit"/></summary>
        public static TView StrokeMiterLimit<TView>(this TView view, double value) where TView : Shape { view.UI.StrokeMiterLimit = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeStartLineCap"/></summary>
        public static TView StrokeStartLineCap<TView>(this TView view, Windows.Media.PenLineCap value) where TView : Shape { view.UI.StrokeStartLineCap = value; return view; }

        /// <summary>Set <see cref="Windows.Shapes.Shape.StrokeThickness"/></summary>
        public static TView StrokeThickness<TView>(this TView view, double value) where TView : Shape { view.UI.StrokeThickness = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.Fill"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Fill<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Shapes.Shape.FillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.Stretch"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Stretch> Stretch<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.Stretch>.Get(target, Windows.Shapes.Shape.StretchProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeDashArray"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.DoubleCollection> StrokeDashArray<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.DoubleCollection>.Get(target, Windows.Shapes.Shape.StrokeDashArrayProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeDashCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> StrokeDashCap<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Shapes.Shape.StrokeDashCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeDashOffset"/></summary>
        public static DependencyProperty<TTarget, double> StrokeDashOffset<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Shape.StrokeDashOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeEndLineCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> StrokeEndLineCap<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Shapes.Shape.StrokeEndLineCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeLineJoin"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineJoin> StrokeLineJoin<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.PenLineJoin>.Get(target, Windows.Shapes.Shape.StrokeLineJoinProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeMiterLimit"/></summary>
        public static DependencyProperty<TTarget, double> StrokeMiterLimit<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Shape.StrokeMiterLimitProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.Stroke"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> Stroke<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Shapes.Shape.StrokeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeStartLineCap"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.PenLineCap> StrokeStartLineCap<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, Windows.Media.PenLineCap>.Get(target, Windows.Shapes.Shape.StrokeStartLineCapProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shapes.Shape.StrokeThickness"/></summary>
        public static DependencyProperty<TTarget, double> StrokeThickness<TTarget>(this TTarget target) where TTarget : Shape
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shapes.Shape.StrokeThicknessProperty);
    }
}

namespace CSharpMarkup.Wpf // TaskbarItemInfo
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shell.TaskbarItemInfo"/></summary>
        public static TaskbarItemInfo TaskbarItemInfo(O<string> Description = default, O<Windows.Media.ImageSource> Overlay = default, O<Windows.Shell.TaskbarItemProgressState> ProgressState = default, O<double> ProgressValue = default, O<Windows.Shell.ThumbButtonInfoCollection> ThumbButtonInfos = default, O<Windows.Thickness> ThumbnailClipMargin = default)
        {
            var ui = new Windows.Shell.TaskbarItemInfo();
            if (Description.HasValue) ui.Description = Description.Value;
            if (Overlay.HasValue) ui.Overlay = Overlay.Value;
            if (ProgressState.HasValue) ui.ProgressState = ProgressState.Value;
            if (ProgressValue.HasValue) ui.ProgressValue = ProgressValue.Value;
            if (ThumbButtonInfos.HasValue) ui.ThumbButtonInfos = ThumbButtonInfos.Value;
            if (ThumbnailClipMargin.HasValue) ui.ThumbnailClipMargin = ThumbnailClipMargin.Value;
            return global::CSharpMarkup.Wpf.TaskbarItemInfo.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shell.TaskbarItemInfo"/></summary>
        public static TaskbarItemInfo TaskbarItemInfo()
        {
            var ui = new Windows.Shell.TaskbarItemInfo();
            return global::CSharpMarkup.Wpf.TaskbarItemInfo.StartChain(ui);
        }
    }

    public partial class TaskbarItemInfo : Freezable, IUI<System.Windows.Shell.TaskbarItemInfo>
    {
        static TaskbarItemInfo instance;

        internal static TaskbarItemInfo StartChain(Windows.Shell.TaskbarItemInfo ui)
        {
            if (instance == null) instance = new TaskbarItemInfo();
            instance.UI = ui;
            return instance;
        }

        Windows.Shell.TaskbarItemInfo ui;

        public new Windows.Shell.TaskbarItemInfo UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Shell.TaskbarItemInfo(TaskbarItemInfo view) => view?.UI;

        public static implicit operator TaskbarItemInfo(Windows.Shell.TaskbarItemInfo ui) => TaskbarItemInfo.StartChain(ui);

        protected TaskbarItemInfo() { }
    }

    public static partial class TaskbarItemInfoExtensions
    {
        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.Description"/></summary>
        public static TView Description<TView>(this TView view, string value) where TView : TaskbarItemInfo { view.UI.Description = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.Overlay"/></summary>
        public static TView Overlay<TView>(this TView view, Windows.Media.ImageSource value) where TView : TaskbarItemInfo { view.UI.Overlay = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ProgressState"/></summary>
        public static TView ProgressState<TView>(this TView view, Windows.Shell.TaskbarItemProgressState value) where TView : TaskbarItemInfo { view.UI.ProgressState = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ProgressValue"/></summary>
        public static TView ProgressValue<TView>(this TView view, double value) where TView : TaskbarItemInfo { view.UI.ProgressValue = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbButtonInfos"/></summary>
        public static TView ThumbButtonInfos<TView>(this TView view, Windows.Shell.ThumbButtonInfoCollection value) where TView : TaskbarItemInfo { view.UI.ThumbButtonInfos = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static TView ThumbnailClipMargin<TView>(this TView view, Windows.Thickness value) where TView : TaskbarItemInfo { view.UI.ThumbnailClipMargin = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static TView ThumbnailClipMargin<TView>(this TView view, double uniform) where TView : TaskbarItemInfo { view.UI.ThumbnailClipMargin = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static TView ThumbnailClipMargin<TView>(this TView view, double horizontal, double vertical) where TView : TaskbarItemInfo { view.UI.ThumbnailClipMargin = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static TView ThumbnailClipMargin<TView>(this TView view, double left, double top, double right, double bottom) where TView : TaskbarItemInfo { view.UI.ThumbnailClipMargin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static TView ThumbnailClipMargins<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : TaskbarItemInfo { view.UI.ThumbnailClipMargin = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.Description"/></summary>
        public static DependencyProperty<TTarget, string> Description<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, string>.Get(target, Windows.Shell.TaskbarItemInfo.DescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.Overlay"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> Overlay<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Shell.TaskbarItemInfo.OverlayProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.ProgressState"/></summary>
        public static DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> ProgressState<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState>.Get(target, Windows.Shell.TaskbarItemInfo.ProgressStateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.ProgressValue"/></summary>
        public static DependencyProperty<TTarget, double> ProgressValue<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shell.TaskbarItemInfo.ProgressValueProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.ThumbButtonInfos"/></summary>
        public static DependencyProperty<TTarget, Windows.Shell.ThumbButtonInfoCollection> ThumbButtonInfos<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, Windows.Shell.ThumbButtonInfoCollection>.Get(target, Windows.Shell.TaskbarItemInfo.ThumbButtonInfosProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.TaskbarItemInfo.ThumbnailClipMargin"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> ThumbnailClipMargin<TTarget>(this TTarget target) where TTarget : TaskbarItemInfo
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Shell.TaskbarItemInfo.ThumbnailClipMarginProperty);
    }
}

namespace CSharpMarkup.Wpf // ThumbButtonInfo
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shell.ThumbButtonInfo"/></summary>
        public static ThumbButtonInfo ThumbButtonInfo(O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<string> Description = default, O<bool> DismissWhenClicked = default, O<Windows.Media.ImageSource> ImageSource = default, O<bool> IsBackgroundVisible = default, O<bool> IsEnabled = default, O<bool> IsInteractive = default, O<Windows.Visibility> Visibility = default)
        {
            var ui = new Windows.Shell.ThumbButtonInfo();
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (Description.HasValue) ui.Description = Description.Value;
            if (DismissWhenClicked.HasValue) ui.DismissWhenClicked = DismissWhenClicked.Value;
            if (ImageSource.HasValue) ui.ImageSource = ImageSource.Value;
            if (IsBackgroundVisible.HasValue) ui.IsBackgroundVisible = IsBackgroundVisible.Value;
            if (IsEnabled.HasValue) ui.IsEnabled = IsEnabled.Value;
            if (IsInteractive.HasValue) ui.IsInteractive = IsInteractive.Value;
            if (Visibility.HasValue) ui.Visibility = Visibility.Value;
            return global::CSharpMarkup.Wpf.ThumbButtonInfo.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shell.ThumbButtonInfo"/></summary>
        public static ThumbButtonInfo ThumbButtonInfo()
        {
            var ui = new Windows.Shell.ThumbButtonInfo();
            return global::CSharpMarkup.Wpf.ThumbButtonInfo.StartChain(ui);
        }
    }

    public partial class ThumbButtonInfo : Freezable, IUI<System.Windows.Shell.ThumbButtonInfo>
    {
        static ThumbButtonInfo instance;

        internal static ThumbButtonInfo StartChain(Windows.Shell.ThumbButtonInfo ui)
        {
            if (instance == null) instance = new ThumbButtonInfo();
            instance.UI = ui;
            return instance;
        }

        Windows.Shell.ThumbButtonInfo ui;

        public new Windows.Shell.ThumbButtonInfo UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Shell.ThumbButtonInfo(ThumbButtonInfo view) => view?.UI;

        public static implicit operator ThumbButtonInfo(Windows.Shell.ThumbButtonInfo ui) => ThumbButtonInfo.StartChain(ui);

        protected ThumbButtonInfo() { }
    }

    public static partial class ThumbButtonInfoExtensions
    {
        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : ThumbButtonInfo { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : ThumbButtonInfo { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : ThumbButtonInfo { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.Description"/></summary>
        public static TView Description<TView>(this TView view, string value) where TView : ThumbButtonInfo { view.UI.Description = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.DismissWhenClicked"/></summary>
        public static TView DismissWhenClicked<TView>(this TView view, bool value) where TView : ThumbButtonInfo { view.UI.DismissWhenClicked = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.ImageSource"/></summary>
        public static TView ImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : ThumbButtonInfo { view.UI.ImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.IsBackgroundVisible"/></summary>
        public static TView IsBackgroundVisible<TView>(this TView view, bool value) where TView : ThumbButtonInfo { view.UI.IsBackgroundVisible = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.IsEnabled"/></summary>
        public static TView IsEnabled<TView>(this TView view, bool value) where TView : ThumbButtonInfo { view.UI.IsEnabled = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.IsInteractive"/></summary>
        public static TView IsInteractive<TView>(this TView view, bool value) where TView : ThumbButtonInfo { view.UI.IsInteractive = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.ThumbButtonInfo.Visibility"/></summary>
        public static TView Visibility<TView>(this TView view, Windows.Visibility value) where TView : ThumbButtonInfo { view.UI.Visibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, object>.Get(target, Windows.Shell.ThumbButtonInfo.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Shell.ThumbButtonInfo.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Shell.ThumbButtonInfo.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.Description"/></summary>
        public static DependencyProperty<TTarget, string> Description<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, string>.Get(target, Windows.Shell.ThumbButtonInfo.DescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.DismissWhenClicked"/></summary>
        public static DependencyProperty<TTarget, bool> DismissWhenClicked<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Shell.ThumbButtonInfo.DismissWhenClickedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.ImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ImageSource<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Shell.ThumbButtonInfo.ImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.IsBackgroundVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsBackgroundVisible<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Shell.ThumbButtonInfo.IsBackgroundVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.IsEnabled"/></summary>
        public static DependencyProperty<TTarget, bool> IsEnabled<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Shell.ThumbButtonInfo.IsEnabledProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.IsInteractive"/></summary>
        public static DependencyProperty<TTarget, bool> IsInteractive<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Shell.ThumbButtonInfo.IsInteractiveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.ThumbButtonInfo.Visibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> Visibility<TTarget>(this TTarget target) where TTarget : ThumbButtonInfo
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Shell.ThumbButtonInfo.VisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // WindowChrome
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Shell.WindowChrome"/></summary>
        public static WindowChrome WindowChrome(O<double> CaptionHeight = default, O<Windows.CornerRadius> CornerRadius = default, O<Windows.Thickness> GlassFrameThickness = default, O<Windows.Shell.NonClientFrameEdges> NonClientFrameEdges = default, O<Windows.Thickness> ResizeBorderThickness = default, O<bool> UseAeroCaptionButtons = default)
        {
            var ui = new Windows.Shell.WindowChrome();
            if (CaptionHeight.HasValue) ui.CaptionHeight = CaptionHeight.Value;
            if (CornerRadius.HasValue) ui.CornerRadius = CornerRadius.Value;
            if (GlassFrameThickness.HasValue) ui.GlassFrameThickness = GlassFrameThickness.Value;
            if (NonClientFrameEdges.HasValue) ui.NonClientFrameEdges = NonClientFrameEdges.Value;
            if (ResizeBorderThickness.HasValue) ui.ResizeBorderThickness = ResizeBorderThickness.Value;
            if (UseAeroCaptionButtons.HasValue) ui.UseAeroCaptionButtons = UseAeroCaptionButtons.Value;
            return global::CSharpMarkup.Wpf.WindowChrome.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Shell.WindowChrome"/></summary>
        public static WindowChrome WindowChrome()
        {
            var ui = new Windows.Shell.WindowChrome();
            return global::CSharpMarkup.Wpf.WindowChrome.StartChain(ui);
        }
    }

    public partial class WindowChrome : Freezable, IUI<System.Windows.Shell.WindowChrome>
    {
        static WindowChrome instance;

        internal static WindowChrome StartChain(Windows.Shell.WindowChrome ui)
        {
            if (instance == null) instance = new WindowChrome();
            instance.UI = ui;
            return instance;
        }

        Windows.Shell.WindowChrome ui;

        public new Windows.Shell.WindowChrome UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Shell.WindowChrome(WindowChrome view) => view?.UI;

        public static implicit operator WindowChrome(Windows.Shell.WindowChrome ui) => WindowChrome.StartChain(ui);

        protected WindowChrome() { }
    }

    public static partial class WindowChromeExtensions
    {
        /// <summary>Set <see cref="Windows.Shell.WindowChrome.CaptionHeight"/></summary>
        public static TView CaptionHeight<TView>(this TView view, double value) where TView : WindowChrome { view.UI.CaptionHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.CornerRadius"/></summary>
        public static TView CornerRadius<TView>(this TView view, Windows.CornerRadius value) where TView : WindowChrome { view.UI.CornerRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static TView GlassFrameThickness<TView>(this TView view, Windows.Thickness value) where TView : WindowChrome { view.UI.GlassFrameThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static TView GlassFrameThickness<TView>(this TView view, double uniform) where TView : WindowChrome { view.UI.GlassFrameThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static TView GlassFrameThickness<TView>(this TView view, double horizontal, double vertical) where TView : WindowChrome { view.UI.GlassFrameThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static TView GlassFrameThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : WindowChrome { view.UI.GlassFrameThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static TView GlassFrameThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : WindowChrome { view.UI.GlassFrameThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.NonClientFrameEdges"/></summary>
        public static TView NonClientFrameEdges<TView>(this TView view, Windows.Shell.NonClientFrameEdges value) where TView : WindowChrome { view.UI.NonClientFrameEdges = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static TView ResizeBorderThickness<TView>(this TView view, Windows.Thickness value) where TView : WindowChrome { view.UI.ResizeBorderThickness = value; return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static TView ResizeBorderThickness<TView>(this TView view, double uniform) where TView : WindowChrome { view.UI.ResizeBorderThickness = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static TView ResizeBorderThickness<TView>(this TView view, double horizontal, double vertical) where TView : WindowChrome { view.UI.ResizeBorderThickness = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static TView ResizeBorderThickness<TView>(this TView view, double left, double top, double right, double bottom) where TView : WindowChrome { view.UI.ResizeBorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static TView ResizeBorderThicknesses<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : WindowChrome { view.UI.ResizeBorderThickness = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.UseAeroCaptionButtons"/></summary>
        public static TView UseAeroCaptionButtons<TView>(this TView view, bool value) where TView : WindowChrome { view.UI.UseAeroCaptionButtons = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.CaptionHeight"/></summary>
        public static DependencyProperty<TTarget, double> CaptionHeight<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, double>.Get(target, Windows.Shell.WindowChrome.CaptionHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.CornerRadius"/></summary>
        public static DependencyProperty<TTarget, Windows.CornerRadius> CornerRadius<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, Windows.CornerRadius>.Get(target, Windows.Shell.WindowChrome.CornerRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.GlassFrameThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> GlassFrameThickness<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Shell.WindowChrome.GlassFrameThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.NonClientFrameEdges"/></summary>
        public static DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> NonClientFrameEdges<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges>.Get(target, Windows.Shell.WindowChrome.NonClientFrameEdgesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.ResizeBorderThickness"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> ResizeBorderThickness<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Shell.WindowChrome.ResizeBorderThicknessProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.UseAeroCaptionButtons"/></summary>
        public static DependencyProperty<TTarget, bool> UseAeroCaptionButtons<TTarget>(this TTarget target) where TTarget : WindowChrome
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Shell.WindowChrome.UseAeroCaptionButtonsProperty);

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.WindowChrome"/></summary>
        public static TTarget WindowChrome_WindowChrome<TTarget>(this TTarget target, Windows.Shell.WindowChrome value) where TTarget : Window
        { Windows.Shell.WindowChrome.SetWindowChrome(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Shell.WindowChrome.WindowChrome"/></summary>
        public static DependencyProperty<TTarget, Windows.Shell.WindowChrome> WindowChrome_WindowChrome<TTarget>(this TTarget target) where TTarget : Window
        => DependencyProperty<TTarget, Windows.Shell.WindowChrome>.Get(target, Windows.Shell.WindowChrome.WindowChromeProperty);

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.IsHitTestVisibleInChrome"/></summary>
        public static TTarget WindowChrome_IsHitTestVisibleInChromeN<TTarget>(this TTarget target, bool value) where TTarget : Windows.IInputElement
        { Windows.Shell.WindowChrome.SetIsHitTestVisibleInChrome(target, value); return target; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome.ResizeGripDirection"/></summary>
        public static TTarget WindowChrome_ResizeGripDirectionN<TTarget>(this TTarget target, Windows.Shell.ResizeGripDirection value) where TTarget : Windows.IInputElement
        { Windows.Shell.WindowChrome.SetResizeGripDirection(target, value); return target; }

        /// <summary>Set <see cref="Windows.Shell.WindowChrome"/> attached properties</summary>
        public static TTarget WindowChromeN<TTarget>(this TTarget target

            , O<bool> IsHitTestVisibleInChrome = default

            , O<Windows.Shell.ResizeGripDirection> ResizeGripDirection = default

        ) where TTarget : Windows.IInputElement
        {
            if (IsHitTestVisibleInChrome.HasValue) Windows.Shell.WindowChrome.SetIsHitTestVisibleInChrome(target, IsHitTestVisibleInChrome.Value);

            if (ResizeGripDirection.HasValue) Windows.Shell.WindowChrome.SetResizeGripDirection(target, ResizeGripDirection.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // KeyTipControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.KeyTipControl"/></summary>
        /// <remarks>Remark: KeyTipControl().Bind() binds to <see cref="Windows.Controls.KeyTipControl.TextProperty"/></remarks>
        public static KeyTipControl KeyTipControl(O<string> Text = default)
        {
            var ui = new Windows.Controls.KeyTipControl();
            if (Text.HasValue) ui.Text = Text.Value;
            return global::CSharpMarkup.Wpf.KeyTipControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.KeyTipControl"/></summary>
        /// <remarks>Remark: KeyTipControl().Bind() binds to <see cref="Windows.Controls.KeyTipControl.TextProperty"/></remarks>
        public static KeyTipControl KeyTipControl()
        {
            var ui = new Windows.Controls.KeyTipControl();
            return global::CSharpMarkup.Wpf.KeyTipControl.StartChain(ui);
        }
    }

    public partial class KeyTipControl : Control, IUI<System.Windows.Controls.KeyTipControl>, IDefaultBindProperty
    {
        static KeyTipControl instance;

        internal static KeyTipControl StartChain(Windows.Controls.KeyTipControl ui)
        {
            if (instance == null) instance = new KeyTipControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.KeyTipControl ui;

        public new Windows.Controls.KeyTipControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        /// <summary><see cref="Windows.Controls.KeyTipControl.TextProperty"/></summary>
        public virtual Windows.DependencyProperty DefaultBindProperty => Windows.Controls.KeyTipControl.TextProperty;

        public static implicit operator Windows.UIElement(KeyTipControl view) => view?.UI;

        public static implicit operator Windows.Controls.KeyTipControl(KeyTipControl view) => view?.UI;

        public static implicit operator KeyTipControl(Windows.Controls.KeyTipControl ui) => KeyTipControl.StartChain(ui);

        protected KeyTipControl() { }
    }

    public static partial class KeyTipControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.KeyTipControl.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : KeyTipControl { view.UI.Text = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.KeyTipControl.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : KeyTipControl
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.KeyTipControl.TextProperty);
    }
}

namespace CSharpMarkup.Wpf // Ribbon
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Ribbon"/></summary>
        public static Ribbon Ribbon(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.Ribbon();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.Ribbon.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Ribbon"/></summary>
        public static Ribbon Ribbon(O<Windows.Controls.Ribbon.RibbonApplicationMenu> ApplicationMenu = default, O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.DataTemplate> ContextualTabGroupHeaderTemplate = default, O<IEnumerable> ContextualTabGroupsSource = default, O<Windows.Style> ContextualTabGroupStyle = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<object> HelpPaneContent = default, O<Windows.DataTemplate> HelpPaneContentTemplate = default, O<bool> IsCollapsed = default, O<bool> IsDropDownOpen = default, O<bool> IsMinimized = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonQuickAccessToolBar> QuickAccessToolBar = default, O<bool> ShowQuickAccessToolBarOnTop = default, O<Windows.Style> TabHeaderStyle = default, O<Windows.DataTemplate> TabHeaderTemplate = default, O<object> Title = default, O<Windows.DataTemplate> TitleTemplate = default, O<Windows.Visibility> WindowIconVisibility = default)
        {
            var ui = new Windows.Controls.Ribbon.Ribbon();
            if (ApplicationMenu.HasValue) ui.ApplicationMenu = ApplicationMenu.Value;
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (ContextualTabGroupHeaderTemplate.HasValue) ui.ContextualTabGroupHeaderTemplate = ContextualTabGroupHeaderTemplate.Value;
            if (ContextualTabGroupsSource.HasValue) ui.ContextualTabGroupsSource = ContextualTabGroupsSource.Value;
            if (ContextualTabGroupStyle.HasValue) ui.ContextualTabGroupStyle = ContextualTabGroupStyle.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (HelpPaneContent.HasValue) ui.HelpPaneContent = HelpPaneContent.Value;
            if (HelpPaneContentTemplate.HasValue) ui.HelpPaneContentTemplate = HelpPaneContentTemplate.Value;
            if (IsCollapsed.HasValue) ui.IsCollapsed = IsCollapsed.Value;
            if (IsDropDownOpen.HasValue) ui.IsDropDownOpen = IsDropDownOpen.Value;
            if (IsMinimized.HasValue) ui.IsMinimized = IsMinimized.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBar.HasValue) ui.QuickAccessToolBar = QuickAccessToolBar.Value;
            if (ShowQuickAccessToolBarOnTop.HasValue) ui.ShowQuickAccessToolBarOnTop = ShowQuickAccessToolBarOnTop.Value;
            if (TabHeaderStyle.HasValue) ui.TabHeaderStyle = TabHeaderStyle.Value;
            if (TabHeaderTemplate.HasValue) ui.TabHeaderTemplate = TabHeaderTemplate.Value;
            if (Title.HasValue) ui.Title = Title.Value;
            if (TitleTemplate.HasValue) ui.TitleTemplate = TitleTemplate.Value;
            if (WindowIconVisibility.HasValue) ui.WindowIconVisibility = WindowIconVisibility.Value;
            return global::CSharpMarkup.Wpf.Ribbon.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Ribbon"/></summary>
        public static Ribbon Ribbon()
        {
            var ui = new Windows.Controls.Ribbon.Ribbon();
            return global::CSharpMarkup.Wpf.Ribbon.StartChain(ui);
        }
    }

    public partial class Ribbon : Selector, IUI<System.Windows.Controls.Ribbon.Ribbon>
    {
        static Ribbon instance;

        internal static Ribbon StartChain(Windows.Controls.Ribbon.Ribbon ui)
        {
            if (instance == null) instance = new Ribbon();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Ribbon ui;

        public new Windows.Controls.Ribbon.Ribbon UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(Ribbon view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Ribbon(Ribbon view) => view?.UI;

        public static implicit operator Ribbon(Windows.Controls.Ribbon.Ribbon ui) => Ribbon.StartChain(ui);

        protected Ribbon() { }
    }

    public static partial class RibbonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.ApplicationMenu"/></summary>
        public static TView ApplicationMenu<TView>(this TView view, Windows.Controls.Ribbon.RibbonApplicationMenu value) where TView : Ribbon { view.UI.ApplicationMenu = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : Ribbon { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : Ribbon { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : Ribbon { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : Ribbon { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupHeaderTemplate"/></summary>
        public static TView ContextualTabGroupHeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : Ribbon { view.UI.ContextualTabGroupHeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupsSource"/></summary>
        public static TView ContextualTabGroupsSource<TView>(this TView view, IEnumerable value) where TView : Ribbon { view.UI.ContextualTabGroupsSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupStyle"/></summary>
        public static TView ContextualTabGroupStyle<TView>(this TView view, Windows.Style value) where TView : Ribbon { view.UI.ContextualTabGroupStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : Ribbon { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : Ribbon { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : Ribbon { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : Ribbon { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.HelpPaneContent"/></summary>
        public static TView HelpPaneContent<TView>(this TView view, object value) where TView : Ribbon { view.UI.HelpPaneContent = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.HelpPaneContentTemplate"/></summary>
        public static TView HelpPaneContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : Ribbon { view.UI.HelpPaneContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.IsCollapsed"/></summary>
        public static TView IsCollapsed<TView>(this TView view, bool value) where TView : Ribbon { view.UI.IsCollapsed = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.IsDropDownOpen"/></summary>
        public static TView IsDropDownOpen<TView>(this TView view, bool value) where TView : Ribbon { view.UI.IsDropDownOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.IsMinimized"/></summary>
        public static TView IsMinimized<TView>(this TView view, bool value) where TView : Ribbon { view.UI.IsMinimized = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : Ribbon { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : Ribbon { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : Ribbon { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : Ribbon { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : Ribbon { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : Ribbon { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : Ribbon { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : Ribbon { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : Ribbon { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.QuickAccessToolBar"/></summary>
        public static TView QuickAccessToolBar<TView>(this TView view, Windows.Controls.Ribbon.RibbonQuickAccessToolBar value) where TView : Ribbon { view.UI.QuickAccessToolBar = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.ShowQuickAccessToolBarOnTop"/></summary>
        public static TView ShowQuickAccessToolBarOnTop<TView>(this TView view, bool value) where TView : Ribbon { view.UI.ShowQuickAccessToolBarOnTop = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.TabHeaderStyle"/></summary>
        public static TView TabHeaderStyle<TView>(this TView view, Windows.Style value) where TView : Ribbon { view.UI.TabHeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.TabHeaderTemplate"/></summary>
        public static TView TabHeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : Ribbon { view.UI.TabHeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.Title"/></summary>
        public static TView Title<TView>(this TView view, object value) where TView : Ribbon { view.UI.Title = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.TitleTemplate"/></summary>
        public static TView TitleTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : Ribbon { view.UI.TitleTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Ribbon.WindowIconVisibility"/></summary>
        public static TView WindowIconVisibility<TView>(this TView view, Windows.Visibility value) where TView : Ribbon { view.UI.WindowIconVisibility = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.ApplicationMenu"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenu> ApplicationMenu<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenu>.Get(target, Windows.Controls.Ribbon.Ribbon.ApplicationMenuProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupHeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ContextualTabGroupHeaderTemplate<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.Ribbon.ContextualTabGroupHeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupsSource"/></summary>
        public static DependencyProperty<TTarget, IEnumerable> ContextualTabGroupsSource<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, IEnumerable>.Get(target, Windows.Controls.Ribbon.Ribbon.ContextualTabGroupsSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.ContextualTabGroupStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> ContextualTabGroupStyle<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.Ribbon.ContextualTabGroupStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.HelpPaneContent"/></summary>
        public static DependencyProperty<TTarget, object> HelpPaneContent<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.Ribbon.HelpPaneContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.HelpPaneContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HelpPaneContentTemplate<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.Ribbon.HelpPaneContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.IsCollapsed"/></summary>
        public static DependencyProperty<TTarget, bool> IsCollapsed<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Ribbon.IsCollapsedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.IsDropDownOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownOpen<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Ribbon.IsDropDownOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.IsHostedInRibbonWindow"/></summary>
        public static DependencyProperty<TTarget, bool> IsHostedInRibbonWindow<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Ribbon.IsHostedInRibbonWindowProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.IsMinimized"/></summary>
        public static DependencyProperty<TTarget, bool> IsMinimized<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Ribbon.IsMinimizedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.Ribbon.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.QuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonQuickAccessToolBar> QuickAccessToolBar<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonQuickAccessToolBar>.Get(target, Windows.Controls.Ribbon.Ribbon.QuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.ShowQuickAccessToolBarOnTop"/></summary>
        public static DependencyProperty<TTarget, bool> ShowQuickAccessToolBarOnTop<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Ribbon.ShowQuickAccessToolBarOnTopProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.TabHeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> TabHeaderStyle<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.Ribbon.TabHeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.TabHeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> TabHeaderTemplate<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.Ribbon.TabHeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.Title"/></summary>
        public static DependencyProperty<TTarget, object> Title<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.Ribbon.TitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.TitleTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> TitleTemplate<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.Ribbon.TitleTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Ribbon.WindowIconVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> WindowIconVisibility<TTarget>(this TTarget target) where TTarget : Ribbon
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.Ribbon.Ribbon.WindowIconVisibilityProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonApplicationMenu
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu"/></summary>
        public static RibbonApplicationMenu RibbonApplicationMenu(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationMenu();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonApplicationMenu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu"/></summary>
        public static RibbonApplicationMenu RibbonApplicationMenu(O<object> AuxiliaryPaneContent = default, O<Windows.DataTemplate> AuxiliaryPaneContentTemplate = default, O<Windows.Controls.DataTemplateSelector> AuxiliaryPaneContentTemplateSelector = default, O<object> FooterPaneContent = default, O<Windows.DataTemplate> FooterPaneContentTemplate = default, O<Windows.Controls.DataTemplateSelector> FooterPaneContentTemplateSelector = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationMenu();
            if (AuxiliaryPaneContent.HasValue) ui.AuxiliaryPaneContent = AuxiliaryPaneContent.Value;
            if (AuxiliaryPaneContentTemplate.HasValue) ui.AuxiliaryPaneContentTemplate = AuxiliaryPaneContentTemplate.Value;
            if (AuxiliaryPaneContentTemplateSelector.HasValue) ui.AuxiliaryPaneContentTemplateSelector = AuxiliaryPaneContentTemplateSelector.Value;
            if (FooterPaneContent.HasValue) ui.FooterPaneContent = FooterPaneContent.Value;
            if (FooterPaneContentTemplate.HasValue) ui.FooterPaneContentTemplate = FooterPaneContentTemplate.Value;
            if (FooterPaneContentTemplateSelector.HasValue) ui.FooterPaneContentTemplateSelector = FooterPaneContentTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.RibbonApplicationMenu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu"/></summary>
        public static RibbonApplicationMenu RibbonApplicationMenu()
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationMenu();
            return global::CSharpMarkup.Wpf.RibbonApplicationMenu.StartChain(ui);
        }
    }

    public partial class RibbonApplicationMenu : RibbonMenuButton, IUI<System.Windows.Controls.Ribbon.RibbonApplicationMenu>
    {
        static RibbonApplicationMenu instance;

        internal static RibbonApplicationMenu StartChain(Windows.Controls.Ribbon.RibbonApplicationMenu ui)
        {
            if (instance == null) instance = new RibbonApplicationMenu();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonApplicationMenu ui;

        public new Windows.Controls.Ribbon.RibbonApplicationMenu UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonApplicationMenu view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonApplicationMenu(RibbonApplicationMenu view) => view?.UI;

        public static implicit operator RibbonApplicationMenu(Windows.Controls.Ribbon.RibbonApplicationMenu ui) => RibbonApplicationMenu.StartChain(ui);

        protected RibbonApplicationMenu() { }
    }

    public static partial class RibbonApplicationMenuExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContent"/></summary>
        public static TView AuxiliaryPaneContent<TView>(this TView view, object value) where TView : RibbonApplicationMenu { view.UI.AuxiliaryPaneContent = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplate"/></summary>
        public static TView AuxiliaryPaneContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonApplicationMenu { view.UI.AuxiliaryPaneContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplateSelector"/></summary>
        public static TView AuxiliaryPaneContentTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : RibbonApplicationMenu { view.UI.AuxiliaryPaneContentTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContent"/></summary>
        public static TView FooterPaneContent<TView>(this TView view, object value) where TView : RibbonApplicationMenu { view.UI.FooterPaneContent = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplate"/></summary>
        public static TView FooterPaneContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonApplicationMenu { view.UI.FooterPaneContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplateSelector"/></summary>
        public static TView FooterPaneContentTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : RibbonApplicationMenu { view.UI.FooterPaneContentTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContent"/></summary>
        public static DependencyProperty<TTarget, object> AuxiliaryPaneContent<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> AuxiliaryPaneContentTemplate<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> AuxiliaryPaneContentTemplateSelector<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.AuxiliaryPaneContentTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContent"/></summary>
        public static DependencyProperty<TTarget, object> FooterPaneContent<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> FooterPaneContentTemplate<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> FooterPaneContentTemplateSelector<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenu
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenu.FooterPaneContentTemplateSelectorProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonApplicationMenuItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItem"/></summary>
        public static RibbonApplicationMenuItem RibbonApplicationMenuItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationMenuItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonApplicationMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItem"/></summary>
        public static RibbonApplicationMenuItem RibbonApplicationMenuItem()
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationMenuItem();
            return global::CSharpMarkup.Wpf.RibbonApplicationMenuItem.StartChain(ui);
        }
    }

    public partial class RibbonApplicationMenuItem : RibbonMenuItem, IUI<System.Windows.Controls.Ribbon.RibbonApplicationMenuItem>
    {
        static RibbonApplicationMenuItem instance;

        internal static RibbonApplicationMenuItem StartChain(Windows.Controls.Ribbon.RibbonApplicationMenuItem ui)
        {
            if (instance == null) instance = new RibbonApplicationMenuItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonApplicationMenuItem ui;

        public new Windows.Controls.Ribbon.RibbonApplicationMenuItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonApplicationMenuItem view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonApplicationMenuItem(RibbonApplicationMenuItem view) => view?.UI;

        public static implicit operator RibbonApplicationMenuItem(Windows.Controls.Ribbon.RibbonApplicationMenuItem ui) => RibbonApplicationMenuItem.StartChain(ui);

        protected RibbonApplicationMenuItem() { }
    }

    public static partial class RibbonApplicationMenuItemExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItem.Level"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> Level<TTarget>(this TTarget target) where TTarget : RibbonApplicationMenuItem
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel>.Get(target, Windows.Controls.Ribbon.RibbonApplicationMenuItem.LevelProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonApplicationSplitMenuItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem"/></summary>
        public static RibbonApplicationSplitMenuItem RibbonApplicationSplitMenuItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonApplicationSplitMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem"/></summary>
        public static RibbonApplicationSplitMenuItem RibbonApplicationSplitMenuItem()
        {
            var ui = new Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem();
            return global::CSharpMarkup.Wpf.RibbonApplicationSplitMenuItem.StartChain(ui);
        }
    }

    public partial class RibbonApplicationSplitMenuItem : RibbonSplitMenuItem, IUI<System.Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem>
    {
        static RibbonApplicationSplitMenuItem instance;

        internal static RibbonApplicationSplitMenuItem StartChain(Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem ui)
        {
            if (instance == null) instance = new RibbonApplicationSplitMenuItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem ui;

        public new Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonApplicationSplitMenuItem view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem(RibbonApplicationSplitMenuItem view) => view?.UI;

        public static implicit operator RibbonApplicationSplitMenuItem(Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem ui) => RibbonApplicationSplitMenuItem.StartChain(ui);

        protected RibbonApplicationSplitMenuItem() { }
    }

    public static partial class RibbonApplicationSplitMenuItemExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem.Level"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> Level<TTarget>(this TTarget target) where TTarget : RibbonApplicationSplitMenuItem
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel>.Get(target, Windows.Controls.Ribbon.RibbonApplicationSplitMenuItem.LevelProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonButton"/></summary>
        public static RibbonButton RibbonButton(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonButton"/></summary>
        public static RibbonButton RibbonButton(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<Windows.CornerRadius> CornerRadius = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonButton();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (CornerRadius.HasValue) ui.CornerRadius = CornerRadius.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonButton"/></summary>
        public static RibbonButton RibbonButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonButton();
            return global::CSharpMarkup.Wpf.RibbonButton.StartChain(ui);
        }
    }

    public partial class RibbonButton : Button, IUI<System.Windows.Controls.Ribbon.RibbonButton>
    {
        static RibbonButton instance;

        internal static RibbonButton StartChain(Windows.Controls.Ribbon.RibbonButton ui)
        {
            if (instance == null) instance = new RibbonButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonButton ui;

        public new Windows.Controls.Ribbon.RibbonButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonButton(RibbonButton view) => view?.UI;

        public static implicit operator RibbonButton(Windows.Controls.Ribbon.RibbonButton ui) => RibbonButton.StartChain(ui);

        protected RibbonButton() { }
    }

    public static partial class RibbonButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonButton { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonButton { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.CornerRadius"/></summary>
        public static TView CornerRadius<TView>(this TView view, Windows.CornerRadius value) where TView : RibbonButton { view.UI.CornerRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonButton { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonButton { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonButton { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonButton { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonButton { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonButton { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonButton { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonButton { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonButton { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonButton { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonButton { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonButton { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonButton { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonButton.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonButton.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.CornerRadius"/></summary>
        public static DependencyProperty<TTarget, Windows.CornerRadius> CornerRadius<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.CornerRadius>.Get(target, Windows.Controls.Ribbon.RibbonButton.CornerRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonButton.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonButton.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonButton.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonButton.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonButton.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonButton.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonButton.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonButton.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonButton.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonButton.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonCheckBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonCheckBox"/></summary>
        public static RibbonCheckBox RibbonCheckBox(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonCheckBox();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonCheckBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonCheckBox"/></summary>
        public static RibbonCheckBox RibbonCheckBox(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonCheckBox();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonCheckBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonCheckBox"/></summary>
        public static RibbonCheckBox RibbonCheckBox()
        {
            var ui = new Windows.Controls.Ribbon.RibbonCheckBox();
            return global::CSharpMarkup.Wpf.RibbonCheckBox.StartChain(ui);
        }
    }

    public partial class RibbonCheckBox : CheckBox, IUI<System.Windows.Controls.Ribbon.RibbonCheckBox>
    {
        static RibbonCheckBox instance;

        internal static RibbonCheckBox StartChain(Windows.Controls.Ribbon.RibbonCheckBox ui)
        {
            if (instance == null) instance = new RibbonCheckBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonCheckBox ui;

        public new Windows.Controls.Ribbon.RibbonCheckBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonCheckBox view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonCheckBox(RibbonCheckBox view) => view?.UI;

        public static implicit operator RibbonCheckBox(Windows.Controls.Ribbon.RibbonCheckBox ui) => RibbonCheckBox.StartChain(ui);

        protected RibbonCheckBox() { }
    }

    public static partial class RibbonCheckBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonCheckBox { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonCheckBox { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonCheckBox { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonCheckBox { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonCheckBox { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonCheckBox { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonCheckBox { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonCheckBox { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonCheckBox { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonCheckBox { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonCheckBox { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonCheckBox { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonCheckBox.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonCheckBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonCheckBox.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonComboBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonComboBox"/></summary>
        public static RibbonComboBox RibbonComboBox(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonComboBox();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonComboBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonComboBox"/></summary>
        public static RibbonComboBox RibbonComboBox(O<bool> IsEditable = default, O<bool> IsReadOnly = default, O<double> SelectionBoxWidth = default, O<bool> StaysOpenOnEdit = default, O<string> Text = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonComboBox();
            if (IsEditable.HasValue) ui.IsEditable = IsEditable.Value;
            if (IsReadOnly.HasValue) ui.IsReadOnly = IsReadOnly.Value;
            if (SelectionBoxWidth.HasValue) ui.SelectionBoxWidth = SelectionBoxWidth.Value;
            if (StaysOpenOnEdit.HasValue) ui.StaysOpenOnEdit = StaysOpenOnEdit.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            return global::CSharpMarkup.Wpf.RibbonComboBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonComboBox"/></summary>
        public static RibbonComboBox RibbonComboBox()
        {
            var ui = new Windows.Controls.Ribbon.RibbonComboBox();
            return global::CSharpMarkup.Wpf.RibbonComboBox.StartChain(ui);
        }
    }

    public partial class RibbonComboBox : RibbonMenuButton, IUI<System.Windows.Controls.Ribbon.RibbonComboBox>
    {
        static RibbonComboBox instance;

        internal static RibbonComboBox StartChain(Windows.Controls.Ribbon.RibbonComboBox ui)
        {
            if (instance == null) instance = new RibbonComboBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonComboBox ui;

        public new Windows.Controls.Ribbon.RibbonComboBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonComboBox view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonComboBox(RibbonComboBox view) => view?.UI;

        public static implicit operator RibbonComboBox(Windows.Controls.Ribbon.RibbonComboBox ui) => RibbonComboBox.StartChain(ui);

        protected RibbonComboBox() { }
    }

    public static partial class RibbonComboBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonComboBox.IsEditable"/></summary>
        public static TView IsEditable<TView>(this TView view, bool value) where TView : RibbonComboBox { view.UI.IsEditable = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonComboBox.IsReadOnly"/></summary>
        public static TView IsReadOnly<TView>(this TView view, bool value) where TView : RibbonComboBox { view.UI.IsReadOnly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxWidth"/></summary>
        public static TView SelectionBoxWidth<TView>(this TView view, double value) where TView : RibbonComboBox { view.UI.SelectionBoxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonComboBox.StaysOpenOnEdit"/></summary>
        public static TView StaysOpenOnEdit<TView>(this TView view, bool value) where TView : RibbonComboBox { view.UI.StaysOpenOnEdit = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonComboBox.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : RibbonComboBox { view.UI.Text = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.IsEditable"/></summary>
        public static DependencyProperty<TTarget, bool> IsEditable<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.IsEditableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.IsReadOnly"/></summary>
        public static DependencyProperty<TTarget, bool> IsReadOnly<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.IsReadOnlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItem"/></summary>
        public static DependencyProperty<TTarget, object> SelectionBoxItem<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> SelectionBoxItemStringFormat<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> SelectionBoxItemTemplate<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> SelectionBoxItemTemplateSelector<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxItemTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxWidth"/></summary>
        public static DependencyProperty<TTarget, double> SelectionBoxWidth<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.SelectionBoxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.StaysOpenOnEdit"/></summary>
        public static DependencyProperty<TTarget, bool> StaysOpenOnEdit<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.StaysOpenOnEditProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonComboBox.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : RibbonComboBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonComboBox.TextProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonContentPresenter
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContentPresenter"/></summary>
        public static RibbonContentPresenter RibbonContentPresenter(O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonContentPresenter();
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            return global::CSharpMarkup.Wpf.RibbonContentPresenter.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContentPresenter"/></summary>
        public static RibbonContentPresenter RibbonContentPresenter()
        {
            var ui = new Windows.Controls.Ribbon.RibbonContentPresenter();
            return global::CSharpMarkup.Wpf.RibbonContentPresenter.StartChain(ui);
        }
    }

    public partial class RibbonContentPresenter : ContentPresenter, IUI<System.Windows.Controls.Ribbon.RibbonContentPresenter>
    {
        static RibbonContentPresenter instance;

        internal static RibbonContentPresenter StartChain(Windows.Controls.Ribbon.RibbonContentPresenter ui)
        {
            if (instance == null) instance = new RibbonContentPresenter();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonContentPresenter ui;

        public new Windows.Controls.Ribbon.RibbonContentPresenter UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonContentPresenter view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonContentPresenter(RibbonContentPresenter view) => view?.UI;

        public static implicit operator RibbonContentPresenter(Windows.Controls.Ribbon.RibbonContentPresenter ui) => RibbonContentPresenter.StartChain(ui);

        protected RibbonContentPresenter() { }
    }

    public static partial class RibbonContentPresenterExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonContentPresenter.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonContentPresenter { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContentPresenter.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonContentPresenter
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonContentPresenter.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContentPresenter.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonContentPresenter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonContentPresenter.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContentPresenter.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonContentPresenter
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonContentPresenter.IsInQuickAccessToolBarProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonContextMenu
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextMenu"/></summary>
        public static RibbonContextMenu RibbonContextMenu(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextMenu();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonContextMenu.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextMenu"/></summary>
        public static RibbonContextMenu RibbonContextMenu()
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextMenu();
            return global::CSharpMarkup.Wpf.RibbonContextMenu.StartChain(ui);
        }
    }

    public partial class RibbonContextMenu : ContextMenu, IUI<System.Windows.Controls.Ribbon.RibbonContextMenu>
    {
        static RibbonContextMenu instance;

        internal static RibbonContextMenu StartChain(Windows.Controls.Ribbon.RibbonContextMenu ui)
        {
            if (instance == null) instance = new RibbonContextMenu();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonContextMenu ui;

        public new Windows.Controls.Ribbon.RibbonContextMenu UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonContextMenu view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonContextMenu(RibbonContextMenu view) => view?.UI;

        public static implicit operator RibbonContextMenu(Windows.Controls.Ribbon.RibbonContextMenu ui) => RibbonContextMenu.StartChain(ui);

        protected RibbonContextMenu() { }
    }

    public static partial class RibbonContextMenuExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextMenu.HasGallery"/></summary>
        public static DependencyProperty<TTarget, bool> HasGallery<TTarget>(this TTarget target) where TTarget : RibbonContextMenu
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonContextMenu.HasGalleryProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonContextualTabGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup"/></summary>
        public static RibbonContextualTabGroup RibbonContextualTabGroup(
            object Header
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextualTabGroup();
            if (Header is not null) ui.Header = Header;
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup"/></summary>
        public static RibbonContextualTabGroup RibbonContextualTabGroup(O<object> Header = default, O<string> HeaderStringFormat = default, O<Windows.DataTemplate> HeaderTemplate = default, O<Windows.Controls.DataTemplateSelector> HeaderTemplateSelector = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextualTabGroup();
            if (Header.HasValue) ui.Header = Header.Value;
            if (HeaderStringFormat.HasValue) ui.HeaderStringFormat = HeaderStringFormat.Value;
            if (HeaderTemplate.HasValue) ui.HeaderTemplate = HeaderTemplate.Value;
            if (HeaderTemplateSelector.HasValue) ui.HeaderTemplateSelector = HeaderTemplateSelector.Value;
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup"/></summary>
        public static RibbonContextualTabGroup RibbonContextualTabGroup()
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextualTabGroup();
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroup.StartChain(ui);
        }
    }

    public partial class RibbonContextualTabGroup : Control, IUI<System.Windows.Controls.Ribbon.RibbonContextualTabGroup>
    {
        static RibbonContextualTabGroup instance;

        internal static RibbonContextualTabGroup StartChain(Windows.Controls.Ribbon.RibbonContextualTabGroup ui)
        {
            if (instance == null) instance = new RibbonContextualTabGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonContextualTabGroup ui;

        public new Windows.Controls.Ribbon.RibbonContextualTabGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonContextualTabGroup view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonContextualTabGroup(RibbonContextualTabGroup view) => view?.UI;

        public static implicit operator RibbonContextualTabGroup(Windows.Controls.Ribbon.RibbonContextualTabGroup ui) => RibbonContextualTabGroup.StartChain(ui);

        protected RibbonContextualTabGroup() { }
    }

    public static partial class RibbonContextualTabGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.Header"/></summary>
        public static TView Header<TView>(this TView view, object value) where TView : RibbonContextualTabGroup { view.UI.Header = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderStringFormat"/></summary>
        public static TView HeaderStringFormat<TView>(this TView view, string value) where TView : RibbonContextualTabGroup { view.UI.HeaderStringFormat = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplate"/></summary>
        public static TView HeaderTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonContextualTabGroup { view.UI.HeaderTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplateSelector"/></summary>
        public static TView HeaderTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : RibbonContextualTabGroup { view.UI.HeaderTemplateSelector = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.Header"/></summary>
        public static DependencyProperty<TTarget, object> Header<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroup
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderStringFormat"/></summary>
        public static DependencyProperty<TTarget, string> HeaderStringFormat<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderStringFormatProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> HeaderTemplate<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroup
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> HeaderTemplateSelector<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroup
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroup.HeaderTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroup.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroup
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroup.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonContextualTabGroupItemsControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl"/></summary>
        public static RibbonContextualTabGroupItemsControl RibbonContextualTabGroupItemsControl(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroupItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl"/></summary>
        public static RibbonContextualTabGroupItemsControl RibbonContextualTabGroupItemsControl()
        {
            var ui = new Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl();
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroupItemsControl.StartChain(ui);
        }
    }

    public partial class RibbonContextualTabGroupItemsControl : ItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl>
    {
        static RibbonContextualTabGroupItemsControl instance;

        internal static RibbonContextualTabGroupItemsControl StartChain(Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl ui)
        {
            if (instance == null) instance = new RibbonContextualTabGroupItemsControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl ui;

        public new Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonContextualTabGroupItemsControl view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl(RibbonContextualTabGroupItemsControl view) => view?.UI;

        public static implicit operator RibbonContextualTabGroupItemsControl(Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl ui) => RibbonContextualTabGroupItemsControl.StartChain(ui);

        protected RibbonContextualTabGroupItemsControl() { }
    }

    public static partial class RibbonContextualTabGroupItemsControlExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroupItemsControl
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonContextualTabGroupItemsControl.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControl"/></summary>
        public static RibbonControl RibbonControl(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonControl();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControl"/></summary>
        public static RibbonControl RibbonControl(O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonControl();
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            return global::CSharpMarkup.Wpf.RibbonControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControl"/></summary>
        public static RibbonControl RibbonControl()
        {
            var ui = new Windows.Controls.Ribbon.RibbonControl();
            return global::CSharpMarkup.Wpf.RibbonControl.StartChain(ui);
        }
    }

    public partial class RibbonControl : ContentControl, IUI<System.Windows.Controls.Ribbon.RibbonControl>
    {
        static RibbonControl instance;

        internal static RibbonControl StartChain(Windows.Controls.Ribbon.RibbonControl ui)
        {
            if (instance == null) instance = new RibbonControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonControl ui;

        public new Windows.Controls.Ribbon.RibbonControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonControl view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonControl(RibbonControl view) => view?.UI;

        public static implicit operator RibbonControl(Windows.Controls.Ribbon.RibbonControl ui) => RibbonControl.StartChain(ui);

        protected RibbonControl() { }
    }

    public static partial class RibbonControlExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControl.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonControl { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControl.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonControl
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonControl.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControl.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonControl.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControl.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonControl
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonControl.IsInQuickAccessToolBarProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonControlGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControlGroup"/></summary>
        public static RibbonControlGroup RibbonControlGroup(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonControlGroup();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonControlGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControlGroup"/></summary>
        public static RibbonControlGroup RibbonControlGroup(O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonControlGroup();
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            return global::CSharpMarkup.Wpf.RibbonControlGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControlGroup"/></summary>
        public static RibbonControlGroup RibbonControlGroup()
        {
            var ui = new Windows.Controls.Ribbon.RibbonControlGroup();
            return global::CSharpMarkup.Wpf.RibbonControlGroup.StartChain(ui);
        }
    }

    public partial class RibbonControlGroup : ItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonControlGroup>
    {
        static RibbonControlGroup instance;

        internal static RibbonControlGroup StartChain(Windows.Controls.Ribbon.RibbonControlGroup ui)
        {
            if (instance == null) instance = new RibbonControlGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonControlGroup ui;

        public new Windows.Controls.Ribbon.RibbonControlGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonControlGroup view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonControlGroup(RibbonControlGroup view) => view?.UI;

        public static implicit operator RibbonControlGroup(Windows.Controls.Ribbon.RibbonControlGroup ui) => RibbonControlGroup.StartChain(ui);

        protected RibbonControlGroup() { }
    }

    public static partial class RibbonControlGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlGroup.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonControlGroup { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlGroup.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonControlGroup
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonControlGroup.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlGroup.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonControlGroup
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonControlGroup.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonControlSizeDefinition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition"/></summary>
        public static RibbonControlSizeDefinition RibbonControlSizeDefinition(O<Windows.Controls.Ribbon.RibbonImageSize> ImageSize = default, O<bool> IsCollapsed = default, O<bool> IsLabelVisible = default, O<Windows.Controls.Ribbon.RibbonControlLength> MaxWidth = default, O<Windows.Controls.Ribbon.RibbonControlLength> MinWidth = default, O<Windows.Controls.Ribbon.RibbonControlLength> Width = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonControlSizeDefinition();
            if (ImageSize.HasValue) ui.ImageSize = ImageSize.Value;
            if (IsCollapsed.HasValue) ui.IsCollapsed = IsCollapsed.Value;
            if (IsLabelVisible.HasValue) ui.IsLabelVisible = IsLabelVisible.Value;
            if (MaxWidth.HasValue) ui.MaxWidth = MaxWidth.Value;
            if (MinWidth.HasValue) ui.MinWidth = MinWidth.Value;
            if (Width.HasValue) ui.Width = Width.Value;
            return global::CSharpMarkup.Wpf.RibbonControlSizeDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition"/></summary>
        public static RibbonControlSizeDefinition RibbonControlSizeDefinition()
        {
            var ui = new Windows.Controls.Ribbon.RibbonControlSizeDefinition();
            return global::CSharpMarkup.Wpf.RibbonControlSizeDefinition.StartChain(ui);
        }
    }

    public partial class RibbonControlSizeDefinition : Freezable, IUI<System.Windows.Controls.Ribbon.RibbonControlSizeDefinition>
    {
        static RibbonControlSizeDefinition instance;

        internal static RibbonControlSizeDefinition StartChain(Windows.Controls.Ribbon.RibbonControlSizeDefinition ui)
        {
            if (instance == null) instance = new RibbonControlSizeDefinition();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonControlSizeDefinition ui;

        public new Windows.Controls.Ribbon.RibbonControlSizeDefinition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.Ribbon.RibbonControlSizeDefinition(RibbonControlSizeDefinition view) => view?.UI;

        public static implicit operator RibbonControlSizeDefinition(Windows.Controls.Ribbon.RibbonControlSizeDefinition ui) => RibbonControlSizeDefinition.StartChain(ui);

        protected RibbonControlSizeDefinition() { }
    }

    public static partial class RibbonControlSizeDefinitionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.ImageSize"/></summary>
        public static TView ImageSize<TView>(this TView view, Windows.Controls.Ribbon.RibbonImageSize value) where TView : RibbonControlSizeDefinition { view.UI.ImageSize = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsCollapsed"/></summary>
        public static TView IsCollapsed<TView>(this TView view, bool value) where TView : RibbonControlSizeDefinition { view.UI.IsCollapsed = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsLabelVisible"/></summary>
        public static TView IsLabelVisible<TView>(this TView view, bool value) where TView : RibbonControlSizeDefinition { view.UI.IsLabelVisible = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.MaxWidth"/></summary>
        public static TView MaxWidth<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlLength value) where TView : RibbonControlSizeDefinition { view.UI.MaxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.MinWidth"/></summary>
        public static TView MinWidth<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlLength value) where TView : RibbonControlSizeDefinition { view.UI.MinWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.Width"/></summary>
        public static TView Width<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlLength value) where TView : RibbonControlSizeDefinition { view.UI.Width = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.ImageSize"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonImageSize> ImageSize<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonImageSize>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.ImageSizeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsCollapsed"/></summary>
        public static DependencyProperty<TTarget, bool> IsCollapsed<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsCollapsedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsLabelVisible"/></summary>
        public static DependencyProperty<TTarget, bool> IsLabelVisible<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.IsLabelVisibleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.MaxWidth"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength> MaxWidth<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.MaxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.MinWidth"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength> MinWidth<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.MinWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonControlSizeDefinition.Width"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength> Width<TTarget>(this TTarget target) where TTarget : RibbonControlSizeDefinition
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlLength>.Get(target, Windows.Controls.Ribbon.RibbonControlSizeDefinition.WidthProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonFilterMenuButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonFilterMenuButton"/></summary>
        public static RibbonFilterMenuButton RibbonFilterMenuButton(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonFilterMenuButton();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonFilterMenuButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonFilterMenuButton"/></summary>
        public static RibbonFilterMenuButton RibbonFilterMenuButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonFilterMenuButton();
            return global::CSharpMarkup.Wpf.RibbonFilterMenuButton.StartChain(ui);
        }
    }

    public partial class RibbonFilterMenuButton : RibbonMenuButton, IUI<System.Windows.Controls.Ribbon.RibbonFilterMenuButton>
    {
        static RibbonFilterMenuButton instance;

        internal static RibbonFilterMenuButton StartChain(Windows.Controls.Ribbon.RibbonFilterMenuButton ui)
        {
            if (instance == null) instance = new RibbonFilterMenuButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonFilterMenuButton ui;

        public new Windows.Controls.Ribbon.RibbonFilterMenuButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonFilterMenuButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonFilterMenuButton(RibbonFilterMenuButton view) => view?.UI;

        public static implicit operator RibbonFilterMenuButton(Windows.Controls.Ribbon.RibbonFilterMenuButton ui) => RibbonFilterMenuButton.StartChain(ui);

        protected RibbonFilterMenuButton() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonGallery
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGallery"/></summary>
        public static RibbonGallery RibbonGallery(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGallery();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonGallery.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGallery"/></summary>
        public static RibbonGallery RibbonGallery(O<Windows.Style> AllFilterItemContainerStyle = default, O<Windows.DataTemplate> AllFilterItemTemplate = default, O<bool> CanAddToQuickAccessToolBarDirectly = default, O<bool> CanUserFilter = default, O<Windows.Style> CategoryStyle = default, O<Windows.DataTemplate> CategoryTemplate = default, O<bool> ColumnsStretchToFill = default, O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<Windows.Style> FilterItemContainerStyle = default, O<Windows.Controls.StyleSelector> FilterItemContainerStyleSelector = default, O<Windows.DataTemplate> FilterItemTemplate = default, O<Windows.Controls.DataTemplateSelector> FilterItemTemplateSelector = default, O<Windows.Style> FilterMenuButtonStyle = default, O<object> FilterPaneContent = default, O<Windows.DataTemplate> FilterPaneContentTemplate = default, O<Windows.Style> GalleryItemStyle = default, O<Windows.DataTemplate> GalleryItemTemplate = default, O<bool> IsSharedColumnSizeScope = default, O<bool?> IsSynchronizedWithCurrentItem = default, O<int> MaxColumnCount = default, O<int> MinColumnCount = default, O<object> PreviewCommandParameter = default, O<object> QuickAccessToolBarId = default, O<object> SelectedItem = default, O<object> SelectedValue = default, O<string> SelectedValuePath = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGallery();
            if (AllFilterItemContainerStyle.HasValue) ui.AllFilterItemContainerStyle = AllFilterItemContainerStyle.Value;
            if (AllFilterItemTemplate.HasValue) ui.AllFilterItemTemplate = AllFilterItemTemplate.Value;
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CanUserFilter.HasValue) ui.CanUserFilter = CanUserFilter.Value;
            if (CategoryStyle.HasValue) ui.CategoryStyle = CategoryStyle.Value;
            if (CategoryTemplate.HasValue) ui.CategoryTemplate = CategoryTemplate.Value;
            if (ColumnsStretchToFill.HasValue) ui.ColumnsStretchToFill = ColumnsStretchToFill.Value;
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (FilterItemContainerStyle.HasValue) ui.FilterItemContainerStyle = FilterItemContainerStyle.Value;
            if (FilterItemContainerStyleSelector.HasValue) ui.FilterItemContainerStyleSelector = FilterItemContainerStyleSelector.Value;
            if (FilterItemTemplate.HasValue) ui.FilterItemTemplate = FilterItemTemplate.Value;
            if (FilterItemTemplateSelector.HasValue) ui.FilterItemTemplateSelector = FilterItemTemplateSelector.Value;
            if (FilterMenuButtonStyle.HasValue) ui.FilterMenuButtonStyle = FilterMenuButtonStyle.Value;
            if (FilterPaneContent.HasValue) ui.FilterPaneContent = FilterPaneContent.Value;
            if (FilterPaneContentTemplate.HasValue) ui.FilterPaneContentTemplate = FilterPaneContentTemplate.Value;
            if (GalleryItemStyle.HasValue) ui.GalleryItemStyle = GalleryItemStyle.Value;
            if (GalleryItemTemplate.HasValue) ui.GalleryItemTemplate = GalleryItemTemplate.Value;
            if (IsSharedColumnSizeScope.HasValue) ui.IsSharedColumnSizeScope = IsSharedColumnSizeScope.Value;
            if (IsSynchronizedWithCurrentItem.HasValue) ui.IsSynchronizedWithCurrentItem = IsSynchronizedWithCurrentItem.Value;
            if (MaxColumnCount.HasValue) ui.MaxColumnCount = MaxColumnCount.Value;
            if (MinColumnCount.HasValue) ui.MinColumnCount = MinColumnCount.Value;
            if (PreviewCommandParameter.HasValue) ui.PreviewCommandParameter = PreviewCommandParameter.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SelectedItem.HasValue) ui.SelectedItem = SelectedItem.Value;
            if (SelectedValue.HasValue) ui.SelectedValue = SelectedValue.Value;
            if (SelectedValuePath.HasValue) ui.SelectedValuePath = SelectedValuePath.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonGallery.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGallery"/></summary>
        public static RibbonGallery RibbonGallery()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGallery();
            return global::CSharpMarkup.Wpf.RibbonGallery.StartChain(ui);
        }
    }

    public partial class RibbonGallery : ItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonGallery>
    {
        static RibbonGallery instance;

        internal static RibbonGallery StartChain(Windows.Controls.Ribbon.RibbonGallery ui)
        {
            if (instance == null) instance = new RibbonGallery();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGallery ui;

        public new Windows.Controls.Ribbon.RibbonGallery UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGallery view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonGallery(RibbonGallery view) => view?.UI;

        public static implicit operator RibbonGallery(Windows.Controls.Ribbon.RibbonGallery ui) => RibbonGallery.StartChain(ui);

        protected RibbonGallery() { }
    }

    public static partial class RibbonGalleryExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.AllFilterItemContainerStyle"/></summary>
        public static TView AllFilterItemContainerStyle<TView>(this TView view, Windows.Style value) where TView : RibbonGallery { view.UI.AllFilterItemContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.AllFilterItemTemplate"/></summary>
        public static TView AllFilterItemTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGallery { view.UI.AllFilterItemTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonGallery { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CanUserFilter"/></summary>
        public static TView CanUserFilter<TView>(this TView view, bool value) where TView : RibbonGallery { view.UI.CanUserFilter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CategoryStyle"/></summary>
        public static TView CategoryStyle<TView>(this TView view, Windows.Style value) where TView : RibbonGallery { view.UI.CategoryStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CategoryTemplate"/></summary>
        public static TView CategoryTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGallery { view.UI.CategoryTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ColumnsStretchToFill"/></summary>
        public static TView ColumnsStretchToFill<TView>(this TView view, bool value) where TView : RibbonGallery { view.UI.ColumnsStretchToFill = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : RibbonGallery { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : RibbonGallery { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyle"/></summary>
        public static TView FilterItemContainerStyle<TView>(this TView view, Windows.Style value) where TView : RibbonGallery { view.UI.FilterItemContainerStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyleSelector"/></summary>
        public static TView FilterItemContainerStyleSelector<TView>(this TView view, Windows.Controls.StyleSelector value) where TView : RibbonGallery { view.UI.FilterItemContainerStyleSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplate"/></summary>
        public static TView FilterItemTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGallery { view.UI.FilterItemTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplateSelector"/></summary>
        public static TView FilterItemTemplateSelector<TView>(this TView view, Windows.Controls.DataTemplateSelector value) where TView : RibbonGallery { view.UI.FilterItemTemplateSelector = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterMenuButtonStyle"/></summary>
        public static TView FilterMenuButtonStyle<TView>(this TView view, Windows.Style value) where TView : RibbonGallery { view.UI.FilterMenuButtonStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterPaneContent"/></summary>
        public static TView FilterPaneContent<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.FilterPaneContent = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterPaneContentTemplate"/></summary>
        public static TView FilterPaneContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGallery { view.UI.FilterPaneContentTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.GalleryItemStyle"/></summary>
        public static TView GalleryItemStyle<TView>(this TView view, Windows.Style value) where TView : RibbonGallery { view.UI.GalleryItemStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.GalleryItemTemplate"/></summary>
        public static TView GalleryItemTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGallery { view.UI.GalleryItemTemplate = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.IsSharedColumnSizeScope"/></summary>
        public static TView IsSharedColumnSizeScope<TView>(this TView view, bool value) where TView : RibbonGallery { view.UI.IsSharedColumnSizeScope = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.IsSynchronizedWithCurrentItem"/></summary>
        public static TView IsSynchronizedWithCurrentItem<TView>(this TView view, bool? value) where TView : RibbonGallery { view.UI.IsSynchronizedWithCurrentItem = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.MaxColumnCount"/></summary>
        public static TView MaxColumnCount<TView>(this TView view, int value) where TView : RibbonGallery { view.UI.MaxColumnCount = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.MinColumnCount"/></summary>
        public static TView MinColumnCount<TView>(this TView view, int value) where TView : RibbonGallery { view.UI.MinColumnCount = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.PreviewCommandParameter"/></summary>
        public static TView PreviewCommandParameter<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.PreviewCommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedItem"/></summary>
        public static TView SelectedItem<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.SelectedItem = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedValue"/></summary>
        public static TView SelectedValue<TView>(this TView view, object value) where TView : RibbonGallery { view.UI.SelectedValue = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedValuePath"/></summary>
        public static TView SelectedValuePath<TView>(this TView view, string value) where TView : RibbonGallery { view.UI.SelectedValuePath = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGallery { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonGallery { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonGallery { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGallery { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonGallery { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGallery { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonGallery { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.AllFilterItemContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> AllFilterItemContainerStyle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonGallery.AllFilterItemContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.AllFilterItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> AllFilterItemTemplate<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGallery.AllFilterItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CanUserFilter"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserFilter<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CanUserFilterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CategoryStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> CategoryStyle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CategoryStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CategoryTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> CategoryTemplate<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CategoryTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ColumnsStretchToFill"/></summary>
        public static DependencyProperty<TTarget, bool> ColumnsStretchToFill<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ColumnsStretchToFillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Controls.Ribbon.RibbonGallery.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> FilterItemContainerStyle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyleSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.StyleSelector> FilterItemContainerStyleSelector<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Controls.StyleSelector>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterItemContainerStyleSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> FilterItemTemplate<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplateSelector"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector> FilterItemTemplateSelector<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Controls.DataTemplateSelector>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterItemTemplateSelectorProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterMenuButtonStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> FilterMenuButtonStyle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterMenuButtonStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterPaneContent"/></summary>
        public static DependencyProperty<TTarget, object> FilterPaneContent<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterPaneContentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.FilterPaneContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> FilterPaneContentTemplate<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGallery.FilterPaneContentTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.GalleryItemStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> GalleryItemStyle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonGallery.GalleryItemStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.GalleryItemTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> GalleryItemTemplate<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGallery.GalleryItemTemplateProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.HighlightedItem"/></summary>
        public static DependencyProperty<TTarget, object> HighlightedItem<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.HighlightedItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.IsSharedColumnSizeScope"/></summary>
        public static DependencyProperty<TTarget, bool> IsSharedColumnSizeScope<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGallery.IsSharedColumnSizeScopeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.IsSynchronizedWithCurrentItem"/></summary>
        public static DependencyProperty<TTarget, bool?> IsSynchronizedWithCurrentItem<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, bool?>.Get(target, Windows.Controls.Ribbon.RibbonGallery.IsSynchronizedWithCurrentItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.MaxColumnCount"/></summary>
        public static DependencyProperty<TTarget, int> MaxColumnCount<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Ribbon.RibbonGallery.MaxColumnCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.MinColumnCount"/></summary>
        public static DependencyProperty<TTarget, int> MinColumnCount<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Ribbon.RibbonGallery.MinColumnCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.PreviewCommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> PreviewCommandParameter<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.PreviewCommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonGallery.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedItem"/></summary>
        public static DependencyProperty<TTarget, object> SelectedItem<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.SelectedItemProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedValuePath"/></summary>
        public static DependencyProperty<TTarget, string> SelectedValuePath<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGallery.SelectedValuePathProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.SelectedValue"/></summary>
        public static DependencyProperty<TTarget, object> SelectedValue<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGallery.SelectedValueProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGallery.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGallery.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonGallery
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGallery.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGalleryCategory
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory"/></summary>
        public static RibbonGalleryCategory RibbonGalleryCategory(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryCategory();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonGalleryCategory.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory"/></summary>
        public static RibbonGalleryCategory RibbonGalleryCategory(O<bool> ColumnsStretchToFill = default, O<Windows.Visibility> HeaderVisibility = default, O<bool> IsSharedColumnSizeScope = default, O<int> MaxColumnCount = default, O<int> MinColumnCount = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryCategory();
            if (ColumnsStretchToFill.HasValue) ui.ColumnsStretchToFill = ColumnsStretchToFill.Value;
            if (HeaderVisibility.HasValue) ui.HeaderVisibility = HeaderVisibility.Value;
            if (IsSharedColumnSizeScope.HasValue) ui.IsSharedColumnSizeScope = IsSharedColumnSizeScope.Value;
            if (MaxColumnCount.HasValue) ui.MaxColumnCount = MaxColumnCount.Value;
            if (MinColumnCount.HasValue) ui.MinColumnCount = MinColumnCount.Value;
            return global::CSharpMarkup.Wpf.RibbonGalleryCategory.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory"/></summary>
        public static RibbonGalleryCategory RibbonGalleryCategory()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryCategory();
            return global::CSharpMarkup.Wpf.RibbonGalleryCategory.StartChain(ui);
        }
    }

    public partial class RibbonGalleryCategory : HeaderedItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonGalleryCategory>
    {
        static RibbonGalleryCategory instance;

        internal static RibbonGalleryCategory StartChain(Windows.Controls.Ribbon.RibbonGalleryCategory ui)
        {
            if (instance == null) instance = new RibbonGalleryCategory();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGalleryCategory ui;

        public new Windows.Controls.Ribbon.RibbonGalleryCategory UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGalleryCategory view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonGalleryCategory(RibbonGalleryCategory view) => view?.UI;

        public static implicit operator RibbonGalleryCategory(Windows.Controls.Ribbon.RibbonGalleryCategory ui) => RibbonGalleryCategory.StartChain(ui);

        protected RibbonGalleryCategory() { }
    }

    public static partial class RibbonGalleryCategoryExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.ColumnsStretchToFill"/></summary>
        public static TView ColumnsStretchToFill<TView>(this TView view, bool value) where TView : RibbonGalleryCategory { view.UI.ColumnsStretchToFill = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.HeaderVisibility"/></summary>
        public static TView HeaderVisibility<TView>(this TView view, Windows.Visibility value) where TView : RibbonGalleryCategory { view.UI.HeaderVisibility = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.IsSharedColumnSizeScope"/></summary>
        public static TView IsSharedColumnSizeScope<TView>(this TView view, bool value) where TView : RibbonGalleryCategory { view.UI.IsSharedColumnSizeScope = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.MaxColumnCount"/></summary>
        public static TView MaxColumnCount<TView>(this TView view, int value) where TView : RibbonGalleryCategory { view.UI.MaxColumnCount = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.MinColumnCount"/></summary>
        public static TView MinColumnCount<TView>(this TView view, int value) where TView : RibbonGalleryCategory { view.UI.MinColumnCount = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.ColumnsStretchToFill"/></summary>
        public static DependencyProperty<TTarget, bool> ColumnsStretchToFill<TTarget>(this TTarget target) where TTarget : RibbonGalleryCategory
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGalleryCategory.ColumnsStretchToFillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.HeaderVisibility"/></summary>
        public static DependencyProperty<TTarget, Windows.Visibility> HeaderVisibility<TTarget>(this TTarget target) where TTarget : RibbonGalleryCategory
        => DependencyProperty<TTarget, Windows.Visibility>.Get(target, Windows.Controls.Ribbon.RibbonGalleryCategory.HeaderVisibilityProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.IsSharedColumnSizeScope"/></summary>
        public static DependencyProperty<TTarget, bool> IsSharedColumnSizeScope<TTarget>(this TTarget target) where TTarget : RibbonGalleryCategory
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGalleryCategory.IsSharedColumnSizeScopeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.MaxColumnCount"/></summary>
        public static DependencyProperty<TTarget, int> MaxColumnCount<TTarget>(this TTarget target) where TTarget : RibbonGalleryCategory
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Ribbon.RibbonGalleryCategory.MaxColumnCountProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryCategory.MinColumnCount"/></summary>
        public static DependencyProperty<TTarget, int> MinColumnCount<TTarget>(this TTarget target) where TTarget : RibbonGalleryCategory
        => DependencyProperty<TTarget, int>.Get(target, Windows.Controls.Ribbon.RibbonGalleryCategory.MinColumnCountProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGalleryItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryItem"/></summary>
        public static RibbonGalleryItem RibbonGalleryItem(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryItem();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonGalleryItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryItem"/></summary>
        public static RibbonGalleryItem RibbonGalleryItem(O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<bool> IsSelected = default, O<string> KeyTip = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryItem();
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonGalleryItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGalleryItem"/></summary>
        public static RibbonGalleryItem RibbonGalleryItem()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGalleryItem();
            return global::CSharpMarkup.Wpf.RibbonGalleryItem.StartChain(ui);
        }
    }

    public partial class RibbonGalleryItem : ContentControl, IUI<System.Windows.Controls.Ribbon.RibbonGalleryItem>
    {
        static RibbonGalleryItem instance;

        internal static RibbonGalleryItem StartChain(Windows.Controls.Ribbon.RibbonGalleryItem ui)
        {
            if (instance == null) instance = new RibbonGalleryItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGalleryItem ui;

        public new Windows.Controls.Ribbon.RibbonGalleryItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGalleryItem view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonGalleryItem(RibbonGalleryItem view) => view?.UI;

        public static implicit operator RibbonGalleryItem(Windows.Controls.Ribbon.RibbonGalleryItem ui) => RibbonGalleryItem.StartChain(ui);

        protected RibbonGalleryItem() { }
    }

    public static partial class RibbonGalleryItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : RibbonGalleryItem { view.UI.IsSelected = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonGalleryItem { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGalleryItem { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonGalleryItem { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonGalleryItem { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonGalleryItem { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonGalleryItem { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGalleryItem { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonGalleryItem { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGalleryItem { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonGalleryItem { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.IsHighlighted"/></summary>
        public static DependencyProperty<TTarget, bool> IsHighlighted<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.IsHighlightedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.IsPressed"/></summary>
        public static DependencyProperty<TTarget, bool> IsPressed<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.IsPressedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonGalleryItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGalleryItem.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGroup
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroup"/></summary>
        public static RibbonGroup RibbonGroup(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroup();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroup"/></summary>
        public static RibbonGroup RibbonGroup(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBaseCollection> GroupSizeDefinitions = default, O<bool> IsDropDownOpen = default, O<string> KeyTip = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroup();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (GroupSizeDefinitions.HasValue) ui.GroupSizeDefinitions = GroupSizeDefinitions.Value;
            if (IsDropDownOpen.HasValue) ui.IsDropDownOpen = IsDropDownOpen.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonGroup.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroup"/></summary>
        public static RibbonGroup RibbonGroup()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroup();
            return global::CSharpMarkup.Wpf.RibbonGroup.StartChain(ui);
        }
    }

    public partial class RibbonGroup : HeaderedItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonGroup>
    {
        static RibbonGroup instance;

        internal static RibbonGroup StartChain(Windows.Controls.Ribbon.RibbonGroup ui)
        {
            if (instance == null) instance = new RibbonGroup();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGroup ui;

        public new Windows.Controls.Ribbon.RibbonGroup UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGroup view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonGroup(RibbonGroup view) => view?.UI;

        public static implicit operator RibbonGroup(Windows.Controls.Ribbon.RibbonGroup ui) => RibbonGroup.StartChain(ui);

        protected RibbonGroup() { }
    }

    public static partial class RibbonGroupExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonGroup { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.GroupSizeDefinitions"/></summary>
        public static TView GroupSizeDefinitions<TView>(this TView view, Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBaseCollection value) where TView : RibbonGroup { view.UI.GroupSizeDefinitions = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.IsDropDownOpen"/></summary>
        public static TView IsDropDownOpen<TView>(this TView view, bool value) where TView : RibbonGroup { view.UI.IsDropDownOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonGroup { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGroup { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGroup { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonGroup { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonGroup { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonGroup { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonGroup { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonGroup { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonGroup { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGroup { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonGroup { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonGroup { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGroup { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonGroup { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonGroup { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonGroup { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGroup.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.GroupSizeDefinitions"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBaseCollection> GroupSizeDefinitions<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBaseCollection>.Get(target, Windows.Controls.Ribbon.RibbonGroup.GroupSizeDefinitionsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.IsCollapsed"/></summary>
        public static DependencyProperty<TTarget, bool> IsCollapsed<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGroup.IsCollapsedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.IsDropDownOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownOpen<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGroup.IsDropDownOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGroup.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGroup.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGroup.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGroup.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonGroup.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonGroup.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonGroup.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGroup.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroup.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonGroup
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonGroup.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGroupSizeDefinition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinition"/></summary>
        public static RibbonGroupSizeDefinition RibbonGroupSizeDefinition(
            params System.Windows.Controls.Ribbon.RibbonControlSizeDefinition[] ControlSizeDefinitions
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupSizeDefinition();
            foreach (var child in ControlSizeDefinitions) if (child is not null) ui.ControlSizeDefinitions.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.ControlSizeDefinitions);
            return global::CSharpMarkup.Wpf.RibbonGroupSizeDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinition"/></summary>
        public static RibbonGroupSizeDefinition RibbonGroupSizeDefinition(O<Windows.Controls.Ribbon.RibbonControlSizeDefinitionCollection> ControlSizeDefinitions = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupSizeDefinition();
            if (ControlSizeDefinitions.HasValue) ui.ControlSizeDefinitions = ControlSizeDefinitions.Value;
            return global::CSharpMarkup.Wpf.RibbonGroupSizeDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinition"/></summary>
        public static RibbonGroupSizeDefinition RibbonGroupSizeDefinition()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupSizeDefinition();
            return global::CSharpMarkup.Wpf.RibbonGroupSizeDefinition.StartChain(ui);
        }
    }

    public partial class RibbonGroupSizeDefinition : RibbonGroupSizeDefinitionBase, IUI<System.Windows.Controls.Ribbon.RibbonGroupSizeDefinition>
    {
        static RibbonGroupSizeDefinition instance;

        internal static RibbonGroupSizeDefinition StartChain(Windows.Controls.Ribbon.RibbonGroupSizeDefinition ui)
        {
            if (instance == null) instance = new RibbonGroupSizeDefinition();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGroupSizeDefinition ui;

        public new Windows.Controls.Ribbon.RibbonGroupSizeDefinition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.Ribbon.RibbonGroupSizeDefinition(RibbonGroupSizeDefinition view) => view?.UI;

        public static implicit operator RibbonGroupSizeDefinition(Windows.Controls.Ribbon.RibbonGroupSizeDefinition ui) => RibbonGroupSizeDefinition.StartChain(ui);

        protected RibbonGroupSizeDefinition() { }
    }

    public static partial class RibbonGroupSizeDefinitionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinition.ControlSizeDefinitions"/></summary>
        public static TView ControlSizeDefinitions<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinitionCollection value) where TView : RibbonGroupSizeDefinition { view.UI.ControlSizeDefinitions = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinition.ControlSizeDefinitions"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinitionCollection> ControlSizeDefinitions<TTarget>(this TTarget target) where TTarget : RibbonGroupSizeDefinition
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinitionCollection>.Get(target, Windows.Controls.Ribbon.RibbonGroupSizeDefinition.ControlSizeDefinitionsProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGroupSizeDefinitionBase
{
    public partial class RibbonGroupSizeDefinitionBase : Freezable, IUI<System.Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase>
    {
        Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase ui;

        public new Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected RibbonGroupSizeDefinitionBase() { }
    }

    public static partial class RibbonGroupSizeDefinitionBaseExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase.IsCollapsed"/></summary>
        public static TView IsCollapsed<TView>(this TView view, bool value) where TView : RibbonGroupSizeDefinitionBase { view.UI.IsCollapsed = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase.IsCollapsed"/></summary>
        public static DependencyProperty<TTarget, bool> IsCollapsed<TTarget>(this TTarget target) where TTarget : RibbonGroupSizeDefinitionBase
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonGroupSizeDefinitionBase.IsCollapsedProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGroupTemplateSizeDefinition
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition"/></summary>
        public static RibbonGroupTemplateSizeDefinition RibbonGroupTemplateSizeDefinition(
            System.Windows.DataTemplate ContentTemplate
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition();
            if (ContentTemplate is not null) ui.ContentTemplate = ContentTemplate;
            return global::CSharpMarkup.Wpf.RibbonGroupTemplateSizeDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition"/></summary>
        public static RibbonGroupTemplateSizeDefinition RibbonGroupTemplateSizeDefinition(O<Windows.DataTemplate> ContentTemplate = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition();
            if (ContentTemplate.HasValue) ui.ContentTemplate = ContentTemplate.Value;
            return global::CSharpMarkup.Wpf.RibbonGroupTemplateSizeDefinition.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition"/></summary>
        public static RibbonGroupTemplateSizeDefinition RibbonGroupTemplateSizeDefinition()
        {
            var ui = new Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition();
            return global::CSharpMarkup.Wpf.RibbonGroupTemplateSizeDefinition.StartChain(ui);
        }
    }

    public partial class RibbonGroupTemplateSizeDefinition : RibbonGroupSizeDefinitionBase, IUI<System.Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition>
    {
        static RibbonGroupTemplateSizeDefinition instance;

        internal static RibbonGroupTemplateSizeDefinition StartChain(Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition ui)
        {
            if (instance == null) instance = new RibbonGroupTemplateSizeDefinition();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition ui;

        public new Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition(RibbonGroupTemplateSizeDefinition view) => view?.UI;

        public static implicit operator RibbonGroupTemplateSizeDefinition(Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition ui) => RibbonGroupTemplateSizeDefinition.StartChain(ui);

        protected RibbonGroupTemplateSizeDefinition() { }
    }

    public static partial class RibbonGroupTemplateSizeDefinitionExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition.ContentTemplate"/></summary>
        public static TView ContentTemplate<TView>(this TView view, Windows.DataTemplate value) where TView : RibbonGroupTemplateSizeDefinition { view.UI.ContentTemplate = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition.ContentTemplate"/></summary>
        public static DependencyProperty<TTarget, Windows.DataTemplate> ContentTemplate<TTarget>(this TTarget target) where TTarget : RibbonGroupTemplateSizeDefinition
        => DependencyProperty<TTarget, Windows.DataTemplate>.Get(target, Windows.Controls.Ribbon.RibbonGroupTemplateSizeDefinition.ContentTemplateProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonMenuButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuButton"/></summary>
        public static RibbonMenuButton RibbonMenuButton(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuButton();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonMenuButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuButton"/></summary>
        public static RibbonMenuButton RibbonMenuButton(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<bool> CanUserResizeHorizontally = default, O<bool> CanUserResizeVertically = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<double> DropDownHeight = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<bool> IsDropDownOpen = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuButton();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CanUserResizeHorizontally.HasValue) ui.CanUserResizeHorizontally = CanUserResizeHorizontally.Value;
            if (CanUserResizeVertically.HasValue) ui.CanUserResizeVertically = CanUserResizeVertically.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (DropDownHeight.HasValue) ui.DropDownHeight = DropDownHeight.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (IsDropDownOpen.HasValue) ui.IsDropDownOpen = IsDropDownOpen.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonMenuButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuButton"/></summary>
        public static RibbonMenuButton RibbonMenuButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuButton();
            return global::CSharpMarkup.Wpf.RibbonMenuButton.StartChain(ui);
        }
    }

    public partial class RibbonMenuButton : Menu, IUI<System.Windows.Controls.Ribbon.RibbonMenuButton>
    {
        static RibbonMenuButton instance;

        internal static RibbonMenuButton StartChain(Windows.Controls.Ribbon.RibbonMenuButton ui)
        {
            if (instance == null) instance = new RibbonMenuButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonMenuButton ui;

        public new Windows.Controls.Ribbon.RibbonMenuButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonMenuButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonMenuButton(RibbonMenuButton view) => view?.UI;

        public static implicit operator RibbonMenuButton(Windows.Controls.Ribbon.RibbonMenuButton ui) => RibbonMenuButton.StartChain(ui);

        protected RibbonMenuButton() { }
    }

    public static partial class RibbonMenuButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonMenuButton { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeHorizontally"/></summary>
        public static TView CanUserResizeHorizontally<TView>(this TView view, bool value) where TView : RibbonMenuButton { view.UI.CanUserResizeHorizontally = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeVertically"/></summary>
        public static TView CanUserResizeVertically<TView>(this TView view, bool value) where TView : RibbonMenuButton { view.UI.CanUserResizeVertically = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonMenuButton { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.DropDownHeight"/></summary>
        public static TView DropDownHeight<TView>(this TView view, double value) where TView : RibbonMenuButton { view.UI.DropDownHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.IsDropDownOpen"/></summary>
        public static TView IsDropDownOpen<TView>(this TView view, bool value) where TView : RibbonMenuButton { view.UI.IsDropDownOpen = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuButton { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuButton { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonMenuButton { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonMenuButton { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuButton { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuButton { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuButton { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonMenuButton { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeHorizontally"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeHorizontally<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeHorizontallyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeVertically"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeVertically<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.CanUserResizeVerticallyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.DropDownHeight"/></summary>
        public static DependencyProperty<TTarget, double> DropDownHeight<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.DropDownHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.HasGallery"/></summary>
        public static DependencyProperty<TTarget, bool> HasGallery<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.HasGalleryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.IsDropDownOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownOpen<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.IsDropDownOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.IsDropDownPositionedAbove"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownPositionedAbove<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.IsDropDownPositionedAboveProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuButton.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonMenuButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuButton.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonMenuItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuItem"/></summary>
        public static RibbonMenuItem RibbonMenuItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuItem"/></summary>
        public static RibbonMenuItem RibbonMenuItem(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<bool> CanUserResizeHorizontally = default, O<bool> CanUserResizeVertically = default, O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<double> DropDownHeight = default, O<Windows.Media.ImageSource> ImageSource = default, O<string> KeyTip = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> QuickAccessToolBarImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuItem();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CanUserResizeHorizontally.HasValue) ui.CanUserResizeHorizontally = CanUserResizeHorizontally.Value;
            if (CanUserResizeVertically.HasValue) ui.CanUserResizeVertically = CanUserResizeVertically.Value;
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (DropDownHeight.HasValue) ui.DropDownHeight = DropDownHeight.Value;
            if (ImageSource.HasValue) ui.ImageSource = ImageSource.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (QuickAccessToolBarImageSource.HasValue) ui.QuickAccessToolBarImageSource = QuickAccessToolBarImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonMenuItem"/></summary>
        public static RibbonMenuItem RibbonMenuItem()
        {
            var ui = new Windows.Controls.Ribbon.RibbonMenuItem();
            return global::CSharpMarkup.Wpf.RibbonMenuItem.StartChain(ui);
        }
    }

    public partial class RibbonMenuItem : MenuItem, IUI<System.Windows.Controls.Ribbon.RibbonMenuItem>
    {
        static RibbonMenuItem instance;

        internal static RibbonMenuItem StartChain(Windows.Controls.Ribbon.RibbonMenuItem ui)
        {
            if (instance == null) instance = new RibbonMenuItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonMenuItem ui;

        public new Windows.Controls.Ribbon.RibbonMenuItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonMenuItem view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonMenuItem(RibbonMenuItem view) => view?.UI;

        public static implicit operator RibbonMenuItem(Windows.Controls.Ribbon.RibbonMenuItem ui) => RibbonMenuItem.StartChain(ui);

        protected RibbonMenuItem() { }
    }

    public static partial class RibbonMenuItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonMenuItem { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeHorizontally"/></summary>
        public static TView CanUserResizeHorizontally<TView>(this TView view, bool value) where TView : RibbonMenuItem { view.UI.CanUserResizeHorizontally = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeVertically"/></summary>
        public static TView CanUserResizeVertically<TView>(this TView view, bool value) where TView : RibbonMenuItem { view.UI.CanUserResizeVertically = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.DropDownHeight"/></summary>
        public static TView DropDownHeight<TView>(this TView view, double value) where TView : RibbonMenuItem { view.UI.DropDownHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ImageSource"/></summary>
        public static TView ImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuItem { view.UI.ImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonMenuItem { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonMenuItem { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonMenuItem { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonMenuItem { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonMenuItem { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarImageSource"/></summary>
        public static TView QuickAccessToolBarImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuItem { view.UI.QuickAccessToolBarImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonMenuItem { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonMenuItem { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuItem { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonMenuItem { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonMenuItem { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonMenuItem { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeHorizontally"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeHorizontally<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeHorizontallyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeVertically"/></summary>
        public static DependencyProperty<TTarget, bool> CanUserResizeVertically<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.CanUserResizeVerticallyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.DropDownHeight"/></summary>
        public static DependencyProperty<TTarget, double> DropDownHeight<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.DropDownHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.HasGallery"/></summary>
        public static DependencyProperty<TTarget, bool> HasGallery<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.HasGalleryProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.IsDropDownPositionedLeft"/></summary>
        public static DependencyProperty<TTarget, bool> IsDropDownPositionedLeft<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.IsDropDownPositionedLeftProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> QuickAccessToolBarImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.QuickAccessToolBarImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonMenuItem.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonMenuItem.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonQuickAccessToolBar
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar"/></summary>
        public static RibbonQuickAccessToolBar RibbonQuickAccessToolBar(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonQuickAccessToolBar();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonQuickAccessToolBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar"/></summary>
        public static RibbonQuickAccessToolBar RibbonQuickAccessToolBar(O<Windows.Controls.Ribbon.RibbonMenuButton> CustomizeMenuButton = default, O<bool> IsOverflowOpen = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonQuickAccessToolBar();
            if (CustomizeMenuButton.HasValue) ui.CustomizeMenuButton = CustomizeMenuButton.Value;
            if (IsOverflowOpen.HasValue) ui.IsOverflowOpen = IsOverflowOpen.Value;
            return global::CSharpMarkup.Wpf.RibbonQuickAccessToolBar.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar"/></summary>
        public static RibbonQuickAccessToolBar RibbonQuickAccessToolBar()
        {
            var ui = new Windows.Controls.Ribbon.RibbonQuickAccessToolBar();
            return global::CSharpMarkup.Wpf.RibbonQuickAccessToolBar.StartChain(ui);
        }
    }

    public partial class RibbonQuickAccessToolBar : ItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonQuickAccessToolBar>
    {
        static RibbonQuickAccessToolBar instance;

        internal static RibbonQuickAccessToolBar StartChain(Windows.Controls.Ribbon.RibbonQuickAccessToolBar ui)
        {
            if (instance == null) instance = new RibbonQuickAccessToolBar();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonQuickAccessToolBar ui;

        public new Windows.Controls.Ribbon.RibbonQuickAccessToolBar UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonQuickAccessToolBar view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonQuickAccessToolBar(RibbonQuickAccessToolBar view) => view?.UI;

        public static implicit operator RibbonQuickAccessToolBar(Windows.Controls.Ribbon.RibbonQuickAccessToolBar ui) => RibbonQuickAccessToolBar.StartChain(ui);

        protected RibbonQuickAccessToolBar() { }
    }

    public static partial class RibbonQuickAccessToolBarExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.CustomizeMenuButton"/></summary>
        public static TView CustomizeMenuButton<TView>(this TView view, Windows.Controls.Ribbon.RibbonMenuButton value) where TView : RibbonQuickAccessToolBar { view.UI.CustomizeMenuButton = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.IsOverflowOpen"/></summary>
        public static TView IsOverflowOpen<TView>(this TView view, bool value) where TView : RibbonQuickAccessToolBar { view.UI.IsOverflowOpen = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.CustomizeMenuButton"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonMenuButton> CustomizeMenuButton<TTarget>(this TTarget target) where TTarget : RibbonQuickAccessToolBar
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonMenuButton>.Get(target, Windows.Controls.Ribbon.RibbonQuickAccessToolBar.CustomizeMenuButtonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.HasOverflowItems"/></summary>
        public static DependencyProperty<TTarget, bool> HasOverflowItems<TTarget>(this TTarget target) where TTarget : RibbonQuickAccessToolBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonQuickAccessToolBar.HasOverflowItemsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.IsOverflowOpen"/></summary>
        public static DependencyProperty<TTarget, bool> IsOverflowOpen<TTarget>(this TTarget target) where TTarget : RibbonQuickAccessToolBar
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonQuickAccessToolBar.IsOverflowOpenProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonQuickAccessToolBar.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonQuickAccessToolBar
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonQuickAccessToolBar.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonRadioButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonRadioButton"/></summary>
        public static RibbonRadioButton RibbonRadioButton(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonRadioButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonRadioButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonRadioButton"/></summary>
        public static RibbonRadioButton RibbonRadioButton(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<Windows.CornerRadius> CornerRadius = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonRadioButton();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (CornerRadius.HasValue) ui.CornerRadius = CornerRadius.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonRadioButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonRadioButton"/></summary>
        public static RibbonRadioButton RibbonRadioButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonRadioButton();
            return global::CSharpMarkup.Wpf.RibbonRadioButton.StartChain(ui);
        }
    }

    public partial class RibbonRadioButton : RadioButton, IUI<System.Windows.Controls.Ribbon.RibbonRadioButton>
    {
        static RibbonRadioButton instance;

        internal static RibbonRadioButton StartChain(Windows.Controls.Ribbon.RibbonRadioButton ui)
        {
            if (instance == null) instance = new RibbonRadioButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonRadioButton ui;

        public new Windows.Controls.Ribbon.RibbonRadioButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonRadioButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonRadioButton(RibbonRadioButton view) => view?.UI;

        public static implicit operator RibbonRadioButton(Windows.Controls.Ribbon.RibbonRadioButton ui) => RibbonRadioButton.StartChain(ui);

        protected RibbonRadioButton() { }
    }

    public static partial class RibbonRadioButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonRadioButton { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonRadioButton { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CornerRadius"/></summary>
        public static TView CornerRadius<TView>(this TView view, Windows.CornerRadius value) where TView : RibbonRadioButton { view.UI.CornerRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonRadioButton { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonRadioButton { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonRadioButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonRadioButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonRadioButton { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonRadioButton { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonRadioButton { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonRadioButton { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonRadioButton { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonRadioButton { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.CornerRadius"/></summary>
        public static DependencyProperty<TTarget, Windows.CornerRadius> CornerRadius<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.CornerRadius>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.CornerRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonRadioButton.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonRadioButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonRadioButton.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonSeparator
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSeparator"/></summary>
        public static RibbonSeparator RibbonSeparator(O<string> Label = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonSeparator();
            if (Label.HasValue) ui.Label = Label.Value;
            return global::CSharpMarkup.Wpf.RibbonSeparator.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSeparator"/></summary>
        public static RibbonSeparator RibbonSeparator()
        {
            var ui = new Windows.Controls.Ribbon.RibbonSeparator();
            return global::CSharpMarkup.Wpf.RibbonSeparator.StartChain(ui);
        }
    }

    public partial class RibbonSeparator : Separator, IUI<System.Windows.Controls.Ribbon.RibbonSeparator>
    {
        static RibbonSeparator instance;

        internal static RibbonSeparator StartChain(Windows.Controls.Ribbon.RibbonSeparator ui)
        {
            if (instance == null) instance = new RibbonSeparator();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonSeparator ui;

        public new Windows.Controls.Ribbon.RibbonSeparator UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonSeparator view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonSeparator(RibbonSeparator view) => view?.UI;

        public static implicit operator RibbonSeparator(Windows.Controls.Ribbon.RibbonSeparator ui) => RibbonSeparator.StartChain(ui);

        protected RibbonSeparator() { }
    }

    public static partial class RibbonSeparatorExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSeparator.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonSeparator { view.UI.Label = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSeparator.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonSeparator
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSeparator.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSeparator.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonSeparator
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonSeparator.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonSplitButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitButton"/></summary>
        public static RibbonSplitButton RibbonSplitButton(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitButton();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonSplitButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitButton"/></summary>
        public static RibbonSplitButton RibbonSplitButton(O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<string> DropDownToolTipDescription = default, O<string> DropDownToolTipFooterDescription = default, O<Windows.Media.ImageSource> DropDownToolTipFooterImageSource = default, O<string> DropDownToolTipFooterTitle = default, O<Windows.Media.ImageSource> DropDownToolTipImageSource = default, O<string> DropDownToolTipTitle = default, O<string> HeaderKeyTip = default, O<object> HeaderQuickAccessToolBarId = default, O<bool> IsCheckable = default, O<bool> IsChecked = default, O<Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition> LabelPosition = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitButton();
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (DropDownToolTipDescription.HasValue) ui.DropDownToolTipDescription = DropDownToolTipDescription.Value;
            if (DropDownToolTipFooterDescription.HasValue) ui.DropDownToolTipFooterDescription = DropDownToolTipFooterDescription.Value;
            if (DropDownToolTipFooterImageSource.HasValue) ui.DropDownToolTipFooterImageSource = DropDownToolTipFooterImageSource.Value;
            if (DropDownToolTipFooterTitle.HasValue) ui.DropDownToolTipFooterTitle = DropDownToolTipFooterTitle.Value;
            if (DropDownToolTipImageSource.HasValue) ui.DropDownToolTipImageSource = DropDownToolTipImageSource.Value;
            if (DropDownToolTipTitle.HasValue) ui.DropDownToolTipTitle = DropDownToolTipTitle.Value;
            if (HeaderKeyTip.HasValue) ui.HeaderKeyTip = HeaderKeyTip.Value;
            if (HeaderQuickAccessToolBarId.HasValue) ui.HeaderQuickAccessToolBarId = HeaderQuickAccessToolBarId.Value;
            if (IsCheckable.HasValue) ui.IsCheckable = IsCheckable.Value;
            if (IsChecked.HasValue) ui.IsChecked = IsChecked.Value;
            if (LabelPosition.HasValue) ui.LabelPosition = LabelPosition.Value;
            return global::CSharpMarkup.Wpf.RibbonSplitButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitButton"/></summary>
        public static RibbonSplitButton RibbonSplitButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitButton();
            return global::CSharpMarkup.Wpf.RibbonSplitButton.StartChain(ui);
        }
    }

    public partial class RibbonSplitButton : RibbonMenuButton, IUI<System.Windows.Controls.Ribbon.RibbonSplitButton>
    {
        static RibbonSplitButton instance;

        internal static RibbonSplitButton StartChain(Windows.Controls.Ribbon.RibbonSplitButton ui)
        {
            if (instance == null) instance = new RibbonSplitButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonSplitButton ui;

        public new Windows.Controls.Ribbon.RibbonSplitButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonSplitButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonSplitButton(RibbonSplitButton view) => view?.UI;

        public static implicit operator RibbonSplitButton(Windows.Controls.Ribbon.RibbonSplitButton ui) => RibbonSplitButton.StartChain(ui);

        protected RibbonSplitButton() { }
    }

    public static partial class RibbonSplitButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonSplitButton { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonSplitButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonSplitButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonSplitButton { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonSplitButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonSplitButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : RibbonSplitButton { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : RibbonSplitButton { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : RibbonSplitButton { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipDescription"/></summary>
        public static TView DropDownToolTipDescription<TView>(this TView view, string value) where TView : RibbonSplitButton { view.UI.DropDownToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterDescription"/></summary>
        public static TView DropDownToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonSplitButton { view.UI.DropDownToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterImageSource"/></summary>
        public static TView DropDownToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonSplitButton { view.UI.DropDownToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterTitle"/></summary>
        public static TView DropDownToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonSplitButton { view.UI.DropDownToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipImageSource"/></summary>
        public static TView DropDownToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonSplitButton { view.UI.DropDownToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipTitle"/></summary>
        public static TView DropDownToolTipTitle<TView>(this TView view, string value) where TView : RibbonSplitButton { view.UI.DropDownToolTipTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.HeaderKeyTip"/></summary>
        public static TView HeaderKeyTip<TView>(this TView view, string value) where TView : RibbonSplitButton { view.UI.HeaderKeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.HeaderQuickAccessToolBarId"/></summary>
        public static TView HeaderQuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonSplitButton { view.UI.HeaderQuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.IsCheckable"/></summary>
        public static TView IsCheckable<TView>(this TView view, bool value) where TView : RibbonSplitButton { view.UI.IsCheckable = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.IsChecked"/></summary>
        public static TView IsChecked<TView>(this TView view, bool value) where TView : RibbonSplitButton { view.UI.IsChecked = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitButton.LabelPosition"/></summary>
        public static TView LabelPosition<TView>(this TView view, Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition value) where TView : RibbonSplitButton { view.UI.LabelPosition = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> DropDownToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> DropDownToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.DropDownToolTipTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.HeaderKeyTip"/></summary>
        public static DependencyProperty<TTarget, string> HeaderKeyTip<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.HeaderKeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.HeaderQuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> HeaderQuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.HeaderQuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.IsCheckable"/></summary>
        public static DependencyProperty<TTarget, bool> IsCheckable<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.IsCheckableProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.IsChecked"/></summary>
        public static DependencyProperty<TTarget, bool> IsChecked<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.IsCheckedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitButton.LabelPosition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition> LabelPosition<TTarget>(this TTarget target) where TTarget : RibbonSplitButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition>.Get(target, Windows.Controls.Ribbon.RibbonSplitButton.LabelPositionProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonSplitMenuItem
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem"/></summary>
        public static RibbonSplitMenuItem RibbonSplitMenuItem(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitMenuItem();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonSplitMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem"/></summary>
        public static RibbonSplitMenuItem RibbonSplitMenuItem(O<string> DropDownToolTipDescription = default, O<string> DropDownToolTipFooterDescription = default, O<Windows.Media.ImageSource> DropDownToolTipFooterImageSource = default, O<string> DropDownToolTipFooterTitle = default, O<Windows.Media.ImageSource> DropDownToolTipImageSource = default, O<string> DropDownToolTipTitle = default, O<string> HeaderKeyTip = default, O<object> HeaderQuickAccessToolBarId = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitMenuItem();
            if (DropDownToolTipDescription.HasValue) ui.DropDownToolTipDescription = DropDownToolTipDescription.Value;
            if (DropDownToolTipFooterDescription.HasValue) ui.DropDownToolTipFooterDescription = DropDownToolTipFooterDescription.Value;
            if (DropDownToolTipFooterImageSource.HasValue) ui.DropDownToolTipFooterImageSource = DropDownToolTipFooterImageSource.Value;
            if (DropDownToolTipFooterTitle.HasValue) ui.DropDownToolTipFooterTitle = DropDownToolTipFooterTitle.Value;
            if (DropDownToolTipImageSource.HasValue) ui.DropDownToolTipImageSource = DropDownToolTipImageSource.Value;
            if (DropDownToolTipTitle.HasValue) ui.DropDownToolTipTitle = DropDownToolTipTitle.Value;
            if (HeaderKeyTip.HasValue) ui.HeaderKeyTip = HeaderKeyTip.Value;
            if (HeaderQuickAccessToolBarId.HasValue) ui.HeaderQuickAccessToolBarId = HeaderQuickAccessToolBarId.Value;
            return global::CSharpMarkup.Wpf.RibbonSplitMenuItem.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem"/></summary>
        public static RibbonSplitMenuItem RibbonSplitMenuItem()
        {
            var ui = new Windows.Controls.Ribbon.RibbonSplitMenuItem();
            return global::CSharpMarkup.Wpf.RibbonSplitMenuItem.StartChain(ui);
        }
    }

    public partial class RibbonSplitMenuItem : RibbonMenuItem, IUI<System.Windows.Controls.Ribbon.RibbonSplitMenuItem>
    {
        static RibbonSplitMenuItem instance;

        internal static RibbonSplitMenuItem StartChain(Windows.Controls.Ribbon.RibbonSplitMenuItem ui)
        {
            if (instance == null) instance = new RibbonSplitMenuItem();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonSplitMenuItem ui;

        public new Windows.Controls.Ribbon.RibbonSplitMenuItem UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonSplitMenuItem view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonSplitMenuItem(RibbonSplitMenuItem view) => view?.UI;

        public static implicit operator RibbonSplitMenuItem(Windows.Controls.Ribbon.RibbonSplitMenuItem ui) => RibbonSplitMenuItem.StartChain(ui);

        protected RibbonSplitMenuItem() { }
    }

    public static partial class RibbonSplitMenuItemExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipDescription"/></summary>
        public static TView DropDownToolTipDescription<TView>(this TView view, string value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterDescription"/></summary>
        public static TView DropDownToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterImageSource"/></summary>
        public static TView DropDownToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterTitle"/></summary>
        public static TView DropDownToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipImageSource"/></summary>
        public static TView DropDownToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipTitle"/></summary>
        public static TView DropDownToolTipTitle<TView>(this TView view, string value) where TView : RibbonSplitMenuItem { view.UI.DropDownToolTipTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderKeyTip"/></summary>
        public static TView HeaderKeyTip<TView>(this TView view, string value) where TView : RibbonSplitMenuItem { view.UI.HeaderKeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderQuickAccessToolBarId"/></summary>
        public static TView HeaderQuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonSplitMenuItem { view.UI.HeaderQuickAccessToolBarId = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> DropDownToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> DropDownToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> DropDownToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.DropDownToolTipTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderKeyTip"/></summary>
        public static DependencyProperty<TTarget, string> HeaderKeyTip<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderKeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderQuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> HeaderQuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonSplitMenuItem
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonSplitMenuItem.HeaderQuickAccessToolBarIdProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonTab
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTab"/></summary>
        public static RibbonTab RibbonTab(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTab();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonTab.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTab"/></summary>
        public static RibbonTab RibbonTab(O<object> ContextualTabGroupHeader = default, O<StringCollection> GroupSizeReductionOrder = default, O<Windows.Style> HeaderStyle = default, O<bool> IsSelected = default, O<string> KeyTip = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTab();
            if (ContextualTabGroupHeader.HasValue) ui.ContextualTabGroupHeader = ContextualTabGroupHeader.Value;
            if (GroupSizeReductionOrder.HasValue) ui.GroupSizeReductionOrder = GroupSizeReductionOrder.Value;
            if (HeaderStyle.HasValue) ui.HeaderStyle = HeaderStyle.Value;
            if (IsSelected.HasValue) ui.IsSelected = IsSelected.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            return global::CSharpMarkup.Wpf.RibbonTab.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTab"/></summary>
        public static RibbonTab RibbonTab()
        {
            var ui = new Windows.Controls.Ribbon.RibbonTab();
            return global::CSharpMarkup.Wpf.RibbonTab.StartChain(ui);
        }
    }

    public partial class RibbonTab : HeaderedItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonTab>
    {
        static RibbonTab instance;

        internal static RibbonTab StartChain(Windows.Controls.Ribbon.RibbonTab ui)
        {
            if (instance == null) instance = new RibbonTab();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonTab ui;

        public new Windows.Controls.Ribbon.RibbonTab UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTab view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonTab(RibbonTab view) => view?.UI;

        public static implicit operator RibbonTab(Windows.Controls.Ribbon.RibbonTab ui) => RibbonTab.StartChain(ui);

        protected RibbonTab() { }
    }

    public static partial class RibbonTabExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTab.ContextualTabGroupHeader"/></summary>
        public static TView ContextualTabGroupHeader<TView>(this TView view, object value) where TView : RibbonTab { view.UI.ContextualTabGroupHeader = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTab.GroupSizeReductionOrder"/></summary>
        public static TView GroupSizeReductionOrder<TView>(this TView view, StringCollection value) where TView : RibbonTab { view.UI.GroupSizeReductionOrder = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTab.HeaderStyle"/></summary>
        public static TView HeaderStyle<TView>(this TView view, Windows.Style value) where TView : RibbonTab { view.UI.HeaderStyle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTab.IsSelected"/></summary>
        public static TView IsSelected<TView>(this TView view, bool value) where TView : RibbonTab { view.UI.IsSelected = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTab.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonTab { view.UI.KeyTip = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.ContextualTabGroupHeader"/></summary>
        public static DependencyProperty<TTarget, object> ContextualTabGroupHeader<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonTab.ContextualTabGroupHeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.ContextualTabGroup"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonContextualTabGroup> ContextualTabGroup<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonContextualTabGroup>.Get(target, Windows.Controls.Ribbon.RibbonTab.ContextualTabGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.GroupSizeReductionOrder"/></summary>
        public static DependencyProperty<TTarget, StringCollection> GroupSizeReductionOrder<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, StringCollection>.Get(target, Windows.Controls.Ribbon.RibbonTab.GroupSizeReductionOrderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.HeaderStyle"/></summary>
        public static DependencyProperty<TTarget, Windows.Style> HeaderStyle<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, Windows.Style>.Get(target, Windows.Controls.Ribbon.RibbonTab.HeaderStyleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.IsSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsSelected<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTab.IsSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTab.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonTab.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.TabHeaderLeft"/></summary>
        public static DependencyProperty<TTarget, double> TabHeaderLeft<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonTab.TabHeaderLeftProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTab.TabHeaderRight"/></summary>
        public static DependencyProperty<TTarget, double> TabHeaderRight<TTarget>(this TTarget target) where TTarget : RibbonTab
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonTab.TabHeaderRightProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonTabHeader
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTabHeader"/></summary>
        public static RibbonTabHeader RibbonTabHeader(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTabHeader();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonTabHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTabHeader"/></summary>
        public static RibbonTabHeader RibbonTabHeader(O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTabHeader();
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            return global::CSharpMarkup.Wpf.RibbonTabHeader.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTabHeader"/></summary>
        public static RibbonTabHeader RibbonTabHeader()
        {
            var ui = new Windows.Controls.Ribbon.RibbonTabHeader();
            return global::CSharpMarkup.Wpf.RibbonTabHeader.StartChain(ui);
        }
    }

    public partial class RibbonTabHeader : ContentControl, IUI<System.Windows.Controls.Ribbon.RibbonTabHeader>
    {
        static RibbonTabHeader instance;

        internal static RibbonTabHeader StartChain(Windows.Controls.Ribbon.RibbonTabHeader ui)
        {
            if (instance == null) instance = new RibbonTabHeader();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonTabHeader ui;

        public new Windows.Controls.Ribbon.RibbonTabHeader UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTabHeader view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonTabHeader(RibbonTabHeader view) => view?.UI;

        public static implicit operator RibbonTabHeader(Windows.Controls.Ribbon.RibbonTabHeader ui) => RibbonTabHeader.StartChain(ui);

        protected RibbonTabHeader() { }
    }

    public static partial class RibbonTabHeaderExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTabHeader { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonTabHeader { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonTabHeader { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.ContextualTabGroup"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonContextualTabGroup> ContextualTabGroup<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonContextualTabGroup>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.ContextualTabGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.IsContextualTab"/></summary>
        public static DependencyProperty<TTarget, bool> IsContextualTab<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.IsContextualTabProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.IsRibbonTabSelected"/></summary>
        public static DependencyProperty<TTarget, bool> IsRibbonTabSelected<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.IsRibbonTabSelectedProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTabHeader.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonTabHeader
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonTabHeader.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonTabHeaderItemsControl
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTabHeaderItemsControl"/></summary>
        public static RibbonTabHeaderItemsControl RibbonTabHeaderItemsControl(
            params object[] Items
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTabHeaderItemsControl();
            foreach (var child in Items) if (child is not null) ui.Items.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Items);
            return global::CSharpMarkup.Wpf.RibbonTabHeaderItemsControl.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTabHeaderItemsControl"/></summary>
        public static RibbonTabHeaderItemsControl RibbonTabHeaderItemsControl()
        {
            var ui = new Windows.Controls.Ribbon.RibbonTabHeaderItemsControl();
            return global::CSharpMarkup.Wpf.RibbonTabHeaderItemsControl.StartChain(ui);
        }
    }

    public partial class RibbonTabHeaderItemsControl : ItemsControl, IUI<System.Windows.Controls.Ribbon.RibbonTabHeaderItemsControl>
    {
        static RibbonTabHeaderItemsControl instance;

        internal static RibbonTabHeaderItemsControl StartChain(Windows.Controls.Ribbon.RibbonTabHeaderItemsControl ui)
        {
            if (instance == null) instance = new RibbonTabHeaderItemsControl();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonTabHeaderItemsControl ui;

        public new Windows.Controls.Ribbon.RibbonTabHeaderItemsControl UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTabHeaderItemsControl view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonTabHeaderItemsControl(RibbonTabHeaderItemsControl view) => view?.UI;

        public static implicit operator RibbonTabHeaderItemsControl(Windows.Controls.Ribbon.RibbonTabHeaderItemsControl ui) => RibbonTabHeaderItemsControl.StartChain(ui);

        protected RibbonTabHeaderItemsControl() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonTextBox
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTextBox"/></summary>
        public static RibbonTextBox RibbonTextBox(
            string Text
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTextBox();
            if (Text is not null) ui.Text = Text;
            return global::CSharpMarkup.Wpf.RibbonTextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTextBox"/></summary>
        public static RibbonTextBox RibbonTextBox(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Input.ICommand> Command = default, O<object> CommandParameter = default, O<Windows.IInputElement> CommandTarget = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<double> TextBoxWidth = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTextBox();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (Command.HasValue) ui.Command = Command.Value;
            if (CommandParameter.HasValue) ui.CommandParameter = CommandParameter.Value;
            if (CommandTarget.HasValue) ui.CommandTarget = CommandTarget.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (TextBoxWidth.HasValue) ui.TextBoxWidth = TextBoxWidth.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonTextBox.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTextBox"/></summary>
        public static RibbonTextBox RibbonTextBox()
        {
            var ui = new Windows.Controls.Ribbon.RibbonTextBox();
            return global::CSharpMarkup.Wpf.RibbonTextBox.StartChain(ui);
        }
    }

    public partial class RibbonTextBox : TextBox, IUI<System.Windows.Controls.Ribbon.RibbonTextBox>
    {
        static RibbonTextBox instance;

        internal static RibbonTextBox StartChain(Windows.Controls.Ribbon.RibbonTextBox ui)
        {
            if (instance == null) instance = new RibbonTextBox();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonTextBox ui;

        public new Windows.Controls.Ribbon.RibbonTextBox UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTextBox view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonTextBox(RibbonTextBox view) => view?.UI;

        public static implicit operator RibbonTextBox(Windows.Controls.Ribbon.RibbonTextBox ui) => RibbonTextBox.StartChain(ui);

        protected RibbonTextBox() { }
    }

    public static partial class RibbonTextBoxExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonTextBox { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.Command"/></summary>
        public static TView Command<TView>(this TView view, Windows.Input.ICommand value) where TView : RibbonTextBox { view.UI.Command = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.CommandParameter"/></summary>
        public static TView CommandParameter<TView>(this TView view, object value) where TView : RibbonTextBox { view.UI.CommandParameter = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.CommandTarget"/></summary>
        public static TView CommandTarget<TView>(this TView view, Windows.IInputElement value) where TView : RibbonTextBox { view.UI.CommandTarget = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonTextBox { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTextBox { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonTextBox { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonTextBox { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTextBox { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonTextBox { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonTextBox { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonTextBox { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTextBox { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonTextBox { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonTextBox { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTextBox { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonTextBox { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonTextBox { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonTextBox { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonTextBox { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonTextBox { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.TextBoxWidth"/></summary>
        public static TView TextBoxWidth<TView>(this TView view, double value) where TView : RibbonTextBox { view.UI.TextBoxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonTextBox { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonTextBox { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonTextBox { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.CommandParameter"/></summary>
        public static DependencyProperty<TTarget, object> CommandParameter<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.CommandParameterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.Command"/></summary>
        public static DependencyProperty<TTarget, Windows.Input.ICommand> Command<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Input.ICommand>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.CommandProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.CommandTarget"/></summary>
        public static DependencyProperty<TTarget, Windows.IInputElement> CommandTarget<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.IInputElement>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.CommandTargetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.TextBoxWidth"/></summary>
        public static DependencyProperty<TTarget, double> TextBoxWidth<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.TextBoxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTextBox.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonTextBox
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTextBox.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonToggleButton
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToggleButton"/></summary>
        public static RibbonToggleButton RibbonToggleButton(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonToggleButton();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonToggleButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToggleButton"/></summary>
        public static RibbonToggleButton RibbonToggleButton(O<bool> CanAddToQuickAccessToolBarDirectly = default, O<Windows.Media.Brush> CheckedBackground = default, O<Windows.Media.Brush> CheckedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition = default, O<Windows.CornerRadius> CornerRadius = default, O<Windows.Media.Brush> FocusedBackground = default, O<Windows.Media.Brush> FocusedBorderBrush = default, O<string> KeyTip = default, O<string> Label = default, O<Windows.Media.ImageSource> LargeImageSource = default, O<Windows.Media.Brush> MouseOverBackground = default, O<Windows.Media.Brush> MouseOverBorderBrush = default, O<Windows.Media.Brush> PressedBackground = default, O<Windows.Media.Brush> PressedBorderBrush = default, O<Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition = default, O<object> QuickAccessToolBarId = default, O<Windows.Media.ImageSource> SmallImageSource = default, O<string> ToolTipDescription = default, O<string> ToolTipFooterDescription = default, O<Windows.Media.ImageSource> ToolTipFooterImageSource = default, O<string> ToolTipFooterTitle = default, O<Windows.Media.ImageSource> ToolTipImageSource = default, O<string> ToolTipTitle = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonToggleButton();
            if (CanAddToQuickAccessToolBarDirectly.HasValue) ui.CanAddToQuickAccessToolBarDirectly = CanAddToQuickAccessToolBarDirectly.Value;
            if (CheckedBackground.HasValue) ui.CheckedBackground = CheckedBackground.Value;
            if (CheckedBorderBrush.HasValue) ui.CheckedBorderBrush = CheckedBorderBrush.Value;
            if (ControlSizeDefinition.HasValue) ui.ControlSizeDefinition = ControlSizeDefinition.Value;
            if (CornerRadius.HasValue) ui.CornerRadius = CornerRadius.Value;
            if (FocusedBackground.HasValue) ui.FocusedBackground = FocusedBackground.Value;
            if (FocusedBorderBrush.HasValue) ui.FocusedBorderBrush = FocusedBorderBrush.Value;
            if (KeyTip.HasValue) ui.KeyTip = KeyTip.Value;
            if (Label.HasValue) ui.Label = Label.Value;
            if (LargeImageSource.HasValue) ui.LargeImageSource = LargeImageSource.Value;
            if (MouseOverBackground.HasValue) ui.MouseOverBackground = MouseOverBackground.Value;
            if (MouseOverBorderBrush.HasValue) ui.MouseOverBorderBrush = MouseOverBorderBrush.Value;
            if (PressedBackground.HasValue) ui.PressedBackground = PressedBackground.Value;
            if (PressedBorderBrush.HasValue) ui.PressedBorderBrush = PressedBorderBrush.Value;
            if (QuickAccessToolBarControlSizeDefinition.HasValue) ui.QuickAccessToolBarControlSizeDefinition = QuickAccessToolBarControlSizeDefinition.Value;
            if (QuickAccessToolBarId.HasValue) ui.QuickAccessToolBarId = QuickAccessToolBarId.Value;
            if (SmallImageSource.HasValue) ui.SmallImageSource = SmallImageSource.Value;
            if (ToolTipDescription.HasValue) ui.ToolTipDescription = ToolTipDescription.Value;
            if (ToolTipFooterDescription.HasValue) ui.ToolTipFooterDescription = ToolTipFooterDescription.Value;
            if (ToolTipFooterImageSource.HasValue) ui.ToolTipFooterImageSource = ToolTipFooterImageSource.Value;
            if (ToolTipFooterTitle.HasValue) ui.ToolTipFooterTitle = ToolTipFooterTitle.Value;
            if (ToolTipImageSource.HasValue) ui.ToolTipImageSource = ToolTipImageSource.Value;
            if (ToolTipTitle.HasValue) ui.ToolTipTitle = ToolTipTitle.Value;
            return global::CSharpMarkup.Wpf.RibbonToggleButton.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToggleButton"/></summary>
        public static RibbonToggleButton RibbonToggleButton()
        {
            var ui = new Windows.Controls.Ribbon.RibbonToggleButton();
            return global::CSharpMarkup.Wpf.RibbonToggleButton.StartChain(ui);
        }
    }

    public partial class RibbonToggleButton : ToggleButton, IUI<System.Windows.Controls.Ribbon.RibbonToggleButton>
    {
        static RibbonToggleButton instance;

        internal static RibbonToggleButton StartChain(Windows.Controls.Ribbon.RibbonToggleButton ui)
        {
            if (instance == null) instance = new RibbonToggleButton();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonToggleButton ui;

        public new Windows.Controls.Ribbon.RibbonToggleButton UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonToggleButton view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonToggleButton(RibbonToggleButton view) => view?.UI;

        public static implicit operator RibbonToggleButton(Windows.Controls.Ribbon.RibbonToggleButton ui) => RibbonToggleButton.StartChain(ui);

        protected RibbonToggleButton() { }
    }

    public static partial class RibbonToggleButtonExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static TView CanAddToQuickAccessToolBarDirectly<TView>(this TView view, bool value) where TView : RibbonToggleButton { view.UI.CanAddToQuickAccessToolBarDirectly = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.CheckedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBackground"/></summary>
        public static TView CheckedBackground<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.CheckedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.CheckedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBorderBrush"/></summary>
        public static TView CheckedBorderBrush<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.CheckedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ControlSizeDefinition"/></summary>
        public static TView ControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonToggleButton { view.UI.ControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CornerRadius"/></summary>
        public static TView CornerRadius<TView>(this TView view, Windows.CornerRadius value) where TView : RibbonToggleButton { view.UI.CornerRadius = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.FocusedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBackground"/></summary>
        public static TView FocusedBackground<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.FocusedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.FocusedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBorderBrush"/></summary>
        public static TView FocusedBorderBrush<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.FocusedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.KeyTip"/></summary>
        public static TView KeyTip<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.KeyTip = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.Label"/></summary>
        public static TView Label<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.Label = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.LargeImageSource"/></summary>
        public static TView LargeImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToggleButton { view.UI.LargeImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.MouseOverBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBackground"/></summary>
        public static TView MouseOverBackground<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.MouseOverBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.MouseOverBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBorderBrush"/></summary>
        public static TView MouseOverBorderBrush<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.MouseOverBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.PressedBackground = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBackground"/></summary>
        public static TView PressedBackground<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.PressedBackground = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonToggleButton { view.UI.PressedBorderBrush = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, Color value) where TView : RibbonToggleButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBorderBrush"/></summary>
        public static TView PressedBorderBrush<TView>(this TView view, string color) where TView : RibbonToggleButton { view.UI.PressedBorderBrush = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static TView QuickAccessToolBarControlSizeDefinition<TView>(this TView view, Windows.Controls.Ribbon.RibbonControlSizeDefinition value) where TView : RibbonToggleButton { view.UI.QuickAccessToolBarControlSizeDefinition = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarId"/></summary>
        public static TView QuickAccessToolBarId<TView>(this TView view, object value) where TView : RibbonToggleButton { view.UI.QuickAccessToolBarId = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.SmallImageSource"/></summary>
        public static TView SmallImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToggleButton { view.UI.SmallImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipDescription"/></summary>
        public static TView ToolTipDescription<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.ToolTipDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterDescription"/></summary>
        public static TView ToolTipFooterDescription<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.ToolTipFooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterImageSource"/></summary>
        public static TView ToolTipFooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToggleButton { view.UI.ToolTipFooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterTitle"/></summary>
        public static TView ToolTipFooterTitle<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.ToolTipFooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipImageSource"/></summary>
        public static TView ToolTipImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToggleButton { view.UI.ToolTipImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipTitle"/></summary>
        public static TView ToolTipTitle<TView>(this TView view, string value) where TView : RibbonToggleButton { view.UI.ToolTipTitle = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CanAddToQuickAccessToolBarDirectly"/></summary>
        public static DependencyProperty<TTarget, bool> CanAddToQuickAccessToolBarDirectly<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.CanAddToQuickAccessToolBarDirectlyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBackground<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.CheckedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CheckedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> CheckedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.CheckedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> ControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.CornerRadius"/></summary>
        public static DependencyProperty<TTarget, Windows.CornerRadius> CornerRadius<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.CornerRadius>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.CornerRadiusProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBackground<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.FocusedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.FocusedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> FocusedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.FocusedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.IsInControlGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsInControlGroup<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.IsInControlGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.IsInQuickAccessToolBar"/></summary>
        public static DependencyProperty<TTarget, bool> IsInQuickAccessToolBar<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.IsInQuickAccessToolBarProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.KeyTip"/></summary>
        public static DependencyProperty<TTarget, string> KeyTip<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.KeyTipProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.Label"/></summary>
        public static DependencyProperty<TTarget, string> Label<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.LabelProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.LargeImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> LargeImageSource<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.LargeImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBackground<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> MouseOverBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.MouseOverBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBackground"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBackground<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.PressedBackgroundProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.PressedBorderBrush"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PressedBorderBrush<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.PressedBorderBrushProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarControlSizeDefinition"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition> QuickAccessToolBarControlSizeDefinition<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonControlSizeDefinition>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarControlSizeDefinitionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarId"/></summary>
        public static DependencyProperty<TTarget, object> QuickAccessToolBarId<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, object>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.QuickAccessToolBarIdProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ShowKeyboardCues"/></summary>
        public static DependencyProperty<TTarget, bool> ShowKeyboardCues<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ShowKeyboardCuesProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.SmallImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> SmallImageSource<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.SmallImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipDescription<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterDescription<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipFooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipFooterTitle<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipFooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ToolTipImageSource<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToggleButton.ToolTipTitle"/></summary>
        public static DependencyProperty<TTarget, string> ToolTipTitle<TTarget>(this TTarget target) where TTarget : RibbonToggleButton
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToggleButton.ToolTipTitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonToolTip
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToolTip"/></summary>
        public static RibbonToolTip RibbonToolTip(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonToolTip();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonToolTip.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToolTip"/></summary>
        public static RibbonToolTip RibbonToolTip(O<string> Description = default, O<string> FooterDescription = default, O<Windows.Media.ImageSource> FooterImageSource = default, O<string> FooterTitle = default, O<Windows.Media.ImageSource> ImageSource = default, O<string> Title = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonToolTip();
            if (Description.HasValue) ui.Description = Description.Value;
            if (FooterDescription.HasValue) ui.FooterDescription = FooterDescription.Value;
            if (FooterImageSource.HasValue) ui.FooterImageSource = FooterImageSource.Value;
            if (FooterTitle.HasValue) ui.FooterTitle = FooterTitle.Value;
            if (ImageSource.HasValue) ui.ImageSource = ImageSource.Value;
            if (Title.HasValue) ui.Title = Title.Value;
            return global::CSharpMarkup.Wpf.RibbonToolTip.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonToolTip"/></summary>
        public static RibbonToolTip RibbonToolTip()
        {
            var ui = new Windows.Controls.Ribbon.RibbonToolTip();
            return global::CSharpMarkup.Wpf.RibbonToolTip.StartChain(ui);
        }
    }

    public partial class RibbonToolTip : ToolTip, IUI<System.Windows.Controls.Ribbon.RibbonToolTip>
    {
        static RibbonToolTip instance;

        internal static RibbonToolTip StartChain(Windows.Controls.Ribbon.RibbonToolTip ui)
        {
            if (instance == null) instance = new RibbonToolTip();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonToolTip ui;

        public new Windows.Controls.Ribbon.RibbonToolTip UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonToolTip view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonToolTip(RibbonToolTip view) => view?.UI;

        public static implicit operator RibbonToolTip(Windows.Controls.Ribbon.RibbonToolTip ui) => RibbonToolTip.StartChain(ui);

        protected RibbonToolTip() { }
    }

    public static partial class RibbonToolTipExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.Description"/></summary>
        public static TView Description<TView>(this TView view, string value) where TView : RibbonToolTip { view.UI.Description = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterDescription"/></summary>
        public static TView FooterDescription<TView>(this TView view, string value) where TView : RibbonToolTip { view.UI.FooterDescription = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterImageSource"/></summary>
        public static TView FooterImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToolTip { view.UI.FooterImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterTitle"/></summary>
        public static TView FooterTitle<TView>(this TView view, string value) where TView : RibbonToolTip { view.UI.FooterTitle = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.ImageSource"/></summary>
        public static TView ImageSource<TView>(this TView view, Windows.Media.ImageSource value) where TView : RibbonToolTip { view.UI.ImageSource = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonToolTip.Title"/></summary>
        public static TView Title<TView>(this TView view, string value) where TView : RibbonToolTip { view.UI.Title = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.Description"/></summary>
        public static DependencyProperty<TTarget, string> Description<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.DescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterDescription"/></summary>
        public static DependencyProperty<TTarget, string> FooterDescription<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.FooterDescriptionProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> FooterImageSource<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.FooterImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.FooterTitle"/></summary>
        public static DependencyProperty<TTarget, string> FooterTitle<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.FooterTitleProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.HasFooter"/></summary>
        public static DependencyProperty<TTarget, bool> HasFooter<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.HasFooterProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.HasHeader"/></summary>
        public static DependencyProperty<TTarget, bool> HasHeader<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.HasHeaderProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.ImageSource"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.ImageSource> ImageSource<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, Windows.Media.ImageSource>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.ImageSourceProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.IsPlacementTargetInRibbonGroup"/></summary>
        public static DependencyProperty<TTarget, bool> IsPlacementTargetInRibbonGroup<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.IsPlacementTargetInRibbonGroupProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.RibbonProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonToolTip.Title"/></summary>
        public static DependencyProperty<TTarget, string> Title<TTarget>(this TTarget target) where TTarget : RibbonToolTip
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonToolTip.TitleProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonTwoLineText
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTwoLineText"/></summary>
        public static RibbonTwoLineText RibbonTwoLineText(O<double> BaselineOffset = default, O<double> LineHeight = default, O<Windows.LineStackingStrategy> LineStackingStrategy = default, O<Windows.Thickness> Padding = default, O<Windows.Media.Brush> PathFill = default, O<Windows.Media.Brush> PathStroke = default, O<string> Text = default, O<Windows.TextAlignment> TextAlignment = default, O<Windows.TextDecorationCollection> TextDecorations = default, O<Windows.Media.TextEffectCollection> TextEffects = default, O<Windows.TextTrimming> TextTrimming = default)
        {
            var ui = new Windows.Controls.Ribbon.RibbonTwoLineText();
            if (BaselineOffset.HasValue) ui.BaselineOffset = BaselineOffset.Value;
            if (LineHeight.HasValue) ui.LineHeight = LineHeight.Value;
            if (LineStackingStrategy.HasValue) ui.LineStackingStrategy = LineStackingStrategy.Value;
            if (Padding.HasValue) ui.Padding = Padding.Value;
            if (PathFill.HasValue) ui.PathFill = PathFill.Value;
            if (PathStroke.HasValue) ui.PathStroke = PathStroke.Value;
            if (Text.HasValue) ui.Text = Text.Value;
            if (TextAlignment.HasValue) ui.TextAlignment = TextAlignment.Value;
            if (TextDecorations.HasValue) ui.TextDecorations = TextDecorations.Value;
            if (TextEffects.HasValue) ui.TextEffects = TextEffects.Value;
            if (TextTrimming.HasValue) ui.TextTrimming = TextTrimming.Value;
            return global::CSharpMarkup.Wpf.RibbonTwoLineText.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonTwoLineText"/></summary>
        public static RibbonTwoLineText RibbonTwoLineText()
        {
            var ui = new Windows.Controls.Ribbon.RibbonTwoLineText();
            return global::CSharpMarkup.Wpf.RibbonTwoLineText.StartChain(ui);
        }
    }

    public partial class RibbonTwoLineText : Control, IUI<System.Windows.Controls.Ribbon.RibbonTwoLineText>
    {
        static RibbonTwoLineText instance;

        internal static RibbonTwoLineText StartChain(Windows.Controls.Ribbon.RibbonTwoLineText ui)
        {
            if (instance == null) instance = new RibbonTwoLineText();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonTwoLineText ui;

        public new Windows.Controls.Ribbon.RibbonTwoLineText UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTwoLineText view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonTwoLineText(RibbonTwoLineText view) => view?.UI;

        public static implicit operator RibbonTwoLineText(Windows.Controls.Ribbon.RibbonTwoLineText ui) => RibbonTwoLineText.StartChain(ui);

        protected RibbonTwoLineText() { }
    }

    public static partial class RibbonTwoLineTextExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.BaselineOffset"/></summary>
        public static TView BaselineOffset<TView>(this TView view, double value) where TView : RibbonTwoLineText { view.UI.BaselineOffset = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.LineHeight"/></summary>
        public static TView LineHeight<TView>(this TView view, double value) where TView : RibbonTwoLineText { view.UI.LineHeight = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.LineStackingStrategy"/></summary>
        public static TView LineStackingStrategy<TView>(this TView view, Windows.LineStackingStrategy value) where TView : RibbonTwoLineText { view.UI.LineStackingStrategy = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static TView Padding<TView>(this TView view, Windows.Thickness value) where TView : RibbonTwoLineText { view.UI.Padding = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double uniform) where TView : RibbonTwoLineText { view.UI.Padding = Helpers.Thickness(uniform); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double horizontal, double vertical) where TView : RibbonTwoLineText { view.UI.Padding = Helpers.Thickness(horizontal, vertical); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static TView Padding<TView>(this TView view, double left, double top, double right, double bottom) where TView : RibbonTwoLineText { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static TView Paddings<TView>(this TView view, double left = 0, double top = 0, double right = 0, double bottom = 0) where TView : RibbonTwoLineText { view.UI.Padding = Helpers.Thickness(left, top, right, bottom); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathFill"/></summary>
        public static TView PathFill<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTwoLineText { view.UI.PathFill = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathFill"/></summary>
        public static TView PathFill<TView>(this TView view, Color value) where TView : RibbonTwoLineText { view.UI.PathFill = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathFill"/></summary>
        public static TView PathFill<TView>(this TView view, string color) where TView : RibbonTwoLineText { view.UI.PathFill = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathStroke"/></summary>
        public static TView PathStroke<TView>(this TView view, Windows.Media.Brush value) where TView : RibbonTwoLineText { view.UI.PathStroke = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathStroke"/></summary>
        public static TView PathStroke<TView>(this TView view, Color value) where TView : RibbonTwoLineText { view.UI.PathStroke = new Windows.Media.SolidColorBrush(value); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathStroke"/></summary>
        public static TView PathStroke<TView>(this TView view, string color) where TView : RibbonTwoLineText { view.UI.PathStroke = new Windows.Media.SolidColorBrush(color.ToColor()); return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Text"/></summary>
        public static TView Text<TView>(this TView view, string value) where TView : RibbonTwoLineText { view.UI.Text = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextAlignment"/></summary>
        public static TView TextAlignment<TView>(this TView view, Windows.TextAlignment value) where TView : RibbonTwoLineText { view.UI.TextAlignment = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextDecorations"/></summary>
        public static TView TextDecorations<TView>(this TView view, Windows.TextDecorationCollection value) where TView : RibbonTwoLineText { view.UI.TextDecorations = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextEffects"/></summary>
        public static TView TextEffects<TView>(this TView view, Windows.Media.TextEffectCollection value) where TView : RibbonTwoLineText { view.UI.TextEffects = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextTrimming"/></summary>
        public static TView TextTrimming<TView>(this TView view, Windows.TextTrimming value) where TView : RibbonTwoLineText { view.UI.TextTrimming = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.BaselineOffset"/></summary>
        public static DependencyProperty<TTarget, double> BaselineOffset<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.BaselineOffsetProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.LineHeight"/></summary>
        public static DependencyProperty<TTarget, double> LineHeight<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.LineHeightProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.LineStackingStrategy"/></summary>
        public static DependencyProperty<TTarget, Windows.LineStackingStrategy> LineStackingStrategy<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.LineStackingStrategy>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.LineStackingStrategyProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Padding"/></summary>
        public static DependencyProperty<TTarget, Windows.Thickness> Padding<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.Thickness>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.PaddingProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathFill"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PathFill<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.PathFillProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathStroke"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Brush> PathStroke<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.Media.Brush>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.PathStrokeProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextAlignment"/></summary>
        public static DependencyProperty<TTarget, Windows.TextAlignment> TextAlignment<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.TextAlignment>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.TextAlignmentProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextDecorations"/></summary>
        public static DependencyProperty<TTarget, Windows.TextDecorationCollection> TextDecorations<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.TextDecorationCollection>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.TextDecorationsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextEffects"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.TextEffectCollection> TextEffects<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.Media.TextEffectCollection>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.TextEffectsProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.Text"/></summary>
        public static DependencyProperty<TTarget, string> Text<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, string>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.TextProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.TextTrimming"/></summary>
        public static DependencyProperty<TTarget, Windows.TextTrimming> TextTrimming<TTarget>(this TTarget target) where TTarget : RibbonTwoLineText
        => DependencyProperty<TTarget, Windows.TextTrimming>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.TextTrimmingProperty);

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.HasTwoLines"/></summary>
        public static TTarget RibbonTwoLineText_HasTwoLines<TTarget>(this TTarget target, bool value) where TTarget : DependencyObject
        { Windows.Controls.Ribbon.RibbonTwoLineText.SetHasTwoLines(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.HasTwoLines"/></summary>
        public static DependencyProperty<TTarget, bool> RibbonTwoLineText_HasTwoLines<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.HasTwoLinesProperty);

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathData"/></summary>
        public static TTarget RibbonTwoLineText_PathData<TTarget>(this TTarget target, Windows.Media.Geometry value) where TTarget : DependencyObject
        { Windows.Controls.Ribbon.RibbonTwoLineText.SetPathData(target.UI, value); return target; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.RibbonTwoLineText.PathData"/></summary>
        public static DependencyProperty<TTarget, Windows.Media.Geometry> RibbonTwoLineText_PathData<TTarget>(this TTarget target) where TTarget : DependencyObject
        => DependencyProperty<TTarget, Windows.Media.Geometry>.Get(target, Windows.Controls.Ribbon.RibbonTwoLineText.PathDataProperty);

        /// <summary>Set <see cref="Windows.Controls.Ribbon.RibbonTwoLineText"/> attached properties</summary>
        public static TTarget RibbonTwoLineText<TTarget>(this TTarget target

            , O<bool> HasTwoLines = default

            , O<Windows.Media.Geometry> PathData = default

        ) where TTarget : DependencyObject
        {
            if (HasTwoLines.HasValue) Windows.Controls.Ribbon.RibbonTwoLineText.SetHasTwoLines(target.UI, HasTwoLines.Value);

            if (PathData.HasValue) Windows.Controls.Ribbon.RibbonTwoLineText.SetPathData(target.UI, PathData.Value);

            return target;
        }
    }
}

namespace CSharpMarkup.Wpf // RibbonWindow
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonWindow"/></summary>
        public static RibbonWindow RibbonWindow(
            object Content
)
        {
            var ui = new Windows.Controls.Ribbon.RibbonWindow();
            if (Content is not null) ui.Content = Content;
            return global::CSharpMarkup.Wpf.RibbonWindow.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.RibbonWindow"/></summary>
        public static RibbonWindow RibbonWindow()
        {
            var ui = new Windows.Controls.Ribbon.RibbonWindow();
            return global::CSharpMarkup.Wpf.RibbonWindow.StartChain(ui);
        }
    }

    public partial class RibbonWindow : Window, IUI<System.Windows.Controls.Ribbon.RibbonWindow>
    {
        static RibbonWindow instance;

        internal static RibbonWindow StartChain(Windows.Controls.Ribbon.RibbonWindow ui)
        {
            if (instance == null) instance = new RibbonWindow();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.RibbonWindow ui;

        public new Windows.Controls.Ribbon.RibbonWindow UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonWindow view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.RibbonWindow(RibbonWindow view) => view?.UI;

        public static implicit operator RibbonWindow(Windows.Controls.Ribbon.RibbonWindow ui) => RibbonWindow.StartChain(ui);

        protected RibbonWindow() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonContextualTabGroupsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel"/></summary>
        public static RibbonContextualTabGroupsPanel RibbonContextualTabGroupsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonContextualTabGroupsPanel.StartChain(ui);
        }
    }

    public partial class RibbonContextualTabGroupsPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel>
    {
        static RibbonContextualTabGroupsPanel instance;

        internal static RibbonContextualTabGroupsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel ui)
        {
            if (instance == null) instance = new RibbonContextualTabGroupsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonContextualTabGroupsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel(RibbonContextualTabGroupsPanel view) => view?.UI;

        public static implicit operator RibbonContextualTabGroupsPanel(Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel ui) => RibbonContextualTabGroupsPanel.StartChain(ui);

        protected RibbonContextualTabGroupsPanel() { }
    }

    public static partial class RibbonContextualTabGroupsPanelExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonContextualTabGroupsPanel
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.Primitives.RibbonContextualTabGroupsPanel.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonGalleryCategoriesPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel"/></summary>
        public static RibbonGalleryCategoriesPanel RibbonGalleryCategoriesPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonGalleryCategoriesPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel"/></summary>
        public static RibbonGalleryCategoriesPanel RibbonGalleryCategoriesPanel(O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel();
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.RibbonGalleryCategoriesPanel.StartChain(ui);
        }
    }

    public partial class RibbonGalleryCategoriesPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel>
    {
        static RibbonGalleryCategoriesPanel instance;

        internal static RibbonGalleryCategoriesPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel ui)
        {
            if (instance == null) instance = new RibbonGalleryCategoriesPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGalleryCategoriesPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel(RibbonGalleryCategoriesPanel view) => view?.UI;

        public static implicit operator RibbonGalleryCategoriesPanel(Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel ui) => RibbonGalleryCategoriesPanel.StartChain(ui);

        protected RibbonGalleryCategoriesPanel() { }
    }

    public static partial class RibbonGalleryCategoriesPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : RibbonGalleryCategoriesPanel { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : RibbonGalleryCategoriesPanel { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryCategoriesPanel.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : RibbonGalleryCategoriesPanel { view.UI.ScrollOwner = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // RibbonGalleryItemsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel"/></summary>
        public static RibbonGalleryItemsPanel RibbonGalleryItemsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonGalleryItemsPanel.StartChain(ui);
        }
    }

    public partial class RibbonGalleryItemsPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel>
    {
        static RibbonGalleryItemsPanel instance;

        internal static RibbonGalleryItemsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel ui)
        {
            if (instance == null) instance = new RibbonGalleryItemsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGalleryItemsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel(RibbonGalleryItemsPanel view) => view?.UI;

        public static implicit operator RibbonGalleryItemsPanel(Windows.Controls.Ribbon.Primitives.RibbonGalleryItemsPanel ui) => RibbonGalleryItemsPanel.StartChain(ui);

        protected RibbonGalleryItemsPanel() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonGroupItemsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel"/></summary>
        public static RibbonGroupItemsPanel RibbonGroupItemsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonGroupItemsPanel.StartChain(ui);
        }
    }

    public partial class RibbonGroupItemsPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel>
    {
        static RibbonGroupItemsPanel instance;

        internal static RibbonGroupItemsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel ui)
        {
            if (instance == null) instance = new RibbonGroupItemsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGroupItemsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel(RibbonGroupItemsPanel view) => view?.UI;

        public static implicit operator RibbonGroupItemsPanel(Windows.Controls.Ribbon.Primitives.RibbonGroupItemsPanel ui) => RibbonGroupItemsPanel.StartChain(ui);

        protected RibbonGroupItemsPanel() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonGroupsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel"/></summary>
        public static RibbonGroupsPanel RibbonGroupsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonGroupsPanel.StartChain(ui);
        }
    }

    public partial class RibbonGroupsPanel : StackPanel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel>
    {
        static RibbonGroupsPanel instance;

        internal static RibbonGroupsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel ui)
        {
            if (instance == null) instance = new RibbonGroupsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonGroupsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel(RibbonGroupsPanel view) => view?.UI;

        public static implicit operator RibbonGroupsPanel(Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel ui) => RibbonGroupsPanel.StartChain(ui);

        protected RibbonGroupsPanel() { }
    }

    public static partial class RibbonGroupsPanelExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel.IsStarLayoutPass"/></summary>
        public static DependencyProperty<TTarget, bool> IsStarLayoutPass<TTarget>(this TTarget target) where TTarget : RibbonGroupsPanel
        => DependencyProperty<TTarget, bool>.Get(target, Windows.Controls.Ribbon.Primitives.RibbonGroupsPanel.IsStarLayoutPassProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonMenuItemsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel"/></summary>
        public static RibbonMenuItemsPanel RibbonMenuItemsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonMenuItemsPanel.StartChain(ui);
        }
    }

    public partial class RibbonMenuItemsPanel : VirtualizingStackPanel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel>
    {
        static RibbonMenuItemsPanel instance;

        internal static RibbonMenuItemsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel ui)
        {
            if (instance == null) instance = new RibbonMenuItemsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonMenuItemsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel(RibbonMenuItemsPanel view) => view?.UI;

        public static implicit operator RibbonMenuItemsPanel(Windows.Controls.Ribbon.Primitives.RibbonMenuItemsPanel ui) => RibbonMenuItemsPanel.StartChain(ui);

        protected RibbonMenuItemsPanel() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonQuickAccessToolBarOverflowPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel"/></summary>
        public static RibbonQuickAccessToolBarOverflowPanel RibbonQuickAccessToolBarOverflowPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonQuickAccessToolBarOverflowPanel.StartChain(ui);
        }
    }

    public partial class RibbonQuickAccessToolBarOverflowPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel>
    {
        static RibbonQuickAccessToolBarOverflowPanel instance;

        internal static RibbonQuickAccessToolBarOverflowPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel ui)
        {
            if (instance == null) instance = new RibbonQuickAccessToolBarOverflowPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonQuickAccessToolBarOverflowPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel(RibbonQuickAccessToolBarOverflowPanel view) => view?.UI;

        public static implicit operator RibbonQuickAccessToolBarOverflowPanel(Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarOverflowPanel ui) => RibbonQuickAccessToolBarOverflowPanel.StartChain(ui);

        protected RibbonQuickAccessToolBarOverflowPanel() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonQuickAccessToolBarPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel"/></summary>
        public static RibbonQuickAccessToolBarPanel RibbonQuickAccessToolBarPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonQuickAccessToolBarPanel.StartChain(ui);
        }
    }

    public partial class RibbonQuickAccessToolBarPanel : VirtualizingPanel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel>
    {
        static RibbonQuickAccessToolBarPanel instance;

        internal static RibbonQuickAccessToolBarPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel ui)
        {
            if (instance == null) instance = new RibbonQuickAccessToolBarPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonQuickAccessToolBarPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel(RibbonQuickAccessToolBarPanel view) => view?.UI;

        public static implicit operator RibbonQuickAccessToolBarPanel(Windows.Controls.Ribbon.Primitives.RibbonQuickAccessToolBarPanel ui) => RibbonQuickAccessToolBarPanel.StartChain(ui);

        protected RibbonQuickAccessToolBarPanel() { }
    }
}

namespace CSharpMarkup.Wpf // RibbonTabHeadersPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel"/></summary>
        public static RibbonTabHeadersPanel RibbonTabHeadersPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonTabHeadersPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel"/></summary>
        public static RibbonTabHeadersPanel RibbonTabHeadersPanel(O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel();
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.RibbonTabHeadersPanel.StartChain(ui);
        }
    }

    public partial class RibbonTabHeadersPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel>
    {
        static RibbonTabHeadersPanel instance;

        internal static RibbonTabHeadersPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel ui)
        {
            if (instance == null) instance = new RibbonTabHeadersPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTabHeadersPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel(RibbonTabHeadersPanel view) => view?.UI;

        public static implicit operator RibbonTabHeadersPanel(Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel ui) => RibbonTabHeadersPanel.StartChain(ui);

        protected RibbonTabHeadersPanel() { }
    }

    public static partial class RibbonTabHeadersPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : RibbonTabHeadersPanel { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : RibbonTabHeadersPanel { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : RibbonTabHeadersPanel { view.UI.ScrollOwner = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonTabHeadersPanel
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.Primitives.RibbonTabHeadersPanel.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // RibbonTabsPanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabsPanel"/></summary>
        public static RibbonTabsPanel RibbonTabsPanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonTabsPanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonTabsPanel.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabsPanel"/></summary>
        public static RibbonTabsPanel RibbonTabsPanel(O<bool> CanHorizontallyScroll = default, O<bool> CanVerticallyScroll = default, O<Windows.Controls.ScrollViewer> ScrollOwner = default)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonTabsPanel();
            if (CanHorizontallyScroll.HasValue) ui.CanHorizontallyScroll = CanHorizontallyScroll.Value;
            if (CanVerticallyScroll.HasValue) ui.CanVerticallyScroll = CanVerticallyScroll.Value;
            if (ScrollOwner.HasValue) ui.ScrollOwner = ScrollOwner.Value;
            return global::CSharpMarkup.Wpf.RibbonTabsPanel.StartChain(ui);
        }
    }

    public partial class RibbonTabsPanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonTabsPanel>
    {
        static RibbonTabsPanel instance;

        internal static RibbonTabsPanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonTabsPanel ui)
        {
            if (instance == null) instance = new RibbonTabsPanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonTabsPanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonTabsPanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTabsPanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonTabsPanel(RibbonTabsPanel view) => view?.UI;

        public static implicit operator RibbonTabsPanel(Windows.Controls.Ribbon.Primitives.RibbonTabsPanel ui) => RibbonTabsPanel.StartChain(ui);

        protected RibbonTabsPanel() { }
    }

    public static partial class RibbonTabsPanelExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabsPanel.CanHorizontallyScroll"/></summary>
        public static TView CanHorizontallyScroll<TView>(this TView view, bool value) where TView : RibbonTabsPanel { view.UI.CanHorizontallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabsPanel.CanVerticallyScroll"/></summary>
        public static TView CanVerticallyScroll<TView>(this TView view, bool value) where TView : RibbonTabsPanel { view.UI.CanVerticallyScroll = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.RibbonTabsPanel.ScrollOwner"/></summary>
        public static TView ScrollOwner<TView>(this TView view, Windows.Controls.ScrollViewer value) where TView : RibbonTabsPanel { view.UI.ScrollOwner = value; return view; }
    }
}

namespace CSharpMarkup.Wpf // RibbonTitlePanel
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.RibbonTitlePanel"/></summary>
        public static RibbonTitlePanel RibbonTitlePanel(
            params System.Windows.UIElement[] Children
)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.RibbonTitlePanel();
            foreach (var child in Children) if (child is not null) ui.Children.Add(child);
            // TODO: 2022 CSharpMarkup.Wpf.Helpers.SpreadChildren(ui.Children);
            return global::CSharpMarkup.Wpf.RibbonTitlePanel.StartChain(ui);
        }
    }

    public partial class RibbonTitlePanel : Panel, IUI<System.Windows.Controls.Ribbon.Primitives.RibbonTitlePanel>
    {
        static RibbonTitlePanel instance;

        internal static RibbonTitlePanel StartChain(Windows.Controls.Ribbon.Primitives.RibbonTitlePanel ui)
        {
            if (instance == null) instance = new RibbonTitlePanel();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.RibbonTitlePanel ui;

        public new Windows.Controls.Ribbon.Primitives.RibbonTitlePanel UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.UIElement(RibbonTitlePanel view) => view?.UI;

        public static implicit operator Windows.Controls.Ribbon.Primitives.RibbonTitlePanel(RibbonTitlePanel view) => view?.UI;

        public static implicit operator RibbonTitlePanel(Windows.Controls.Ribbon.Primitives.RibbonTitlePanel ui) => RibbonTitlePanel.StartChain(ui);

        protected RibbonTitlePanel() { }
    }

    public static partial class RibbonTitlePanelExtensions
    {
        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.RibbonTitlePanel.Ribbon"/></summary>
        public static DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon> Ribbon<TTarget>(this TTarget target) where TTarget : RibbonTitlePanel
        => DependencyProperty<TTarget, Windows.Controls.Ribbon.Ribbon>.Get(target, Windows.Controls.Ribbon.Primitives.RibbonTitlePanel.RibbonProperty);
    }
}

namespace CSharpMarkup.Wpf // StarLayoutInfo
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo"/></summary>
        public static StarLayoutInfo StarLayoutInfo(O<double> AllocatedStarWidth = default, O<double> RequestedStarMaxWidth = default, O<double> RequestedStarMinWidth = default, O<double> RequestedStarWeight = default)
        {
            var ui = new Windows.Controls.Ribbon.Primitives.StarLayoutInfo();
            if (AllocatedStarWidth.HasValue) ui.AllocatedStarWidth = AllocatedStarWidth.Value;
            if (RequestedStarMaxWidth.HasValue) ui.RequestedStarMaxWidth = RequestedStarMaxWidth.Value;
            if (RequestedStarMinWidth.HasValue) ui.RequestedStarMinWidth = RequestedStarMinWidth.Value;
            if (RequestedStarWeight.HasValue) ui.RequestedStarWeight = RequestedStarWeight.Value;
            return global::CSharpMarkup.Wpf.StarLayoutInfo.StartChain(ui);
        }

        /// <summary>Create a <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo"/></summary>
        public static StarLayoutInfo StarLayoutInfo()
        {
            var ui = new Windows.Controls.Ribbon.Primitives.StarLayoutInfo();
            return global::CSharpMarkup.Wpf.StarLayoutInfo.StartChain(ui);
        }
    }

    public partial class StarLayoutInfo : DependencyObject, IUI<System.Windows.Controls.Ribbon.Primitives.StarLayoutInfo>
    {
        static StarLayoutInfo instance;

        internal static StarLayoutInfo StartChain(Windows.Controls.Ribbon.Primitives.StarLayoutInfo ui)
        {
            if (instance == null) instance = new StarLayoutInfo();
            instance.UI = ui;
            return instance;
        }

        Windows.Controls.Ribbon.Primitives.StarLayoutInfo ui;

        public new Windows.Controls.Ribbon.Primitives.StarLayoutInfo UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        public static implicit operator Windows.Controls.Ribbon.Primitives.StarLayoutInfo(StarLayoutInfo view) => view?.UI;

        public static implicit operator StarLayoutInfo(Windows.Controls.Ribbon.Primitives.StarLayoutInfo ui) => StarLayoutInfo.StartChain(ui);

        protected StarLayoutInfo() { }
    }

    public static partial class StarLayoutInfoExtensions
    {
        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.AllocatedStarWidth"/></summary>
        public static TView AllocatedStarWidth<TView>(this TView view, double value) where TView : StarLayoutInfo { view.UI.AllocatedStarWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMaxWidth"/></summary>
        public static TView RequestedStarMaxWidth<TView>(this TView view, double value) where TView : StarLayoutInfo { view.UI.RequestedStarMaxWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMinWidth"/></summary>
        public static TView RequestedStarMinWidth<TView>(this TView view, double value) where TView : StarLayoutInfo { view.UI.RequestedStarMinWidth = value; return view; }

        /// <summary>Set <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarWeight"/></summary>
        public static TView RequestedStarWeight<TView>(this TView view, double value) where TView : StarLayoutInfo { view.UI.RequestedStarWeight = value; return view; }

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.AllocatedStarWidth"/></summary>
        public static DependencyProperty<TTarget, double> AllocatedStarWidth<TTarget>(this TTarget target) where TTarget : StarLayoutInfo
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.Primitives.StarLayoutInfo.AllocatedStarWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMaxWidth"/></summary>
        public static DependencyProperty<TTarget, double> RequestedStarMaxWidth<TTarget>(this TTarget target) where TTarget : StarLayoutInfo
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMaxWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMinWidth"/></summary>
        public static DependencyProperty<TTarget, double> RequestedStarMinWidth<TTarget>(this TTarget target) where TTarget : StarLayoutInfo
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarMinWidthProperty);

        /// <summary>Bind (or set enum value of) <see cref="Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarWeight"/></summary>
        public static DependencyProperty<TTarget, double> RequestedStarWeight<TTarget>(this TTarget target) where TTarget : StarLayoutInfo
        => DependencyProperty<TTarget, double>.Get(target, Windows.Controls.Ribbon.Primitives.StarLayoutInfo.RequestedStarWeightProperty);
    }
}

namespace CSharpMarkup.Wpf // DependencyObject
{
    public static partial class Helpers
    {
        /// <summary>Create a <see cref="Windows.DependencyObject"/></summary>
        public static DependencyObject DependencyObject()
        {
            var ui = new Windows.DependencyObject();
            return global::CSharpMarkup.Wpf.DependencyObject.StartChain(ui);
        }
    }

    public partial class DependencyObject: IUI<System.Windows.DependencyObject>
    {
        static DependencyObject instance;

        internal static DependencyObject StartChain(Windows.DependencyObject ui)
        {
            if (instance == null) instance = new DependencyObject();
            instance.UI = ui;
            return instance;
        }

        public Windows.DependencyObject UI { get; protected set; }

        public static implicit operator Windows.DependencyObject(DependencyObject view) => view?.UI;

        public static implicit operator DependencyObject(Windows.DependencyObject ui) => DependencyObject.StartChain(ui);

        protected DependencyObject() { }
    }
}

namespace CSharpMarkup.Wpf // Freezable
{
    public partial class Freezable : DependencyObject, IUI<System.Windows.Freezable>
    {
        Windows.Freezable ui;

        public new Windows.Freezable UI
        {
            get => ui;
            protected set => base.UI = ui = value;
        }

        protected Freezable() { }
    }
}

namespace CSharpMarkup.Wpf // EnumPropertyValues
{
    public static partial class AccessTextExtensions
    {
        /// <summary>Set to <see cref="Windows.TextWrapping.WrapWithOverflow"/></summary>
        public static TTarget WrapWithOverflow<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : AccessText
        => property.Set(Windows.TextWrapping.WrapWithOverflow);

        /// <summary>Set to <see cref="Windows.TextWrapping.NoWrap"/></summary>
        public static TTarget NoWrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : AccessText
        => property.Set(Windows.TextWrapping.NoWrap);

        /// <summary>Set to <see cref="Windows.TextWrapping.Wrap"/></summary>
        public static TTarget Wrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : AccessText
        => property.Set(Windows.TextWrapping.Wrap);

        /// <summary>Set to <see cref="Windows.TextTrimming.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : AccessText
        => property.Set(Windows.TextTrimming.None);

        /// <summary>Set to <see cref="Windows.TextTrimming.CharacterEllipsis"/></summary>
        public static TTarget CharacterEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : AccessText
        => property.Set(Windows.TextTrimming.CharacterEllipsis);

        /// <summary>Set to <see cref="Windows.TextTrimming.WordEllipsis"/></summary>
        public static TTarget WordEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : AccessText
        => property.Set(Windows.TextTrimming.WordEllipsis);
    }

    public static partial class ArcSegmentExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.SweepDirection.Counterclockwise"/></summary>
        public static TTarget Counterclockwise<TTarget>(this DependencyProperty<TTarget, Windows.Media.SweepDirection> property) where TTarget : ArcSegment
        => property.Set(Windows.Media.SweepDirection.Counterclockwise);

        /// <summary>Set to <see cref="Windows.Media.SweepDirection.Clockwise"/></summary>
        public static TTarget Clockwise<TTarget>(this DependencyProperty<TTarget, Windows.Media.SweepDirection> property) where TTarget : ArcSegment
        => property.Set(Windows.Media.SweepDirection.Clockwise);
    }

    public static partial class BevelBitmapEffectExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Effects.EdgeProfile.Linear"/></summary>
        public static TTarget Linear<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile> property) where TTarget : BevelBitmapEffect
        => property.Set(Windows.Media.Effects.EdgeProfile.Linear);

        /// <summary>Set to <see cref="Windows.Media.Effects.EdgeProfile.CurvedIn"/></summary>
        public static TTarget CurvedIn<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile> property) where TTarget : BevelBitmapEffect
        => property.Set(Windows.Media.Effects.EdgeProfile.CurvedIn);

        /// <summary>Set to <see cref="Windows.Media.Effects.EdgeProfile.CurvedOut"/></summary>
        public static TTarget CurvedOut<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile> property) where TTarget : BevelBitmapEffect
        => property.Set(Windows.Media.Effects.EdgeProfile.CurvedOut);

        /// <summary>Set to <see cref="Windows.Media.Effects.EdgeProfile.BulgedUp"/></summary>
        public static TTarget BulgedUp<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.EdgeProfile> property) where TTarget : BevelBitmapEffect
        => property.Set(Windows.Media.Effects.EdgeProfile.BulgedUp);
    }

    public static partial class BitmapEffectInputExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : BitmapEffectInput
        => property.Set(Windows.Media.BrushMappingMode.Absolute);

        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.RelativeToBoundingBox"/></summary>
        public static TTarget RelativeToBoundingBox<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : BitmapEffectInput
        => property.Set(Windows.Media.BrushMappingMode.RelativeToBoundingBox);
    }

    public static partial class BitmapImageExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Imaging.Rotation.Rotate0"/></summary>
        public static TTarget Rotate0<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.Rotation> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.Rotation.Rotate0);

        /// <summary>Set to <see cref="Windows.Media.Imaging.Rotation.Rotate90"/></summary>
        public static TTarget Rotate90<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.Rotation> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.Rotation.Rotate90);

        /// <summary>Set to <see cref="Windows.Media.Imaging.Rotation.Rotate180"/></summary>
        public static TTarget Rotate180<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.Rotation> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.Rotation.Rotate180);

        /// <summary>Set to <see cref="Windows.Media.Imaging.Rotation.Rotate270"/></summary>
        public static TTarget Rotate270<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.Rotation> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.Rotation.Rotate270);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCreateOptions.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCreateOptions.None);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCreateOptions.PreservePixelFormat"/></summary>
        public static TTarget PreservePixelFormat<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCreateOptions.PreservePixelFormat);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCreateOptions.DelayCreation"/></summary>
        public static TTarget DelayCreation<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCreateOptions.DelayCreation);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCreateOptions.IgnoreColorProfile"/></summary>
        public static TTarget IgnoreColorProfile<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCreateOptions.IgnoreColorProfile);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCreateOptions.IgnoreImageCache"/></summary>
        public static TTarget IgnoreImageCache<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCreateOptions> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCreateOptions.IgnoreImageCache);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCacheOption.Default"/></summary>
        public static TTarget Default<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCacheOption.Default);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCacheOption.OnDemand"/></summary>
        public static TTarget OnDemand<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCacheOption.OnDemand);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCacheOption.OnLoad"/></summary>
        public static TTarget OnLoad<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCacheOption.OnLoad);

        /// <summary>Set to <see cref="Windows.Media.Imaging.BitmapCacheOption.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Imaging.BitmapCacheOption> property) where TTarget : BitmapImage
        => property.Set(Windows.Media.Imaging.BitmapCacheOption.None);
    }

    public static partial class BlockExtensions
    {
        /// <summary>Set to <see cref="Windows.WrapDirection.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Block
        => property.Set(Windows.WrapDirection.None);

        /// <summary>Set to <see cref="Windows.WrapDirection.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Block
        => property.Set(Windows.WrapDirection.Left);

        /// <summary>Set to <see cref="Windows.WrapDirection.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Block
        => property.Set(Windows.WrapDirection.Right);

        /// <summary>Set to <see cref="Windows.WrapDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Block
        => property.Set(Windows.WrapDirection.Both);
    }

    public static partial class BlurBitmapEffectExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Effects.KernelType.Gaussian"/></summary>
        public static TTarget Gaussian<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.KernelType> property) where TTarget : BlurBitmapEffect
        => property.Set(Windows.Media.Effects.KernelType.Gaussian);

        /// <summary>Set to <see cref="Windows.Media.Effects.KernelType.Box"/></summary>
        public static TTarget Box<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.KernelType> property) where TTarget : BlurBitmapEffect
        => property.Set(Windows.Media.Effects.KernelType.Box);
    }

    public static partial class BlurEffectExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Effects.KernelType.Gaussian"/></summary>
        public static TTarget Gaussian<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.KernelType> property) where TTarget : BlurEffect
        => property.Set(Windows.Media.Effects.KernelType.Gaussian);

        /// <summary>Set to <see cref="Windows.Media.Effects.KernelType.Box"/></summary>
        public static TTarget Box<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.KernelType> property) where TTarget : BlurEffect
        => property.Set(Windows.Media.Effects.KernelType.Box);

        /// <summary>Set to <see cref="Windows.Media.Effects.RenderingBias.Performance"/></summary>
        public static TTarget Performance<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> property) where TTarget : BlurEffect
        => property.Set(Windows.Media.Effects.RenderingBias.Performance);

        /// <summary>Set to <see cref="Windows.Media.Effects.RenderingBias.Quality"/></summary>
        public static TTarget Quality<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> property) where TTarget : BlurEffect
        => property.Set(Windows.Media.Effects.RenderingBias.Quality);
    }

    public static partial class ButtonBaseExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.ClickMode.Release"/></summary>
        public static TTarget Release<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ClickMode> property) where TTarget : ButtonBase
        => property.Set(Windows.Controls.ClickMode.Release);

        /// <summary>Set to <see cref="Windows.Controls.ClickMode.Press"/></summary>
        public static TTarget Press<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ClickMode> property) where TTarget : ButtonBase
        => property.Set(Windows.Controls.ClickMode.Press);

        /// <summary>Set to <see cref="Windows.Controls.ClickMode.Hover"/></summary>
        public static TTarget Hover<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ClickMode> property) where TTarget : ButtonBase
        => property.Set(Windows.Controls.ClickMode.Hover);
    }

    public static partial class CalendarExtensions
    {
        /// <summary>Set to <see cref="DayOfWeek.Sunday"/></summary>
        public static TTarget Sunday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Sunday);

        /// <summary>Set to <see cref="DayOfWeek.Monday"/></summary>
        public static TTarget Monday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Monday);

        /// <summary>Set to <see cref="DayOfWeek.Tuesday"/></summary>
        public static TTarget Tuesday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Tuesday);

        /// <summary>Set to <see cref="DayOfWeek.Wednesday"/></summary>
        public static TTarget Wednesday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Wednesday);

        /// <summary>Set to <see cref="DayOfWeek.Thursday"/></summary>
        public static TTarget Thursday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Thursday);

        /// <summary>Set to <see cref="DayOfWeek.Friday"/></summary>
        public static TTarget Friday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Friday);

        /// <summary>Set to <see cref="DayOfWeek.Saturday"/></summary>
        public static TTarget Saturday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : Calendar
        => property.Set(DayOfWeek.Saturday);

        /// <summary>Set to <see cref="Windows.Controls.CalendarSelectionMode.SingleDate"/></summary>
        public static TTarget SingleDate<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarSelectionMode.SingleDate);

        /// <summary>Set to <see cref="Windows.Controls.CalendarSelectionMode.SingleRange"/></summary>
        public static TTarget SingleRange<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarSelectionMode.SingleRange);

        /// <summary>Set to <see cref="Windows.Controls.CalendarSelectionMode.MultipleRange"/></summary>
        public static TTarget MultipleRange<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarSelectionMode.MultipleRange);

        /// <summary>Set to <see cref="Windows.Controls.CalendarSelectionMode.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarSelectionMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarSelectionMode.None);

        /// <summary>Set to <see cref="Windows.Controls.CalendarMode.Month"/></summary>
        public static TTarget Month<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarMode.Month);

        /// <summary>Set to <see cref="Windows.Controls.CalendarMode.Year"/></summary>
        public static TTarget Year<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarMode.Year);

        /// <summary>Set to <see cref="Windows.Controls.CalendarMode.Decade"/></summary>
        public static TTarget Decade<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CalendarMode> property) where TTarget : Calendar
        => property.Set(Windows.Controls.CalendarMode.Decade);
    }

    public static partial class CombinedGeometryExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.GeometryCombineMode.Union"/></summary>
        public static TTarget Union<TTarget>(this DependencyProperty<TTarget, Windows.Media.GeometryCombineMode> property) where TTarget : CombinedGeometry
        => property.Set(Windows.Media.GeometryCombineMode.Union);

        /// <summary>Set to <see cref="Windows.Media.GeometryCombineMode.Intersect"/></summary>
        public static TTarget Intersect<TTarget>(this DependencyProperty<TTarget, Windows.Media.GeometryCombineMode> property) where TTarget : CombinedGeometry
        => property.Set(Windows.Media.GeometryCombineMode.Intersect);

        /// <summary>Set to <see cref="Windows.Media.GeometryCombineMode.Xor"/></summary>
        public static TTarget Xor<TTarget>(this DependencyProperty<TTarget, Windows.Media.GeometryCombineMode> property) where TTarget : CombinedGeometry
        => property.Set(Windows.Media.GeometryCombineMode.Xor);

        /// <summary>Set to <see cref="Windows.Media.GeometryCombineMode.Exclude"/></summary>
        public static TTarget Exclude<TTarget>(this DependencyProperty<TTarget, Windows.Media.GeometryCombineMode> property) where TTarget : CombinedGeometry
        => property.Set(Windows.Media.GeometryCombineMode.Exclude);
    }

    public static partial class ContextMenuExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Absolute);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Relative"/></summary>
        public static TTarget Relative<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Relative);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Bottom);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Center);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Right);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.AbsolutePoint"/></summary>
        public static TTarget AbsolutePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.AbsolutePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.RelativePoint"/></summary>
        public static TTarget RelativePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.RelativePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Mouse"/></summary>
        public static TTarget Mouse<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Mouse);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.MousePoint"/></summary>
        public static TTarget MousePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.MousePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Left);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Top);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Custom"/></summary>
        public static TTarget Custom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ContextMenu
        => property.Set(Windows.Controls.Primitives.PlacementMode.Custom);
    }

    public static partial class DataGridExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.DataGridSelectionUnit.Cell"/></summary>
        public static TTarget Cell<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridSelectionUnit> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridSelectionUnit.Cell);

        /// <summary>Set to <see cref="Windows.Controls.DataGridSelectionUnit.FullRow"/></summary>
        public static TTarget FullRow<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridSelectionUnit> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridSelectionUnit.FullRow);

        /// <summary>Set to <see cref="Windows.Controls.DataGridSelectionUnit.CellOrRowHeader"/></summary>
        public static TTarget CellOrRowHeader<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridSelectionUnit> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridSelectionUnit.CellOrRowHeader);

        /// <summary>Set to <see cref="Windows.Controls.DataGridSelectionMode.Single"/></summary>
        public static TTarget Single<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridSelectionMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridSelectionMode.Single);

        /// <summary>Set to <see cref="Windows.Controls.DataGridSelectionMode.Extended"/></summary>
        public static TTarget Extended<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridSelectionMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridSelectionMode.Extended);

        /// <summary>Set to <see cref="Windows.Controls.DataGridRowDetailsVisibilityMode.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridRowDetailsVisibilityMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridRowDetailsVisibilityMode.Collapsed);

        /// <summary>Set to <see cref="Windows.Controls.DataGridRowDetailsVisibilityMode.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridRowDetailsVisibilityMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridRowDetailsVisibilityMode.Visible);

        /// <summary>Set to <see cref="Windows.Controls.DataGridRowDetailsVisibilityMode.VisibleWhenSelected"/></summary>
        public static TTarget VisibleWhenSelected<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridRowDetailsVisibilityMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridRowDetailsVisibilityMode.VisibleWhenSelected);

        /// <summary>Set to <see cref="Windows.Controls.DataGridHeadersVisibility.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridHeadersVisibility.None);

        /// <summary>Set to <see cref="Windows.Controls.DataGridHeadersVisibility.Column"/></summary>
        public static TTarget Column<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridHeadersVisibility.Column);

        /// <summary>Set to <see cref="Windows.Controls.DataGridHeadersVisibility.Row"/></summary>
        public static TTarget Row<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridHeadersVisibility.Row);

        /// <summary>Set to <see cref="Windows.Controls.DataGridHeadersVisibility.All"/></summary>
        public static TTarget All<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridHeadersVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridHeadersVisibility.All);

        /// <summary>Set to <see cref="Windows.Controls.DataGridGridLinesVisibility.All"/></summary>
        public static TTarget All<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridGridLinesVisibility.All);

        /// <summary>Set to <see cref="Windows.Controls.DataGridGridLinesVisibility.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridGridLinesVisibility.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.DataGridGridLinesVisibility.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridGridLinesVisibility.None);

        /// <summary>Set to <see cref="Windows.Controls.DataGridGridLinesVisibility.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridGridLinesVisibility> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridGridLinesVisibility.Vertical);

        /// <summary>Set to <see cref="Windows.Controls.DataGridClipboardCopyMode.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridClipboardCopyMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridClipboardCopyMode.None);

        /// <summary>Set to <see cref="Windows.Controls.DataGridClipboardCopyMode.ExcludeHeader"/></summary>
        public static TTarget ExcludeHeader<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridClipboardCopyMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridClipboardCopyMode.ExcludeHeader);

        /// <summary>Set to <see cref="Windows.Controls.DataGridClipboardCopyMode.IncludeHeader"/></summary>
        public static TTarget IncludeHeader<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DataGridClipboardCopyMode> property) where TTarget : DataGrid
        => property.Set(Windows.Controls.DataGridClipboardCopyMode.IncludeHeader);
    }

    public static partial class DataGridColumnExtensions
    {
        /// <summary>Set to <see cref="Windows.Visibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : DataGridColumn
        => property.Set(Windows.Visibility.Visible);

        /// <summary>Set to <see cref="Windows.Visibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : DataGridColumn
        => property.Set(Windows.Visibility.Hidden);

        /// <summary>Set to <see cref="Windows.Visibility.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : DataGridColumn
        => property.Set(Windows.Visibility.Collapsed);
    }

    public static partial class DatePickerExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.DatePickerFormat.Long"/></summary>
        public static TTarget Long<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DatePickerFormat> property) where TTarget : DatePicker
        => property.Set(Windows.Controls.DatePickerFormat.Long);

        /// <summary>Set to <see cref="Windows.Controls.DatePickerFormat.Short"/></summary>
        public static TTarget Short<TTarget>(this DependencyProperty<TTarget, Windows.Controls.DatePickerFormat> property) where TTarget : DatePicker
        => property.Set(Windows.Controls.DatePickerFormat.Short);

        /// <summary>Set to <see cref="DayOfWeek.Sunday"/></summary>
        public static TTarget Sunday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Sunday);

        /// <summary>Set to <see cref="DayOfWeek.Monday"/></summary>
        public static TTarget Monday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Monday);

        /// <summary>Set to <see cref="DayOfWeek.Tuesday"/></summary>
        public static TTarget Tuesday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Tuesday);

        /// <summary>Set to <see cref="DayOfWeek.Wednesday"/></summary>
        public static TTarget Wednesday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Wednesday);

        /// <summary>Set to <see cref="DayOfWeek.Thursday"/></summary>
        public static TTarget Thursday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Thursday);

        /// <summary>Set to <see cref="DayOfWeek.Friday"/></summary>
        public static TTarget Friday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Friday);

        /// <summary>Set to <see cref="DayOfWeek.Saturday"/></summary>
        public static TTarget Saturday<TTarget>(this DependencyProperty<TTarget, DayOfWeek> property) where TTarget : DatePicker
        => property.Set(DayOfWeek.Saturday);
    }

    public static partial class DependencyObjectExtensions
    {
        /// <summary>Set to <see cref="Windows.TextAlignment.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.TextAlignment> property) where TTarget : DependencyObject
        => property.Set(Windows.TextAlignment.Left);

        /// <summary>Set to <see cref="Windows.TextAlignment.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.TextAlignment> property) where TTarget : DependencyObject
        => property.Set(Windows.TextAlignment.Right);

        /// <summary>Set to <see cref="Windows.TextAlignment.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.TextAlignment> property) where TTarget : DependencyObject
        => property.Set(Windows.TextAlignment.Center);

        /// <summary>Set to <see cref="Windows.TextAlignment.Justify"/></summary>
        public static TTarget Justify<TTarget>(this DependencyProperty<TTarget, Windows.TextAlignment> property) where TTarget : DependencyObject
        => property.Set(Windows.TextAlignment.Justify);

        /// <summary>Set to <see cref="Windows.LineStackingStrategy.BlockLineHeight"/></summary>
        public static TTarget BlockLineHeight<TTarget>(this DependencyProperty<TTarget, Windows.LineStackingStrategy> property) where TTarget : DependencyObject
        => property.Set(Windows.LineStackingStrategy.BlockLineHeight);

        /// <summary>Set to <see cref="Windows.LineStackingStrategy.MaxHeight"/></summary>
        public static TTarget MaxHeight<TTarget>(this DependencyProperty<TTarget, Windows.LineStackingStrategy> property) where TTarget : DependencyObject
        => property.Set(Windows.LineStackingStrategy.MaxHeight);

        /// <summary>Set to <see cref="Windows.Controls.VirtualizationCacheLengthUnit.Pixel"/></summary>
        public static TTarget Pixel<TTarget>(this DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLengthUnit> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.VirtualizationCacheLengthUnit.Pixel);

        /// <summary>Set to <see cref="Windows.Controls.VirtualizationCacheLengthUnit.Item"/></summary>
        public static TTarget Item<TTarget>(this DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLengthUnit> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.VirtualizationCacheLengthUnit.Item);

        /// <summary>Set to <see cref="Windows.Controls.VirtualizationCacheLengthUnit.Page"/></summary>
        public static TTarget Page<TTarget>(this DependencyProperty<TTarget, Windows.Controls.VirtualizationCacheLengthUnit> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.VirtualizationCacheLengthUnit.Page);

        /// <summary>Set to <see cref="Windows.Controls.ScrollUnit.Pixel"/></summary>
        public static TTarget Pixel<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollUnit> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollUnit.Pixel);

        /// <summary>Set to <see cref="Windows.Controls.ScrollUnit.Item"/></summary>
        public static TTarget Item<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollUnit> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollUnit.Item);

        /// <summary>Set to <see cref="Windows.Controls.ScrollBarVisibility.Disabled"/></summary>
        public static TTarget Disabled<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollBarVisibility.Disabled);

        /// <summary>Set to <see cref="Windows.Controls.ScrollBarVisibility.Auto"/></summary>
        public static TTarget Auto<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollBarVisibility.Auto);

        /// <summary>Set to <see cref="Windows.Controls.ScrollBarVisibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollBarVisibility.Hidden);

        /// <summary>Set to <see cref="Windows.Controls.ScrollBarVisibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ScrollBarVisibility> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.ScrollBarVisibility.Visible);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.None);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.HorizontalOnly"/></summary>
        public static TTarget HorizontalOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.HorizontalOnly);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.VerticalOnly"/></summary>
        public static TTarget VerticalOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.VerticalOnly);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.Both);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.HorizontalFirst"/></summary>
        public static TTarget HorizontalFirst<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.HorizontalFirst);

        /// <summary>Set to <see cref="Windows.Controls.PanningMode.VerticalFirst"/></summary>
        public static TTarget VerticalFirst<TTarget>(this DependencyProperty<TTarget, Windows.Controls.PanningMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.PanningMode.VerticalFirst);

        /// <summary>Set to <see cref="Windows.Controls.OverflowMode.AsNeeded"/></summary>
        public static TTarget AsNeeded<TTarget>(this DependencyProperty<TTarget, Windows.Controls.OverflowMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.OverflowMode.AsNeeded);

        /// <summary>Set to <see cref="Windows.Controls.OverflowMode.Always"/></summary>
        public static TTarget Always<TTarget>(this DependencyProperty<TTarget, Windows.Controls.OverflowMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.OverflowMode.Always);

        /// <summary>Set to <see cref="Windows.Controls.OverflowMode.Never"/></summary>
        public static TTarget Never<TTarget>(this DependencyProperty<TTarget, Windows.Controls.OverflowMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.OverflowMode.Never);

        /// <summary>Set to <see cref="Windows.Controls.VirtualizationMode.Standard"/></summary>
        public static TTarget Standard<TTarget>(this DependencyProperty<TTarget, Windows.Controls.VirtualizationMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.VirtualizationMode.Standard);

        /// <summary>Set to <see cref="Windows.Controls.VirtualizationMode.Recycling"/></summary>
        public static TTarget Recycling<TTarget>(this DependencyProperty<TTarget, Windows.Controls.VirtualizationMode> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.VirtualizationMode.Recycling);

        /// <summary>Set to <see cref="Windows.FlowDirection.LeftToRight"/></summary>
        public static TTarget LeftToRight<TTarget>(this DependencyProperty<TTarget, Windows.FlowDirection> property) where TTarget : DependencyObject
        => property.Set(Windows.FlowDirection.LeftToRight);

        /// <summary>Set to <see cref="Windows.FlowDirection.RightToLeft"/></summary>
        public static TTarget RightToLeft<TTarget>(this DependencyProperty<TTarget, Windows.FlowDirection> property) where TTarget : DependencyObject
        => property.Set(Windows.FlowDirection.RightToLeft);

        /// <summary>Set to <see cref="Windows.Controls.SelectiveScrollingOrientation.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.SelectiveScrollingOrientation.None);

        /// <summary>Set to <see cref="Windows.Controls.SelectiveScrollingOrientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.SelectiveScrollingOrientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.SelectiveScrollingOrientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.SelectiveScrollingOrientation.Vertical);

        /// <summary>Set to <see cref="Windows.Controls.SelectiveScrollingOrientation.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectiveScrollingOrientation> property) where TTarget : DependencyObject
        => property.Set(Windows.Controls.SelectiveScrollingOrientation.Both);
    }

    public static partial class DocumentPageViewExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.UpOnly"/></summary>
        public static TTarget UpOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : DocumentPageView
        => property.Set(Windows.Controls.StretchDirection.UpOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.DownOnly"/></summary>
        public static TTarget DownOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : DocumentPageView
        => property.Set(Windows.Controls.StretchDirection.DownOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : DocumentPageView
        => property.Set(Windows.Controls.StretchDirection.Both);

        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : DocumentPageView
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : DocumentPageView
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : DocumentPageView
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : DocumentPageView
        => property.Set(Windows.Media.Stretch.UniformToFill);
    }

    public static partial class DoubleAnimationUsingPathExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Animation.PathAnimationSource.X"/></summary>
        public static TTarget X<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.PathAnimationSource> property) where TTarget : DoubleAnimationUsingPath
        => property.Set(Windows.Media.Animation.PathAnimationSource.X);

        /// <summary>Set to <see cref="Windows.Media.Animation.PathAnimationSource.Y"/></summary>
        public static TTarget Y<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.PathAnimationSource> property) where TTarget : DoubleAnimationUsingPath
        => property.Set(Windows.Media.Animation.PathAnimationSource.Y);

        /// <summary>Set to <see cref="Windows.Media.Animation.PathAnimationSource.Angle"/></summary>
        public static TTarget Angle<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.PathAnimationSource> property) where TTarget : DoubleAnimationUsingPath
        => property.Set(Windows.Media.Animation.PathAnimationSource.Angle);
    }

    public static partial class DropShadowEffectExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Effects.RenderingBias.Performance"/></summary>
        public static TTarget Performance<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> property) where TTarget : DropShadowEffect
        => property.Set(Windows.Media.Effects.RenderingBias.Performance);

        /// <summary>Set to <see cref="Windows.Media.Effects.RenderingBias.Quality"/></summary>
        public static TTarget Quality<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.RenderingBias> property) where TTarget : DropShadowEffect
        => property.Set(Windows.Media.Effects.RenderingBias.Quality);
    }

    public static partial class EasingFunctionBaseExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Animation.EasingMode.EaseIn"/></summary>
        public static TTarget EaseIn<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.EasingMode> property) where TTarget : EasingFunctionBase
        => property.Set(Windows.Media.Animation.EasingMode.EaseIn);

        /// <summary>Set to <see cref="Windows.Media.Animation.EasingMode.EaseOut"/></summary>
        public static TTarget EaseOut<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.EasingMode> property) where TTarget : EasingFunctionBase
        => property.Set(Windows.Media.Animation.EasingMode.EaseOut);

        /// <summary>Set to <see cref="Windows.Media.Animation.EasingMode.EaseInOut"/></summary>
        public static TTarget EaseInOut<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.EasingMode> property) where TTarget : EasingFunctionBase
        => property.Set(Windows.Media.Animation.EasingMode.EaseInOut);
    }

    public static partial class ExpanderExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.ExpandDirection.Down"/></summary>
        public static TTarget Down<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ExpandDirection> property) where TTarget : Expander
        => property.Set(Windows.Controls.ExpandDirection.Down);

        /// <summary>Set to <see cref="Windows.Controls.ExpandDirection.Up"/></summary>
        public static TTarget Up<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ExpandDirection> property) where TTarget : Expander
        => property.Set(Windows.Controls.ExpandDirection.Up);

        /// <summary>Set to <see cref="Windows.Controls.ExpandDirection.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ExpandDirection> property) where TTarget : Expander
        => property.Set(Windows.Controls.ExpandDirection.Left);

        /// <summary>Set to <see cref="Windows.Controls.ExpandDirection.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.ExpandDirection> property) where TTarget : Expander
        => property.Set(Windows.Controls.ExpandDirection.Right);
    }

    public static partial class FigureExtensions
    {
        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.PageLeft"/></summary>
        public static TTarget PageLeft<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.PageLeft);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.PageCenter"/></summary>
        public static TTarget PageCenter<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.PageCenter);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.PageRight"/></summary>
        public static TTarget PageRight<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.PageRight);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ContentLeft"/></summary>
        public static TTarget ContentLeft<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ContentLeft);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ContentCenter"/></summary>
        public static TTarget ContentCenter<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ContentCenter);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ContentRight"/></summary>
        public static TTarget ContentRight<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ContentRight);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ColumnLeft"/></summary>
        public static TTarget ColumnLeft<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ColumnLeft);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ColumnCenter"/></summary>
        public static TTarget ColumnCenter<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ColumnCenter);

        /// <summary>Set to <see cref="Windows.FigureHorizontalAnchor.ColumnRight"/></summary>
        public static TTarget ColumnRight<TTarget>(this DependencyProperty<TTarget, Windows.FigureHorizontalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureHorizontalAnchor.ColumnRight);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.PageTop"/></summary>
        public static TTarget PageTop<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.PageTop);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.PageCenter"/></summary>
        public static TTarget PageCenter<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.PageCenter);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.PageBottom"/></summary>
        public static TTarget PageBottom<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.PageBottom);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.ContentTop"/></summary>
        public static TTarget ContentTop<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.ContentTop);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.ContentCenter"/></summary>
        public static TTarget ContentCenter<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.ContentCenter);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.ContentBottom"/></summary>
        public static TTarget ContentBottom<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.ContentBottom);

        /// <summary>Set to <see cref="Windows.FigureVerticalAnchor.ParagraphTop"/></summary>
        public static TTarget ParagraphTop<TTarget>(this DependencyProperty<TTarget, Windows.FigureVerticalAnchor> property) where TTarget : Figure
        => property.Set(Windows.FigureVerticalAnchor.ParagraphTop);

        /// <summary>Set to <see cref="Windows.WrapDirection.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Figure
        => property.Set(Windows.WrapDirection.None);

        /// <summary>Set to <see cref="Windows.WrapDirection.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Figure
        => property.Set(Windows.WrapDirection.Left);

        /// <summary>Set to <see cref="Windows.WrapDirection.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Figure
        => property.Set(Windows.WrapDirection.Right);

        /// <summary>Set to <see cref="Windows.WrapDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.WrapDirection> property) where TTarget : Figure
        => property.Set(Windows.WrapDirection.Both);
    }

    public static partial class FloaterExtensions
    {
        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : Floater
        => property.Set(Windows.HorizontalAlignment.Left);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : Floater
        => property.Set(Windows.HorizontalAlignment.Center);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : Floater
        => property.Set(Windows.HorizontalAlignment.Right);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Stretch"/></summary>
        public static TTarget Stretch<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : Floater
        => property.Set(Windows.HorizontalAlignment.Stretch);
    }

    public static partial class FlowDocumentReaderExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.FlowDocumentReaderViewingMode.Page"/></summary>
        public static TTarget Page<TTarget>(this DependencyProperty<TTarget, Windows.Controls.FlowDocumentReaderViewingMode> property) where TTarget : FlowDocumentReader
        => property.Set(Windows.Controls.FlowDocumentReaderViewingMode.Page);

        /// <summary>Set to <see cref="Windows.Controls.FlowDocumentReaderViewingMode.TwoPage"/></summary>
        public static TTarget TwoPage<TTarget>(this DependencyProperty<TTarget, Windows.Controls.FlowDocumentReaderViewingMode> property) where TTarget : FlowDocumentReader
        => property.Set(Windows.Controls.FlowDocumentReaderViewingMode.TwoPage);

        /// <summary>Set to <see cref="Windows.Controls.FlowDocumentReaderViewingMode.Scroll"/></summary>
        public static TTarget Scroll<TTarget>(this DependencyProperty<TTarget, Windows.Controls.FlowDocumentReaderViewingMode> property) where TTarget : FlowDocumentReader
        => property.Set(Windows.Controls.FlowDocumentReaderViewingMode.Scroll);
    }

    public static partial class FrameExtensions
    {
        /// <summary>Set to <see cref="Windows.Navigation.NavigationUIVisibility.Automatic"/></summary>
        public static TTarget Automatic<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.NavigationUIVisibility> property) where TTarget : Frame
        => property.Set(Windows.Navigation.NavigationUIVisibility.Automatic);

        /// <summary>Set to <see cref="Windows.Navigation.NavigationUIVisibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.NavigationUIVisibility> property) where TTarget : Frame
        => property.Set(Windows.Navigation.NavigationUIVisibility.Visible);

        /// <summary>Set to <see cref="Windows.Navigation.NavigationUIVisibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.NavigationUIVisibility> property) where TTarget : Frame
        => property.Set(Windows.Navigation.NavigationUIVisibility.Hidden);

        /// <summary>Set to <see cref="Windows.Navigation.JournalOwnership.Automatic"/></summary>
        public static TTarget Automatic<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.JournalOwnership> property) where TTarget : Frame
        => property.Set(Windows.Navigation.JournalOwnership.Automatic);

        /// <summary>Set to <see cref="Windows.Navigation.JournalOwnership.OwnsJournal"/></summary>
        public static TTarget OwnsJournal<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.JournalOwnership> property) where TTarget : Frame
        => property.Set(Windows.Navigation.JournalOwnership.OwnsJournal);

        /// <summary>Set to <see cref="Windows.Navigation.JournalOwnership.UsesParentJournal"/></summary>
        public static TTarget UsesParentJournal<TTarget>(this DependencyProperty<TTarget, Windows.Navigation.JournalOwnership> property) where TTarget : Frame
        => property.Set(Windows.Navigation.JournalOwnership.UsesParentJournal);
    }

    public static partial class FrameworkElementExtensions
    {
        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.HorizontalAlignment.Left);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.HorizontalAlignment.Center);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.HorizontalAlignment.Right);

        /// <summary>Set to <see cref="Windows.HorizontalAlignment.Stretch"/></summary>
        public static TTarget Stretch<TTarget>(this DependencyProperty<TTarget, Windows.HorizontalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.HorizontalAlignment.Stretch);

        /// <summary>Set to <see cref="Windows.VerticalAlignment.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.VerticalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.VerticalAlignment.Top);

        /// <summary>Set to <see cref="Windows.VerticalAlignment.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.VerticalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.VerticalAlignment.Center);

        /// <summary>Set to <see cref="Windows.VerticalAlignment.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.VerticalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.VerticalAlignment.Bottom);

        /// <summary>Set to <see cref="Windows.VerticalAlignment.Stretch"/></summary>
        public static TTarget Stretch<TTarget>(this DependencyProperty<TTarget, Windows.VerticalAlignment> property) where TTarget : FrameworkElement
        => property.Set(Windows.VerticalAlignment.Stretch);
    }

    public static partial class GeometryGroupExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.FillRule.EvenOdd"/></summary>
        public static TTarget EvenOdd<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : GeometryGroup
        => property.Set(Windows.Media.FillRule.EvenOdd);

        /// <summary>Set to <see cref="Windows.Media.FillRule.Nonzero"/></summary>
        public static TTarget Nonzero<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : GeometryGroup
        => property.Set(Windows.Media.FillRule.Nonzero);
    }

    public static partial class GlyphsExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.StyleSimulations.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.StyleSimulations> property) where TTarget : Glyphs
        => property.Set(Windows.Media.StyleSimulations.None);

        /// <summary>Set to <see cref="Windows.Media.StyleSimulations.BoldSimulation"/></summary>
        public static TTarget BoldSimulation<TTarget>(this DependencyProperty<TTarget, Windows.Media.StyleSimulations> property) where TTarget : Glyphs
        => property.Set(Windows.Media.StyleSimulations.BoldSimulation);

        /// <summary>Set to <see cref="Windows.Media.StyleSimulations.ItalicSimulation"/></summary>
        public static TTarget ItalicSimulation<TTarget>(this DependencyProperty<TTarget, Windows.Media.StyleSimulations> property) where TTarget : Glyphs
        => property.Set(Windows.Media.StyleSimulations.ItalicSimulation);

        /// <summary>Set to <see cref="Windows.Media.StyleSimulations.BoldItalicSimulation"/></summary>
        public static TTarget BoldItalicSimulation<TTarget>(this DependencyProperty<TTarget, Windows.Media.StyleSimulations> property) where TTarget : Glyphs
        => property.Set(Windows.Media.StyleSimulations.BoldItalicSimulation);
    }

    public static partial class GradientBrushExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.ColorInterpolationMode.ScRgbLinearInterpolation"/></summary>
        public static TTarget ScRgbLinearInterpolation<TTarget>(this DependencyProperty<TTarget, Windows.Media.ColorInterpolationMode> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.ColorInterpolationMode.ScRgbLinearInterpolation);

        /// <summary>Set to <see cref="Windows.Media.ColorInterpolationMode.SRgbLinearInterpolation"/></summary>
        public static TTarget SRgbLinearInterpolation<TTarget>(this DependencyProperty<TTarget, Windows.Media.ColorInterpolationMode> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.ColorInterpolationMode.SRgbLinearInterpolation);

        /// <summary>Set to <see cref="Windows.Media.GradientSpreadMethod.Pad"/></summary>
        public static TTarget Pad<TTarget>(this DependencyProperty<TTarget, Windows.Media.GradientSpreadMethod> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.GradientSpreadMethod.Pad);

        /// <summary>Set to <see cref="Windows.Media.GradientSpreadMethod.Reflect"/></summary>
        public static TTarget Reflect<TTarget>(this DependencyProperty<TTarget, Windows.Media.GradientSpreadMethod> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.GradientSpreadMethod.Reflect);

        /// <summary>Set to <see cref="Windows.Media.GradientSpreadMethod.Repeat"/></summary>
        public static TTarget Repeat<TTarget>(this DependencyProperty<TTarget, Windows.Media.GradientSpreadMethod> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.GradientSpreadMethod.Repeat);

        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.BrushMappingMode.Absolute);

        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.RelativeToBoundingBox"/></summary>
        public static TTarget RelativeToBoundingBox<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : GradientBrush
        => property.Set(Windows.Media.BrushMappingMode.RelativeToBoundingBox);
    }

    public static partial class GridSplitterExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.GridResizeBehavior.BasedOnAlignment"/></summary>
        public static TTarget BasedOnAlignment<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeBehavior.BasedOnAlignment);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeBehavior.CurrentAndNext"/></summary>
        public static TTarget CurrentAndNext<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeBehavior.CurrentAndNext);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeBehavior.PreviousAndCurrent"/></summary>
        public static TTarget PreviousAndCurrent<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeBehavior.PreviousAndCurrent);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeBehavior.PreviousAndNext"/></summary>
        public static TTarget PreviousAndNext<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeBehavior> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeBehavior.PreviousAndNext);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeDirection.Auto"/></summary>
        public static TTarget Auto<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeDirection> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeDirection.Auto);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeDirection.Columns"/></summary>
        public static TTarget Columns<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeDirection> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeDirection.Columns);

        /// <summary>Set to <see cref="Windows.Controls.GridResizeDirection.Rows"/></summary>
        public static TTarget Rows<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridResizeDirection> property) where TTarget : GridSplitter
        => property.Set(Windows.Controls.GridResizeDirection.Rows);
    }

    public static partial class GridViewColumnHeaderExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.GridViewColumnHeaderRole.Normal"/></summary>
        public static TTarget Normal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridViewColumnHeaderRole> property) where TTarget : GridViewColumnHeader
        => property.Set(Windows.Controls.GridViewColumnHeaderRole.Normal);

        /// <summary>Set to <see cref="Windows.Controls.GridViewColumnHeaderRole.Floating"/></summary>
        public static TTarget Floating<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridViewColumnHeaderRole> property) where TTarget : GridViewColumnHeader
        => property.Set(Windows.Controls.GridViewColumnHeaderRole.Floating);

        /// <summary>Set to <see cref="Windows.Controls.GridViewColumnHeaderRole.Padding"/></summary>
        public static TTarget Padding<TTarget>(this DependencyProperty<TTarget, Windows.Controls.GridViewColumnHeaderRole> property) where TTarget : GridViewColumnHeader
        => property.Set(Windows.Controls.GridViewColumnHeaderRole.Padding);
    }

    public static partial class ImageExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Image
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Image
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Image
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Image
        => property.Set(Windows.Media.Stretch.UniformToFill);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.UpOnly"/></summary>
        public static TTarget UpOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Image
        => property.Set(Windows.Controls.StretchDirection.UpOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.DownOnly"/></summary>
        public static TTarget DownOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Image
        => property.Set(Windows.Controls.StretchDirection.DownOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Image
        => property.Set(Windows.Controls.StretchDirection.Both);
    }

    public static partial class InkCanvasExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.None);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.Ink"/></summary>
        public static TTarget Ink<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.Ink);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.GestureOnly"/></summary>
        public static TTarget GestureOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.GestureOnly);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.InkAndGesture"/></summary>
        public static TTarget InkAndGesture<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.InkAndGesture);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.Select"/></summary>
        public static TTarget Select<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.Select);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.EraseByPoint"/></summary>
        public static TTarget EraseByPoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.EraseByPoint);

        /// <summary>Set to <see cref="Windows.Controls.InkCanvasEditingMode.EraseByStroke"/></summary>
        public static TTarget EraseByStroke<TTarget>(this DependencyProperty<TTarget, Windows.Controls.InkCanvasEditingMode> property) where TTarget : InkCanvas
        => property.Set(Windows.Controls.InkCanvasEditingMode.EraseByStroke);
    }

    public static partial class InlineExtensions
    {
        /// <summary>Set to <see cref="Windows.BaselineAlignment.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Top);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Center);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Bottom);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.Baseline"/></summary>
        public static TTarget Baseline<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Baseline);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.TextTop"/></summary>
        public static TTarget TextTop<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.TextTop);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.TextBottom"/></summary>
        public static TTarget TextBottom<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.TextBottom);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.Subscript"/></summary>
        public static TTarget Subscript<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Subscript);

        /// <summary>Set to <see cref="Windows.BaselineAlignment.Superscript"/></summary>
        public static TTarget Superscript<TTarget>(this DependencyProperty<TTarget, Windows.BaselineAlignment> property) where TTarget : Inline
        => property.Set(Windows.BaselineAlignment.Superscript);
    }

    public static partial class ListExtensions
    {
        /// <summary>Set to <see cref="Windows.TextMarkerStyle.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.None);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.Disc"/></summary>
        public static TTarget Disc<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.Disc);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.Circle"/></summary>
        public static TTarget Circle<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.Circle);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.Square"/></summary>
        public static TTarget Square<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.Square);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.Box"/></summary>
        public static TTarget Box<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.Box);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.LowerRoman"/></summary>
        public static TTarget LowerRoman<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.LowerRoman);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.UpperRoman"/></summary>
        public static TTarget UpperRoman<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.UpperRoman);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.LowerLatin"/></summary>
        public static TTarget LowerLatin<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.LowerLatin);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.UpperLatin"/></summary>
        public static TTarget UpperLatin<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.UpperLatin);

        /// <summary>Set to <see cref="Windows.TextMarkerStyle.Decimal"/></summary>
        public static TTarget Decimal<TTarget>(this DependencyProperty<TTarget, Windows.TextMarkerStyle> property) where TTarget : List
        => property.Set(Windows.TextMarkerStyle.Decimal);
    }

    public static partial class ListBoxExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.SelectionMode.Single"/></summary>
        public static TTarget Single<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectionMode> property) where TTarget : ListBox
        => property.Set(Windows.Controls.SelectionMode.Single);

        /// <summary>Set to <see cref="Windows.Controls.SelectionMode.Multiple"/></summary>
        public static TTarget Multiple<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectionMode> property) where TTarget : ListBox
        => property.Set(Windows.Controls.SelectionMode.Multiple);

        /// <summary>Set to <see cref="Windows.Controls.SelectionMode.Extended"/></summary>
        public static TTarget Extended<TTarget>(this DependencyProperty<TTarget, Windows.Controls.SelectionMode> property) where TTarget : ListBox
        => property.Set(Windows.Controls.SelectionMode.Extended);
    }

    public static partial class MediaElementExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : MediaElement
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : MediaElement
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : MediaElement
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : MediaElement
        => property.Set(Windows.Media.Stretch.UniformToFill);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.UpOnly"/></summary>
        public static TTarget UpOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.StretchDirection.UpOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.DownOnly"/></summary>
        public static TTarget DownOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.StretchDirection.DownOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.StretchDirection.Both);

        /// <summary>Set to <see cref="Windows.Controls.MediaState.Manual"/></summary>
        public static TTarget Manual<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MediaState> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.MediaState.Manual);

        /// <summary>Set to <see cref="Windows.Controls.MediaState.Play"/></summary>
        public static TTarget Play<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MediaState> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.MediaState.Play);

        /// <summary>Set to <see cref="Windows.Controls.MediaState.Close"/></summary>
        public static TTarget Close<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MediaState> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.MediaState.Close);

        /// <summary>Set to <see cref="Windows.Controls.MediaState.Pause"/></summary>
        public static TTarget Pause<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MediaState> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.MediaState.Pause);

        /// <summary>Set to <see cref="Windows.Controls.MediaState.Stop"/></summary>
        public static TTarget Stop<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MediaState> property) where TTarget : MediaElement
        => property.Set(Windows.Controls.MediaState.Stop);
    }

    public static partial class MenuItemExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.MenuItemRole.TopLevelItem"/></summary>
        public static TTarget TopLevelItem<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MenuItemRole> property) where TTarget : MenuItem
        => property.Set(Windows.Controls.MenuItemRole.TopLevelItem);

        /// <summary>Set to <see cref="Windows.Controls.MenuItemRole.TopLevelHeader"/></summary>
        public static TTarget TopLevelHeader<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MenuItemRole> property) where TTarget : MenuItem
        => property.Set(Windows.Controls.MenuItemRole.TopLevelHeader);

        /// <summary>Set to <see cref="Windows.Controls.MenuItemRole.SubmenuItem"/></summary>
        public static TTarget SubmenuItem<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MenuItemRole> property) where TTarget : MenuItem
        => property.Set(Windows.Controls.MenuItemRole.SubmenuItem);

        /// <summary>Set to <see cref="Windows.Controls.MenuItemRole.SubmenuHeader"/></summary>
        public static TTarget SubmenuHeader<TTarget>(this DependencyProperty<TTarget, Windows.Controls.MenuItemRole> property) where TTarget : MenuItem
        => property.Set(Windows.Controls.MenuItemRole.SubmenuHeader);
    }

    public static partial class ParallelTimelineExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Animation.SlipBehavior.Grow"/></summary>
        public static TTarget Grow<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.SlipBehavior> property) where TTarget : ParallelTimeline
        => property.Set(Windows.Media.Animation.SlipBehavior.Grow);

        /// <summary>Set to <see cref="Windows.Media.Animation.SlipBehavior.Slip"/></summary>
        public static TTarget Slip<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.SlipBehavior> property) where TTarget : ParallelTimeline
        => property.Set(Windows.Media.Animation.SlipBehavior.Slip);
    }

    public static partial class PathGeometryExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.FillRule.EvenOdd"/></summary>
        public static TTarget EvenOdd<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : PathGeometry
        => property.Set(Windows.Media.FillRule.EvenOdd);

        /// <summary>Set to <see cref="Windows.Media.FillRule.Nonzero"/></summary>
        public static TTarget Nonzero<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : PathGeometry
        => property.Set(Windows.Media.FillRule.Nonzero);
    }

    public static partial class PenExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Flat"/></summary>
        public static TTarget Flat<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineCap.Flat);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Square"/></summary>
        public static TTarget Square<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineCap.Square);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Round"/></summary>
        public static TTarget Round<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineCap.Round);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Triangle"/></summary>
        public static TTarget Triangle<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineCap.Triangle);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Miter"/></summary>
        public static TTarget Miter<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineJoin.Miter);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Bevel"/></summary>
        public static TTarget Bevel<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineJoin.Bevel);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Round"/></summary>
        public static TTarget Round<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Pen
        => property.Set(Windows.Media.PenLineJoin.Round);
    }

    public static partial class PixelShaderExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Effects.ShaderRenderMode.Auto"/></summary>
        public static TTarget Auto<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.ShaderRenderMode> property) where TTarget : PixelShader
        => property.Set(Windows.Media.Effects.ShaderRenderMode.Auto);

        /// <summary>Set to <see cref="Windows.Media.Effects.ShaderRenderMode.SoftwareOnly"/></summary>
        public static TTarget SoftwareOnly<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.ShaderRenderMode> property) where TTarget : PixelShader
        => property.Set(Windows.Media.Effects.ShaderRenderMode.SoftwareOnly);

        /// <summary>Set to <see cref="Windows.Media.Effects.ShaderRenderMode.HardwareOnly"/></summary>
        public static TTarget HardwareOnly<TTarget>(this DependencyProperty<TTarget, Windows.Media.Effects.ShaderRenderMode> property) where TTarget : PixelShader
        => property.Set(Windows.Media.Effects.ShaderRenderMode.HardwareOnly);
    }

    public static partial class PolygonExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.FillRule.EvenOdd"/></summary>
        public static TTarget EvenOdd<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : Polygon
        => property.Set(Windows.Media.FillRule.EvenOdd);

        /// <summary>Set to <see cref="Windows.Media.FillRule.Nonzero"/></summary>
        public static TTarget Nonzero<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : Polygon
        => property.Set(Windows.Media.FillRule.Nonzero);
    }

    public static partial class PolylineExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.FillRule.EvenOdd"/></summary>
        public static TTarget EvenOdd<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : Polyline
        => property.Set(Windows.Media.FillRule.EvenOdd);

        /// <summary>Set to <see cref="Windows.Media.FillRule.Nonzero"/></summary>
        public static TTarget Nonzero<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : Polyline
        => property.Set(Windows.Media.FillRule.Nonzero);
    }

    public static partial class PopupExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Absolute);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Relative"/></summary>
        public static TTarget Relative<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Relative);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Bottom);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Center);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Right);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.AbsolutePoint"/></summary>
        public static TTarget AbsolutePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.AbsolutePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.RelativePoint"/></summary>
        public static TTarget RelativePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.RelativePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Mouse"/></summary>
        public static TTarget Mouse<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Mouse);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.MousePoint"/></summary>
        public static TTarget MousePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.MousePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Left);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Top);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Custom"/></summary>
        public static TTarget Custom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PlacementMode.Custom);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PopupAnimation.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PopupAnimation.None);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PopupAnimation.Fade"/></summary>
        public static TTarget Fade<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PopupAnimation.Fade);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PopupAnimation.Slide"/></summary>
        public static TTarget Slide<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PopupAnimation.Slide);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PopupAnimation.Scroll"/></summary>
        public static TTarget Scroll<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PopupAnimation> property) where TTarget : Popup
        => property.Set(Windows.Controls.Primitives.PopupAnimation.Scroll);
    }

    public static partial class ProgressBarExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ProgressBar
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ProgressBar
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class RibbonApplicationMenuItemExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Top);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Middle"/></summary>
        public static TTarget Middle<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Middle);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Sub"/></summary>
        public static TTarget Sub<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Sub);
    }

    public static partial class RibbonApplicationSplitMenuItemExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationSplitMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Top);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Middle"/></summary>
        public static TTarget Middle<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationSplitMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Middle);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Sub"/></summary>
        public static TTarget Sub<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel> property) where TTarget : RibbonApplicationSplitMenuItem
        => property.Set(Windows.Controls.Ribbon.RibbonApplicationMenuItemLevel.Sub);
    }

    public static partial class RibbonControlSizeDefinitionExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonImageSize.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonImageSize> property) where TTarget : RibbonControlSizeDefinition
        => property.Set(Windows.Controls.Ribbon.RibbonImageSize.Collapsed);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonImageSize.Small"/></summary>
        public static TTarget Small<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonImageSize> property) where TTarget : RibbonControlSizeDefinition
        => property.Set(Windows.Controls.Ribbon.RibbonImageSize.Small);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonImageSize.Large"/></summary>
        public static TTarget Large<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonImageSize> property) where TTarget : RibbonControlSizeDefinition
        => property.Set(Windows.Controls.Ribbon.RibbonImageSize.Large);
    }

    public static partial class RibbonSplitButtonExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition.Header"/></summary>
        public static TTarget Header<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition> property) where TTarget : RibbonSplitButton
        => property.Set(Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition.Header);

        /// <summary>Set to <see cref="Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition.DropDown"/></summary>
        public static TTarget DropDown<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition> property) where TTarget : RibbonSplitButton
        => property.Set(Windows.Controls.Ribbon.RibbonSplitButtonLabelPosition.DropDown);
    }

    public static partial class RibbonTwoLineTextExtensions
    {
        /// <summary>Set to <see cref="Windows.TextTrimming.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : RibbonTwoLineText
        => property.Set(Windows.TextTrimming.None);

        /// <summary>Set to <see cref="Windows.TextTrimming.CharacterEllipsis"/></summary>
        public static TTarget CharacterEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : RibbonTwoLineText
        => property.Set(Windows.TextTrimming.CharacterEllipsis);

        /// <summary>Set to <see cref="Windows.TextTrimming.WordEllipsis"/></summary>
        public static TTarget WordEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : RibbonTwoLineText
        => property.Set(Windows.TextTrimming.WordEllipsis);
    }

    public static partial class ScrollBarExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ScrollBar
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ScrollBar
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class ShapeExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Shape
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Shape
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Shape
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Shape
        => property.Set(Windows.Media.Stretch.UniformToFill);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Miter"/></summary>
        public static TTarget Miter<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineJoin.Miter);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Bevel"/></summary>
        public static TTarget Bevel<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineJoin.Bevel);

        /// <summary>Set to <see cref="Windows.Media.PenLineJoin.Round"/></summary>
        public static TTarget Round<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineJoin> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineJoin.Round);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Flat"/></summary>
        public static TTarget Flat<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineCap.Flat);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Square"/></summary>
        public static TTarget Square<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineCap.Square);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Round"/></summary>
        public static TTarget Round<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineCap.Round);

        /// <summary>Set to <see cref="Windows.Media.PenLineCap.Triangle"/></summary>
        public static TTarget Triangle<TTarget>(this DependencyProperty<TTarget, Windows.Media.PenLineCap> property) where TTarget : Shape
        => property.Set(Windows.Media.PenLineCap.Triangle);
    }

    public static partial class SliderExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : Slider
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : Slider
        => property.Set(Windows.Controls.Orientation.Vertical);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.AutoToolTipPlacement.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.AutoToolTipPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.AutoToolTipPlacement.None);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.AutoToolTipPlacement.TopLeft"/></summary>
        public static TTarget TopLeft<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.AutoToolTipPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.AutoToolTipPlacement.TopLeft);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.AutoToolTipPlacement.BottomRight"/></summary>
        public static TTarget BottomRight<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.AutoToolTipPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.AutoToolTipPlacement.BottomRight);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickPlacement.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.TickPlacement.None);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickPlacement.TopLeft"/></summary>
        public static TTarget TopLeft<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.TickPlacement.TopLeft);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickPlacement.BottomRight"/></summary>
        public static TTarget BottomRight<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.TickPlacement.BottomRight);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickPlacement.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickPlacement> property) where TTarget : Slider
        => property.Set(Windows.Controls.Primitives.TickPlacement.Both);
    }

    public static partial class StackPanelExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : StackPanel
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : StackPanel
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class StickyNoteControlExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.StickyNoteType.Text"/></summary>
        public static TTarget Text<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StickyNoteType> property) where TTarget : StickyNoteControl
        => property.Set(Windows.Controls.StickyNoteType.Text);

        /// <summary>Set to <see cref="Windows.Controls.StickyNoteType.Ink"/></summary>
        public static TTarget Ink<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StickyNoteType> property) where TTarget : StickyNoteControl
        => property.Set(Windows.Controls.StickyNoteType.Ink);
    }

    public static partial class StreamGeometryExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.FillRule.EvenOdd"/></summary>
        public static TTarget EvenOdd<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : StreamGeometry
        => property.Set(Windows.Media.FillRule.EvenOdd);

        /// <summary>Set to <see cref="Windows.Media.FillRule.Nonzero"/></summary>
        public static TTarget Nonzero<TTarget>(this DependencyProperty<TTarget, Windows.Media.FillRule> property) where TTarget : StreamGeometry
        => property.Set(Windows.Media.FillRule.Nonzero);
    }

    public static partial class TaskbarItemInfoExtensions
    {
        /// <summary>Set to <see cref="Windows.Shell.TaskbarItemProgressState.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> property) where TTarget : TaskbarItemInfo
        => property.Set(Windows.Shell.TaskbarItemProgressState.None);

        /// <summary>Set to <see cref="Windows.Shell.TaskbarItemProgressState.Indeterminate"/></summary>
        public static TTarget Indeterminate<TTarget>(this DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> property) where TTarget : TaskbarItemInfo
        => property.Set(Windows.Shell.TaskbarItemProgressState.Indeterminate);

        /// <summary>Set to <see cref="Windows.Shell.TaskbarItemProgressState.Normal"/></summary>
        public static TTarget Normal<TTarget>(this DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> property) where TTarget : TaskbarItemInfo
        => property.Set(Windows.Shell.TaskbarItemProgressState.Normal);

        /// <summary>Set to <see cref="Windows.Shell.TaskbarItemProgressState.Error"/></summary>
        public static TTarget Error<TTarget>(this DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> property) where TTarget : TaskbarItemInfo
        => property.Set(Windows.Shell.TaskbarItemProgressState.Error);

        /// <summary>Set to <see cref="Windows.Shell.TaskbarItemProgressState.Paused"/></summary>
        public static TTarget Paused<TTarget>(this DependencyProperty<TTarget, Windows.Shell.TaskbarItemProgressState> property) where TTarget : TaskbarItemInfo
        => property.Set(Windows.Shell.TaskbarItemProgressState.Paused);
    }

    public static partial class TextBlockExtensions
    {
        /// <summary>Set to <see cref="Windows.TextWrapping.WrapWithOverflow"/></summary>
        public static TTarget WrapWithOverflow<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBlock
        => property.Set(Windows.TextWrapping.WrapWithOverflow);

        /// <summary>Set to <see cref="Windows.TextWrapping.NoWrap"/></summary>
        public static TTarget NoWrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBlock
        => property.Set(Windows.TextWrapping.NoWrap);

        /// <summary>Set to <see cref="Windows.TextWrapping.Wrap"/></summary>
        public static TTarget Wrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBlock
        => property.Set(Windows.TextWrapping.Wrap);

        /// <summary>Set to <see cref="Windows.TextTrimming.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : TextBlock
        => property.Set(Windows.TextTrimming.None);

        /// <summary>Set to <see cref="Windows.TextTrimming.CharacterEllipsis"/></summary>
        public static TTarget CharacterEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : TextBlock
        => property.Set(Windows.TextTrimming.CharacterEllipsis);

        /// <summary>Set to <see cref="Windows.TextTrimming.WordEllipsis"/></summary>
        public static TTarget WordEllipsis<TTarget>(this DependencyProperty<TTarget, Windows.TextTrimming> property) where TTarget : TextBlock
        => property.Set(Windows.TextTrimming.WordEllipsis);
    }

    public static partial class TextBoxExtensions
    {
        /// <summary>Set to <see cref="Windows.TextWrapping.WrapWithOverflow"/></summary>
        public static TTarget WrapWithOverflow<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBox
        => property.Set(Windows.TextWrapping.WrapWithOverflow);

        /// <summary>Set to <see cref="Windows.TextWrapping.NoWrap"/></summary>
        public static TTarget NoWrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBox
        => property.Set(Windows.TextWrapping.NoWrap);

        /// <summary>Set to <see cref="Windows.TextWrapping.Wrap"/></summary>
        public static TTarget Wrap<TTarget>(this DependencyProperty<TTarget, Windows.TextWrapping> property) where TTarget : TextBox
        => property.Set(Windows.TextWrapping.Wrap);

        /// <summary>Set to <see cref="Windows.Controls.CharacterCasing.Normal"/></summary>
        public static TTarget Normal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CharacterCasing> property) where TTarget : TextBox
        => property.Set(Windows.Controls.CharacterCasing.Normal);

        /// <summary>Set to <see cref="Windows.Controls.CharacterCasing.Lower"/></summary>
        public static TTarget Lower<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CharacterCasing> property) where TTarget : TextBox
        => property.Set(Windows.Controls.CharacterCasing.Lower);

        /// <summary>Set to <see cref="Windows.Controls.CharacterCasing.Upper"/></summary>
        public static TTarget Upper<TTarget>(this DependencyProperty<TTarget, Windows.Controls.CharacterCasing> property) where TTarget : TextBox
        => property.Set(Windows.Controls.CharacterCasing.Upper);
    }

    public static partial class TextDecorationExtensions
    {
        /// <summary>Set to <see cref="Windows.TextDecorationLocation.Underline"/></summary>
        public static TTarget Underline<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationLocation> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationLocation.Underline);

        /// <summary>Set to <see cref="Windows.TextDecorationLocation.OverLine"/></summary>
        public static TTarget OverLine<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationLocation> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationLocation.OverLine);

        /// <summary>Set to <see cref="Windows.TextDecorationLocation.Strikethrough"/></summary>
        public static TTarget Strikethrough<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationLocation> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationLocation.Strikethrough);

        /// <summary>Set to <see cref="Windows.TextDecorationLocation.Baseline"/></summary>
        public static TTarget Baseline<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationLocation> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationLocation.Baseline);

        /// <summary>Set to <see cref="Windows.TextDecorationUnit.FontRecommended"/></summary>
        public static TTarget FontRecommended<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationUnit> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationUnit.FontRecommended);

        /// <summary>Set to <see cref="Windows.TextDecorationUnit.FontRenderingEmSize"/></summary>
        public static TTarget FontRenderingEmSize<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationUnit> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationUnit.FontRenderingEmSize);

        /// <summary>Set to <see cref="Windows.TextDecorationUnit.Pixel"/></summary>
        public static TTarget Pixel<TTarget>(this DependencyProperty<TTarget, Windows.TextDecorationUnit> property) where TTarget : TextDecoration
        => property.Set(Windows.TextDecorationUnit.Pixel);
    }

    public static partial class ThumbButtonInfoExtensions
    {
        /// <summary>Set to <see cref="Windows.Visibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : ThumbButtonInfo
        => property.Set(Windows.Visibility.Visible);

        /// <summary>Set to <see cref="Windows.Visibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : ThumbButtonInfo
        => property.Set(Windows.Visibility.Hidden);

        /// <summary>Set to <see cref="Windows.Visibility.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : ThumbButtonInfo
        => property.Set(Windows.Visibility.Collapsed);
    }

    public static partial class TickBarExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickBarPlacement.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement> property) where TTarget : TickBar
        => property.Set(Windows.Controls.Primitives.TickBarPlacement.Left);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickBarPlacement.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement> property) where TTarget : TickBar
        => property.Set(Windows.Controls.Primitives.TickBarPlacement.Top);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickBarPlacement.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement> property) where TTarget : TickBar
        => property.Set(Windows.Controls.Primitives.TickBarPlacement.Right);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.TickBarPlacement.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.TickBarPlacement> property) where TTarget : TickBar
        => property.Set(Windows.Controls.Primitives.TickBarPlacement.Bottom);
    }

    public static partial class TileBrushExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.TileMode.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.TileMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.TileMode.None);

        /// <summary>Set to <see cref="Windows.Media.TileMode.FlipX"/></summary>
        public static TTarget FlipX<TTarget>(this DependencyProperty<TTarget, Windows.Media.TileMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.TileMode.FlipX);

        /// <summary>Set to <see cref="Windows.Media.TileMode.FlipY"/></summary>
        public static TTarget FlipY<TTarget>(this DependencyProperty<TTarget, Windows.Media.TileMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.TileMode.FlipY);

        /// <summary>Set to <see cref="Windows.Media.TileMode.FlipXY"/></summary>
        public static TTarget FlipXY<TTarget>(this DependencyProperty<TTarget, Windows.Media.TileMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.TileMode.FlipXY);

        /// <summary>Set to <see cref="Windows.Media.TileMode.Tile"/></summary>
        public static TTarget Tile<TTarget>(this DependencyProperty<TTarget, Windows.Media.TileMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.TileMode.Tile);

        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.BrushMappingMode.Absolute);

        /// <summary>Set to <see cref="Windows.Media.BrushMappingMode.RelativeToBoundingBox"/></summary>
        public static TTarget RelativeToBoundingBox<TTarget>(this DependencyProperty<TTarget, Windows.Media.BrushMappingMode> property) where TTarget : TileBrush
        => property.Set(Windows.Media.BrushMappingMode.RelativeToBoundingBox);

        /// <summary>Set to <see cref="Windows.Media.AlignmentX.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentX> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentX.Left);

        /// <summary>Set to <see cref="Windows.Media.AlignmentX.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentX> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentX.Center);

        /// <summary>Set to <see cref="Windows.Media.AlignmentX.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentX> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentX.Right);

        /// <summary>Set to <see cref="Windows.Media.AlignmentY.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentY> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentY.Top);

        /// <summary>Set to <see cref="Windows.Media.AlignmentY.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentY> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentY.Center);

        /// <summary>Set to <see cref="Windows.Media.AlignmentY.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Media.AlignmentY> property) where TTarget : TileBrush
        => property.Set(Windows.Media.AlignmentY.Bottom);

        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : TileBrush
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : TileBrush
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : TileBrush
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : TileBrush
        => property.Set(Windows.Media.Stretch.UniformToFill);
    }

    public static partial class TimelineExtensions
    {
        /// <summary>Set to <see cref="Windows.Media.Animation.FillBehavior.HoldEnd"/></summary>
        public static TTarget HoldEnd<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.FillBehavior> property) where TTarget : Timeline
        => property.Set(Windows.Media.Animation.FillBehavior.HoldEnd);

        /// <summary>Set to <see cref="Windows.Media.Animation.FillBehavior.Stop"/></summary>
        public static TTarget Stop<TTarget>(this DependencyProperty<TTarget, Windows.Media.Animation.FillBehavior> property) where TTarget : Timeline
        => property.Set(Windows.Media.Animation.FillBehavior.Stop);
    }

    public static partial class ToolBarExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ToolBar
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ToolBar
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class ToolBarTrayExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ToolBarTray
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : ToolBarTray
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class ToolTipExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Absolute"/></summary>
        public static TTarget Absolute<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Absolute);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Relative"/></summary>
        public static TTarget Relative<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Relative);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Bottom);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Center"/></summary>
        public static TTarget Center<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Center);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Right);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.AbsolutePoint"/></summary>
        public static TTarget AbsolutePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.AbsolutePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.RelativePoint"/></summary>
        public static TTarget RelativePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.RelativePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Mouse"/></summary>
        public static TTarget Mouse<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Mouse);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.MousePoint"/></summary>
        public static TTarget MousePoint<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.MousePoint);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Left);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Top);

        /// <summary>Set to <see cref="Windows.Controls.Primitives.PlacementMode.Custom"/></summary>
        public static TTarget Custom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Primitives.PlacementMode> property) where TTarget : ToolTip
        => property.Set(Windows.Controls.Primitives.PlacementMode.Custom);
    }

    public static partial class TrackExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : Track
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : Track
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class UIElementExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Dock.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Dock> property) where TTarget : UIElement
        => property.Set(Windows.Controls.Dock.Left);

        /// <summary>Set to <see cref="Windows.Controls.Dock.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Dock> property) where TTarget : UIElement
        => property.Set(Windows.Controls.Dock.Top);

        /// <summary>Set to <see cref="Windows.Controls.Dock.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Dock> property) where TTarget : UIElement
        => property.Set(Windows.Controls.Dock.Right);

        /// <summary>Set to <see cref="Windows.Controls.Dock.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Dock> property) where TTarget : UIElement
        => property.Set(Windows.Controls.Dock.Bottom);

        /// <summary>Set to <see cref="Windows.Visibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement
        => property.Set(Windows.Visibility.Visible);

        /// <summary>Set to <see cref="Windows.Visibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement
        => property.Set(Windows.Visibility.Hidden);

        /// <summary>Set to <see cref="Windows.Visibility.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement
        => property.Set(Windows.Visibility.Collapsed);
    }

    public static partial class UIElement3DExtensions
    {
        /// <summary>Set to <see cref="Windows.Visibility.Visible"/></summary>
        public static TTarget Visible<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement3D
        => property.Set(Windows.Visibility.Visible);

        /// <summary>Set to <see cref="Windows.Visibility.Hidden"/></summary>
        public static TTarget Hidden<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement3D
        => property.Set(Windows.Visibility.Hidden);

        /// <summary>Set to <see cref="Windows.Visibility.Collapsed"/></summary>
        public static TTarget Collapsed<TTarget>(this DependencyProperty<TTarget, Windows.Visibility> property) where TTarget : UIElement3D
        => property.Set(Windows.Visibility.Collapsed);
    }

    public static partial class ViewboxExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.UpOnly"/></summary>
        public static TTarget UpOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Viewbox
        => property.Set(Windows.Controls.StretchDirection.UpOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.DownOnly"/></summary>
        public static TTarget DownOnly<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Viewbox
        => property.Set(Windows.Controls.StretchDirection.DownOnly);

        /// <summary>Set to <see cref="Windows.Controls.StretchDirection.Both"/></summary>
        public static TTarget Both<TTarget>(this DependencyProperty<TTarget, Windows.Controls.StretchDirection> property) where TTarget : Viewbox
        => property.Set(Windows.Controls.StretchDirection.Both);

        /// <summary>Set to <see cref="Windows.Media.Stretch.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Viewbox
        => property.Set(Windows.Media.Stretch.None);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Fill"/></summary>
        public static TTarget Fill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Viewbox
        => property.Set(Windows.Media.Stretch.Fill);

        /// <summary>Set to <see cref="Windows.Media.Stretch.Uniform"/></summary>
        public static TTarget Uniform<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Viewbox
        => property.Set(Windows.Media.Stretch.Uniform);

        /// <summary>Set to <see cref="Windows.Media.Stretch.UniformToFill"/></summary>
        public static TTarget UniformToFill<TTarget>(this DependencyProperty<TTarget, Windows.Media.Stretch> property) where TTarget : Viewbox
        => property.Set(Windows.Media.Stretch.UniformToFill);
    }

    public static partial class VirtualizingStackPanelExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : VirtualizingStackPanel
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : VirtualizingStackPanel
        => property.Set(Windows.Controls.Orientation.Vertical);
    }

    public static partial class WindowExtensions
    {
        /// <summary>Set to <see cref="Windows.WindowState.Normal"/></summary>
        public static TTarget Normal<TTarget>(this DependencyProperty<TTarget, Windows.WindowState> property) where TTarget : Window
        => property.Set(Windows.WindowState.Normal);

        /// <summary>Set to <see cref="Windows.WindowState.Minimized"/></summary>
        public static TTarget Minimized<TTarget>(this DependencyProperty<TTarget, Windows.WindowState> property) where TTarget : Window
        => property.Set(Windows.WindowState.Minimized);

        /// <summary>Set to <see cref="Windows.WindowState.Maximized"/></summary>
        public static TTarget Maximized<TTarget>(this DependencyProperty<TTarget, Windows.WindowState> property) where TTarget : Window
        => property.Set(Windows.WindowState.Maximized);

        /// <summary>Set to <see cref="Windows.WindowStyle.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.WindowStyle> property) where TTarget : Window
        => property.Set(Windows.WindowStyle.None);

        /// <summary>Set to <see cref="Windows.WindowStyle.SingleBorderWindow"/></summary>
        public static TTarget SingleBorderWindow<TTarget>(this DependencyProperty<TTarget, Windows.WindowStyle> property) where TTarget : Window
        => property.Set(Windows.WindowStyle.SingleBorderWindow);

        /// <summary>Set to <see cref="Windows.WindowStyle.ThreeDBorderWindow"/></summary>
        public static TTarget ThreeDBorderWindow<TTarget>(this DependencyProperty<TTarget, Windows.WindowStyle> property) where TTarget : Window
        => property.Set(Windows.WindowStyle.ThreeDBorderWindow);

        /// <summary>Set to <see cref="Windows.WindowStyle.ToolWindow"/></summary>
        public static TTarget ToolWindow<TTarget>(this DependencyProperty<TTarget, Windows.WindowStyle> property) where TTarget : Window
        => property.Set(Windows.WindowStyle.ToolWindow);

        /// <summary>Set to <see cref="Windows.SizeToContent.Manual"/></summary>
        public static TTarget Manual<TTarget>(this DependencyProperty<TTarget, Windows.SizeToContent> property) where TTarget : Window
        => property.Set(Windows.SizeToContent.Manual);

        /// <summary>Set to <see cref="Windows.SizeToContent.Width"/></summary>
        public static TTarget Width<TTarget>(this DependencyProperty<TTarget, Windows.SizeToContent> property) where TTarget : Window
        => property.Set(Windows.SizeToContent.Width);

        /// <summary>Set to <see cref="Windows.SizeToContent.Height"/></summary>
        public static TTarget Height<TTarget>(this DependencyProperty<TTarget, Windows.SizeToContent> property) where TTarget : Window
        => property.Set(Windows.SizeToContent.Height);

        /// <summary>Set to <see cref="Windows.SizeToContent.WidthAndHeight"/></summary>
        public static TTarget WidthAndHeight<TTarget>(this DependencyProperty<TTarget, Windows.SizeToContent> property) where TTarget : Window
        => property.Set(Windows.SizeToContent.WidthAndHeight);

        /// <summary>Set to <see cref="Windows.ResizeMode.NoResize"/></summary>
        public static TTarget NoResize<TTarget>(this DependencyProperty<TTarget, Windows.ResizeMode> property) where TTarget : Window
        => property.Set(Windows.ResizeMode.NoResize);

        /// <summary>Set to <see cref="Windows.ResizeMode.CanMinimize"/></summary>
        public static TTarget CanMinimize<TTarget>(this DependencyProperty<TTarget, Windows.ResizeMode> property) where TTarget : Window
        => property.Set(Windows.ResizeMode.CanMinimize);

        /// <summary>Set to <see cref="Windows.ResizeMode.CanResize"/></summary>
        public static TTarget CanResize<TTarget>(this DependencyProperty<TTarget, Windows.ResizeMode> property) where TTarget : Window
        => property.Set(Windows.ResizeMode.CanResize);

        /// <summary>Set to <see cref="Windows.ResizeMode.CanResizeWithGrip"/></summary>
        public static TTarget CanResizeWithGrip<TTarget>(this DependencyProperty<TTarget, Windows.ResizeMode> property) where TTarget : Window
        => property.Set(Windows.ResizeMode.CanResizeWithGrip);
    }

    public static partial class WindowChromeExtensions
    {
        /// <summary>Set to <see cref="Windows.Shell.NonClientFrameEdges.None"/></summary>
        public static TTarget None<TTarget>(this DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> property) where TTarget : WindowChrome
        => property.Set(Windows.Shell.NonClientFrameEdges.None);

        /// <summary>Set to <see cref="Windows.Shell.NonClientFrameEdges.Left"/></summary>
        public static TTarget Left<TTarget>(this DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> property) where TTarget : WindowChrome
        => property.Set(Windows.Shell.NonClientFrameEdges.Left);

        /// <summary>Set to <see cref="Windows.Shell.NonClientFrameEdges.Top"/></summary>
        public static TTarget Top<TTarget>(this DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> property) where TTarget : WindowChrome
        => property.Set(Windows.Shell.NonClientFrameEdges.Top);

        /// <summary>Set to <see cref="Windows.Shell.NonClientFrameEdges.Right"/></summary>
        public static TTarget Right<TTarget>(this DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> property) where TTarget : WindowChrome
        => property.Set(Windows.Shell.NonClientFrameEdges.Right);

        /// <summary>Set to <see cref="Windows.Shell.NonClientFrameEdges.Bottom"/></summary>
        public static TTarget Bottom<TTarget>(this DependencyProperty<TTarget, Windows.Shell.NonClientFrameEdges> property) where TTarget : WindowChrome
        => property.Set(Windows.Shell.NonClientFrameEdges.Bottom);
    }

    public static partial class WrapPanelExtensions
    {
        /// <summary>Set to <see cref="Windows.Controls.Orientation.Horizontal"/></summary>
        public static TTarget Horizontal<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : WrapPanel
        => property.Set(Windows.Controls.Orientation.Horizontal);

        /// <summary>Set to <see cref="Windows.Controls.Orientation.Vertical"/></summary>
        public static TTarget Vertical<TTarget>(this DependencyProperty<TTarget, Windows.Controls.Orientation> property) where TTarget : WrapPanel
        => property.Set(Windows.Controls.Orientation.Vertical);
    }
}

#endif
// End of generated C# Markup API for the Microsoft.WindowsDesktop.App Object hierarchy
